<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Cargo Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon-ba9a2803.png">
        <link rel="stylesheet" href="css/variables-3865ffda.css">
        <link rel="stylesheet" href="css/general-4c35105a.css">
        <link rel="stylesheet" href="css/chrome-c0e702bf.css">
        <link rel="stylesheet" href="css/print-ad67d350.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome-799aeb25.css">
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight-56612340.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-8fc2a0db.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-4c5cc278.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/tree/master/src/doc/src" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-cargo-book"><a class="header" href="#the-cargo-book">The Cargo Book</a></h1>
<p><img src="images/Cargo-Logo-Small.png" alt="Cargo Logo" /></p>
<p>Cargo is the <a href="https://www.rust-lang.org/">Rust</a> <a href="./appendix/glossary.html#package-manager" title="&quot;package manager&quot; (glossary entry)"><em>package manager</em></a>. Cargo downloads your Rust <a href="./appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a>’s
dependencies, compiles your packages, makes distributable packages, and uploads them to
<a href="https://crates.io/">crates.io</a>, the Rust community’s <a href="./appendix/glossary.html#package-registry" title="&quot;package registry&quot; (glossary entry)"><em>package registry</em></a>. You can contribute
to this book on <a href="https://github.com/rust-lang/cargo/tree/master/src/doc">GitHub</a>.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p><strong><a href="getting-started/index.html">Getting Started</a></strong></p>
<p>To get started with Cargo, install Cargo (and Rust) and set up your first
<a href="./appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>crate</em></a>.</p>
<p><strong><a href="guide/index.html">Cargo Guide</a></strong></p>
<p>The guide will give you all you need to know about how to use Cargo to develop
Rust packages.</p>
<p><strong><a href="reference/index.html">Cargo Reference</a></strong></p>
<p>The reference covers the details of various areas of Cargo.</p>
<p><strong><a href="commands/index.html">Cargo Commands</a></strong></p>
<p>The commands will let you interact with Cargo using its command-line interface.</p>
<p><strong><a href="faq.html">Frequently Asked Questions</a></strong></p>
<p><strong>Appendices:</strong></p>
<ul>
<li><a href="appendix/glossary.html">Glossary</a></li>
<li><a href="appendix/git-authentication.html">Git Authentication</a></li>
</ul>
<p><strong>Other Documentation:</strong></p>
<ul>
<li><a href="CHANGELOG.html">Changelog</a>
— Detailed notes about changes in Cargo in each release.</li>
<li><a href="https://doc.rust-lang.org/">Rust documentation website</a> — Links to official
Rust documentation and tools.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To get started with Cargo, install Cargo (and Rust) and set up your first
<a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>crate</em></a>.</p>
<ul>
<li><a href="getting-started/installation.html">Installation</a></li>
<li><a href="getting-started/first-steps.html">First steps with Cargo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="install-rust-and-cargo"><a class="header" href="#install-rust-and-cargo">Install Rust and Cargo</a></h2>
<p>The easiest way to get Cargo is to install the current stable release of <a href="https://www.rust-lang.org/">Rust</a>
by using <a href="https://rustup.rs/">rustup</a>. Installing Rust using <code>rustup</code> will also install <code>cargo</code>.</p>
<p>On Linux and macOS systems, this is done as follows:</p>
<pre><code class="language-console">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>It will download a script, and start the installation. If everything goes well,
you’ll see this appear:</p>
<pre><code class="language-console">Rust is installed now. Great!
</code></pre>
<p>On Windows, download and run <a href="https://win.rustup.rs/">rustup-init.exe</a>. It will start the installation
in a console and present the above message on success.</p>
<p>After this, you can use the <code>rustup</code> command to also install <code>beta</code> or <code>nightly</code>
channels for Rust and Cargo.</p>
<p>For other installation options and information, visit the
<a href="https://www.rust-lang.org/tools/install">install</a> page of the Rust website.</p>
<h2 id="build-and-install-cargo-from-source"><a class="header" href="#build-and-install-cargo-from-source">Build and Install Cargo from Source</a></h2>
<p>Alternatively, you can <a href="https://github.com/rust-lang/cargo#compiling-from-source">build Cargo from source</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-steps-with-cargo"><a class="header" href="#first-steps-with-cargo">First Steps with Cargo</a></h1>
<p>This section provides a quick sense for the <code>cargo</code> command line tool. We
demonstrate its ability to generate a new <a href="getting-started/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)"><em><strong>package</strong></em></a> for us,
its ability to compile the <a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em><strong>crate</strong></em></a> within the package, and
its ability to run the resulting program.</p>
<p>To start a new package with Cargo, use <code>cargo new</code>:</p>
<pre><code class="language-console">$ cargo new hello_world
</code></pre>
<p>Cargo defaults to <code>--bin</code> to make a binary program. To make a library, we
would pass <code>--lib</code>, instead.</p>
<p>Let’s check out what Cargo has generated for us:</p>
<pre><code class="language-console">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>This is all we need to get started. First, let’s check out <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>This is called a <a href="getting-started/../appendix/glossary.html#manifest" title="&quot;manifest&quot; (glossary entry)"><em><strong>manifest</strong></em></a>, and it contains all of the
metadata that Cargo needs to compile your package.</p>
<p>Here’s what’s in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo generated a “hello world” program for us, otherwise known as a
<a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em><strong>binary crate</strong></em></a>. Let’s compile it:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p>And then run it:</p>
<pre><code class="language-console">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>We can also use <code>cargo run</code> to compile and then run it, all in one step:</p>
<pre><code class="language-console">$ cargo run
     Fresh hello_world v0.1.0 (file:///path/to/package/hello_world)
   Running `target/hello_world`
Hello, world!
</code></pre>
<h2 id="going-further"><a class="header" href="#going-further">Going further</a></h2>
<p>For more details on using Cargo, check out the <a href="getting-started/../guide/index.html">Cargo Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-guide"><a class="header" href="#cargo-guide">Cargo Guide</a></h1>
<p>This guide will give you all that you need to know about how to use Cargo to
develop Rust packages.</p>
<ul>
<li><a href="guide/why-cargo-exists.html">Why Cargo Exists</a></li>
<li><a href="guide/creating-a-new-project.html">Creating a New Package</a></li>
<li><a href="guide/working-on-an-existing-project.html">Working on an Existing Cargo Package</a></li>
<li><a href="guide/dependencies.html">Dependencies</a></li>
<li><a href="guide/project-layout.html">Package Layout</a></li>
<li><a href="guide/cargo-toml-vs-cargo-lock.html">Cargo.toml vs Cargo.lock</a></li>
<li><a href="guide/tests.html">Tests</a></li>
<li><a href="guide/continuous-integration.html">Continuous Integration</a></li>
<li><a href="guide/../reference/publishing.html">Publishing on crates.io</a></li>
<li><a href="guide/cargo-home.html">Cargo Home</a></li>
<li><a href="guide/build-performance.html">Optimizing Build Performance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-cargo-exists"><a class="header" href="#why-cargo-exists">Why Cargo Exists</a></h1>
<h2 id="preliminaries"><a class="header" href="#preliminaries">Preliminaries</a></h2>
<p>In Rust, as you may know, a library or executable program is called a
<a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>crate</em></a>. Crates are compiled using the Rust compiler,
<code>rustc</code>. When starting with Rust, the first source code most people encounter
is that of the classic “hello world” program, which they compile by invoking
<code>rustc</code> directly:</p>
<pre><code class="language-console">$ rustc hello.rs
$ ./hello
Hello, world!
</code></pre>
<p>Note that the above command required that you specify the file name
explicitly. If you were to directly use <code>rustc</code> to compile a different program,
a different command line invocation would be required. If you needed to specify
any specific compiler flags or include external dependencies, then the
needed command would be even more specific (and complex).</p>
<p>Furthermore, most non-trivial programs will likely have dependencies on
external libraries, and will therefore also depend transitively on <em>their</em>
dependencies. Obtaining the correct versions of all the necessary dependencies
and keeping them up to date would be hard and error-prone if done by
hand.</p>
<p>Rather than work only with crates and <code>rustc</code>, you can avoid the difficulties
involved with performing the above tasks by introducing a higher-level
<a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">“<em>package</em>”</a> abstraction and by using a
<a href="guide/../appendix/glossary.html#package-manager" title="&quot;package manager&quot; (glossary entry)"><em>package manager</em></a>.</p>
<h2 id="enter-cargo"><a class="header" href="#enter-cargo">Enter: Cargo</a></h2>
<p><em>Cargo</em> is the Rust package manager. It is a tool that allows Rust
<a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)"><em>packages</em></a> to declare their various dependencies and ensure
that you’ll always get a repeatable build.</p>
<p>To accomplish this goal, Cargo does four things:</p>
<ul>
<li>Introduces two metadata files with various bits of package information.</li>
<li>Fetches and builds your package’s dependencies.</li>
<li>Invokes <code>rustc</code> or another build tool with the correct parameters to build
your package.</li>
<li>Introduces conventions to make working with Rust packages easier.</li>
</ul>
<p>To a large extent, Cargo normalizes the commands needed to build a given
program or library; this is one aspect to the above mentioned conventions. As
we show later, the same command can be used to build different
<a href="guide/../appendix/glossary.html#artifact" title="&quot;artifact&quot; (glossary entry)"><em>artifacts</em></a>, regardless of their names. Rather than invoke
<code>rustc</code> directly, you can instead invoke something generic such as <code>cargo build</code> and let cargo worry about constructing the correct <code>rustc</code>
invocation. Furthermore, Cargo will automatically fetch any dependencies
you have defined for your artifact from a <a href="guide/../appendix/glossary.html#registry" title="&quot;registry&quot; (glossary entry)"><em>registry</em></a>,
and arrange for them to be added into your build as needed.</p>
<p>It is only a slight exaggeration to say that once you know how to build one
Cargo-based project, you know how to build <em>all</em> of them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-package"><a class="header" href="#creating-a-new-package">Creating a New Package</a></h1>
<p>To start a new <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a> with Cargo, use <code>cargo new</code>:</p>
<pre><code class="language-console">$ cargo new hello_world --bin
</code></pre>
<p>We’re passing <code>--bin</code> because we’re making a binary program: if we
were making a library, we’d pass <code>--lib</code>. This also initializes a new <code>git</code>
repository by default. If you don’t want it to do that, pass <code>--vcs none</code>.</p>
<p>Let’s check out what Cargo has generated for us:</p>
<pre><code class="language-console">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>Let’s take a closer look at <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024"

[dependencies]

</code></pre>
<p>This is called a <a href="guide/../appendix/glossary.html#manifest" title="&quot;manifest&quot; (glossary entry)"><em><strong>manifest</strong></em></a>, and it contains all of the
metadata that Cargo needs to compile your package. This file is written in the
<a href="https://toml.io/">TOML</a> format (pronounced /tɑməl/).</p>
<p>Here’s what’s in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo generated a “hello world” program for you, otherwise known as a
<a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>binary crate</em></a>. Let’s compile it:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p>And then run it:</p>
<pre><code class="language-console">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>You can also use <code>cargo run</code> to compile and then run it, all in one step (You
won’t see the <code>Compiling</code> line if you have not made any changes since you last
compiled):</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<p>You’ll now notice a new file, <code>Cargo.lock</code>. It contains information about your
dependencies. Since there are none yet, it’s not very interesting.</p>
<p>Once you’re ready for release, you can use <code>cargo build --release</code> to compile
your files with optimizations turned on:</p>
<pre><code class="language-console">$ cargo build --release
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p><code>cargo build --release</code> puts the resulting binary in <code>target/release</code> instead of
<code>target/debug</code>.</p>
<p>Compiling in debug mode is the default for development. Compilation time is
shorter since the compiler doesn’t do optimizations, but the code will run
slower. Release mode takes longer to compile, but the code will run faster.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-on-an-existing-cargo-package"><a class="header" href="#working-on-an-existing-cargo-package">Working on an Existing Cargo Package</a></h1>
<p>If you download an existing <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a> that uses Cargo, it’s
really easy to get going.</p>
<p>First, get the package from somewhere. In this example, we’ll use <code>regex</code>
cloned from its repository on GitHub:</p>
<pre><code class="language-console">$ git clone https://github.com/rust-lang/regex.git
$ cd regex
</code></pre>
<p>To build, use <code>cargo build</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling regex v1.5.0 (file:///path/to/package/regex)
</code></pre>
<p>This will fetch all of the dependencies and then build them, along with the
package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p><a href="https://crates.io/">crates.io</a> is the Rust community’s central <a href="guide/../appendix/glossary.html#package-registry" title="&quot;package-registry&quot; (glossary entry)"><em>package registry</em></a>
that serves as a location to discover and download
<a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">packages</a>. <code>cargo</code> is configured to use it by default to find
requested packages.</p>
<p>To depend on a library hosted on <a href="https://crates.io/">crates.io</a>, add it to your <code>Cargo.toml</code>.</p>
<h2 id="adding-a-dependency"><a class="header" href="#adding-a-dependency">Adding a dependency</a></h2>
<p>If your <code>Cargo.toml</code> doesn’t already have a <code>[dependencies]</code> section, add
that, then list the <a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)">crate</a> name and version that you would like to
use. This example adds a dependency on the <code>time</code> crate:</p>
<pre><code class="language-toml">[dependencies]
time = "0.1.12"
</code></pre>
<p>The version string is a <a href="https://semver.org">SemVer</a> version requirement. The <a href="guide/../reference/specifying-dependencies.html">specifying
dependencies</a> docs have more information about
the options you have here.</p>
<p>If you also wanted to add a dependency on the <code>regex</code> crate, you would not need
to add <code>[dependencies]</code> for each crate listed. Here’s what your whole
<code>Cargo.toml</code> file would look like with dependencies on the <code>time</code> and <code>regex</code>
crates:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024"

[dependencies]
time = "0.1.12"
regex = "0.1.41"
</code></pre>
<p>Re-run <code>cargo build</code>, and Cargo will fetch the new dependencies and all of
their dependencies, compile them all, and update the <code>Cargo.lock</code>:</p>
<pre><code class="language-console">$ cargo build
      Updating crates.io index
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p><code>Cargo.lock</code> contains the exact information about which revision was used
for all of these dependencies.</p>
<p>Now, if <code>regex</code> gets updated, you will still build with the same revision until
you choose to run <code>cargo update</code>.</p>
<p>You can now use the <code>regex</code> library in <code>main.rs</code>.</p>
<pre><code class="language-rust ignore">use regex::Regex;

fn main() {
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    println!("Did our date match? {}", re.is_match("2014-01-01"));
}</code></pre>
<p>Running it will show:</p>
<pre><code class="language-console">$ cargo run
   Running `target/hello_world`
Did our date match? true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-layout"><a class="header" href="#package-layout">Package Layout</a></h1>
<p>Cargo uses conventions for file placement to make it easy to dive into a new
Cargo <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a>:</p>
<pre><code class="language-text">.
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── main.rs
│   └── bin/
│       ├── named-executable.rs
│       ├── another-executable.rs
│       └── multi-file-executable/
│           ├── main.rs
│           └── some_module.rs
├── benches/
│   ├── large-input.rs
│   └── multi-file-bench/
│       ├── main.rs
│       └── bench_module.rs
├── examples/
│   ├── simple.rs
│   └── multi-file-example/
│       ├── main.rs
│       └── ex_module.rs
└── tests/
    ├── some-integration-tests.rs
    └── multi-file-test/
        ├── main.rs
        └── test_module.rs
</code></pre>
<ul>
<li><code>Cargo.toml</code> and <code>Cargo.lock</code> are stored in the root of your package (<em>package
root</em>).</li>
<li>Source code goes in the <code>src</code> directory.</li>
<li>The default library file is <code>src/lib.rs</code>.</li>
<li>The default executable file is <code>src/main.rs</code>.
<ul>
<li>Other executables can be placed in <code>src/bin/</code>.</li>
</ul>
</li>
<li>Benchmarks go in the <code>benches</code> directory.</li>
<li>Examples go in the <code>examples</code> directory.</li>
<li>Integration tests go in the <code>tests</code> directory.</li>
</ul>
<p>If a binary, example, bench, or integration test consists of multiple source
files, place a <code>main.rs</code> file along with the extra <a href="guide/../appendix/glossary.html#module" title="&quot;module&quot; (glossary entry)"><em>modules</em></a>
within a subdirectory of the <code>src/bin</code>, <code>examples</code>, <code>benches</code>, or <code>tests</code>
directory. The name of the executable will be the directory name.</p>
<blockquote>
<p><strong>Note:</strong> By convention, binaries, examples, benches and integration tests follow <code>kebab-case</code> naming style, unless there are compatibility reasons to do otherwise (e.g. compatibility with a pre-existing binary name). Modules within those targets are <code>snake_case</code> following the <a href="https://rust-lang.github.io/rfcs/0430-finalizing-naming-conventions.html">Rust standard</a>.</p>
</blockquote>
<p>You can learn more about Rust’s module system in <a href="guide/../../book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">the book</a>.</p>
<p>See <a href="guide/../reference/cargo-targets.html#configuring-a-target">Configuring a target</a> for more details on manually configuring targets.
See <a href="guide/../reference/cargo-targets.html#target-auto-discovery">Target auto-discovery</a> for more information on controlling how Cargo
automatically infers target names.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargotoml-vs-cargolock"><a class="header" href="#cargotoml-vs-cargolock">Cargo.toml vs Cargo.lock</a></h1>
<p><code>Cargo.toml</code> and <code>Cargo.lock</code> serve two different purposes. Before we talk
about them, here’s a summary:</p>
<ul>
<li><code>Cargo.toml</code> is about describing your dependencies in a broad sense, and is
written by you.</li>
<li><code>Cargo.lock</code> contains exact information about your dependencies. It is
maintained by Cargo and should not be manually edited.</li>
</ul>
<p>When in doubt, check <code>Cargo.lock</code> into the version control system (e.g. Git).
For a better understanding of why and what the alternatives might be, see
<a href="guide/../faq.html#why-have-cargolock-in-version-control">“Why have Cargo.lock in version control?” in the FAQ</a>.
We recommend pairing this with
<a href="guide/continuous-integration.html#verifying-latest-dependencies">Verifying Latest Dependencies</a></p>
<p>Let’s dig in a little bit more.</p>
<p><code>Cargo.toml</code> is a <a href="guide/../appendix/glossary.html#manifest" title="&quot;manifest&quot; (glossary entry)"><strong>manifest</strong></a> file in which you can specify a
bunch of different metadata about your package. For example, you can say that you
depend on another package:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
</code></pre>
<p>This package has a single dependency, on the <code>regex</code> library. It states in
this case to rely on a particular Git repository that lives on
GitHub. Since you haven’t specified any other information, Cargo assumes that
you intend to use the latest commit on the default branch to build our package.</p>
<p>Sound good? Well, there’s one problem: If you build this package today, and
then you send a copy to me, and I build this package tomorrow, something bad
could happen. There could be more commits to <code>regex</code> in the meantime, and my
build would include new commits while yours would not. Therefore, we would
get different builds. This would be bad because we want reproducible builds.</p>
<p>You could fix this problem by defining a specific <code>rev</code> value in our <code>Cargo.toml</code>,
so Cargo could know exactly which revision to use when building the package:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git", rev = "9f9f693" }
</code></pre>
<p>Now our builds will be the same. But there’s a big drawback: now you have to
manually think about SHA-1s every time you want to update our library. This is
both tedious and error prone.</p>
<p>Enter the <code>Cargo.lock</code>. Because of its existence, you don’t need to manually
keep track of the exact revisions: Cargo will do it for you. When you have a
manifest like this:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
</code></pre>
<p>Cargo will take the latest commit and write that information out into your
<code>Cargo.lock</code> when you build for the first time. That file will look like this:</p>
<pre><code class="language-toml">[[package]]
name = "hello_world"
version = "0.1.0"
dependencies = [
 "regex 1.5.0 (git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831)",
]

[[package]]
name = "regex"
version = "1.5.0"
source = "git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831"
</code></pre>
<p>You can see that there’s a lot more information here, including the exact
revision you used to build. Now when you give your package to someone else,
they’ll use the exact same SHA, even though you didn’t specify it in your
<code>Cargo.toml</code>.</p>
<p>When you’re ready to opt in to a new version of the library, Cargo can
re-calculate the dependencies and update things for you:</p>
<pre><code class="language-console">$ cargo update         # updates all dependencies
$ cargo update regex   # updates just “regex”
</code></pre>
<p>This will write out a new <code>Cargo.lock</code> with the new version information. Note
that the argument to <code>cargo update</code> is actually a
<a href="guide/../reference/pkgid-spec.html">Package ID Specification</a> and <code>regex</code> is just a
short specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>Cargo can run your tests with the <code>cargo test</code> command. Cargo looks for tests
to run in two places: in each of your <code>src</code> files and any tests in <code>tests/</code>.
Tests in your <code>src</code> files should be unit tests and <a href="guide/../../rustdoc/write-documentation/documentation-tests.html">documentation tests</a>.
Tests in <code>tests/</code> should be integration-style tests. As such, you’ll need to
import your crates into the files in <code>tests</code>.</p>
<p>Here’s an example of running <code>cargo test</code> in our <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a>, which
currently has no tests:</p>
<pre><code class="language-console">$ cargo test
   Compiling regex v1.5.0 (https://github.com/rust-lang/regex.git#9f9f693)
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
     Running target/test/hello_world-9c2b65bbb79eabce

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>If your package had tests, you would see more output with the correct number of
tests.</p>
<p>You can also run a specific test by passing a filter:</p>
<pre><code class="language-console">$ cargo test foo
</code></pre>
<p>This will run any test with <code>foo</code> in its name.</p>
<p><code>cargo test</code> runs additional checks as well. It will compile any examples
you’ve included to ensure they still compile. It also runs documentation
tests to ensure your code samples from documentation comments compile.
Please see the <a href="guide/../../book/ch11-00-testing.html">testing guide</a> in the Rust documentation for a general
view of writing and organizing tests. See <a href="guide/../reference/cargo-targets.html#tests">Cargo Targets: Tests</a> to learn more
about different styles of tests in Cargo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>A basic CI will build and test your projects:</p>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<p>To test your package on GitHub Actions, here is a sample <code>.github/workflows/ci.yml</code> file:</p>
<pre><code class="language-yaml">name: Cargo Build &amp; Test

on:
  push:
  pull_request:

env: 
  CARGO_TERM_COLOR: always

jobs:
  build_and_test:
    name: Rust project - latest
    runs-on: ubuntu-latest
    strategy:
      matrix:
        toolchain:
          - stable
          - beta
          - nightly
    steps:
      - uses: actions/checkout@v4
      - run: rustup update ${{ matrix.toolchain }} &amp;&amp; rustup default ${{ matrix.toolchain }}
      - run: cargo build --verbose
      - run: cargo test --verbose
  
</code></pre>
<p>This will test all three release channels (note a failure in any toolchain version will fail the entire job). You can also click <code>"Actions" &gt; "new workflow"</code> in the GitHub UI and select Rust to add the <a href="https://github.com/actions/starter-workflows/blob/main/ci/rust.yml">default configuration</a> to your repo. See <a href="https://docs.github.com/en/actions">GitHub Actions documentation</a> for more information.</p>
<h3 id="gitlab-ci"><a class="header" href="#gitlab-ci">GitLab CI</a></h3>
<p>To test your package on GitLab CI, here is a sample <code>.gitlab-ci.yml</code> file:</p>
<pre><code class="language-yaml">stages:
  - build

rust-latest:
  stage: build
  image: rust:latest
  script:
    - cargo build --verbose
    - cargo test --verbose

rust-nightly:
  stage: build
  image: rustlang/rust:nightly
  script:
    - cargo build --verbose
    - cargo test --verbose
  allow_failure: true
</code></pre>
<p>This will test on the stable channel and nightly channel, but any
breakage in nightly will not fail your overall build. Please see the
<a href="https://docs.gitlab.com/ce/ci/yaml/index.html">GitLab CI documentation</a> for more
information.</p>
<h3 id="buildssrht"><a class="header" href="#buildssrht">builds.sr.ht</a></h3>
<p>To test your package on sr.ht, here is a sample <code>.build.yml</code> file.
Be sure to change <code>&lt;your repo&gt;</code> and <code>&lt;your project&gt;</code> to the repo to clone and
the directory where it was cloned.</p>
<pre><code class="language-yaml">image: archlinux
packages:
  - rustup
sources:
  - &lt;your repo&gt;
tasks:
  - setup: |
      rustup toolchain install nightly stable
      cd &lt;your project&gt;/
      rustup run stable cargo fetch
  - stable: |
      rustup default stable
      cd &lt;your project&gt;/
      cargo build --verbose
      cargo test --verbose
  - nightly: |
      rustup default nightly
      cd &lt;your project&gt;/
      cargo build --verbose ||:
      cargo test --verbose  ||:
  - docs: |
      cd &lt;your project&gt;/
      rustup run stable cargo doc --no-deps
      rustup run nightly cargo doc --no-deps ||:
</code></pre>
<p>This will test and build documentation on the stable channel and nightly
channel, but any breakage in nightly will not fail your overall build. Please
see the <a href="https://man.sr.ht/builds.sr.ht/">builds.sr.ht documentation</a> for more
information.</p>
<h3 id="circleci"><a class="header" href="#circleci">CircleCI</a></h3>
<p>To test your package on CircleCI, here is a sample <code>.circleci/config.yml</code> file:</p>
<pre><code class="language-yaml">version: 2.1
jobs:
  build:
    docker:
      # check https://circleci.com/developer/images/image/cimg/rust#image-tags for latest
      - image: cimg/rust:1.77.2
    steps:
      - checkout
      - run: cargo test
</code></pre>
<p>To run more complex pipelines, including flaky test detection, caching, and artifact management, please see <a href="https://circleci.com/docs/configuration-reference/">CircleCI Configuration Reference</a>.</p>
<h2 id="verifying-latest-dependencies"><a class="header" href="#verifying-latest-dependencies">Verifying Latest Dependencies</a></h2>
<p>When <a href="guide/../reference/specifying-dependencies.html">specifying dependencies</a> in
<code>Cargo.toml</code>, they generally match a range of versions.
Exhaustively testing all version combination would be unwieldy.
Verifying the latest versions would at least test for users who run <a href="guide/../commands/cargo-add.html"><code>cargo add</code></a> or <a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>.</p>
<p>When testing the latest versions some considerations are:</p>
<ul>
<li>Minimizing external factors affecting local development or CI</li>
<li>Rate of new dependencies being published</li>
<li>Level of risk a project is willing to accept</li>
<li>CI costs, including indirect costs like if a CI service has a maximum for
parallel runners, causing new jobs to be serialized when at the maximum.</li>
</ul>
<p>Some potential solutions include:</p>
<ul>
<li><a href="guide/../faq.html#why-have-cargolock-in-version-control">Not checking in the <code>Cargo.lock</code></a>
<ul>
<li>Depending on PR velocity, many versions may go untested</li>
<li>This comes at the cost of determinism</li>
</ul>
</li>
<li>Have a CI job verify the latest dependencies but mark it to “continue on failure”
<ul>
<li>Depending on the CI service, failures might not be obvious</li>
<li>Depending on PR velocity, may use more resources than necessary</li>
</ul>
</li>
<li>Have a scheduled CI job to verify latest dependencies
<ul>
<li>A hosted CI service may disable scheduled jobs for repositories that
haven’t been touched in a while, affecting passively maintained packages</li>
<li>Depending on the CI service, notifications might not be routed to people
who can act on the failure</li>
<li>If not balanced with dependency publish rate, may not test enough versions
or may do redundant testing</li>
</ul>
</li>
<li>Regularly update dependencies through PRs, like with <a href="https://docs.github.com/en/code-security/dependabot/working-with-dependabot">Dependabot</a> or <a href="https://renovatebot.com/">RenovateBot</a>
<ul>
<li>Can isolate dependencies to their own PR or roll them up into a single PR</li>
<li>Only uses the resources necessary</li>
<li>Can configure the frequency to balance CI resources and coverage of dependency versions</li>
</ul>
</li>
</ul>
<p>An example CI job to verify latest dependencies, using GitHub Actions:</p>
<pre><code class="language-yaml">jobs:
  latest_deps:
    name: Latest Dependencies
    runs-on: ubuntu-latest
    continue-on-error: true
    env:
      CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS: allow
    steps:
      - uses: actions/checkout@v4
      - run: rustup update stable &amp;&amp; rustup default stable
      - run: cargo update --verbose
      - run: cargo build --verbose
      - run: cargo test --verbose
</code></pre>
<p>Notes:</p>
<ul>
<li><a href="guide/../reference/config.html#resolverincompatible-rust-versions"><code>CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS</code></a> is set to ensure the <a href="guide/../reference/resolver.html">resolver</a> doesn’t limit selected dependencies because of your project’s <a href="guide/../reference/rust-version.html">Rust version</a>.</li>
</ul>
<p>For projects with higher risks of per-platform or per-Rust version failures,
more combinations may want to be tested.</p>
<h2 id="verifying-rust-version"><a class="header" href="#verifying-rust-version">Verifying <code>rust-version</code></a></h2>
<p>When publishing packages that specify <a href="guide/../reference/manifest.html#the-rust-version-field"><code>rust-version</code></a>,
it is important to verify the correctness of that field.</p>
<p>Some third-party tools that can help with this include:</p>
<ul>
<li><a href="https://crates.io/crates/cargo-msrv"><code>cargo-msrv</code></a></li>
<li><a href="https://crates.io/crates/cargo-hack"><code>cargo-hack</code></a></li>
</ul>
<p>An example of one way to do this, using GitHub Actions:</p>
<pre><code class="language-yaml">jobs:
  msrv:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: taiki-e/install-action@cargo-hack
    - run: cargo hack check --rust-version --workspace --all-targets --ignore-private
</code></pre>
<p>This tries to balance thoroughness with turnaround time:</p>
<ul>
<li>A single platform is used as most projects are platform-agnostic, trusting platform-specific dependencies to verify their behavior.</li>
<li><code>cargo check</code> is used as most issues contributors will run into are API availability and not behavior.</li>
<li>Unpublished packages are skipped as this assumes only consumers of the verified project, through a registry, will care about <code>rust-version</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-on-cratesio"><a class="header" href="#publishing-on-cratesio">Publishing on crates.io</a></h1>
<p>Once you’ve got a library that you’d like to share with the world, it’s time to
publish it on <a href="https://crates.io/">crates.io</a>! Publishing a crate is when a specific
version is uploaded to be hosted on <a href="https://crates.io/">crates.io</a>.</p>
<p>Take care when publishing a crate, because a publish is <strong>permanent</strong>. The
version can never be overwritten, and the code cannot be deleted. There is no
limit to the number of versions which can be published, however.</p>
<h2 id="before-your-first-publish"><a class="header" href="#before-your-first-publish">Before your first publish</a></h2>
<p>First things first, you’ll need an account on <a href="https://crates.io/">crates.io</a> to acquire
an API token. To do so, <a href="https://crates.io/">visit the home page</a> and log in via a GitHub
account (required for now). You will also need to provide and verify your email
address on the <a href="https://crates.io/settings/profile">Account Settings</a> page. Once
that is done <a href="https://crates.io/settings/tokens">create an API token</a>, make sure
you copy it. Once you leave the page you will not be able to see it again.</p>
<p>Then run the <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> command.</p>
<pre><code class="language-console">$ cargo login
</code></pre>
<p>Then at the prompt put in the token specified.</p>
<pre><code class="language-console">please paste the API Token found on https://crates.io/me below
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in your
<code>~/.cargo/credentials.toml</code>. Note that this token is a <strong>secret</strong> and should not be
shared with anyone else. If it leaks for any reason, you should revoke it
immediately.</p>
<blockquote>
<p><strong>Note</strong>: The <a href="reference/../commands/cargo-logout.html"><code>cargo logout</code></a> command can be used to remove the token from
<code>credentials.toml</code>. This can be useful if you no longer need it stored on
the local machine.</p>
</blockquote>
<h2 id="before-publishing-a-new-crate"><a class="header" href="#before-publishing-a-new-crate">Before publishing a new crate</a></h2>
<p>Keep in mind that crate names on <a href="https://crates.io/">crates.io</a> are allocated on a first-come-first-serve
basis. Once a crate name is taken, it cannot be used for another crate.</p>
<p>Check out the <a href="reference/manifest.html">metadata you can specify</a> in <code>Cargo.toml</code> to
ensure your crate can be discovered more easily! Before publishing, make sure
you have filled out the following fields:</p>
<ul>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license</code> or <code>license-file</code></a></li>
<li><a href="reference/manifest.html#the-description-field"><code>description</code></a></li>
<li><a href="reference/manifest.html#the-homepage-field"><code>homepage</code></a></li>
<li><a href="reference/manifest.html#the-repository-field"><code>repository</code></a></li>
<li><a href="reference/manifest.html#the-readme-field"><code>readme</code></a></li>
</ul>
<p>It would also be a good idea to include some <a href="reference/manifest.html#the-keywords-field"><code>keywords</code></a> and <a href="reference/manifest.html#the-categories-field"><code>categories</code></a>,
though they are not required.</p>
<p>If you are publishing a library, you may also want to consult the <a href="https://rust-lang.github.io/api-guidelines/">Rust API
Guidelines</a>.</p>
<h3 id="packaging-a-crate"><a class="header" href="#packaging-a-crate">Packaging a crate</a></h3>
<p>The next step is to package up your crate and upload it to <a href="https://crates.io/">crates.io</a>. For
this we’ll use the <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> subcommand. This command performs the following
steps:</p>
<ol>
<li>Perform some verification checks on your package.</li>
<li>Compress your source code into a <code>.crate</code> file.</li>
<li>Extract the <code>.crate</code> file into a temporary directory and verify that it
compiles.</li>
<li>Upload the <code>.crate</code> file to <a href="https://crates.io/">crates.io</a>.</li>
<li>The registry will perform some additional checks on the uploaded package
before adding it.</li>
</ol>
<p>It is recommended that you first run <code>cargo publish --dry-run</code> (or <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a> which is equivalent) to ensure there aren’t any warnings or errors
before publishing. This will perform the first three steps listed above.</p>
<pre><code class="language-console">$ cargo publish --dry-run
</code></pre>
<p>You can inspect the generated <code>.crate</code> file in the <code>target/package</code> directory.
<a href="https://crates.io/">crates.io</a> currently has a 10MB size limit on the <code>.crate</code> file. You may want
to check the size of the <code>.crate</code> file to ensure you didn’t accidentally
package up large assets that are not required to build your package, such as
test data, website documentation, or code generation. You can check which
files are included with the following command:</p>
<pre><code class="language-console">$ cargo package --list
</code></pre>
<p>Cargo will automatically ignore files ignored by your version control system
when packaging, but if you want to specify an extra set of files to ignore you
can use the <a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code> key</a> in the
manifest:</p>
<pre><code class="language-toml">[package]
# ...
exclude = [
    "public/assets/*",
    "videos/*",
]
</code></pre>
<p>If you’d rather explicitly list the files to include, Cargo also supports an
<a href="reference/manifest.html#the-exclude-and-include-fields"><code>include</code> key</a>, which if set, overrides the <code>exclude</code> key:</p>
<pre><code class="language-toml">[package]
# ...
include = [
    "**/*.rs",
]
</code></pre>
<h2 id="uploading-the-crate"><a class="header" href="#uploading-the-crate">Uploading the crate</a></h2>
<p>When you are ready to publish, use the <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> command
to upload to <a href="https://crates.io/">crates.io</a>:</p>
<pre><code class="language-console">$ cargo publish
</code></pre>
<p>And that’s it, you’ve now published your first crate!</p>
<h2 id="publishing-a-new-version-of-an-existing-crate"><a class="header" href="#publishing-a-new-version-of-an-existing-crate">Publishing a new version of an existing crate</a></h2>
<p>In order to release a new version, change <a href="reference/manifest.html#the-version-field">the <code>version</code> value</a> specified in your <code>Cargo.toml</code> manifest.
Keep in mind <a href="reference/semver.html">the SemVer rules</a> which provide guidelines on what is a compatible change.
Then run <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> as described above to upload the new version.</p>
<blockquote>
<p><strong>Recommendation:</strong> Consider the full release process and automate what you can.</p>
<p>Each version should include:</p>
<ul>
<li>A changelog entry, preferably <a href="https://keepachangelog.com/en/1.0.0/">manually curated</a> though a generated one is better than nothing</li>
<li>A <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">git tag</a> pointing to the published commit</li>
</ul>
<p>Examples of third-party tools that are representative of different workflows include (in alphabetical order):</p>
<ul>
<li><a href="https://crates.io/crates/cargo-release">cargo-release</a></li>
<li><a href="https://crates.io/crates/cargo-smart-release">cargo-smart-release</a></li>
<li><a href="https://crates.io/crates/release-plz">release-plz</a></li>
</ul>
<p>For more, see <a href="https://crates.io/search?q=cargo%20release">crates.io</a>.</p>
</blockquote>
<h2 id="managing-a-cratesio-based-crate"><a class="header" href="#managing-a-cratesio-based-crate">Managing a crates.io-based crate</a></h2>
<p>Management of crates is primarily done through the command line <code>cargo</code> tool
rather than the <a href="https://crates.io/">crates.io</a> web interface. For this, there are a few subcommands
to manage a crate.</p>
<h3 id="cargo-yank"><a class="header" href="#cargo-yank"><code>cargo yank</code></a></h3>
<p>Occasions may arise where you publish a version of a crate that actually ends up
being broken for one reason or another (syntax error, forgot to include a file,
etc.). For situations such as this, Cargo supports a “yank” of a version of a
crate.</p>
<pre><code class="language-console">$ cargo yank --version 1.0.1
$ cargo yank --version 1.0.1 --undo
</code></pre>
<p>A yank <strong>does not</strong> delete any code. This feature is not intended for deleting
accidentally uploaded secrets, for example. If that happens, you must reset
those secrets immediately.</p>
<p>The semantics of a yanked version are that no new dependencies can be created
against that version, but all existing dependencies continue to work. One of the
major goals of <a href="https://crates.io/">crates.io</a> is to act as a permanent archive of crates that does
not change over time, and allowing deletion of a version would go against this
goal. Essentially a yank means that all packages with a <code>Cargo.lock</code> will not
break, while any future <code>Cargo.lock</code> files generated will not list the yanked
version.</p>
<h3 id="cargo-owner"><a class="header" href="#cargo-owner"><code>cargo owner</code></a></h3>
<p>A crate is often developed by more than one person, or the primary maintainer
may change over time! The owner of a crate is the only person allowed to publish
new versions of the crate, but an owner may designate additional owners.</p>
<pre><code class="language-console">$ cargo owner --add github-handle
$ cargo owner --remove github-handle
$ cargo owner --add github:rust-lang:owners
$ cargo owner --remove github:rust-lang:owners
</code></pre>
<p>The owner IDs given to these commands must be GitHub user names or GitHub teams.</p>
<p>If a user name is given to <code>--add</code>, that user is invited as a “named” owner, with
full rights to the crate. In addition to being able to publish or yank versions
of the crate, they have the ability to add or remove owners, <em>including</em> the
owner that made <em>them</em> an owner. Needless to say, you shouldn’t make people you
don’t fully trust into a named owner. In order to become a named owner, a user
must have logged into <a href="https://crates.io/">crates.io</a> previously.</p>
<p>If a team name is given to <code>--add</code>, that team is invited as a “team” owner, with
restricted right to the crate. While they have permission to publish or yank
versions of the crate, they <em>do not</em> have the ability to add or remove owners.
In addition to being more convenient for managing groups of owners, teams are
just a bit more secure against owners becoming malicious.</p>
<p>The syntax for teams is currently <code>github:org:team</code> (see examples above).
In order to invite a team as an owner one must be a member of that team. No
such restriction applies to removing a team as an owner.</p>
<h2 id="github-permissions"><a class="header" href="#github-permissions">GitHub permissions</a></h2>
<p>Team membership is not something GitHub provides simple public access to, and it
is likely for you to encounter the following message when working with them:</p>
<blockquote>
<p>It looks like you don’t have permission to query a necessary property from
GitHub to complete this request. You may need to re-authenticate on <a href="https://crates.io/">crates.io</a>
to grant permission to read GitHub org memberships.</p>
</blockquote>
<p>This is basically a catch-all for “you tried to query a team, and one of the
five levels of membership access control denied this”. That is not an
exaggeration. GitHub’s support for team access control is Enterprise Grade.</p>
<p>The most likely cause of this is simply that you last logged in before this
feature was added. We originally requested <em>no</em> permissions from GitHub when
authenticating users, because we didn’t actually ever use the user’s token for
anything other than logging them in. However to query team membership on your
behalf, we now require <a href="https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/">the <code>read:org</code> scope</a>.</p>
<p>You are free to deny us this scope, and everything that worked before teams
were introduced will keep working. However you will never be able to add a team
as an owner, or publish a crate as a team owner. If you ever attempt to do this,
you will get the error above. You may also see this error if you ever try to
publish a crate that you don’t own at all, but otherwise happens to have a team.</p>
<p>If you ever change your mind, or just aren’t sure if <a href="https://crates.io/">crates.io</a> has sufficient
permission, you can always go to <a href="https://crates.io/">https://crates.io/</a> and re-authenticate,
which will prompt you for permission if <a href="https://crates.io/">crates.io</a> doesn’t have all the scopes
it would like to.</p>
<p>An additional barrier to querying GitHub is that the organization may be
actively denying third party access. To check this, you can go to:</p>
<pre><code class="language-text">https://github.com/organizations/:org/settings/oauth_application_policy
</code></pre>
<p>where <code>:org</code> is the name of the organization (e.g., <code>rust-lang</code>). You may see
something like:</p>
<p><img src="reference/../images/org-level-acl.png" alt="Organization Access Control" /></p>
<p>Where you may choose to explicitly remove <a href="https://crates.io/">crates.io</a> from your organization’s
blacklist, or simply press the “Remove Restrictions” button to allow all third
party applications to access this data.</p>
<p>Alternatively, when <a href="https://crates.io/">crates.io</a> requested the <code>read:org</code> scope, you could have
explicitly whitelisted <a href="https://crates.io/">crates.io</a> querying the org in question by pressing
the “Grant Access” button next to its name:</p>
<p><img src="reference/../images/auth-level-acl.png" alt="Authentication Access Control" /></p>
<h3 id="troubleshooting-github-team-access-errors"><a class="header" href="#troubleshooting-github-team-access-errors">Troubleshooting GitHub team access errors</a></h3>
<p>When trying to add a GitHub team as crate owner, you may see an error like:</p>
<pre><code class="language-text">error: failed to invite owners to crate &lt;crate_name&gt;: api errors (status 200 OK): could not find the github team org/repo
</code></pre>
<p>In that case, you should go to <a href="https://github.com/settings/applications">the GitHub Application settings page</a> and
check if crates.io is listed in the <code>Authorized OAuth Apps</code> tab.
If it isn’t, you should go to <a href="https://crates.io/">https://crates.io/</a> and authorize it.
Then go back to the Application Settings page on GitHub, click on the
crates.io application in the list, and make sure you or your organization is
listed in the “Organization access” list with a green check mark. If there’s
a button labeled <code>Grant</code> or <code>Request</code>, you should grant the access or
request the org owner to do so.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-home"><a class="header" href="#cargo-home">Cargo Home</a></h1>
<p>The “Cargo home” functions as a download and source cache.
When building a <a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)">crate</a>, Cargo stores downloaded build dependencies in the Cargo home.
You can alter the location of the Cargo home by setting the <code>CARGO_HOME</code> <a href="guide/../reference/environment-variables.html">environmental variable</a>.
The <a href="https://crates.io/crates/home">home</a> crate provides an API for getting this location if you need this information inside your Rust crate.
By default, the Cargo home is located in <code>$HOME/.cargo/</code>.</p>
<p>Please note that the internal structure of the Cargo home is not stabilized and may be subject to change at any time.</p>
<p>The Cargo home consists of following components:</p>
<h2 id="files"><a class="header" href="#files">Files:</a></h2>
<ul>
<li>
<p><code>config.toml</code>
Cargo’s global configuration file, see the <a href="guide/../reference/config.html">config entry in the reference</a>.</p>
</li>
<li>
<p><code>credentials.toml</code>
Private login credentials from <a href="guide/../commands/cargo-login.html"><code>cargo login</code></a> in order to log in to a <a href="guide/../appendix/glossary.html#registry" title="&quot;registry&quot; (glossary entry)">registry</a>.</p>
</li>
<li>
<p><code>.crates.toml</code>, <code>.crates2.json</code>
These hidden files contain <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a> information of crates installed via <a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>. Do NOT edit by hand!</p>
</li>
</ul>
<h2 id="directories"><a class="header" href="#directories">Directories:</a></h2>
<ul>
<li>
<p><code>bin</code>
The bin directory contains executables of crates that were installed via <a href="guide/../commands/cargo-install.html"><code>cargo install</code></a> or <a href="https://rust-lang.github.io/rustup/"><code>rustup</code></a>.
To be able to make these binaries accessible, add the path of the directory to your <code>$PATH</code> environment variable.</p>
</li>
<li>
<p><code>git</code>
Git sources are stored here:</p>
<ul>
<li>
<p><code>git/db</code>
When a crate depends on a git repository, Cargo clones the repo as a bare repo into this directory and updates it if necessary.</p>
</li>
<li>
<p><code>git/checkouts</code>
If a git source is used, the required commit of the repo is checked out from the bare repo inside <code>git/db</code> into this directory.
This provides the compiler with the actual files contained in the repo of the commit specified for that dependency.
Multiple checkouts of different commits of the same repo are possible.</p>
</li>
</ul>
</li>
<li>
<p><code>registry</code>
Packages and metadata of crate registries (such as <a href="https://crates.io/">crates.io</a>) are located here.</p>
<ul>
<li>
<p><code>registry/index</code>
The index is a bare git repository which contains the metadata (versions, dependencies etc) of all available crates of a registry.</p>
</li>
<li>
<p><code>registry/cache</code>
Downloaded dependencies are stored in the cache. The crates are compressed gzip archives named with a <code>.crate</code> extension.</p>
</li>
<li>
<p><code>registry/src</code>
If a downloaded <code>.crate</code> archive is required by a package, it is unpacked into <code>registry/src</code> folder where rustc will find the <code>.rs</code> files.</p>
</li>
</ul>
</li>
</ul>
<h2 id="caching-the-cargo-home-in-ci"><a class="header" href="#caching-the-cargo-home-in-ci">Caching the Cargo home in CI</a></h2>
<p>To avoid redownloading all crate dependencies during continuous integration, you can cache the <code>$CARGO_HOME</code> directory.
However, caching the entire directory is often inefficient as it will contain downloaded sources twice.
If we depend on a crate such as <code>serde 1.0.92</code> and cache the entire <code>$CARGO_HOME</code> we would actually cache the sources twice, the <code>serde-1.0.92.crate</code> inside <code>registry/cache</code> and the extracted <code>.rs</code> files of serde inside <code>registry/src</code>.
That can unnecessarily slow down the build as downloading, extracting, recompressing and reuploading the cache to the CI servers can take some time.</p>
<p>If you wish to cache binaries installed with <a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>, you need to cache the <code>bin/</code> folder and the <code>.crates.toml</code> and <code>.crates2.json</code> files.</p>
<p>It should be sufficient to cache the following files and directories across builds:</p>
<ul>
<li><code>.crates.toml</code></li>
<li><code>.crates2.json</code></li>
<li><code>bin/</code></li>
<li><code>registry/index/</code></li>
<li><code>registry/cache/</code></li>
<li><code>git/db/</code></li>
</ul>
<h2 id="vendoring-all-dependencies-of-a-project"><a class="header" href="#vendoring-all-dependencies-of-a-project">Vendoring all dependencies of a project</a></h2>
<p>See the <a href="guide/../commands/cargo-vendor.html"><code>cargo vendor</code></a> subcommand.</p>
<h2 id="clearing-the-cache"><a class="header" href="#clearing-the-cache">Clearing the cache</a></h2>
<p>In theory, you can always remove any part of the cache and Cargo will do its best to restore sources if a crate needs them either by reextracting an archive or checking out a bare repo or by simply redownloading the sources from the web.</p>
<p>Alternatively, the <a href="https://crates.io/crates/cargo-cache">cargo-cache</a> crate provides a simple CLI tool to only clear selected parts of the cache or show sizes of its components in your command-line.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizing-build-performance"><a class="header" href="#optimizing-build-performance">Optimizing Build Performance</a></h1>
<p>Cargo configuration options and source code organization patterns can help improve build performance, by prioritizing it over other aspects which may not be as important for your circumstances.</p>
<p>Same as when optimizing runtime performance, be sure to measure these changes against the workflows you actually care about, as we provide general guidelines and your circumstances may be different, it is possible that some of these approaches might actually make build performance worse for your use-case.</p>
<p>Example workflows to consider include:</p>
<ul>
<li>Compiler feedback as you develop (<code>cargo check</code> after making a code change)</li>
<li>Test feedback as you develop (<code>cargo test</code> after making a code change)</li>
<li>CI builds</li>
</ul>
<h2 id="cargo-and-compiler-configuration"><a class="header" href="#cargo-and-compiler-configuration">Cargo and Compiler Configuration</a></h2>
<p>Cargo uses configuration defaults that try to balance several aspects, including debuggability, runtime performance, build performance, binary size and others. This section describes several approaches for changing these defaults that should be designed to maximize build performance.</p>
<p>Common locations to override defaults are:</p>
<ul>
<li><a href="guide/../reference/profiles.html"><code>Cargo.toml</code> manifest</a>
<ul>
<li>Available to all developers contributing to your project</li>
<li>Limited in what configuration is supported (see <a href="https://github.com/rust-lang/cargo/issues/12738">#12738</a> for expanding this)</li>
</ul>
</li>
<li><a href="guide/../reference/config.html"><code>$WORKSPACE_ROOT/.cargo/config.toml</code> configuration file</a>
<ul>
<li>Available to all developers contributing to your project</li>
<li>Unlike <code>Cargo.toml</code>, this is sensitive to what directory you invoke <code>cargo</code> from (see <a href="https://github.com/rust-lang/cargo/issues/2930">#2930</a>)</li>
</ul>
</li>
<li><a href="guide/../reference/config.html"><code>$CARGO_HOME/.cargo/config.toml</code> configuration file</a>
<ul>
<li>For a developer to control the defaults for their development</li>
</ul>
</li>
</ul>
<h3 id="reduce-amount-of-generated-debug-information"><a class="header" href="#reduce-amount-of-generated-debug-information">Reduce amount of generated debug information</a></h3>
<p>Recommendation: Add to your <code>Cargo.toml</code> or <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[profile.dev]
debug = "line-tables-only"

[profile.dev.package."*"]
debug = false

[profile.debugging]
inherits = "dev"
debug = true
</code></pre>
<p>This will:</p>
<ul>
<li>Change the <a href="guide/../reference/profiles.html#dev"><code>dev</code> profile</a> (default for development commands) to:
<ul>
<li>Limit <a href="guide/../reference/profiles.html#debug">debug information</a> for workspace members to what is needed for useful panic backtraces</li>
<li>Avoid generating any debug information for dependencies</li>
</ul>
</li>
<li>Provide an opt-in for when debugging via <a href="guide/../reference/profiles.html#custom-profiles"><code>--profile debugging</code></a></li>
</ul>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster code generation (<code>cargo build</code>)</li>
<li>✅ Faster link times</li>
<li>✅ Smaller disk usage of the <code>target</code> directory</li>
<li>❌ Requires a full rebuild to have a high-quality debugger experience</li>
</ul>
<h3 id="use-an-alternative-codegen-backend"><a class="header" href="#use-an-alternative-codegen-backend">Use an alternative codegen backend</a></h3>
<p>Recommendation:</p>
<ul>
<li>Install the Cranelift codegen backend rustup component
<pre><code class="language-console">$ rustup component add rustc-codegen-cranelift-preview --toolchain nightly
</code></pre>
</li>
<li>Add to your <code>Cargo.toml</code> or <code>.cargo/config.toml</code>:
<pre><code class="language-toml">[profile.dev]
codegen-backend = "cranelift"
</code></pre>
</li>
<li>Run Cargo with <code>-Z codegen-backend</code> or enable the <a href="guide/../reference/unstable.html#codegen-backend"><code>codegen-backend</code></a> feature in <code>.cargo/config.toml</code>.
<ul>
<li>This is required because this is currently an unstable feature.</li>
</ul>
</li>
</ul>
<p>This will change the <a href="guide/../reference/profiles.html#dev"><code>dev</code> profile</a> to use the <a href="https://github.com/rust-lang/rustc_codegen_cranelift">Cranelift codegen backend</a> for generating machine code, instead of the default LLVM backend. The Cranelift backend should generate code faster than LLVM, which should result in improved build performance.</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster code generation (<code>cargo build</code>)</li>
<li>❌ <strong>Requires using nightly Rust and an <a href="guide/../reference/unstable.html#codegen-backend">unstable Cargo feature</a></strong></li>
<li>❌ Worse runtime performance of the generated code
<ul>
<li>Speeds up build part of <code>cargo test</code>, but might increase its test execution part</li>
</ul>
</li>
<li>❌ Only available for <a href="https://github.com/rust-lang/rustc_codegen_cranelift?tab=readme-ov-file#platform-support">certain targets</a></li>
<li>❌ Might not support all Rust features (e.g. unwinding)</li>
</ul>
<h3 id="enable-the-experimental-parallel-frontend"><a class="header" href="#enable-the-experimental-parallel-frontend">Enable the experimental parallel frontend</a></h3>
<p>Recommendation: Add to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[build]
rustflags = "-Zthreads=8"
</code></pre>
<p>This <a href="guide/../reference/config.html#buildrustflags"><code>rustflags</code></a> will enable the <a href="https://blog.rust-lang.org/2023/11/09/parallel-rustc/">parallel frontend</a> of the Rust compiler, and tell it to use <code>n</code> threads. The value of <code>n</code> should be chosen according to the number of cores available on your system, although there are diminishing returns. We recommend using at most <code>8</code> threads.</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster build times (both <code>cargo check</code> and <code>cargo build</code>)</li>
<li>❌ <strong>Requires using nightly Rust and an <a href="https://github.com/rust-lang/rust/issues/113349">unstable Rust feature</a></strong></li>
</ul>
<h3 id="use-an-alternative-linker"><a class="header" href="#use-an-alternative-linker">Use an alternative linker</a></h3>
<p>Consider: installing and configuring an alternative linker, like <a href="https://lld.llvm.org/">LLD</a>, <a href="https://github.com/rui314/mold">mold</a> or <a href="https://github.com/davidlattimore/wild">wild</a>. For example, to configure mold on Linux, you can add to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.'cfg(target_os = "linux")']
# mold, if you have GCC 12+
rustflags = ["-C", "link-arg=-fuse-ld=mold"]

# mold, otherwise
linker = "clang"
rustflags = ["-C", "link-arg=-fuse-ld=/path/to/mold"]
</code></pre>
<p>While dependencies may be built in parallel, linking all of your dependencies happens at once at the end of your build, which can make linking dominate your build times, especially for incremental rebuilds. Often, the linker Rust uses is already fairly fast and the gains from switching may not be worth it, but it is not always the case. For example, Linux targets besides <code>x86_64-unknown-linux-gnu</code> still use the Linux system linker which is quite slow (see <a href="https://github.com/rust-lang/rust/issues/39915">rust#39915</a> for more details).</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster link times</li>
<li>❌ Might not support all use-cases, in particular if you depend on C or C++ dependencies</li>
</ul>
<h3 id="resolve-features-for-the-whole-workspace"><a class="header" href="#resolve-features-for-the-whole-workspace">Resolve features for the whole workspace</a></h3>
<p>Consider: adding to your project’s <code>.cargo/config.toml</code></p>
<pre><code class="language-toml">[resolver]
feature-unification = "workspace"
</code></pre>
<p>When invoking <code>cargo</code>,
<a href="guide/../reference/resolver.html#features">features get activated</a> based on which workspace members you have selected.
However, when contributing to an application,
you may need to build and test various packages within the application,
which can cause extraneous rebuilds because different sets of features may be activated for common dependencies.
With <a href="guide/../reference/unstable.html#feature-unification"><code>feauture-unification</code></a>,
you can reuse more dependency builds by ensuring the same set of dependency features are activated,
independent of which package you are currently building and testing.</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Fewer rebuilds when building different packages in a workspace</li>
<li>❌ <strong>Requires using nightly Rust and an <a href="guide/../reference/unstable.html#feature-unification">unstable Cargo feature</a></strong></li>
<li>❌ A package activating a feature can mask bugs in other packages that should activate it but don’t</li>
<li>❌ If the feature unification from <code>--workspace</code> doesn’t work for you, then this won’t either</li>
</ul>
<h2 id="reducing-built-code"><a class="header" href="#reducing-built-code">Reducing built code</a></h2>
<h3 id="removing-unused-dependencies"><a class="header" href="#removing-unused-dependencies">Removing unused dependencies</a></h3>
<p>Recommendation: Periodically review unused dependencies for removal using third-party tools like
<a href="https://crates.io/crates/cargo-machete">cargo-machete</a>,
<a href="https://crates.io/crates/cargo-udeps">cargo-udeps</a>,
<a href="https://crates.io/crates/cargo-shear">cargo-shear</a>.</p>
<p>When changing code,
it can be easy to miss that a dependency is no longer used and can be removed.</p>
<blockquote>
<p><strong>Note:</strong> native support for this in Cargo is being tracked in <a href="https://github.com/rust-lang/cargo/issues/15813">#15813</a>.</p>
</blockquote>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster full build and link times</li>
<li>❌ May incorrectly flag dependencies as unused or miss some</li>
</ul>
<h3 id="removing-unused-features-from-dependencies"><a class="header" href="#removing-unused-features-from-dependencies">Removing unused features from dependencies</a></h3>
<p>Recommendation: Periodically review unused features from dependencies for removal using third-party tools like
<a href="https://crates.io/crates/cargo-features-manager">cargo-features-manager</a>,
<a href="https://crates.io/crates/cargo-unused-features">cargo-unused-features</a>.</p>
<p>When changing code,
it can be easy to miss that a dependency’s feature is no longer used and can be removed.
This can reduce the number of transitive dependencies being built or
reduce the amount of code within a crate being built.
When removing features, extra caution is needed because features
may also be used for desired behavior or performance changes
which may not always be obvious from compiling or testing.</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster full build and link times</li>
<li>❌ May incorrectly flag features as unused</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-reference"><a class="header" href="#cargo-reference">Cargo Reference</a></h1>
<p>The reference covers the details of various areas of Cargo.</p>
<ul>
<li><a href="reference/manifest.html">The Manifest Format</a>
<ul>
<li><a href="reference/cargo-targets.html">Cargo Targets</a></li>
<li><a href="reference/rust-version.html">Rust version</a></li>
</ul>
</li>
<li><a href="reference/workspaces.html">Workspaces</a></li>
<li><a href="reference/specifying-dependencies.html">Specifying Dependencies</a>
<ul>
<li><a href="reference/overriding-dependencies.html">Overriding Dependencies</a></li>
<li><a href="reference/source-replacement.html">Source Replacement</a></li>
<li><a href="reference/resolver.html">Dependency Resolution</a></li>
</ul>
</li>
<li><a href="reference/features.html">Features</a>
<ul>
<li><a href="reference/features-examples.html">Features Examples</a></li>
</ul>
</li>
<li><a href="reference/profiles.html">Profiles</a></li>
<li><a href="reference/config.html">Configuration</a></li>
<li><a href="reference/environment-variables.html">Environment Variables</a></li>
<li><a href="reference/build-scripts.html">Build Scripts</a>
<ul>
<li><a href="reference/build-script-examples.html">Build Script Examples</a></li>
</ul>
</li>
<li><a href="reference/build-cache.html">Build Cache</a></li>
<li><a href="reference/pkgid-spec.html">Package ID Specifications</a></li>
<li><a href="reference/external-tools.html">External Tools</a></li>
<li><a href="reference/registries.html">Registries</a>
<ul>
<li><a href="reference/registry-authentication.html">Registry Authentication</a>
<ul>
<li><a href="reference/credential-provider-protocol.html">Credential Provider Protocol</a></li>
</ul>
</li>
<li><a href="reference/running-a-registry.html">Running a Registry</a>
<ul>
<li><a href="reference/registry-index.html">Registry Index</a></li>
<li><a href="reference/registry-web-api.html">Registry Web API</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="reference/semver.html">SemVer Compatibility</a></li>
<li><a href="reference/future-incompat-report.html">Future incompat report</a></li>
<li><a href="reference/timings.html">Reporting build timings</a></li>
<li><a href="reference/lints.html">Lints</a></li>
<li><a href="reference/unstable.html">Unstable Features</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-manifest-format"><a class="header" href="#the-manifest-format">The Manifest Format</a></h1>
<p>The <code>Cargo.toml</code> file for each package is called its <em>manifest</em>. It is written
in the <a href="https://toml.io/">TOML</a> format. It contains metadata that is needed to compile the package. Checkout
the <code>cargo locate-project</code> section for more detail on how cargo finds the manifest file.</p>
<p>Every manifest file consists of the following sections:</p>
<ul>
<li><a href="reference/unstable.html"><code>cargo-features</code></a> — Unstable, nightly-only features.</li>
<li><a href="reference/manifest.html#the-package-section"><code>[package]</code></a> — Defines a package.
<ul>
<li><a href="reference/manifest.html#the-name-field"><code>name</code></a> — The name of the package.</li>
<li><a href="reference/manifest.html#the-version-field"><code>version</code></a> — The version of the package.</li>
<li><a href="reference/manifest.html#the-authors-field"><code>authors</code></a> — The authors of the package.</li>
<li><a href="reference/manifest.html#the-edition-field"><code>edition</code></a> — The Rust edition.</li>
<li><a href="reference/rust-version.html"><code>rust-version</code></a> — The minimal supported Rust version.</li>
<li><a href="reference/manifest.html#the-description-field"><code>description</code></a> — A description of the package.</li>
<li><a href="reference/manifest.html#the-documentation-field"><code>documentation</code></a> — URL of the package documentation.</li>
<li><a href="reference/manifest.html#the-readme-field"><code>readme</code></a> — Path to the package’s README file.</li>
<li><a href="reference/manifest.html#the-homepage-field"><code>homepage</code></a> — URL of the package homepage.</li>
<li><a href="reference/manifest.html#the-repository-field"><code>repository</code></a> — URL of the package source repository.</li>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license</code></a> — The package license.</li>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license-file</code></a> — Path to the text of the license.</li>
<li><a href="reference/manifest.html#the-keywords-field"><code>keywords</code></a> — Keywords for the package.</li>
<li><a href="reference/manifest.html#the-categories-field"><code>categories</code></a> — Categories of the package.</li>
<li><a href="reference/manifest.html#the-workspace-field"><code>workspace</code></a> — Path to the workspace for the package.</li>
<li><a href="reference/manifest.html#the-build-field"><code>build</code></a> — Path to the package build script.</li>
<li><a href="reference/manifest.html#the-links-field"><code>links</code></a> — Name of the native library the package links with.</li>
<li><a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code></a> — Files to exclude when publishing.</li>
<li><a href="reference/manifest.html#the-exclude-and-include-fields"><code>include</code></a> — Files to include when publishing.</li>
<li><a href="reference/manifest.html#the-publish-field"><code>publish</code></a> — Can be used to prevent publishing the package.</li>
<li><a href="reference/manifest.html#the-metadata-table"><code>metadata</code></a> — Extra settings for external tools.</li>
<li><a href="reference/manifest.html#the-default-run-field"><code>default-run</code></a> — The default binary to run by <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autolib</code></a> — Disables library auto discovery.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autobins</code></a> — Disables binary auto discovery.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autoexamples</code></a> — Disables example auto discovery.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autotests</code></a> — Disables test auto discovery.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autobenches</code></a> — Disables bench auto discovery.</li>
<li><a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> — Sets the dependency resolver to use.</li>
</ul>
</li>
<li>Target tables: (see <a href="reference/cargo-targets.html#configuring-a-target">configuration</a> for settings)
<ul>
<li><a href="reference/cargo-targets.html#library"><code>[lib]</code></a> — Library target settings.</li>
<li><a href="reference/cargo-targets.html#binaries"><code>[[bin]]</code></a> — Binary target settings.</li>
<li><a href="reference/cargo-targets.html#examples"><code>[[example]]</code></a> — Example target settings.</li>
<li><a href="reference/cargo-targets.html#tests"><code>[[test]]</code></a> — Test target settings.</li>
<li><a href="reference/cargo-targets.html#benchmarks"><code>[[bench]]</code></a> — Benchmark target settings.</li>
</ul>
</li>
<li>Dependency tables:
<ul>
<li><a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> — Package library dependencies.</li>
<li><a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> — Dependencies for examples, tests, and benchmarks.</li>
<li><a href="reference/specifying-dependencies.html#build-dependencies"><code>[build-dependencies]</code></a> — Dependencies for build scripts.</li>
<li><a href="reference/specifying-dependencies.html#platform-specific-dependencies"><code>[target]</code></a> — Platform-specific dependencies.</li>
</ul>
</li>
<li><a href="reference/manifest.html#the-badges-section"><code>[badges]</code></a> — Badges to display on a registry.</li>
<li><a href="reference/features.html"><code>[features]</code></a> — Conditional compilation features.</li>
<li><a href="reference/manifest.html#the-lints-section"><code>[lints]</code></a> — Configure linters for this package.</li>
<li><a href="reference/manifest.html#the-hints-section"><code>[hints]</code></a> — Provide hints for compiling this package.</li>
<li><a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> — Override dependencies.</li>
<li><a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a> — Override dependencies (deprecated).</li>
<li><a href="reference/profiles.html"><code>[profile]</code></a> — Compiler settings and optimizations.</li>
<li><a href="reference/workspaces.html"><code>[workspace]</code></a> — The workspace definition.</li>
</ul>
<h2 id="the-package-section"><a class="header" href="#the-package-section">The <code>[package]</code> section</a></h2>
<p>The first section in a <code>Cargo.toml</code> is <code>[package]</code>.</p>
<pre><code class="language-toml">[package]
name = "hello_world" # the name of the package
version = "0.1.0"    # the current version, obeying semver
</code></pre>
<p>The only field required by Cargo is <a href="reference/manifest.html#the-name-field"><code>name</code></a>. If publishing to
a registry, the registry may require additional fields. See the notes below and
<a href="reference/publishing.html">the publishing chapter</a> for requirements for publishing to
<a href="https://crates.io/">crates.io</a>.</p>
<h3 id="the-name-field"><a class="header" href="#the-name-field">The <code>name</code> field</a></h3>
<p>The package name is an identifier used to refer to the package. It is used
when listed as a dependency in another package, and as the default name of
inferred lib and bin targets.</p>
<p>The name must use only <a href="reference/../../std/primitive.char.html#method.is_alphanumeric">alphanumeric</a> characters or <code>-</code> or <code>_</code>, and cannot be empty.</p>
<p>Note that <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> and <a href="reference/../commands/cargo-init.html"><code>cargo init</code></a> impose some additional restrictions on
the package name, such as enforcing that it is a valid Rust identifier and not
a keyword. <a href="https://crates.io/">crates.io</a> imposes even more restrictions, such as:</p>
<ul>
<li>Only ASCII characters are allowed.</li>
<li>Do not use reserved names.</li>
<li>Do not use special Windows names such as “nul”.</li>
<li>Use a maximum of 64 characters of length.</li>
</ul>
<h3 id="the-version-field"><a class="header" href="#the-version-field">The <code>version</code> field</a></h3>
<p>The <code>version</code> field is formatted according to the <a href="https://semver.org">SemVer</a> specification:</p>
<p>Versions must have three numeric parts,
the major version, the minor version, and the patch version.</p>
<p>A pre-release part can be added after a dash such as <code>1.0.0-alpha</code>.
The pre-release part may be separated with periods to distinguish separate
components. Numeric components will use numeric comparison while
everything else will be compared lexicographically.
For example, <code>1.0.0-alpha.11</code> is higher than <code>1.0.0-alpha.4</code>.</p>
<p>A metadata part can be added after a plus, such as <code>1.0.0+21AF26D3</code>.
This is for informational purposes only and is generally ignored by Cargo.</p>
<p>Cargo bakes in the concept of <a href="https://semver.org/">Semantic Versioning</a>,
so versions are considered <a href="reference/semver.html">compatible</a> if their left-most non-zero major/minor/patch component is the same.
See the <a href="reference/resolver.html">Resolver</a> chapter for more information on how Cargo uses versions to
resolve dependencies.</p>
<p>This field is optional and defaults to <code>0.0.0</code>.  The field is required for publishing packages.</p>
<blockquote>
<p><strong>MSRV:</strong> Before 1.75, this field was required</p>
</blockquote>
<h3 id="the-authors-field"><a class="header" href="#the-authors-field">The <code>authors</code> field</a></h3>
<blockquote>
<p><strong>Warning</strong>: This field is deprecated</p>
</blockquote>
<p>The optional <code>authors</code> field lists in an array the people or organizations that are considered
the “authors” of the package. An optional email address may be included within angled brackets at
the end of each author entry.</p>
<pre><code class="language-toml">[package]
# ...
authors = ["Graydon Hoare", "Fnu Lnu &lt;no-reply@rust-lang.org&gt;"]
</code></pre>
<p>This field is surfaced in package metadata and in the <code>CARGO_PKG_AUTHORS</code>
environment variable within <code>build.rs</code> for backwards compatibility.</p>
<h3 id="the-edition-field"><a class="header" href="#the-edition-field">The <code>edition</code> field</a></h3>
<p>The <code>edition</code> key is an optional key that affects which <a href="reference/../../edition-guide/index.html">Rust Edition</a> your package
is compiled with. Setting the <code>edition</code> key in <code>[package]</code> will affect all
targets/crates in the package, including test suites, benchmarks, binaries,
examples, etc.</p>
<pre><code class="language-toml">[package]
# ...
edition = '2024'
</code></pre>
<p>Most manifests have the <code>edition</code> field filled in automatically by <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a>
with the latest stable edition. By default <code>cargo new</code> creates a manifest with
the 2024 edition currently.</p>
<p>If the <code>edition</code> field is not present in <code>Cargo.toml</code>, then the 2015 edition is
assumed for backwards compatibility. Note that all manifests
created with <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> will not use this historical fallback because they
will have <code>edition</code> explicitly specified to a newer value.</p>
<h3 id="the-rust-version-field"><a class="header" href="#the-rust-version-field">The <code>rust-version</code> field</a></h3>
<p>The <code>rust-version</code> field tells cargo what version of the
Rust toolchain you support for your package.
See <a href="reference/rust-version.html">the Rust version chapter</a> for more detail.</p>
<h3 id="the-description-field"><a class="header" href="#the-description-field">The <code>description</code> field</a></h3>
<p>The description is a short blurb about the package. <a href="https://crates.io/">crates.io</a> will display
this with your package. This should be plain text (not Markdown).</p>
<pre><code class="language-toml">[package]
# ...
description = "A short description of my package"
</code></pre>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> requires the <code>description</code> to be set.</p>
</blockquote>
<h3 id="the-documentation-field"><a class="header" href="#the-documentation-field">The <code>documentation</code> field</a></h3>
<p>The <code>documentation</code> field specifies a URL to a website hosting the crate’s
documentation. If no URL is specified in the manifest file, <a href="https://crates.io/">crates.io</a> will
automatically link your crate to the corresponding <a href="https://docs.rs/">docs.rs</a> page when the
documentation has been built and is available (see <a href="https://docs.rs/releases/queue">docs.rs queue</a>).</p>
<pre><code class="language-toml">[package]
# ...
documentation = "https://docs.rs/bitflags"
</code></pre>
<h3 id="the-readme-field"><a class="header" href="#the-readme-field">The <code>readme</code> field</a></h3>
<p>The <code>readme</code> field should be the path to a file in the package root (relative
to this <code>Cargo.toml</code>) that contains general information about the package.
This file will be transferred to the registry when you publish. <a href="https://crates.io/">crates.io</a>
will interpret it as Markdown and render it on the crate’s page.</p>
<pre><code class="language-toml">[package]
# ...
readme = "README.md"
</code></pre>
<p>If no value is specified for this field, and a file named <code>README.md</code>,
<code>README.txt</code> or <code>README</code> exists in the package root, then the name of that
file will be used. You can suppress this behavior by setting this field to
<code>false</code>. If the field is set to <code>true</code>, a default value of <code>README.md</code> will
be assumed.</p>
<h3 id="the-homepage-field"><a class="header" href="#the-homepage-field">The <code>homepage</code> field</a></h3>
<p>The <code>homepage</code> field should be a URL to a site that is the home page for your
package.</p>
<pre><code class="language-toml">[package]
# ...
homepage = "https://serde.rs"
</code></pre>
<p>A value should only be set for <code>homepage</code> if there is a dedicated website for
the crate other than the source repository or API documentation. Do not make
<code>homepage</code> redundant with either the <code>documentation</code> or <code>repository</code> values.</p>
<h3 id="the-repository-field"><a class="header" href="#the-repository-field">The <code>repository</code> field</a></h3>
<p>The <code>repository</code> field should be a URL to the source repository for your
package.</p>
<pre><code class="language-toml">[package]
# ...
repository = "https://github.com/rust-lang/cargo"
</code></pre>
<h3 id="the-license-and-license-file-fields"><a class="header" href="#the-license-and-license-file-fields">The <code>license</code> and <code>license-file</code> fields</a></h3>
<p>The <code>license</code> field contains the name of the software license that the package
is released under. The <code>license-file</code> field contains the path to a file
containing the text of the license (relative to this <code>Cargo.toml</code>).</p>
<p><a href="https://crates.io/">crates.io</a> interprets the <code>license</code> field as an <a href="https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/">SPDX 2.3 license
expression</a>. The name must be a known license
from the <a href="https://github.com/spdx/license-list-data/tree/v3.20">SPDX license list 3.20</a>. See the <a href="https://spdx.org">SPDX site</a>
for more information.</p>
<p>SPDX license expressions support AND and OR operators to combine multiple
licenses.<sup class="footnote-reference" id="fr-slash-1"><a href="#footnote-slash">1</a></sup></p>
<pre><code class="language-toml">[package]
# ...
license = "MIT OR Apache-2.0"
</code></pre>
<p>Using <code>OR</code> indicates the user may choose either license. Using <code>AND</code> indicates
the user must comply with both licenses simultaneously. The <code>WITH</code> operator
indicates a license with a special exception. Some examples:</p>
<ul>
<li><code>MIT OR Apache-2.0</code></li>
<li><code>LGPL-2.1-only AND MIT AND BSD-2-Clause</code></li>
<li><code>GPL-2.0-or-later WITH Bison-exception-2.2</code></li>
</ul>
<p>If a package is using a nonstandard license, then the <code>license-file</code> field may
be specified in lieu of the <code>license</code> field.</p>
<pre><code class="language-toml">[package]
# ...
license-file = "LICENSE.txt"
</code></pre>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> requires either <code>license</code> or <code>license-file</code> to be set.</p>
</blockquote>
<h3 id="the-keywords-field"><a class="header" href="#the-keywords-field">The <code>keywords</code> field</a></h3>
<p>The <code>keywords</code> field is an array of strings that describe this package. This
can help when searching for the package on a registry, and you may choose any
words that would help someone find this crate.</p>
<pre><code class="language-toml">[package]
# ...
keywords = ["gamedev", "graphics"]
</code></pre>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> allows a maximum of 5 keywords. Each keyword must be
ASCII text, have at most 20 characters, start with an alphanumeric character,
and only contain letters, numbers, <code>_</code>, <code>-</code> or <code>+</code>.</p>
</blockquote>
<h3 id="the-categories-field"><a class="header" href="#the-categories-field">The <code>categories</code> field</a></h3>
<p>The <code>categories</code> field is an array of strings of the categories this package
belongs to.</p>
<pre><code class="language-toml">categories = ["command-line-utilities", "development-tools::cargo-plugins"]
</code></pre>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> has a maximum of 5 categories. Each category should
match one of the strings available at <a href="https://crates.io/category_slugs">https://crates.io/category_slugs</a>, and
must match exactly.</p>
</blockquote>
<h3 id="the-workspace-field"><a class="header" href="#the-workspace-field">The <code>workspace</code> field</a></h3>
<p>The <code>workspace</code> field can be used to configure the workspace that this package
will be a member of. If not specified this will be inferred as the first
Cargo.toml with <code>[workspace]</code> upwards in the filesystem. Setting this is
useful if the member is not inside a subdirectory of the workspace root.</p>
<pre><code class="language-toml">[package]
# ...
workspace = "path/to/workspace/root"
</code></pre>
<p>This field cannot be specified if the manifest already has a <code>[workspace]</code>
table defined. That is, a crate cannot both be a root crate in a workspace
(contain <code>[workspace]</code>) and also be a member crate of another workspace
(contain <code>package.workspace</code>).</p>
<p>For more information, see the <a href="reference/workspaces.html">workspaces chapter</a>.</p>
<h3 id="the-build-field"><a class="header" href="#the-build-field">The <code>build</code> field</a></h3>
<p>The <code>build</code> field specifies a file in the package root which is a <a href="reference/build-scripts.html">build
script</a> for building native code. More information can be found in the <a href="reference/build-scripts.html">build
script guide</a>.</p>
<pre><code class="language-toml">[package]
# ...
build = "build.rs"
</code></pre>
<p>The default is <code>"build.rs"</code>, which loads the script from a file named
<code>build.rs</code> in the root of the package. Use <code>build = "custom_build_name.rs"</code> to
specify a path to a different file or <code>build = false</code> to disable automatic
detection of the build script.</p>
<h3 id="the-links-field"><a class="header" href="#the-links-field">The <code>links</code> field</a></h3>
<p>The <code>links</code> field specifies the name of a native library that is being linked
to. More information can be found in the <a href="reference/build-scripts.html#the-links-manifest-key"><code>links</code></a> section of the build
script guide.</p>
<p>For example, a crate that links a native library called “git2” (e.g. <code>libgit2.a</code>
on Linux) may specify:</p>
<pre><code class="language-toml">[package]
# ...
links = "git2"
</code></pre>
<h3 id="the-exclude-and-include-fields"><a class="header" href="#the-exclude-and-include-fields">The <code>exclude</code> and <code>include</code> fields</a></h3>
<p>The <code>exclude</code> and <code>include</code> fields can be used to explicitly specify which
files are included when packaging a project to be <a href="reference/publishing.html">published</a>,
and certain kinds of change tracking (described below).
The patterns specified in the <code>exclude</code> field identify a set of files that are
not included, and the patterns in <code>include</code> specify files that are explicitly
included.
You may run <a href="reference/../commands/cargo-package.html"><code>cargo package --list</code></a> to verify which files will
be included in the package.</p>
<pre><code class="language-toml">[package]
# ...
exclude = ["/ci", "images/", ".*"]
</code></pre>
<pre><code class="language-toml">[package]
# ...
include = ["/src", "COPYRIGHT", "/examples", "!/examples/big_example"]
</code></pre>
<p>The default if neither field is specified is to include all files from the
root of the package, except for the exclusions listed below.</p>
<p>If <code>include</code> is not specified, then the following files will be excluded:</p>
<ul>
<li>If the package is not in a git repository, all “hidden” files starting with
a dot will be skipped.</li>
<li>If the package is in a git repository, any files that are ignored by the
<a href="https://git-scm.com/docs/gitignore">gitignore</a> rules of the repository and global git configuration will be
skipped.</li>
</ul>
<p>Regardless of whether <code>exclude</code> or <code>include</code> is specified, the following files
are always excluded:</p>
<ul>
<li>Any sub-packages will be skipped (any subdirectory that contains a
<code>Cargo.toml</code> file).</li>
<li>A directory named <code>target</code> in the root of the package will be skipped.</li>
</ul>
<p>The following files are always included:</p>
<ul>
<li>The <code>Cargo.toml</code> file of the package itself is always included, it does not
need to be listed in <code>include</code>.</li>
<li>A minimized <code>Cargo.lock</code> is automatically included.
See <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a> for more information.</li>
<li>If a <a href="reference/manifest.html#the-license-and-license-file-fields"><code>license-file</code></a> is specified, it
is always included.</li>
</ul>
<p>The options are mutually exclusive; setting <code>include</code> will override an
<code>exclude</code>. If you need to have exclusions to a set of <code>include</code> files, use the
<code>!</code> operator described below.</p>
<p>The patterns should be <a href="https://git-scm.com/docs/gitignore">gitignore</a>-style patterns. Briefly:</p>
<ul>
<li><code>foo</code> matches any file or directory with the name <code>foo</code> anywhere in the
package. This is equivalent to the pattern <code>**/foo</code>.</li>
<li><code>/foo</code> matches any file or directory with the name <code>foo</code> only in the root of
the package.</li>
<li><code>foo/</code> matches any <em>directory</em> with the name <code>foo</code> anywhere in the package.</li>
<li>Common glob patterns like <code>*</code>, <code>?</code>, and <code>[]</code> are supported:
<ul>
<li><code>*</code> matches zero or more characters except <code>/</code>.  For example, <code>*.html</code>
matches any file or directory with the <code>.html</code> extension anywhere in the
package.</li>
<li><code>?</code> matches any character except <code>/</code>. For example, <code>foo?</code> matches <code>food</code>,
but not <code>foo</code>.</li>
<li><code>[]</code> allows for matching a range of characters. For example, <code>[ab]</code>
matches either <code>a</code> or <code>b</code>. <code>[a-z]</code> matches letters a through z.</li>
</ul>
</li>
<li><code>**/</code> prefix matches in any directory. For example, <code>**/foo/bar</code> matches the
file or directory <code>bar</code> anywhere that is directly under directory <code>foo</code>.</li>
<li><code>/**</code> suffix matches everything inside. For example, <code>foo/**</code> matches all
files inside directory <code>foo</code>, including all files in subdirectories below
<code>foo</code>.</li>
<li><code>/**/</code> matches zero or more directories. For example, <code>a/**/b</code> matches
<code>a/b</code>, <code>a/x/b</code>, <code>a/x/y/b</code>, and so on.</li>
<li><code>!</code> prefix negates a pattern. For example, a pattern of <code>src/*.rs</code> and
<code>!foo.rs</code> would match all files with the <code>.rs</code> extension inside the <code>src</code>
directory, except for any file named <code>foo.rs</code>.</li>
</ul>
<p>The include/exclude list is also used for change tracking in some situations.
For targets built with <code>rustdoc</code>, it is used to determine the list of files to
track to determine if the target should be rebuilt. If the package has a
<a href="reference/build-scripts.html">build script</a> that does not emit any <code>rerun-if-*</code> directives, then the
include/exclude list is used for tracking if the build script should be re-run
if any of those files change.</p>
<h3 id="the-publish-field"><a class="header" href="#the-publish-field">The <code>publish</code> field</a></h3>
<p>The <code>publish</code> field can be used to control which registries names the package
may be published to:</p>
<pre><code class="language-toml">[package]
# ...
publish = ["some-registry-name"]
</code></pre>
<p>To prevent a package from being published to a registry (like crates.io) by mistake,
for instance to keep a package private in a company,
you can omit the <a href="reference/manifest.html#the-version-field"><code>version</code></a> field.
If you’d like to be more explicit, you can disable publishing:</p>
<pre><code class="language-toml">[package]
# ...
publish = false
</code></pre>
<p>If publish array contains a single registry, <code>cargo publish</code> command will use
it when <code>--registry</code> flag is not specified.</p>
<h3 id="the-metadata-table"><a class="header" href="#the-metadata-table">The <code>metadata</code> table</a></h3>
<p>Cargo by default will warn about unused keys in <code>Cargo.toml</code> to assist in
detecting typos and such. The <code>package.metadata</code> table, however, is completely
ignored by Cargo and will not be warned about. This section can be used for
tools which would like to store package configuration in <code>Cargo.toml</code>. For
example:</p>
<pre><code class="language-toml">[package]
name = "..."
# ...

# Metadata used when generating an Android APK, for example.
[package.metadata.android]
package-name = "my-awesome-android-app"
assets = "path/to/static"
</code></pre>
<p>You’ll need to look in the documentation for your tool to see how to use this field.
For Rust Projects that use <code>package.metadata</code> tables, see:</p>
<ul>
<li><a href="https://docs.rs/about/metadata">docs.rs</a></li>
</ul>
<p>There is a similar table at the workspace level at
<a href="reference/workspaces.html#the-metadata-table"><code>workspace.metadata</code></a>. While cargo does not specify a
format for the content of either of these tables, it is suggested that
external tools may wish to use them in a consistent fashion, such as referring
to the data in <code>workspace.metadata</code> if data is missing from <code>package.metadata</code>,
if that makes sense for the tool in question.</p>
<h3 id="the-default-run-field"><a class="header" href="#the-default-run-field">The <code>default-run</code> field</a></h3>
<p>The <code>default-run</code> field in the <code>[package]</code> section of the manifest can be used
to specify a default binary picked by <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>. For example, when there is
both <code>src/bin/a.rs</code> and <code>src/bin/b.rs</code>:</p>
<pre><code class="language-toml">[package]
default-run = "a"
</code></pre>
<h2 id="the-lints-section"><a class="header" href="#the-lints-section">The <code>[lints]</code> section</a></h2>
<p>Override the default level of lints from different tools by assigning them to a new level in a
table, for example:</p>
<pre><code class="language-toml">[lints.rust]
unsafe_code = "forbid"
</code></pre>
<p>This is short-hand for:</p>
<pre><code class="language-toml">[lints.rust]
unsafe_code = { level = "forbid", priority = 0 }
</code></pre>
<p><code>level</code> corresponds to the <a href="https://doc.rust-lang.org/rustc/lints/levels.html">lint levels</a> in <code>rustc</code>:</p>
<ul>
<li><code>forbid</code></li>
<li><code>deny</code></li>
<li><code>warn</code></li>
<li><code>allow</code></li>
</ul>
<p><code>priority</code> is a signed integer that controls which lints or lint groups override other lint groups:</p>
<ul>
<li>lower (particularly negative) numbers have lower priority, being overridden
by higher numbers, and show up first on the command-line to tools like
<code>rustc</code></li>
</ul>
<p>To know which table under <code>[lints]</code> a particular lint belongs under, it is the part before <code>::</code> in the lint
name.  If there isn’t a <code>::</code>, then the tool is <code>rust</code>.  For example a warning
about <code>unsafe_code</code> would be <code>lints.rust.unsafe_code</code> but a lint about
<code>clippy::enum_glob_use</code> would be <code>lints.clippy.enum_glob_use</code>.</p>
<p>For example:</p>
<pre><code class="language-toml">[lints.rust]
unsafe_code = "forbid"

[lints.clippy]
enum_glob_use = "deny"
</code></pre>
<p>Generally, these will only affect local development of the current package.
Cargo only applies these to the current package and not to dependencies.
As for dependents, Cargo suppresses lints from non-path dependencies with features like
<a href="reference/../../rustc/lints/levels.html#capping-lints"><code>--cap-lints</code></a>.</p>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.74</p>
</blockquote>
<h2 id="the-hints-section"><a class="header" href="#the-hints-section">The <code>[hints]</code> section</a></h2>
<p>The <code>[hints]</code> section allows specifying hints for compiling this package. Cargo
will respect these hints by default when compiling this package, though the
top-level package being built can override these values through the <code>[profile]</code>
mechanism. Hints are, by design, always safe for Cargo to ignore; if Cargo
encounters a hint it doesn’t understand, or a hint it understands but with a
value it doesn’t understand, it will warn, but not error. As a result,
specifying hints in a crate does not impact the MSRV of the crate.</p>
<p>Individual hints may have an associated unstable feature gate that you need to
pass in order to apply the configuration they specify, but if you don’t specify
that unstable feature gate, you will again get only a warning, not an error.</p>
<p>There are no stable hints at this time. See the <a href="reference/unstable.html#profile-hint-mostly-unused-option">hint-mostly-unused
documentation</a> for information
on an unstable hint.</p>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.90.</p>
</blockquote>
<h2 id="the-badges-section"><a class="header" href="#the-badges-section">The <code>[badges]</code> section</a></h2>
<p>The <code>[badges]</code> section is for specifying status badges that can be displayed
on a registry website when the package is published.</p>
<blockquote>
<p>Note: <a href="https://crates.io/">crates.io</a> previously displayed badges next to a crate on its
website, but that functionality has been removed. Packages should place
badges in its README file which will be displayed on <a href="https://crates.io/">crates.io</a> (see <a href="reference/manifest.html#the-readme-field">the
<code>readme</code> field</a>).</p>
</blockquote>
<pre><code class="language-toml">[badges]
# The `maintenance` table indicates the status of the maintenance of
# the crate. This may be used by a registry, but is currently not
# used by crates.io. See https://github.com/rust-lang/crates.io/issues/2437
# and https://github.com/rust-lang/crates.io/issues/2438 for more details.
#
# The `status` field is required. Available options are:
# - `actively-developed`: New features are being added and bugs are being fixed.
# - `passively-maintained`: There are no plans for new features, but the maintainer intends to
#   respond to issues that get filed.
# - `as-is`: The crate is feature complete, the maintainer does not intend to continue working on
#   it or providing support, but it works for the purposes it was designed for.
# - `experimental`: The author wants to share it with the community but is not intending to meet
#   anyone's particular use case.
# - `looking-for-maintainer`: The current maintainer would like to transfer the crate to someone
#   else.
# - `deprecated`: The maintainer does not recommend using this crate (the description of the crate
#   can describe why, there could be a better solution available or there could be problems with
#   the crate that the author does not want to fix).
# - `none`: Displays no badge on crates.io, since the maintainer has not chosen to specify
#   their intentions, potential crate users will need to investigate on their own.
maintenance = { status = "..." }
</code></pre>
<h2 id="dependency-sections"><a class="header" href="#dependency-sections">Dependency sections</a></h2>
<p>See the <a href="reference/specifying-dependencies.html">specifying dependencies page</a> for
information on the <code>[dependencies]</code>, <code>[dev-dependencies]</code>,
<code>[build-dependencies]</code>, and target-specific <code>[target.*.dependencies]</code> sections.</p>
<h2 id="the-profile-sections"><a class="header" href="#the-profile-sections">The <code>[profile.*]</code> sections</a></h2>
<p>The <code>[profile]</code> tables provide a way to customize compiler settings such as
optimizations and debug settings. See <a href="reference/profiles.html">the Profiles chapter</a> for
more detail.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-slash">
<p>Previously multiple licenses could be separated with a <code>/</code>, but that
usage is deprecated. <a href="#fr-slash-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-targets"><a class="header" href="#cargo-targets">Cargo Targets</a></h1>
<p>Cargo packages consist of <em>targets</em> which correspond to source files which can
be compiled into a crate. Packages can have <a href="reference/cargo-targets.html#library">library</a>,
<a href="reference/cargo-targets.html#binaries">binary</a>, <a href="reference/cargo-targets.html#examples">example</a>, <a href="reference/cargo-targets.html#tests">test</a>, and
<a href="reference/cargo-targets.html#benchmarks">benchmark</a> targets. The list of targets can be configured in the
<code>Cargo.toml</code> manifest, often <a href="reference/cargo-targets.html#target-auto-discovery">inferred automatically</a>
by the <a href="reference/../guide/project-layout.html">directory layout</a> of the source files.</p>
<p>See <a href="reference/cargo-targets.html#configuring-a-target">Configuring a target</a> below for details on
configuring the settings for a target.</p>
<h2 id="library"><a class="header" href="#library">Library</a></h2>
<p>The library target defines a “library” that can be used and linked by other
libraries and executables. The filename defaults to <code>src/lib.rs</code>, and the name
of the library defaults to the name of the package, with any dashes replaced
with underscores. A package can have only one library. The settings for the
library can be <a href="reference/cargo-targets.html#configuring-a-target">customized</a> in the <code>[lib]</code> table in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml"># Example of customizing the library in Cargo.toml.
[lib]
crate-type = ["cdylib"]
bench = false
</code></pre>
<h2 id="binaries"><a class="header" href="#binaries">Binaries</a></h2>
<p>Binary targets are executable programs that can be run after being compiled.
A binary’s source can be <code>src/main.rs</code> and/or stored in the <a href="reference/../guide/project-layout.html"><code>src/bin/</code>
directory</a>. For <code>src/main.rs</code>, the default binary name is the
package name. The settings for each binary can be <a href="reference/cargo-targets.html#configuring-a-target">customized</a> in the<code>[[bin]]</code>
tables in <code>Cargo.toml</code>.</p>
<p>Binaries can use the public API of the package’s library. They are also linked
with the <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> defined in <code>Cargo.toml</code>.</p>
<p>You can run individual binaries with the <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> command with the <code>--bin &lt;bin-name&gt;</code> option. <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> can be used to copy the executable to a
common location.</p>
<pre><code class="language-toml"># Example of customizing binaries in Cargo.toml.
[[bin]]
name = "cool-tool"
test = false
bench = false

[[bin]]
name = "frobnicator"
required-features = ["frobnicate"]
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Files located under the <a href="reference/../guide/project-layout.html"><code>examples</code> directory</a> are example
uses of the functionality provided by the library. When compiled, they are
placed in the <a href="reference/build-cache.html"><code>target/debug/examples</code> directory</a>.</p>
<p>Examples can use the public API of the package’s library. They are also linked
with the <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> and
<a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> defined in <code>Cargo.toml</code>.</p>
<p>By default, examples are executable binaries (with a <code>main()</code> function). You
can specify the <a href="reference/cargo-targets.html#the-crate-type-field"><code>crate-type</code> field</a> to make an example
be compiled as a library:</p>
<pre><code class="language-toml">[[example]]
name = "foo"
crate-type = ["staticlib"]
</code></pre>
<p>You can run individual executable examples with the <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> command with
the <code>--example &lt;example-name&gt;</code> option. Library examples can be built with
<a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> with the <code>--example &lt;example-name&gt;</code> option. <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>
with the <code>--example &lt;example-name&gt;</code> option can be used to copy executable
binaries to a common location. Examples are compiled by <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> by
default to protect them from bit-rotting. Set <a href="reference/cargo-targets.html#the-test-field">the <code>test</code>
field</a> to <code>true</code> if you have <code>#[test]</code> functions in the
example that you want to run with <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>.</p>
<h2 id="tests-1"><a class="header" href="#tests-1">Tests</a></h2>
<p>There are two styles of tests within a Cargo project:</p>
<ul>
<li><em>Unit tests</em> which are functions marked with the <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code>
attribute</a> located within your library or binaries (or any
target enabled with <a href="reference/cargo-targets.html#the-test-field">the <code>test</code> field</a>). These tests have
access to private APIs located within the target they are defined in.</li>
<li><em>Integration tests</em> which is a separate executable binary, also containing
<code>#[test]</code> functions, which is linked with the project’s library and has
access to its <em>public</em> API.</li>
</ul>
<p>Tests are run with the <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> command. By default, Cargo and <code>rustc</code>
use the <a href="reference/../../rustc/tests/index.html">libtest harness</a> which is responsible for collecting functions
annotated with the <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> attribute</a> and executing them in
parallel, reporting the success and failure of each test. See <a href="reference/cargo-targets.html#the-harness-field">the <code>harness</code>
field</a> if you want to use a different harness or test
strategy.</p>
<blockquote>
<p><strong>Note</strong>: There is another special style of test in Cargo:
<a href="reference/../../rustdoc/documentation-tests.html">documentation tests</a>.
They are handled by <code>rustdoc</code> and have a slightly different execution model.
For more information, please see <a href="reference/../commands/cargo-test.html#documentation-tests"><code>cargo test</code></a>.</p>
</blockquote>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h3>
<p>Files located under the <a href="reference/../guide/project-layout.html"><code>tests</code> directory</a> are integration
tests. When you run <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>, Cargo will compile each of these files as
a separate crate, and execute them.</p>
<p>Integration tests can use the public API of the package’s library. They are
also linked with the <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> and
<a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> defined in <code>Cargo.toml</code>.</p>
<p>If you want to share code among multiple integration tests, you can place it
in a separate module such as <code>tests/common/mod.rs</code> and then put <code>mod common;</code>
in each test to import it.</p>
<p>Each integration test results in a separate executable binary, and <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> will run them serially. In some cases this can be inefficient, as it
can take longer to compile, and may not make full use of multiple CPUs when
running the tests. If you have a lot of integration tests, you may want to
consider creating a single integration test, and split the tests into multiple
modules. The libtest harness will automatically find all of the <code>#[test]</code>
annotated functions and run them in parallel. You can pass module names to
<a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> to only run the tests within that module.</p>
<p>Binary targets are automatically built if there is an integration test. This
allows an integration test to execute the binary to exercise and test its
behavior. The <code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a> is set when the
integration test is built so that it can use the <a href="reference/../../std/macro.env.html"><code>env</code> macro</a> to locate the
executable.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>Benchmarks provide a way to test the performance of your code using the
<a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> command. They follow the same structure as <a href="reference/cargo-targets.html#tests">tests</a>,
with each benchmark function annotated with the <code>#[bench]</code> attribute.
Similarly to tests:</p>
<ul>
<li>Benchmarks are placed in the <a href="reference/../guide/project-layout.html"><code>benches</code> directory</a>.</li>
<li>Benchmark functions defined in libraries and binaries have access to the
<em>private</em> API within the target they are defined in. Benchmarks in the
<code>benches</code> directory may use the <em>public</em> API.</li>
<li><a href="reference/cargo-targets.html#the-bench-field">The <code>bench</code> field</a> can be used to define which targets
are benchmarked by default.</li>
<li><a href="reference/cargo-targets.html#the-harness-field">The <code>harness</code> field</a> can be used to disable the
built-in harness.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The <a href="reference/../../unstable-book/library-features/test.html"><code>#[bench]</code>
attribute</a> is currently
unstable and only available on the <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>. There are some
packages available on <a href="https://crates.io/keywords/benchmark">crates.io</a> that
may help with running benchmarks on the stable channel, such as
<a href="https://crates.io/crates/criterion">Criterion</a>.</p>
</blockquote>
<h2 id="configuring-a-target"><a class="header" href="#configuring-a-target">Configuring a target</a></h2>
<p>All of the  <code>[lib]</code>, <code>[[bin]]</code>, <code>[[example]]</code>, <code>[[test]]</code>, and <code>[[bench]]</code>
sections in <code>Cargo.toml</code> support similar configuration for specifying how a
target should be built. The double-bracket sections like <code>[[bin]]</code> are
<a href="https://toml.io/en/v1.0.0-rc.3#array-of-tables">array-of-table of TOML</a>,
which means you can write more than one <code>[[bin]]</code> section to make several
executables in your crate. You can only specify one library, so <code>[lib]</code> is a
normal TOML table.</p>
<p>The following is an overview of the TOML settings for each target, with each
field described in detail below.</p>
<pre><code class="language-toml">[lib]
name = "foo"           # The name of the target.
path = "src/lib.rs"    # The source file of the target.
test = true            # Is tested by default.
doctest = true         # Documentation examples are tested by default.
bench = true           # Is benchmarked by default.
doc = true             # Is documented by default.
proc-macro = false     # Set to `true` for a proc-macro library.
harness = true         # Use libtest harness.
crate-type = ["lib"]   # The crate types to generate.
required-features = [] # Features required to build this target (N/A for lib).
</code></pre>
<h3 id="the-name-field-1"><a class="header" href="#the-name-field-1">The <code>name</code> field</a></h3>
<p>The <code>name</code> field specifies the name of the target, which corresponds to the
filename of the artifact that will be generated. For a library, this is the
crate name that dependencies will use to reference it.</p>
<p>For the library target, this defaults to the name of the package , with any
dashes replaced with underscores. For the default binary (<code>src/main.rs</code>),
it also defaults to the name of the package, with no replacement for dashes.
For <a href="reference/cargo-targets.html#target-auto-discovery">auto discovered</a> targets, it defaults to the
directory or file name.</p>
<p>This is required for all targets except <code>[lib]</code>.</p>
<h3 id="the-path-field"><a class="header" href="#the-path-field">The <code>path</code> field</a></h3>
<p>The <code>path</code> field specifies where the source for the crate is located, relative
to the <code>Cargo.toml</code> file.</p>
<p>If not specified, the <a href="reference/cargo-targets.html#target-auto-discovery">inferred path</a> is used based on
the target name.</p>
<h3 id="the-test-field"><a class="header" href="#the-test-field">The <code>test</code> field</a></h3>
<p>The <code>test</code> field indicates whether or not the target is tested by default by
<a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>. The default is <code>true</code> for lib, bins, and tests.</p>
<blockquote>
<p><strong>Note</strong>: Examples are built by <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> by default to ensure they
continue to compile, but they are not <em>tested</em> by default. Setting <code>test = true</code> for an example will also build it as a test and run any
<a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> functions defined in the example.</p>
</blockquote>
<h3 id="the-doctest-field"><a class="header" href="#the-doctest-field">The <code>doctest</code> field</a></h3>
<p>The <code>doctest</code> field indicates whether or not <a href="reference/../../rustdoc/documentation-tests.html">documentation examples</a> are
tested by default by <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>. This is only relevant for libraries, it
has no effect on other sections. The default is <code>true</code> for the library.</p>
<h3 id="the-bench-field"><a class="header" href="#the-bench-field">The <code>bench</code> field</a></h3>
<p>The <code>bench</code> field indicates whether or not the target is benchmarked by
default by <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a>. The default is <code>true</code> for lib, bins, and
benchmarks.</p>
<h3 id="the-doc-field"><a class="header" href="#the-doc-field">The <code>doc</code> field</a></h3>
<p>The <code>doc</code> field indicates whether or not the target is included in the
documentation generated by <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> by default. The default is <code>true</code> for
libraries and binaries.</p>
<blockquote>
<p><strong>Note</strong>: The binary will be skipped if its name is the same as the lib
target.</p>
</blockquote>
<h3 id="the-plugin-field"><a class="header" href="#the-plugin-field">The <code>plugin</code> field</a></h3>
<p>This option is deprecated and unused.</p>
<h3 id="the-proc-macro-field"><a class="header" href="#the-proc-macro-field">The <code>proc-macro</code> field</a></h3>
<p>The <code>proc-macro</code> field indicates that the library is a <a href="reference/../../book/ch19-06-macros.html">procedural macro</a>
(<a href="reference/../../reference/procedural-macros.html">reference</a>). This is only valid for the <code>[lib]</code>
target.</p>
<h3 id="the-harness-field"><a class="header" href="#the-harness-field">The <code>harness</code> field</a></h3>
<p>The <code>harness</code> field indicates that the <a href="reference/../../rustc/command-line-arguments.html#option-test"><code>--test</code> flag</a> will be passed to
<code>rustc</code> which will automatically include the libtest library which is the
driver for collecting and running tests marked with the <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code>
attribute</a> or benchmarks with the <code>#[bench]</code> attribute. The
default is <code>true</code> for all targets.</p>
<p>If set to <code>false</code>, then you are responsible for defining a <code>main()</code> function
to run tests and benchmarks.</p>
<p>Tests have the <a href="reference/../../reference/conditional-compilation.html#test"><code>cfg(test)</code> conditional expression</a> enabled whether
or not the harness is enabled.</p>
<h3 id="the-crate-type-field"><a class="header" href="#the-crate-type-field">The <code>crate-type</code> field</a></h3>
<p>The <code>crate-type</code> field defines the <a href="reference/../../reference/linkage.html">crate types</a> that will be generated by the
target. It is an array of strings, allowing you to specify multiple crate
types for a single target. This can only be specified for libraries and
examples. Binaries, tests, and benchmarks are always the “bin” crate type. The
defaults are:</p>
<div class="table-wrapper"><table><thead><tr><th>Target</th><th>Crate Type</th></tr></thead><tbody>
<tr><td>Normal library</td><td><code>"lib"</code></td></tr>
<tr><td>Proc-macro library</td><td><code>"proc-macro"</code></td></tr>
<tr><td>Example</td><td><code>"bin"</code></td></tr>
</tbody></table>
</div>
<p>The available options are <code>bin</code>, <code>lib</code>, <code>rlib</code>, <code>dylib</code>, <code>cdylib</code>,
<code>staticlib</code>, and <code>proc-macro</code>. You can read more about the different crate
types in the <a href="reference/../../reference/linkage.html">Rust Reference Manual</a>.</p>
<h3 id="the-required-features-field"><a class="header" href="#the-required-features-field">The <code>required-features</code> field</a></h3>
<p>The <code>required-features</code> field specifies which <a href="reference/features.html">features</a> the target needs in
order to be built. If any of the required features are not enabled, the
target will be skipped. This is only relevant for the <code>[[bin]]</code>, <code>[[bench]]</code>,
<code>[[test]]</code>, and <code>[[example]]</code> sections, it has no effect on <code>[lib]</code>.</p>
<pre><code class="language-toml">[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
name = "my-pg-tool"
required-features = ["postgres", "tools"]
</code></pre>
<h3 id="the-edition-field-1"><a class="header" href="#the-edition-field-1">The <code>edition</code> field</a></h3>
<p>The <code>edition</code> field defines the <a href="reference/../../edition-guide/index.html">Rust edition</a> the target will use. If not
specified, it defaults to the <a href="reference/manifest.html#the-edition-field"><code>edition</code> field</a> for the
<code>[package]</code>.</p>
<blockquote>
<p><strong>Note:</strong> This field is deprecated and will be removed in a future Edition</p>
</blockquote>
<h2 id="target-auto-discovery"><a class="header" href="#target-auto-discovery">Target auto-discovery</a></h2>
<p>By default, Cargo automatically determines the targets to build based on the
<a href="reference/../guide/project-layout.html">layout of the files</a> on the filesystem. The target
configuration tables, such as <code>[lib]</code>, <code>[[bin]]</code>, <code>[[test]]</code>, <code>[[bench]]</code>, or
<code>[[example]]</code>, can be used to add additional targets that don’t follow the
standard directory layout.</p>
<p>The automatic target discovery can be disabled so that only manually
configured targets will be built. Setting the keys <code>autolib</code>, <code>autobins</code>, <code>autoexamples</code>,
<code>autotests</code>, or <code>autobenches</code> to <code>false</code> in the <code>[package]</code> section will
disable auto-discovery of the corresponding target type.</p>
<pre><code class="language-toml">[package]
# ...
autolib = false
autobins = false
autoexamples = false
autotests = false
autobenches = false
</code></pre>
<p>Disabling automatic discovery should only be needed for specialized
situations. For example, if you have a library where you want a <em>module</em> named
<code>bin</code>, this would present a problem because Cargo would usually attempt to
compile anything in the <code>bin</code> directory as an executable. Here is a sample
layout of this scenario:</p>
<pre><code class="language-text">├── Cargo.toml
└── src
    ├── lib.rs
    └── bin
        └── mod.rs
</code></pre>
<p>To prevent Cargo from inferring <code>src/bin/mod.rs</code> as an executable, set
<code>autobins = false</code> in <code>Cargo.toml</code> to disable auto-discovery:</p>
<pre><code class="language-toml">[package]
# …
autobins = false
</code></pre>
<blockquote>
<p><strong>Note</strong>: For packages with the 2015 edition, the default for auto-discovery
is <code>false</code> if at least one target is manually defined in <code>Cargo.toml</code>.
Beginning with the 2018 edition, the default is always <code>true</code>.</p>
</blockquote>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.27 for <code>autobins</code>, <code>autoexamples</code>, <code>autotests</code>, and <code>autobenches</code></p>
</blockquote>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.83 for <code>autolib</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-version"><a class="header" href="#rust-version">Rust Version</a></h1>
<p>The <code>rust-version</code> field is an optional key that tells cargo what version of the
Rust toolchain you support for your package.</p>
<pre><code class="language-toml">[package]
# ...
rust-version = "1.56"
</code></pre>
<p>The Rust version must be a bare version number with at least one component; it
cannot include semver operators or pre-release identifiers. Compiler pre-release
identifiers such as -nightly will be ignored while checking the Rust version.</p>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.56</p>
</blockquote>
<h2 id="uses"><a class="header" href="#uses">Uses</a></h2>
<p><strong>Diagnostics:</strong></p>
<p>When your package is compiled on an unsupported toolchain, Cargo will report that as an error to the user. This makes the support expectations clear and avoids reporting a less direct diagnostic like invalid syntax or missing functionality
in the standard library. This affects all <a href="reference/cargo-targets.html">Cargo targets</a> in the
package, including binaries, examples, test suites, benchmarks, etc.
A user can opt-in to an unsupported build of a package with the <code>--ignore-rust-version</code> flag.</p>
<p><strong>Development aid:</strong></p>
<p><code>cargo add</code> will auto-select the dependency’s version requirement to be the latest version compatible with your <code>rust-version</code>.
If that isn’t the latest version, <code>cargo add</code> will inform users so they can make the choice on whether to keep it or update your <code>rust-version</code>.</p>
<p>The <a href="reference/resolver.html#rust-version">resolver</a> may take Rust version into account when picking dependencies.</p>
<p>Other tools may also take advantage of it, like <code>cargo clippy</code>’s
<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#incompatible_msrv"><code>incompatible_msrv</code> lint</a>.</p>
<blockquote>
<p><strong>Note:</strong> The <code>rust-version</code> may be ignored using the <code>--ignore-rust-version</code> option.</p>
</blockquote>
<h2 id="support-expectations"><a class="header" href="#support-expectations">Support Expectations</a></h2>
<p>These are general expectations; some packages may document when they do not follow these.</p>
<p><strong>Complete:</strong></p>
<p>All functionality, including binaries and API, are available on the supported Rust versions under every <a href="reference/features.html">feature</a>.</p>
<p><strong>Verified:</strong></p>
<p>A package’s functionality is verified on its supported Rust versions, including automated testing.
See also our
<a href="reference/../guide/continuous-integration.html#verifying-rust-version">Rust version CI guide</a>.</p>
<p><strong>Patchable:</strong></p>
<p>When licenses allow it,
users can <a href="reference/overriding-dependencies.html">override their local dependency</a> with a fork of your package.
In this situation, Cargo may load the entire workspace for the patched dependency which should work on the supported Rust versions, even if other packages in the workspace have different supported Rust versions.</p>
<p><strong>Dependency Support:</strong></p>
<p>In support of the above,
it is expected that each dependency’s version-requirement supports at least one version compatible with your <code>rust-version</code>.
However,
it is <strong>not</strong> expected that the dependency specification excludes versions incompatible with your <code>rust-version</code>.
In fact, supporting both allows you to balance the needs of users that support older Rust versions with those that don’t.</p>
<h2 id="setting-and-updating-rust-version"><a class="header" href="#setting-and-updating-rust-version">Setting and Updating Rust Version</a></h2>
<p>What Rust versions to support is a trade off between</p>
<ul>
<li>Costs for the maintainer in not using newer features of the Rust toolchain or their dependencies</li>
<li>Costs to users who would benefit from a package using newer features of a toolchain, e.g. reducing build times by migrating to a feature in the standard library from a polyfill</li>
<li>Availability of a package to users supporting older Rust versions</li>
</ul>
<blockquote>
<p><strong>Note:</strong> <a href="reference/semver.html#env-new-rust">Changing <code>rust-version</code></a> is assumed to be a minor incompatibility</p>
</blockquote>
<blockquote>
<p><strong>Recommendation:</strong> Choose a policy for what Rust versions to support and when that is changed so users can compare it with their own policy and,
if it isn’t compatible,
decide whether the loss of general improvements or the risk of a blocking bug that won’t be fixed is acceptable or not.</p>
<p>The simplest policy to support is to always use the latest Rust version.</p>
<p>Depending on your risk profile, the next simplest approach is to continue to support old major or minor versions of your package that support older Rust versions.</p>
</blockquote>
<h3 id="selecting-supported-rust-versions"><a class="header" href="#selecting-supported-rust-versions">Selecting supported Rust versions</a></h3>
<p>Users of your package are most likely to track their supported Rust versions to:</p>
<ul>
<li>Their Rust toolchain vendor’s support policy, e.g. The Rust Project or a Linux distribution
<ul>
<li>Note: the Rust Project only offers bug fixes and security updates for the latest version.</li>
</ul>
</li>
<li>A fixed schedule for users to re-verify their packages with the new toolchain, e.g. the first release of the year, every 5 releases.</li>
</ul>
<p>In addition, users are unlikely to be using the new Rust version immediately but need time to notice and re-verify or might not be aligned on the exact same schedule..</p>
<p>Example version policies:</p>
<ul>
<li>“N-2”, meaning “latest version with a 2 release grace window for updating”</li>
<li>Every even release with a 2 release grace window for updating</li>
<li>Every version from this calendar year with a one year grace window for updating</li>
</ul>
<blockquote>
<p><strong>Note:</strong> To find the minimum <code>rust-version</code> compatible with your project as-is, you can use third-party tools like <a href="https://crates.io/crates/cargo-msrv"><code>cargo-msrv</code></a>.</p>
</blockquote>
<h3 id="update-timeline"><a class="header" href="#update-timeline">Update timeline</a></h3>
<p>When your policy specifies you no longer need to support a Rust version, you can update <code>rust-version</code> immediately or when needed.</p>
<p>By allowing <code>rust-version</code> to drift from your policy,
you offer users more of a grace window for upgrading.
However, this is too unpredictable to be relied on for aligning with the Rust version users track.</p>
<p>The further <code>rust-version</code> drifts from your specified policy,
the more likely users are to infer a policy you did not intend,
leading to frustration at the unmet expectations.</p>
<p>When drift is allowed,
there is the question of what is “justifiable enough” to drop supported Versions.
Each person can come to a reasonably different justification;
working through that discussion can be frustrating for the involved parties.
This will disempower those who would want to avoid that type of conflict,
which is particularly the case for new or casual contributors who either
feel that they are not in a position to raise the question or
that the conflict may hurt the chance of their change being merged.</p>
<h3 id="multiple-policies-in-a-workspace"><a class="header" href="#multiple-policies-in-a-workspace">Multiple Policies in a Workspace</a></h3>
<p>Cargo allows supporting multiple policies within one workspace.</p>
<p>Verifying specific packages under specific Rust versions can get complicated.
Tools like <a href="https://crates.io/crates/cargo-hack"><code>cargo-hack</code></a> can help.</p>
<p>For any dependency shared across policies,
the lowest common versions must be used as Cargo
<a href="reference/resolver.html#semver-compatibility">unifies SemVer-compatible versions</a>,
potentially limiting access to features of the shared dependency for the workspace member with the higher <code>rust-version</code>.</p>
<p>To allow users to patch a dependency on one of your workspace members,
every package in the workspace would need to be loadable in the oldest Rust version supported by the workspace.</p>
<p>When using <a href="reference/config.html#resolverincompatible-rust-versions"><code>incompatible-rust-versions = "fallback"</code></a>,
the Rust version of one package can affect dependency versions selected for another package with a different Rust version.
See the <a href="reference/resolver.html#rust-version">resolver</a> chapter for more details.</p>
<h3 id="one-or-more-policies"><a class="header" href="#one-or-more-policies">One or More Policies</a></h3>
<p>One way to mitigate the downsides of supporting older Rust versions is to apply your policy to older major or minor versions of your package that you continue to support.
You likely still need a policy for what Rust versions the development branch support compared to the release branches for those major or minor versions.</p>
<p>Only updating the development branch when “needed”’ can help reduce the number of supported release branches.</p>
<p>There is the question of what can be backported into these release branches.
By backporting new functionality between minor versions,
the next available version would be missing it which could be considered a breaking change, violating SemVer.
Backporting changes also comes with the risk of introducing bugs.</p>
<p>Supporting older versions comes at a cost.
This cost is dependent on the risk and impact of bugs within the package and what is acceptable for backporting.
Creating the release branches on-demand and putting the backport burden on the community are ways to balance this cost.</p>
<p>There is not yet a way for dependency management tools to report that a non-latest version is still supported,
shifting the responsibility to users to notice this in documentation.</p>
<p>For example, a Rust version support policy could look like:</p>
<ul>
<li>The development branch tracks to the latest stable release from the Rust Project, updated when needed
<ul>
<li>The minor version will be raised when changing <code>rust-version</code></li>
</ul>
</li>
<li>The project supports every version for this calendar year, with another year grace window
<ul>
<li>The last minor version that supports a supported Rust version will receive community provided bug fixes</li>
<li>Fixes must be backported to all supported minor releases between the development branch and the needed supported Rust version</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h1>
<p>A <em>workspace</em> is a collection of one or more packages, called <em>workspace
members</em>, that are managed together.</p>
<p>The key points of workspaces are:</p>
<ul>
<li>Common commands can run across all workspace members, like <code>cargo check --workspace</code>.</li>
<li>All packages share a common <a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code></a> file which resides in the
<em>workspace root</em>.</li>
<li>All packages share a common <a href="reference/build-cache.html">output directory</a>, which defaults to a
directory named <code>target</code> in the <em>workspace root</em>.</li>
<li>Sharing package metadata, like with <a href="reference/workspaces.html#the-package-table"><code>workspace.package</code></a>.</li>
<li>The <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a>, <a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a> and <a href="reference/profiles.html"><code>[profile.*]</code></a>
sections in <code>Cargo.toml</code> are only recognized in the <em>root</em> manifest, and
ignored in member crates’ manifests.</li>
</ul>
<p>The root <code>Cargo.toml</code> of a workspace supports the following sections:</p>
<ul>
<li><a href="reference/workspaces.html#the-workspace-section"><code>[workspace]</code></a> — Defines a workspace.
<ul>
<li><a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> — Sets the dependency resolver to use.</li>
<li><a href="reference/workspaces.html#the-members-and-exclude-fields"><code>members</code></a> — Packages to include in the workspace.</li>
<li><a href="reference/workspaces.html#the-members-and-exclude-fields"><code>exclude</code></a> — Packages to exclude from the workspace.</li>
<li><a href="reference/workspaces.html#the-default-members-field"><code>default-members</code></a> — Packages to operate on when a specific package wasn’t selected.</li>
<li><a href="reference/workspaces.html#the-package-table"><code>package</code></a> — Keys for inheriting in packages.</li>
<li><a href="reference/workspaces.html#the-dependencies-table"><code>dependencies</code></a> — Keys for inheriting in package dependencies.</li>
<li><a href="reference/workspaces.html#the-lints-table"><code>lints</code></a> — Keys for inheriting in package lints.</li>
<li><a href="reference/workspaces.html#the-metadata-table"><code>metadata</code></a> — Extra settings for external tools.</li>
</ul>
</li>
<li><a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> — Override dependencies.</li>
<li><a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a> — Override dependencies (deprecated).</li>
<li><a href="reference/profiles.html"><code>[profile]</code></a> — Compiler settings and optimizations.</li>
</ul>
<h2 id="the-workspace-section"><a class="header" href="#the-workspace-section">The <code>[workspace]</code> section</a></h2>
<p>To create a workspace, you add the <code>[workspace]</code> table to a <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[workspace]
# ...
</code></pre>
<p>At minimum, a workspace has to have a member, either with a root package or as
a virtual manifest.</p>
<h3 id="root-package"><a class="header" href="#root-package">Root package</a></h3>
<p>If the <a href="reference/workspaces.html#the-workspace-section"><code>[workspace]</code> section</a> is added to a
<code>Cargo.toml</code> that already defines a <code>[package]</code>, the package is
the <em>root package</em> of the workspace. The <em>workspace root</em> is the directory
where the workspace’s <code>Cargo.toml</code> is located.</p>
<pre><code class="language-toml">[workspace]

[package]
name = "hello_world" # the name of the package
version = "0.1.0"    # the current version, obeying semver
</code></pre>
<h3 id="virtual-workspace"><a class="header" href="#virtual-workspace">Virtual workspace</a></h3>
<p>Alternatively, a <code>Cargo.toml</code> file can be created with a <code>[workspace]</code> section
but without a <a href="reference/manifest.html#the-package-section"><code>[package]</code> section</a>. This is called a <em>virtual
manifest</em>. This is typically useful when there isn’t a “primary” package, or
you want to keep all the packages organized in separate directories.</p>
<pre><code class="language-toml"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = ["hello_world"]
resolver = "3"
</code></pre>
<pre><code class="language-toml"># [PROJECT_DIR]/hello_world/Cargo.toml
[package]
name = "hello_world" # the name of the package
version = "0.1.0"    # the current version, obeying semver
edition = "2024"     # the edition, will have no effect on a resolver used in the workspace
</code></pre>
<p>By having a workspace without a root package,</p>
<ul>
<li><a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> must be
set explicitly in virtual workspaces as they have no
<a href="reference/manifest.html#the-edition-field"><code>package.edition</code></a> to infer it from
<a href="reference/resolver.html#resolver-versions">resolver version</a>.</li>
<li>Commands run in the workspace root will run against all workspace
members by default, see <a href="reference/workspaces.html#the-default-members-field"><code>default-members</code></a>.</li>
</ul>
<h2 id="the-members-and-exclude-fields"><a class="header" href="#the-members-and-exclude-fields">The <code>members</code> and <code>exclude</code> fields</a></h2>
<p>The <code>members</code> and <code>exclude</code> fields define which packages are members of
the workspace:</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
</code></pre>
<p>All <a href="reference/specifying-dependencies.html#specifying-path-dependencies"><code>path</code> dependencies</a> residing in the workspace directory automatically
become members. Additional members can be listed with the <code>members</code> key, which
should be an array of strings containing directories with <code>Cargo.toml</code> files.</p>
<p>The <code>members</code> list also supports <a href="https://docs.rs/glob/0.3.0/glob/struct.Pattern.html">globs</a> to match multiple paths, using
typical filename glob patterns like <code>*</code> and <code>?</code>.</p>
<p>The <code>exclude</code> key can be used to prevent paths from being included in a
workspace. This can be useful if some path dependencies aren’t desired to be
in the workspace at all, or using a glob pattern and you want to remove a
directory.</p>
<p>When inside a subdirectory within the workspace, Cargo will automatically
search the parent directories for a <code>Cargo.toml</code> file with a <code>[workspace]</code>
definition to determine which workspace to use. The <a href="reference/manifest.html#the-workspace-field"><code>package.workspace</code></a>
manifest key can be used in member crates to point at a workspace’s root to
override this automatic search. The manual setting can be useful if the member
is not inside a subdirectory of the workspace root.</p>
<h3 id="package-selection"><a class="header" href="#package-selection">Package selection</a></h3>
<p>In a workspace, package-related Cargo commands like <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> can use
the <code>-p</code> / <code>--package</code> or <code>--workspace</code> command-line flags to determine which
packages to operate on. If neither of those flags are specified, Cargo will
use the package in the current working directory. However, if the current directory is
a workspace root, the <a href="reference/workspaces.html#the-default-members-field"><code>default-members</code></a> will be used.</p>
<h2 id="the-default-members-field"><a class="header" href="#the-default-members-field">The <code>default-members</code> field</a></h2>
<p>The <code>default-members</code> field specifies paths of <a href="reference/workspaces.html#the-members-and-exclude-fields">members</a> to
operate on when in the workspace root and the package selection flags are not
used:</p>
<pre><code class="language-toml">[workspace]
members = ["path/to/member1", "path/to/member2", "path/to/member3/*"]
default-members = ["path/to/member2", "path/to/member3/foo"]
</code></pre>
<blockquote>
<p>Note: when a <a href="reference/workspaces.html#root-package">root package</a> is present,
you can only operate on it using <code>--package</code> and <code>--workspace</code> flags.</p>
</blockquote>
<p>When unspecified, the <a href="reference/workspaces.html#root-package">root package</a> will be used.
In the case of a <a href="reference/workspaces.html#virtual-workspace">virtual workspace</a>, all members will be used
(as if <code>--workspace</code> were specified on the command-line).</p>
<h2 id="the-package-table"><a class="header" href="#the-package-table">The <code>package</code> table</a></h2>
<p>The <code>workspace.package</code> table is where you define keys that can be
inherited by members of a workspace. These keys can be inherited by
defining them in the member package with <code>{key}.workspace = true</code>.</p>
<p>Keys that are supported:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><code>authors</code></td><td><code>categories</code></td></tr>
<tr><td><code>description</code></td><td><code>documentation</code></td></tr>
<tr><td><code>edition</code></td><td><code>exclude</code></td></tr>
<tr><td><code>homepage</code></td><td><code>include</code></td></tr>
<tr><td><code>keywords</code></td><td><code>license</code></td></tr>
<tr><td><code>license-file</code></td><td><code>publish</code></td></tr>
<tr><td><code>readme</code></td><td><code>repository</code></td></tr>
<tr><td><code>rust-version</code></td><td><code>version</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>license-file</code> and <code>readme</code> are relative to the workspace root</li>
<li><code>include</code> and <code>exclude</code> are relative to your package root</li>
</ul>
<p>Example:</p>
<pre><code class="language-toml"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = ["bar"]

[workspace.package]
version = "1.2.3"
authors = ["Nice Folks"]
description = "A short description of my package"
documentation = "https://example.com/bar"
</code></pre>
<pre><code class="language-toml"># [PROJECT_DIR]/bar/Cargo.toml
[package]
name = "bar"
version.workspace = true
authors.workspace = true
description.workspace = true
documentation.workspace = true
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> Requires 1.64+</p>
</blockquote>
<h2 id="the-dependencies-table"><a class="header" href="#the-dependencies-table">The <code>dependencies</code> table</a></h2>
<p>The <code>workspace.dependencies</code> table is where you define dependencies to be
inherited by members of a workspace.</p>
<p>Specifying a workspace dependency is similar to <a href="reference/specifying-dependencies.html">package dependencies</a> except:</p>
<ul>
<li>Dependencies from this table cannot be declared as <code>optional</code></li>
<li><a href="reference/features.html"><code>features</code></a> declared in this table are additive with the <code>features</code> from <code>[dependencies]</code></li>
</ul>
<p>You can then <a href="reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace">inherit the workspace dependency as a package dependency</a></p>
<p>Example:</p>
<pre><code class="language-toml"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = ["bar"]

[workspace.dependencies]
cc = "1.0.73"
rand = "0.8.5"
regex = { version = "1.6.0", default-features = false, features = ["std"] }
</code></pre>
<pre><code class="language-toml"># [PROJECT_DIR]/bar/Cargo.toml
[package]
name = "bar"
version = "0.2.0"

[dependencies]
regex = { workspace = true, features = ["unicode"] }

[build-dependencies]
cc.workspace = true

[dev-dependencies]
rand.workspace = true
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> Requires 1.64+</p>
</blockquote>
<h2 id="the-lints-table"><a class="header" href="#the-lints-table">The <code>lints</code> table</a></h2>
<p>The <code>workspace.lints</code> table is where you define lint configuration to be inherited by members of a workspace.</p>
<p>Specifying a workspace lint configuration is similar to <a href="reference/manifest.html#the-lints-section">package lints</a>.</p>
<p>Example:</p>
<pre><code class="language-toml"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = ["crates/*"]

[workspace.lints.rust]
unsafe_code = "forbid"
</code></pre>
<pre><code class="language-toml"># [PROJECT_DIR]/crates/bar/Cargo.toml
[package]
name = "bar"
version = "0.1.0"

[lints]
workspace = true
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.74</p>
</blockquote>
<h2 id="the-metadata-table-1"><a class="header" href="#the-metadata-table-1">The <code>metadata</code> table</a></h2>
<p>The <code>workspace.metadata</code> table is ignored by Cargo and will not be warned
about. This section can be used for tools that would like to store workspace
configuration in <code>Cargo.toml</code>. For example:</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "member2"]

[workspace.metadata.webcontents]
root = "path/to/webproject"
tool = ["npm", "run", "build"]
# ...
</code></pre>
<p>There is a similar set of tables at the package level at
<a href="reference/manifest.html#the-metadata-table"><code>package.metadata</code></a>. While cargo does not specify a
format for the content of either of these tables, it is suggested that
external tools may wish to use them in a consistent fashion, such as referring
to the data in <code>workspace.metadata</code> if data is missing from <code>package.metadata</code>,
if that makes sense for the tool in question.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifying-dependencies"><a class="header" href="#specifying-dependencies">Specifying Dependencies</a></h1>
<p>Your crates can depend on other libraries from <a href="https://crates.io/">crates.io</a> or other
registries, <code>git</code> repositories, or subdirectories on your local file system.
You can also temporarily override the location of a dependency — for example,
to be able to test out a bug fix in the dependency that you are working on
locally. You can have different dependencies for different platforms, and
dependencies that are only used during development. Let’s take a look at how
to do each of these.</p>
<h2 id="specifying-dependencies-from-cratesio"><a class="header" href="#specifying-dependencies-from-cratesio">Specifying dependencies from crates.io</a></h2>
<p>Cargo is configured to look for dependencies on <a href="https://crates.io/">crates.io</a> by default. Only
the name and a version string are required in this case. In <a href="reference/../guide/index.html">the cargo
guide</a>, we specified a dependency on the <code>time</code> crate:</p>
<pre><code class="language-toml">[dependencies]
time = "0.1.12"
</code></pre>
<p>The version string <code>"0.1.12"</code> is called a <a href="reference/specifying-dependencies.html#version-requirement-syntax">version requirement</a>.
It specifies a range of versions that can be selected from when <a href="reference/resolver.html">resolving dependencies</a>.
In this case, <code>"0.1.12"</code> represents the version range <code>&gt;=0.1.12, &lt;0.2.0</code>.
An update is allowed if it is within that range.
In this case, if we ran <code>cargo update time</code>, cargo should
update us to version <code>0.1.13</code> if it is the latest <code>0.1.z</code> release, but would not
update us to <code>0.2.0</code>.</p>
<h2 id="version-requirement-syntax"><a class="header" href="#version-requirement-syntax">Version requirement syntax</a></h2>
<h3 id="default-requirements"><a class="header" href="#default-requirements">Default requirements</a></h3>
<p><strong>Default requirements</strong> specify a minimum version with the ability to update to <a href="https://semver.org">SemVer</a> compatible versions.
Versions are considered compatible if their left-most non-zero major/minor/patch component is the same.
This is different from <a href="https://semver.org">SemVer</a> which considers all pre-1.0.0 packages to be incompatible.</p>
<p><code>1.2.3</code> is an example of a default requirement.</p>
<pre><code class="language-notrust">1.2.3  :=  &gt;=1.2.3, &lt;2.0.0
1.2    :=  &gt;=1.2.0, &lt;2.0.0
1      :=  &gt;=1.0.0, &lt;2.0.0
0.2.3  :=  &gt;=0.2.3, &lt;0.3.0
0.2    :=  &gt;=0.2.0, &lt;0.3.0
0.0.3  :=  &gt;=0.0.3, &lt;0.0.4
0.0    :=  &gt;=0.0.0, &lt;0.1.0
0      :=  &gt;=0.0.0, &lt;1.0.0
</code></pre>
<h3 id="caret-requirements"><a class="header" href="#caret-requirements">Caret requirements</a></h3>
<p><strong>Caret requirements</strong> are the default version requirement strategy.
This version strategy allows <a href="https://semver.org">SemVer</a> compatible updates.
They are specified as version requirements with a leading caret (<code>^</code>).</p>
<p><code>^1.2.3</code> is an example of a caret requirement.</p>
<p>Leaving off the caret is a simplified equivalent syntax to using caret requirements.
While caret requirements are the default, it is recommended to use the
simplified syntax when possible.</p>
<p><code>log = "^1.2.3"</code> is exactly equivalent to <code>log = "1.2.3"</code>.</p>
<h3 id="tilde-requirements"><a class="header" href="#tilde-requirements">Tilde requirements</a></h3>
<p><strong>Tilde requirements</strong> specify a minimal version with some ability to update.
If you specify a major, minor, and patch version or only a major and minor
version, only patch-level changes are allowed. If you only specify a major
version, then minor- and patch-level changes are allowed.</p>
<p><code>~1.2.3</code> is an example of a tilde requirement.</p>
<pre><code class="language-notrust">~1.2.3  := &gt;=1.2.3, &lt;1.3.0
~1.2    := &gt;=1.2.0, &lt;1.3.0
~1      := &gt;=1.0.0, &lt;2.0.0
</code></pre>
<h3 id="wildcard-requirements"><a class="header" href="#wildcard-requirements">Wildcard requirements</a></h3>
<p><strong>Wildcard requirements</strong> allow for any version where the wildcard is
positioned.</p>
<p><code>*</code>, <code>1.*</code> and <code>1.2.*</code> are examples of wildcard requirements.</p>
<pre><code class="language-notrust">*     := &gt;=0.0.0
1.*   := &gt;=1.0.0, &lt;2.0.0
1.2.* := &gt;=1.2.0, &lt;1.3.0
</code></pre>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> does not allow bare <code>*</code> versions.</p>
</blockquote>
<h3 id="comparison-requirements"><a class="header" href="#comparison-requirements">Comparison requirements</a></h3>
<p><strong>Comparison requirements</strong> allow manually specifying a version range or an
exact version to depend on.</p>
<p>Here are some examples of comparison requirements:</p>
<pre><code class="language-notrust">&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3
</code></pre>
<p><span id="multiple-requirements"></span></p>
<h3 id="multiple-version-requirements"><a class="header" href="#multiple-version-requirements">Multiple version requirements</a></h3>
<p>As shown in the examples above, multiple version requirements can be
separated with a comma, e.g., <code>&gt;= 1.2, &lt; 1.5</code>.
All requirements must be satisfied,
so non-overlapping requirements like <code>&lt;1.2, ^1.2.2</code> result in no matching versions.</p>
<h3 id="pre-releases"><a class="header" href="#pre-releases">Pre-releases</a></h3>
<p>Version requirements exclude <a href="reference/manifest.html#the-version-field">pre-release versions</a>, such as <code>1.0.0-alpha</code>,
unless specifically asked for.
For example, if <code>1.0.0-alpha</code> of package
<code>foo</code> is published, then a requirement of <code>foo = "1.0"</code> will <em>not</em> match, and
will return an error. The pre-release must be specified, such as <code>foo = "1.0.0-alpha"</code>.
Similarly <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> will avoid pre-releases unless
explicitly asked to install one.</p>
<p>Cargo allows “newer” pre-releases to be used automatically. For example, if
<code>1.0.0-beta</code> is published, then a requirement <code>foo = "1.0.0-alpha"</code> will allow
updating to the <code>beta</code> version. Note that this only works on the same release
version, <code>foo = "1.0.0-alpha"</code> will not allow updating to <code>foo = "1.0.1-alpha"</code>
or <code>foo = "1.0.1-beta"</code>.</p>
<p>Cargo will also upgrade automatically to semver-compatible released versions
from prereleases. The requirement <code>foo = "1.0.0-alpha"</code> will allow updating to
<code>foo = "1.0.0"</code> as well as <code>foo = "1.2.0"</code>.</p>
<p>Beware that pre-release versions can be unstable, and as such care should be
taken when using them. Some projects may choose to publish breaking changes
between pre-release versions. It is recommended to not use pre-release
dependencies in a library if your library is not also a pre-release. Care
should also be taken when updating your <code>Cargo.lock</code>, and be prepared if a
pre-release update causes issues.</p>
<h3 id="version-metadata"><a class="header" href="#version-metadata">Version metadata</a></h3>
<p><a href="reference/manifest.html#the-version-field">Version metadata</a>, such as <code>1.0.0+21AF26D3</code>,
is ignored and should not be used in version requirements.</p>
<blockquote>
<p><strong>Recommendation:</strong> When in doubt, use the default version requirement operator.</p>
<p>In rare circumstances, a package with a “public dependency”
(re-exports the dependency or interoperates with it in its public API)
that is compatible with multiple semver-incompatible versions
(e.g. only uses a simple type that hasn’t changed between releases, like an <code>Id</code>)
may support users choosing which version of the “public dependency” to use.
In this case, a version requirement like <code>"&gt;=0.4, &lt;2"</code> may be of interest.
<em>However</em> users of the package will likely run into errors and need to
manually select a version of the “public dependency” via <code>cargo update</code> if
they also depend on it as Cargo might pick different versions of the “public
dependency” when <a href="reference/resolver.html">resolving dependency versions</a>  (see
<a href="https://github.com/rust-lang/cargo/issues/10599">#10599</a>).</p>
<p>Avoid constraining the upper bound of a version to be anything less than the
next semver incompatible version
(e.g. avoid <code>"&gt;=2.0, &lt;2.4"</code>, <code>"2.0.*"</code>, or <code>~2.0</code>),
as other packages in the dependency tree may
require a newer version, leading to an unresolvable error (see <a href="https://github.com/rust-lang/cargo/issues/9029">#9029</a>).
Consider whether controlling the version in your <a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code></a> would be more
appropriate.</p>
<p>In some instances this won’t matter or the benefits might outweigh the cost, including:</p>
<ul>
<li>When no one else depends on your package; e.g. it only has a <code>[[bin]]</code></li>
<li>When depending on a pre-release package and wishing to avoid breaking
changes, then a fully specified <code>"=1.2.3-alpha.3"</code> might be warranted (see
<a href="https://github.com/rust-lang/cargo/issues/2222">#2222</a>)</li>
<li>When a library re-exports a proc-macro but the proc-macro generates code that
calls into the re-exporting library, then a fully specified <code>=1.2.3</code> might be
warranted to ensure the proc-macro isn’t newer than the re-exporting library
and generating code that uses parts of the API that don’t exist within the
current version</li>
</ul>
</blockquote>
<h2 id="specifying-dependencies-from-other-registries"><a class="header" href="#specifying-dependencies-from-other-registries">Specifying dependencies from other registries</a></h2>
<p>To specify a dependency from a registry other than <a href="https://crates.io/">crates.io</a> set the <code>registry</code> key
to the name of the registry to use:</p>
<pre><code class="language-toml">[dependencies]
some-crate = { version = "1.0", registry = "my-registry" }
</code></pre>
<p>where <code>my-registry</code> is the registry name configured in <code>.cargo/config.toml</code> file.
See the <a href="reference/registries.html">registries documentation</a> for more information.</p>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> does not allow packages to be published with
dependencies on code published outside of <a href="https://crates.io/">crates.io</a>.</p>
</blockquote>
<h2 id="specifying-dependencies-from-git-repositories"><a class="header" href="#specifying-dependencies-from-git-repositories">Specifying dependencies from <code>git</code> repositories</a></h2>
<p>To depend on a library located in a <code>git</code> repository, the minimum information
you need to specify is the location of the repository with the <code>git</code> key:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
</code></pre>
<p>Cargo fetches the <code>git</code> repository at that location and traverses the file tree to find
<code>Cargo.toml</code> file for the requested crate anywhere inside the <code>git</code> repository.
For example, <code>regex-lite</code> and <code>regex-syntax</code> are members of <code>rust-lang/regex</code> repo
and can be referred to by the repo’s root URL (<code>https://github.com/rust-lang/regex.git</code>)
regardless of where in the file tree they reside.</p>
<pre><code class="language-toml">regex-lite   = { git = "https://github.com/rust-lang/regex.git" }
regex-syntax = { git = "https://github.com/rust-lang/regex.git" }
</code></pre>
<p>The above rule does not apply to <a href="reference/specifying-dependencies.html#specifying-path-dependencies"><code>path</code> dependencies</a>.</p>
<h3 id="choice-of-commit"><a class="header" href="#choice-of-commit">Choice of commit</a></h3>
<p>Cargo assumes that we intend to use the latest commit on the default branch to build
our package if we only specify the repo URL, as in the examples above.</p>
<p>You can combine the <code>git</code> key with the <code>rev</code>, <code>tag</code>, or <code>branch</code> keys to be more specific about
which commit to use. Here’s an example of using the latest commit on a branch named <code>next</code>:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git", branch = "next" }
</code></pre>
<p>Anything that is not a branch or a tag falls under <code>rev</code> key. This can be a commit
hash like <code>rev = "4c59b707"</code>, or a named reference exposed by the remote
repository such as <code>rev = "refs/pull/493/head"</code>.</p>
<p>What references are available for the <code>rev</code> key varies by where the repo is hosted.<br />
GitHub exposes a reference to the most recent commit of every pull request as in the example above.
Other git hosts may provide something equivalent under a different naming scheme.</p>
<p><strong>More <code>git</code> dependency examples:</strong></p>
<pre><code class="language-toml"># .git suffix can be omitted if the host accepts such URLs - both examples work the same
regex = { git = "https://github.com/rust-lang/regex" }
regex = { git = "https://github.com/rust-lang/regex.git" }

# a commit with a particular tag
regex = { git = "https://github.com/rust-lang/regex.git", tag = "1.10.3" }

# a commit by its SHA1 hash
regex = { git = "https://github.com/rust-lang/regex.git", rev = "0c0990399270277832fbb5b91a1fa118e6f63dba" }

# HEAD commit of PR 493
regex = { git = "https://github.com/rust-lang/regex.git", rev = "refs/pull/493/head" }

# INVALID EXAMPLES

# specifying the commit after # ignores the commit ID and generates a warning
regex = { git = "https://github.com/rust-lang/regex.git#4c59b70" }

# git and path cannot be used at the same time
regex = { git = "https://github.com/rust-lang/regex.git#4c59b70", path = "../regex" }
</code></pre>
<p>Cargo locks the commits of <code>git</code> dependencies in <code>Cargo.lock</code> file at the time of their addition
and checks for updates only when you run <code>cargo update</code> command.</p>
<h3 id="the-role-of-the-version-key"><a class="header" href="#the-role-of-the-version-key">The role of the <code>version</code> key</a></h3>
<p>The <code>version</code> key always implies that the package is available in a registry,
regardless of the presence of <code>git</code> or <code>path</code> keys.</p>
<p>The <code>version</code> key does <em>not</em> affect which commit is used when Cargo retrieves the <code>git</code> dependency,
but Cargo checks the version information in the dependency’s <code>Cargo.toml</code> file
against the <code>version</code> key and raises an error if the check fails.</p>
<p>In this example, Cargo retrieves the HEAD commit of the branch called <code>next</code> from Git and checks if the crate’s version
is compatible with <code>version = "1.10.3"</code>:</p>
<pre><code class="language-toml">[dependencies]
regex = { version = "1.10.3", git = "https://github.com/rust-lang/regex.git", branch = "next" }
</code></pre>
<p><code>version</code>, <code>git</code>, and <code>path</code> keys are considered separate locations for resolving the dependency.
See <a href="reference/specifying-dependencies.html#multiple-locations">Multiple locations</a> section below for detailed explanations.</p>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> does not allow packages to be published with
dependencies on code published outside of <a href="https://crates.io/">crates.io</a> itself
(<a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> are ignored). See the <a href="reference/specifying-dependencies.html#multiple-locations">Multiple
locations</a> section for a fallback alternative for <code>git</code>
and <code>path</code> dependencies.</p>
</blockquote>
<h3 id="git-submodules"><a class="header" href="#git-submodules">Git submodules</a></h3>
<p>When cloning a <code>git</code> dependency,
Cargo automatically fetches its submodules recursively
so that all required code is available for the build.</p>
<p>To skip fetching submodules unrelated to the build,
you can set <a href="https://git-scm.com/docs/gitmodules#Documentation/gitmodules.txt-submodulenameupdate"><code>submodule.&lt;name&gt;.update = none</code></a> in the dependency repo’s <code>.gitmodules</code>.
This requires write access to the repo and will disable submodule updates more generally.</p>
<h3 id="accessing-private-git-repositories"><a class="header" href="#accessing-private-git-repositories">Accessing private Git repositories</a></h3>
<p>See <a href="reference/../appendix/git-authentication.html">Git Authentication</a> for help with Git authentication for private repos.</p>
<h2 id="specifying-path-dependencies"><a class="header" href="#specifying-path-dependencies">Specifying path dependencies</a></h2>
<p>Over time, our <code>hello_world</code> package from <a href="reference/../guide/index.html">the guide</a> has
grown significantly in size! It’s gotten to the point that we probably want to
split out a separate crate for others to use. To do this Cargo supports <strong>path
dependencies</strong> which are typically sub-crates that live within one repository.
Let’s start by making a new crate inside of our <code>hello_world</code> package:</p>
<pre><code class="language-console"># inside of hello_world/
$ cargo new hello_utils
</code></pre>
<p>This will create a new folder <code>hello_utils</code> inside of which a <code>Cargo.toml</code> and
<code>src</code> folder are ready to be configured. To tell Cargo about this, open
up <code>hello_world/Cargo.toml</code> and add <code>hello_utils</code> to your dependencies:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = "hello_utils" }
</code></pre>
<p>This tells Cargo that we depend on a crate called <code>hello_utils</code> which is found
in the <code>hello_utils</code> folder, relative to the <code>Cargo.toml</code> file it’s written in.</p>
<p>The next <code>cargo build</code> will automatically build <code>hello_utils</code> and
all of its dependencies.</p>
<h3 id="no-local-path-traversal"><a class="header" href="#no-local-path-traversal">No local path traversal</a></h3>
<p>The local paths must point to the exact folder with the dependency’s <code>Cargo.toml</code>.
Unlike with <code>git</code> dependencies, Cargo does not traverse local paths.
For example, if <code>regex-lite</code> and <code>regex-syntax</code> are members of a
locally cloned <code>rust-lang/regex</code> repo, they have to be referred to by the full path:</p>
<pre><code class="language-toml"># git key accepts the repo root URL and Cargo traverses the tree to find the crate
[dependencies]
regex-lite   = { git = "https://github.com/rust-lang/regex.git" }
regex-syntax = { git = "https://github.com/rust-lang/regex.git" }

# path key requires the member name to be included in the local path
[dependencies]
regex-lite   = { path = "../regex/regex-lite" }
regex-syntax = { path = "../regex/regex-syntax" }
</code></pre>
<h3 id="local-paths-in-published-crates"><a class="header" href="#local-paths-in-published-crates">Local paths in published crates</a></h3>
<p>Crates that use dependencies specified with only a path are not
permitted on <a href="https://crates.io/">crates.io</a>.</p>
<p>If we wanted to publish our <code>hello_world</code> crate,
we would need to publish a version of <code>hello_utils</code> to <a href="https://crates.io/">crates.io</a> as a separate crate
and specify its version in the dependencies line of <code>hello_world</code>:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = "hello_utils", version = "0.1.0" }
</code></pre>
<p>The use of <code>path</code> and <code>version</code> keys together is explained in the <a href="reference/specifying-dependencies.html#multiple-locations">Multiple locations</a> section.</p>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> does not allow packages to be published with
dependencies on code outside of <a href="https://crates.io/">crates.io</a>, except for <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a>.
See the <a href="reference/specifying-dependencies.html#multiple-locations">Multiple locations</a> section
for a fallback alternative for <code>git</code> and <code>path</code> dependencies.</p>
</blockquote>
<h2 id="multiple-locations"><a class="header" href="#multiple-locations">Multiple locations</a></h2>
<p>It is possible to specify both a registry version and a <code>git</code> or <code>path</code>
location. The <code>git</code> or <code>path</code> dependency will be used locally (in which case
the <code>version</code> is checked against the local copy), and when published to a
registry like <a href="https://crates.io/">crates.io</a>, it will use the registry version. Other
combinations are not allowed. Examples:</p>
<pre><code class="language-toml">[dependencies]
# Uses `my-bitflags` when used locally, and uses
# version 1.0 from crates.io when published.
bitflags = { path = "my-bitflags", version = "1.0" }

# Uses the given git repo when used locally, and uses
# version 1.0 from crates.io when published.
smallvec = { git = "https://github.com/servo/rust-smallvec.git", version = "1.0" }

# Note: if a version doesn't match, Cargo will fail to compile!
</code></pre>
<p>One example where this can be useful is when you have split up a library into
multiple packages within the same workspace. You can then use <code>path</code>
dependencies to point to the local packages within the workspace to use the
local version during development, and then use the <a href="https://crates.io/">crates.io</a> version once it
is published. This is similar to specifying an
<a href="reference/overriding-dependencies.html">override</a>, but only applies to this one
dependency declaration.</p>
<h2 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform specific dependencies</a></h2>
<p>Platform-specific dependencies take the same format, but are listed under a
<code>target</code> section. Normally Rust-like <a href="reference/../../reference/conditional-compilation.html"><code>#[cfg]</code>
syntax</a> will be used to define
these sections:</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winhttp = "0.4.0"

[target.'cfg(unix)'.dependencies]
openssl = "1.0.1"

[target.'cfg(target_arch = "x86")'.dependencies]
native-i686 = { path = "native/i686" }

[target.'cfg(target_arch = "x86_64")'.dependencies]
native-x86_64 = { path = "native/x86_64" }
</code></pre>
<p>Like with Rust, the syntax here supports the <code>not</code>, <code>any</code>, and <code>all</code> operators
to combine various cfg name/value pairs.</p>
<p>If you want to know which cfg targets are available on your platform, run
<code>rustc --print=cfg</code> from the command line. If you want to know which <code>cfg</code>
targets are available for another platform, such as 64-bit Windows,
run <code>rustc --print=cfg --target=x86_64-pc-windows-msvc</code>.</p>
<p>Unlike in your Rust source code, you cannot use
<code>[target.'cfg(feature = "fancy-feature")'.dependencies]</code> to add dependencies
based on optional features. Use <a href="reference/features.html">the <code>[features]</code> section</a>
instead:</p>
<pre><code class="language-toml">[dependencies]
foo = { version = "1.0", optional = true }
bar = { version = "1.0", optional = true }

[features]
fancy-feature = ["foo", "bar"]
</code></pre>
<p>The same applies to <code>cfg(debug_assertions)</code>, <code>cfg(test)</code> and <code>cfg(proc_macro)</code>.
These values will not work as expected and will always have the default value
returned by <code>rustc --print=cfg</code>.
There is currently no way to add dependencies based on these configuration values.</p>
<p>In addition to <code>#[cfg]</code> syntax, Cargo also supports listing out the full target
the dependencies would apply to:</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-gnu.dependencies]
winhttp = "0.4.0"

[target.i686-unknown-linux-gnu.dependencies]
openssl = "1.0.1"
</code></pre>
<h3 id="custom-target-specifications"><a class="header" href="#custom-target-specifications">Custom target specifications</a></h3>
<p>If you’re using a custom target specification (such as <code>--target foo/bar.json</code>), use the base filename without the <code>.json</code> extension:</p>
<pre><code class="language-toml">[target.bar.dependencies]
winhttp = "0.4.0"

[target.my-special-i686-platform.dependencies]
openssl = "1.0.1"
native = { path = "native/i686" }
</code></pre>
<blockquote>
<p><strong>Note</strong>: Custom target specifications are not usable on the stable channel.</p>
</blockquote>
<h2 id="development-dependencies"><a class="header" href="#development-dependencies">Development dependencies</a></h2>
<p>You can add a <code>[dev-dependencies]</code> section to your <code>Cargo.toml</code> whose format
is equivalent to <code>[dependencies]</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
tempdir = "0.3"
</code></pre>
<p>Dev-dependencies are not used when compiling
a package for building, but are used for compiling tests, examples, and
benchmarks.</p>
<p>These dependencies are <em>not</em> propagated to other packages which depend on this
package.</p>
<p>You can also have target-specific development dependencies by using
<code>dev-dependencies</code> in the target section header instead of <code>dependencies</code>. For
example:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.dev-dependencies]
mio = "0.0.1"
</code></pre>
<blockquote>
<p><strong>Note</strong>: When a package is published, only dev-dependencies that specify a
<code>version</code> will be included in the published crate. For most use cases,
dev-dependencies are not needed when published, though some users (like OS
packagers) may want to run tests within a crate, so providing a <code>version</code> if
possible can still be beneficial.</p>
</blockquote>
<h2 id="build-dependencies"><a class="header" href="#build-dependencies">Build dependencies</a></h2>
<p>You can depend on other Cargo-based crates for use in your build scripts.
Dependencies are declared through the <code>build-dependencies</code> section of the
manifest:</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0.3"
</code></pre>
<p>You can also have target-specific build dependencies by using
<code>build-dependencies</code> in the target section header instead of <code>dependencies</code>. For
example:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.build-dependencies]
cc = "1.0.3"
</code></pre>
<p>In this case, the dependency will only be built when the host platform matches the
specified target.</p>
<p>The build script <strong>does not</strong> have access to the dependencies listed
in the <code>dependencies</code> or <code>dev-dependencies</code> section. Build
dependencies will likewise not be available to the package itself
unless listed under the <code>dependencies</code> section as well. A package
itself and its build script are built separately, so their
dependencies need not coincide. Cargo is kept simpler and cleaner by
using independent dependencies for independent purposes.</p>
<h2 id="choosing-features"><a class="header" href="#choosing-features">Choosing features</a></h2>
<p>If a package you depend on offers conditional features, you can
specify which to use:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = "1.3.5"
default-features = false # do not include the default features, and optionally
                         # cherry-pick individual features
features = ["secure-password", "civet"]
</code></pre>
<p>More information about features can be found in the <a href="reference/features.html#dependency-features">features
chapter</a>.</p>
<h2 id="renaming-dependencies-in-cargotoml"><a class="header" href="#renaming-dependencies-in-cargotoml">Renaming dependencies in <code>Cargo.toml</code></a></h2>
<p>When writing a <code>[dependencies]</code> section in <code>Cargo.toml</code> the key you write for a
dependency typically matches up to the name of the crate you import from in the
code. For some projects, though, you may wish to reference the crate with a
different name in the code regardless of how it’s published on crates.io. For
example you may wish to:</p>
<ul>
<li>Avoid the need to  <code>use foo as bar</code> in Rust source.</li>
<li>Depend on multiple versions of a crate.</li>
<li>Depend on crates with the same name from different registries.</li>
</ul>
<p>To support this Cargo supports a <code>package</code> key in the <code>[dependencies]</code> section
of which package should be depended on:</p>
<pre><code class="language-toml">[package]
name = "mypackage"
version = "0.0.1"

[dependencies]
foo = "0.1"
bar = { git = "https://github.com/example/project.git", package = "foo" }
baz = { version = "0.1", registry = "custom", package = "foo" }
</code></pre>
<p>In this example, three crates are now available in your Rust code:</p>
<pre><code class="language-rust ignore">extern crate foo; // crates.io
extern crate bar; // git repository
extern crate baz; // registry `custom`</code></pre>
<p>All three of these crates have the package name of <code>foo</code> in their own
<code>Cargo.toml</code>, so we’re explicitly using the <code>package</code> key to inform Cargo that
we want the <code>foo</code> package even though we’re calling it something else locally.
The <code>package</code> key, if not specified, defaults to the name of the dependency
being requested.</p>
<p>Note that if you have an optional dependency like:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = "0.1", package = 'foo', optional = true }
</code></pre>
<p>you’re depending on the crate <code>foo</code> from crates.io, but your crate has a <code>bar</code>
feature instead of a <code>foo</code> feature. That is, names of features take after the
name of the dependency, not the package name, when renamed.</p>
<p>Enabling transitive dependencies works similarly, for example we could add the
following to the above manifest:</p>
<pre><code class="language-toml">[features]
log-debug = ['bar/log-debug'] # using 'foo/log-debug' would be an error!
</code></pre>
<h2 id="inheriting-a-dependency-from-a-workspace"><a class="header" href="#inheriting-a-dependency-from-a-workspace">Inheriting a dependency from a workspace</a></h2>
<p>Dependencies can be inherited from a workspace by specifying the
dependency in the workspace’s <a href="reference/workspaces.html#the-dependencies-table"><code>[workspace.dependencies]</code></a> table.
After that, add it to the <code>[dependencies]</code> table with <code>workspace = true</code>.</p>
<p>Along with the <code>workspace</code> key, dependencies can also include these keys:</p>
<ul>
<li><a href="reference/features.html#optional-dependencies"><code>optional</code></a>: Note that the<code>[workspace.dependencies]</code> table is not allowed to specify <code>optional</code>.</li>
<li><a href="reference/features.html"><code>features</code></a>: These are additive with the features declared in the <code>[workspace.dependencies]</code></li>
</ul>
<p>Other than <code>optional</code> and <code>features</code>, inherited dependencies cannot use any other
dependency key (such as <code>version</code> or <code>default-features</code>).</p>
<p>Dependencies in the <code>[dependencies]</code>, <code>[dev-dependencies]</code>, <code>[build-dependencies]</code>, and
<code>[target."...".dependencies]</code> sections support the ability to reference the
<code>[workspace.dependencies]</code> definition of dependencies.</p>
<pre><code class="language-toml">[package]
name = "bar"
version = "0.2.0"

[dependencies]
regex = { workspace = true, features = ["unicode"] }

[build-dependencies]
cc.workspace = true

[dev-dependencies]
rand = { workspace = true, optional = true }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overriding-dependencies"><a class="header" href="#overriding-dependencies">Overriding Dependencies</a></h1>
<p>The desire to override a dependency can arise through a number of scenarios.
Most of them, however, boil down to the ability to work with a crate before
it’s been published to <a href="https://crates.io/">crates.io</a>. For example:</p>
<ul>
<li>A crate you’re working on is also used in a much larger application you’re
working on, and you’d like to test a bug fix to the library inside of the
larger application.</li>
<li>An upstream crate you don’t work on has a new feature or a bug fix on the
master branch of its git repository which you’d like to test out.</li>
<li>You’re about to publish a new major version of your crate, but you’d like to
do integration testing across an entire package to ensure the new major
version works.</li>
<li>You’ve submitted a fix to an upstream crate for a bug you found, but you’d
like to immediately have your application start depending on the fixed
version of the crate to avoid blocking on the bug fix getting merged.</li>
</ul>
<p>These scenarios can be solved with the <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code> manifest
section</a>.</p>
<p>This chapter walks through a few different use cases, and includes details
on the different ways to override a dependency.</p>
<ul>
<li>Example use cases
<ul>
<li><a href="reference/overriding-dependencies.html#testing-a-bugfix">Testing a bugfix</a></li>
<li><a href="reference/overriding-dependencies.html#working-with-an-unpublished-minor-version">Working with an unpublished minor version</a>
<ul>
<li><a href="reference/overriding-dependencies.html#overriding-repository-url">Overriding repository URL</a></li>
</ul>
</li>
<li><a href="reference/overriding-dependencies.html#prepublishing-a-breaking-change">Prepublishing a breaking change</a></li>
<li><a href="reference/overriding-dependencies.html#using-patch-with-multiple-versions">Using <code>[patch]</code> with multiple versions</a></li>
</ul>
</li>
<li>Reference
<ul>
<li><a href="reference/overriding-dependencies.html#the-patch-section">The <code>[patch]</code> section</a></li>
<li><a href="reference/overriding-dependencies.html#the-replace-section">The <code>[replace]</code> section</a></li>
<li><a href="reference/overriding-dependencies.html#paths-overrides"><code>paths</code> overrides</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: See also specifying a dependency with <a href="reference/specifying-dependencies.html#multiple-locations">multiple locations</a>, which
can be used to override the source for a single dependency declaration in a
local package.</p>
</blockquote>
<h2 id="testing-a-bugfix"><a class="header" href="#testing-a-bugfix">Testing a bugfix</a></h2>
<p>Let’s say you’re working with the <a href="https://crates.io/crates/uuid"><code>uuid</code> crate</a> but while you’re working on it
you discover a bug. You are, however, quite enterprising so you decide to also
try to fix the bug! Originally your manifest will look like:</p>
<pre><code class="language-toml">[package]
name = "my-library"
version = "0.1.0"

[dependencies]
uuid = "1.0"
</code></pre>
<p>First thing we’ll do is to clone the <a href="https://github.com/uuid-rs/uuid"><code>uuid</code> repository</a>
locally via:</p>
<pre><code class="language-console">$ git clone https://github.com/uuid-rs/uuid.git
</code></pre>
<p>Next we’ll edit the manifest of <code>my-library</code> to contain:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { path = "../path/to/uuid" }
</code></pre>
<p>Here we declare that we’re <em>patching</em> the source <code>crates-io</code> with a new
dependency. This will effectively add the local checked out version of <code>uuid</code> to
the crates.io registry for our local package.</p>
<p>Next up we need to ensure that our lock file is updated to use this new version
of <code>uuid</code> so our package uses the locally checked out copy instead of one from
crates.io. The way <code>[patch]</code> works is that it’ll load the dependency at
<code>../path/to/uuid</code> and then whenever crates.io is queried for versions of <code>uuid</code>
it’ll <em>also</em> return the local version.</p>
<p>This means that the version number of the local checkout is significant and will
affect whether the patch is used. Our manifest declared <code>uuid = "1.0"</code> which
means we’ll only resolve to <code>&gt;= 1.0.0, &lt; 2.0.0</code>, and Cargo’s greedy resolution
algorithm also means that we’ll resolve to the maximum version within that
range. Typically this doesn’t matter as the version of the git repository will
already be greater or match the maximum version published on crates.io, but it’s
important to keep this in mind!</p>
<p>In any case, typically all you need to do now is:</p>
<pre><code class="language-console">$ cargo build
   Compiling uuid v1.0.0 (.../uuid)
   Compiling my-library v0.1.0 (.../my-library)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>And that’s it! You’re now building with the local version of <code>uuid</code> (note the
path in parentheses in the build output). If you don’t see the local path version getting
built then you may need to run <code>cargo update uuid --precise $version</code> where
<code>$version</code> is the version of the locally checked out copy of <code>uuid</code>.</p>
<p>Once you’ve fixed the bug you originally found the next thing you’ll want to do
is to likely submit that as a pull request to the <code>uuid</code> crate itself. Once
you’ve done this then you can also update the <code>[patch]</code> section. The listing
inside of <code>[patch]</code> is just like the <code>[dependencies]</code> section, so once your pull
request is merged you could change your <code>path</code> dependency to:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<h2 id="working-with-an-unpublished-minor-version"><a class="header" href="#working-with-an-unpublished-minor-version">Working with an unpublished minor version</a></h2>
<p>Let’s now shift gears a bit from bug fixes to adding features. While working on
<code>my-library</code> you discover that a whole new feature is needed in the <code>uuid</code>
crate. You’ve implemented this feature, tested it locally above with <code>[patch]</code>,
and submitted a pull request. Let’s go over how you continue to use and test it
before it’s actually published.</p>
<p>Let’s also say that the current version of <code>uuid</code> on crates.io is <code>1.0.0</code>, but
since then the master branch of the git repository has updated to <code>1.0.1</code>. This
branch includes your new feature you submitted previously. To use this
repository we’ll edit our <code>Cargo.toml</code> to look like</p>
<pre><code class="language-toml">[package]
name = "my-library"
version = "0.1.0"

[dependencies]
uuid = "1.0.1"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<p>Note that our local dependency on <code>uuid</code> has been updated to <code>1.0.1</code> as it’s
what we’ll actually require once the crate is published. This version doesn’t
exist on crates.io, though, so we provide it with the <code>[patch]</code> section of the
manifest.</p>
<p>Now when our library is built it’ll fetch <code>uuid</code> from the git repository and
resolve to 1.0.1 inside the repository instead of trying to download a version
from crates.io. Once 1.0.1 is published on crates.io the <code>[patch]</code> section can
be deleted.</p>
<p>It’s also worth noting that <code>[patch]</code> applies <em>transitively</em>. Let’s say you use
<code>my-library</code> in a larger package, such as:</p>
<pre><code class="language-toml">[package]
name = "my-binary"
version = "0.1.0"

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<p>Remember that <code>[patch]</code> is applicable <em>transitively</em> but can only be defined at
the <em>top level</em> so we consumers of <code>my-library</code> have to repeat the <code>[patch]</code> section
if necessary. Here, though, the new <code>uuid</code> crate applies to <em>both</em> our dependency on
<code>uuid</code> and the <code>my-library -&gt; uuid</code> dependency. The <code>uuid</code> crate will be resolved to
one version for this entire crate graph, 1.0.1, and it’ll be pulled from the git
repository.</p>
<h3 id="overriding-repository-url"><a class="header" href="#overriding-repository-url">Overriding repository URL</a></h3>
<p>In case the dependency you want to override isn’t loaded from <code>crates.io</code>,
you’ll have to change a bit how you use <code>[patch]</code>. For example, if the
dependency is a git dependency, you can override it to a local path with:</p>
<pre><code class="language-toml">[patch."https://github.com/your/repository"]
my-library = { path = "../my-library/path" }
</code></pre>
<p>And that’s it!</p>
<h2 id="prepublishing-a-breaking-change"><a class="header" href="#prepublishing-a-breaking-change">Prepublishing a breaking change</a></h2>
<p>Let’s take a look at working with a new major version of a crate, typically
accompanied with breaking changes. Sticking with our previous crates, this
means that we’re going to be creating version 2.0.0 of the <code>uuid</code> crate. After
we’ve submitted all changes upstream we can update our manifest for
<code>my-library</code> to look like:</p>
<pre><code class="language-toml">[dependencies]
uuid = "2.0"

[patch.crates-io]
uuid = { git = "https://github.com/uuid-rs/uuid.git", branch = "2.0.0" }
</code></pre>
<p>And that’s it! Like with the previous example the 2.0.0 version doesn’t actually
exist on crates.io but we can still put it in through a git dependency through
the usage of the <code>[patch]</code> section. As a thought exercise let’s take another
look at the <code>my-binary</code> manifest from above again as well:</p>
<pre><code class="language-toml">[package]
name = "my-binary"
version = "0.1.0"

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git', branch = '2.0.0' }
</code></pre>
<p>Note that this will actually resolve to two versions of the <code>uuid</code> crate. The
<code>my-binary</code> crate will continue to use the 1.x.y series of the <code>uuid</code> crate but
the <code>my-library</code> crate will use the <code>2.0.0</code> version of <code>uuid</code>. This will allow you
to gradually roll out breaking changes to a crate through a dependency graph
without being forced to update everything all at once.</p>
<h2 id="using-patch-with-multiple-versions"><a class="header" href="#using-patch-with-multiple-versions">Using <code>[patch]</code> with multiple versions</a></h2>
<p>You can patch in multiple versions of the same crate with the <code>package</code> key
used to rename dependencies. For example let’s say that the <code>serde</code> crate has
a bugfix that we’d like to use to its <code>1.*</code> series but we’d also like to
prototype using a <code>2.0.0</code> version of serde we have in our git repository. To
configure this we’d do:</p>
<pre><code class="language-toml">[patch.crates-io]
serde = { git = 'https://github.com/serde-rs/serde.git' }
serde2 = { git = 'https://github.com/example/serde.git', package = 'serde', branch = 'v2' }
</code></pre>
<p>The first <code>serde = ...</code> directive indicates that serde <code>1.*</code> should be used
from the git repository (pulling in the bugfix we need) and the second <code>serde2 = ...</code> directive indicates that the <code>serde</code> package should also be pulled from
the <code>v2</code> branch of <code>https://github.com/example/serde</code>. We’re assuming here
that <code>Cargo.toml</code> on that branch mentions version <code>2.0.0</code>.</p>
<p>Note that when using the <code>package</code> key the <code>serde2</code> identifier here is actually
ignored. We simply need a unique name which doesn’t conflict with other patched
crates.</p>
<h2 id="the-patch-section"><a class="header" href="#the-patch-section">The <code>[patch]</code> section</a></h2>
<p>The <code>[patch]</code> section of <code>Cargo.toml</code> can be used to override dependencies
with other copies. The syntax is similar to the
<a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> section:</p>
<pre><code class="language-toml">[patch.crates-io]
foo = { git = 'https://github.com/example/foo.git' }
bar = { path = 'my/local/bar' }

[dependencies.baz]
git = 'https://github.com/example/baz.git'

[patch.'https://github.com/example/baz']
baz = { git = 'https://github.com/example/patched-baz.git', branch = 'my-branch' }
</code></pre>
<blockquote>
<p><strong>Note</strong>: The <code>[patch]</code> table can also be specified as a <a href="reference/config.html">configuration
option</a>, such as in a <code>.cargo/config.toml</code> file or a CLI option
like <code>--config 'patch.crates-io.rand.path="rand"'</code>. This can be useful for
local-only changes that you don’t want to commit, or temporarily testing a
patch.</p>
</blockquote>
<p>The <code>[patch]</code> table is made of dependency-like sub-tables. Each key after
<code>[patch]</code> is a URL of the source that is being patched, or the name of a
registry. The name <code>crates-io</code> may be used to override the default registry
<a href="https://crates.io/">crates.io</a>. The first <code>[patch]</code> in the example above demonstrates overriding
<a href="https://crates.io/">crates.io</a>, and the second <code>[patch]</code> demonstrates overriding a git source.</p>
<p>Each entry in these tables is a normal dependency specification, the same as
found in the <code>[dependencies]</code> section of the manifest. The dependencies listed
in the <code>[patch]</code> section are resolved and used to patch the source at the
URL specified. The above manifest snippet patches the <code>crates-io</code> source (e.g.
crates.io itself) with the <code>foo</code> crate and <code>bar</code> crate. It also
patches the <code>https://github.com/example/baz</code> source with a <code>my-branch</code> that
comes from elsewhere.</p>
<p>Sources can be patched with versions of crates that do not exist, and they can
also be patched with versions of crates that already exist. If a source is
patched with a crate version that already exists in the source, then the
source’s original crate is replaced.</p>
<p>Cargo only looks at the patch settings in the <code>Cargo.toml</code> manifest at the
root of the workspace. Patch settings defined in dependencies will be
ignored.</p>
<h2 id="the-replace-section"><a class="header" href="#the-replace-section">The <code>[replace]</code> section</a></h2>
<blockquote>
<p><strong>Note</strong>: <code>[replace]</code> is deprecated. You should use the
<a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> table instead.</p>
</blockquote>
<p>This section of Cargo.toml can be used to override dependencies with other
copies. The syntax is similar to the <code>[dependencies]</code> section:</p>
<pre><code class="language-toml">[replace]
"foo:0.1.0" = { git = 'https://github.com/example/foo.git' }
"bar:1.0.2" = { path = 'my/local/bar' }
</code></pre>
<p>Each key in the <code>[replace]</code> table is a <a href="reference/pkgid-spec.html">package ID
specification</a>, which allows arbitrarily choosing a node in the
dependency graph to override (the 3-part version number is required). The
value of each key is the same as the <code>[dependencies]</code> syntax for specifying
dependencies, except that you can’t specify features. Note that when a crate
is overridden the copy it’s overridden with must have both the same name and
version, but it can come from a different source (e.g., git or a local path).</p>
<p>Cargo only looks at the replace settings in the <code>Cargo.toml</code> manifest at the
root of the workspace. Replace settings defined in dependencies will be
ignored.</p>
<h2 id="paths-overrides"><a class="header" href="#paths-overrides"><code>paths</code> overrides</a></h2>
<p>Sometimes you’re only temporarily working on a crate and you don’t want to have
to modify <code>Cargo.toml</code> like with the <code>[patch]</code> section above. For this use
case Cargo offers a much more limited version of overrides called <strong>path
overrides</strong>.</p>
<p>Path overrides are specified through <a href="reference/config.html"><code>.cargo/config.toml</code></a> instead of
<code>Cargo.toml</code>. Inside of <code>.cargo/config.toml</code> you’ll specify a key called <code>paths</code>:</p>
<pre><code class="language-toml">paths = ["/path/to/uuid"]
</code></pre>
<p>This array should be filled with directories that contain a <code>Cargo.toml</code>. In
this instance, we’re just adding <code>uuid</code>, so it will be the only one that’s
overridden. This path can be either absolute or relative to the directory that
contains the <code>.cargo</code> folder.</p>
<p>Path overrides are more restricted than the <code>[patch]</code> section, however, in
that they cannot change the structure of the dependency graph. When a
path replacement is used then the previous set of dependencies
must all match exactly to the new <code>Cargo.toml</code> specification. For example this
means that path overrides cannot be used to test out adding a dependency to a
crate. Instead, <code>[patch]</code> must be used in that situation. As a result, usage of a
path override is typically isolated to quick bug fixes rather than larger
changes.</p>
<blockquote>
<p><strong>Note</strong>: using a local configuration to override paths will only work for
crates that have been published to <a href="https://crates.io/">crates.io</a>. You cannot use this feature
to tell Cargo how to find local unpublished crates.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-replacement"><a class="header" href="#source-replacement">Source Replacement</a></h1>
<p>This document is about redirecting communication with <a href="reference/registries.html">registries</a>
or repositories of <a href="reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">git-based dependencies</a> to another data source, such as a
server mirroring the original registry or an exact local copy.</p>
<p>If you want to patch individual dependencies, see <a href="reference/overriding-dependencies.html">overriding dependencies</a> section of this
documentation. If you want to control how Cargo makes network requests, see <a href="reference/config.html#http"><code>[http]</code></a>
and <a href="reference/config.html#net"><code>[net]</code></a> configuration.</p>
<p>A <em>source</em> is a provider that contains crates that may be included as
dependencies for a package. Cargo supports the ability to <strong>replace one source
with another</strong> to express strategies such as:</p>
<ul>
<li>
<p>Vendoring — custom sources can be defined which represent crates on the local
filesystem. These sources are subsets of the source that they’re replacing and
can be checked into packages if necessary.</p>
</li>
<li>
<p>Mirroring — sources can be replaced with an equivalent version which acts as a
cache for crates.io itself.</p>
</li>
</ul>
<p>Cargo has a core assumption about source replacement that the source code is
exactly the same from both sources. Note that this also means that
a replacement source is not allowed to have crates which are not present in the
original source.</p>
<p>As a consequence, source replacement is not appropriate for situations such as
patching a dependency or a private registry. Cargo supports patching
dependencies through the usage of <a href="reference/overriding-dependencies.html">the <code>[patch]</code> key</a>, and private registry support is described in <a href="reference/registries.html">the Registries
chapter</a>.</p>
<p>When using source replacement, running commands that need to
contact the registry directly<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> requires passing the <code>--registry</code> option. This helps avoid
any ambiguity about which registry to contact, and will use the authentication
token for the specified registry.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Configuration of replacement sources is done through <a href="reference/config.html"><code>.cargo/config.toml</code></a>
and the full set of available keys are:</p>
<pre><code class="language-toml"># The `source` table is where all keys related to source-replacement
# are stored.
[source]

# Under the `source` table are a number of other tables whose keys are a
# name for the relevant source. For example this section defines a new
# source, called `my-vendor-source`, which comes from a directory
# located at `vendor` relative to the directory containing this `.cargo/config.toml`
# file
[source.my-vendor-source]
directory = "vendor"

# The crates.io default source for crates is available under the name
# "crates-io", and here we use the `replace-with` key to indicate that it's
# replaced with our source above.
#
# The `replace-with` key can also reference an alternative registry name
# defined in the `[registries]` table.
[source.crates-io]
replace-with = "my-vendor-source"

# Each source has its own table where the key is the name of the source
[source.the-source-name]

# Indicate that `the-source-name` will be replaced with `another-source`,
# defined elsewhere
replace-with = "another-source"

# Several kinds of sources can be specified (described in more detail below):
registry = "https://example.com/path/to/index"
local-registry = "path/to/registry"
directory = "path/to/vendor"

# Git sources can optionally specify a branch/tag/rev as well
git = "https://example.com/path/to/repo"
# branch = "master"
# tag = "v1.0.1"
# rev = "313f44e8"
</code></pre>
<h2 id="registry-sources"><a class="header" href="#registry-sources">Registry Sources</a></h2>
<p>A “registry source” is one that works like crates.io itself. It’s an index
that conforms to the specification at https://doc.rust-lang.org/cargo/reference/registry-index.html
with a configuration file indicating where to download crates from.</p>
<p>Registry sources can use <a href="reference/registries.html#registry-protocols">either git or sparse HTTP protocol</a>:</p>
<pre><code class="language-toml"># Git protocol
registry = "ssh://git@example.com/path/to/index.git"

# Sparse HTTP protocol  
registry = "sparse+https://example.com/path/to/index"

# HTTPS git protocol
registry = "https://example.com/path/to/index"
</code></pre>
<h2 id="local-registry-sources"><a class="header" href="#local-registry-sources">Local Registry Sources</a></h2>
<p>A “local registry source” is intended to be a subset of another registry
source, but available on the local filesystem (aka vendoring). Local registries
are downloaded ahead of time, typically sync’d with a <code>Cargo.lock</code>, and are
made up of a set of <code>*.crate</code> files and an index like the normal registry is.</p>
<p>The primary way to manage and create local registry sources is through the
<a href="https://crates.io/crates/cargo-local-registry"><code>cargo-local-registry</code></a> subcommand,
<a href="https://crates.io/crates/cargo-local-registry">available on crates.io</a> and can be installed with
<code>cargo install cargo-local-registry</code>.</p>
<p>Local registries are contained within one directory and contain a number of
<code>*.crate</code> files downloaded from crates.io as well as an <code>index</code> directory with
the same format as the crates.io-index project (populated with just entries for
the crates that are present).</p>
<h2 id="directory-sources"><a class="header" href="#directory-sources">Directory Sources</a></h2>
<p>A “directory source” is similar to a local registry source where it contains a
number of crates available on the local filesystem, suitable for vendoring
dependencies. Directory sources are primarily managed by the <code>cargo vendor</code>
subcommand.</p>
<p>Directory sources are distinct from local registries though in that they contain
the unpacked version of <code>*.crate</code> files, making it more suitable in some
situations to check everything into source control. A directory source is just a
directory containing a number of other directories which contain the source code
for crates (the unpacked version of <code>*.crate</code> files). Currently no restriction
is placed on the name of each directory.</p>
<p>Each crate in a directory source also has an associated metadata file indicating
the checksum of each file in the crate to protect against accidental
modifications.</p>
<h2 id="git-sources"><a class="header" href="#git-sources">Git sources</a></h2>
<p>Git sources represent repositories used by <a href="reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">git-based dependencies</a>. They’re
used to specify which git-based dependencies should be replaced with alternative sources.</p>
<p>Git sources are <em>not</em> related to the <a href="reference/registries.html#registry-protocols">git registries</a>,
and can’t be used to replace registry sources.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Examples of such commands are in <a href="reference/../commands/publishing-commands.html">Publishing Commands</a>. <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-resolution"><a class="header" href="#dependency-resolution">Dependency Resolution</a></h1>
<p>One of Cargo’s primary tasks is to determine the versions of dependencies to
use based on the version requirements specified in each package. This process
is called “dependency resolution” and is performed by the “resolver”. The
result of the resolution is stored in the <a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code> file</a> which “locks” the
dependencies to specific versions, and keeps them fixed over time.
The <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> command can be used to visualize the result of the
resolver.</p>
<h2 id="constraints-and-heuristics"><a class="header" href="#constraints-and-heuristics">Constraints and Heuristics</a></h2>
<p>In many cases there is no single “best” dependency resolution.
The resolver operates under various constraints and heuristics to find a generally applicable resolution.
To understand how these interact, it is helpful to have a coarse understanding of how dependency resolution works.</p>
<p>This pseudo-code approximates what Cargo’s resolver does:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn resolve(workspace: &amp;[Package], policy: Policy) -&gt; Option&lt;ResolveGraph&gt; {
    let dep_queue = Queue::new(workspace);
    let resolved = ResolveGraph::new();
    resolve_next(dep_queue, resolved, policy)
}

fn resolve_next(dep_queue: Queue, resolved: ResolveGraph, policy: Policy) -&gt; Option&lt;ResolveGraph&gt; {
    let Some(dep_spec) = policy.pick_next_dep(dep_queue) else {
        // Done
        return Some(resolved);
    };

    if let Some(resolved) = policy.try_unify_version(dep_spec, resolved.clone()) {
        return Some(resolved);
    }

    let dep_versions = dep_spec.lookup_versions()?;
    let mut dep_versions = policy.filter_versions(dep_spec, dep_versions);
    while let Some(dep_version) = policy.pick_next_version(&amp;mut dep_versions) {
        if policy.needs_version_unification(dep_version, &amp;resolved) {
            continue;
        }

        let mut dep_queue = dep_queue.clone();
        dep_queue.enqueue(dep_version.dependencies);
        let mut resolved = resolved.clone();
        resolved.register(dep_version);
        if let Some(resolved) = resolve_next(dep_queue, resolved) {
            return Some(resolved);
        }
    }

    // No valid solution found, backtrack and `pick_next_version`
    None
}
<span class="boring">}</span></code></pre></pre>
<p>Key steps:</p>
<ul>
<li>Walking dependencies (<code>pick_next_dep</code>):
The order dependencies are walked can affect
how related version requirements for the same dependency get resolved, see unifying versions,
and how much the resolver backtracks, affecting resolver performance,</li>
<li>Unifying versions (<code>try_unify_version</code>, <code>needs_version_unification</code>):
Cargo reuses versions where possible to reduce build times and allow types from common dependencies to be passed between APIs.
If multiple versions would have been unified if it wasn’t for conflicts in their <a href="reference/specifying-dependencies.html">dependency specifications</a>, Cargo will backtrack, erroring if no solution is found, rather than selecting multiple versions.
A <a href="reference/specifying-dependencies.html">dependency specification</a> or Cargo may decide that a version is undesirable,
preferring to backtrack or error rather than use it.</li>
<li>Preferring versions (<code>pick_next_version</code>):
Cargo may decide that it should prefer a specific version,
falling back to the next version when backtracking.</li>
</ul>
<h3 id="version-numbers"><a class="header" href="#version-numbers">Version numbers</a></h3>
<p>Generally, Cargo prefers the highest version currently available.</p>
<p>For example, if you had a package in the resolve graph with:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "*"
</code></pre>
<p>If at the time the <code>Cargo.lock</code> file is generated, the greatest version of
<code>bitflags</code> is <code>1.2.1</code>, then the package will use <code>1.2.1</code>.</p>
<p>For an example of a possible exception, see <a href="reference/resolver.html#rust-version">Rust version</a>.</p>
<h3 id="version-requirements"><a class="header" href="#version-requirements">Version requirements</a></h3>
<p>Package specify what versions they support, rejecting all others, through
<a href="reference/specifying-dependencies.html#version-requirement-syntax">version requirements</a>.</p>
<p>For example, if you had a package in the resolve graph with:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "1.0"  # meaning `&gt;=1.0.0,&lt;2.0.0`
</code></pre>
<p>If at the time the <code>Cargo.lock</code> file is generated, the greatest version of
<code>bitflags</code> is <code>1.2.1</code>, then the package will use <code>1.2.1</code> because it is the
greatest within the compatibility range. If <code>2.0.0</code> is published, it will
still use <code>1.2.1</code> because <code>2.0.0</code> is considered incompatible.</p>
<h3 id="semver-compatibility"><a class="header" href="#semver-compatibility">SemVer compatibility</a></h3>
<p>Cargo assumes packages follow <a href="https://semver.org/">SemVer</a> and will unify dependency versions if they are
<a href="https://semver.org/">SemVer</a> compatible according to the <a href="reference/specifying-dependencies.html#default-requirements">Caret version requirements</a>.
If two compatible versions cannot be unified because of conflicting version requirements,
Cargo will error.</p>
<p>See the <a href="reference/semver.html">SemVer Compatibility</a> chapter for guidance on what is considered a
“compatible” change.</p>
<p>Examples:</p>
<p>The following two packages will have their dependencies on <code>bitflags</code> unified because any version picked will be compatible with each other.</p>
<pre><code class="language-toml"># Package A
[dependencies]
bitflags = "1.0"  # meaning `&gt;=1.0.0,&lt;2.0.0`

# Package B
[dependencies]
bitflags = "1.1"  # meaning `&gt;=1.1.0,&lt;2.0.0`
</code></pre>
<p>The following packages will error because the version requirements conflict, selecting two distinct compatible versions.</p>
<pre><code class="language-toml"># Package A
[dependencies]
log = "=0.4.11"

# Package B
[dependencies]
log = "=0.4.8"
</code></pre>
<p>The following two packages will not have their dependencies on <code>rand</code> unified because only incompatible versions are available for each.
Instead, two different versions (e.g. 0.6.5 and 0.7.3) will be resolved and built.
This can lead to potential problems, see the <a href="reference/resolver.html#version-incompatibility-hazards">Version-incompatibility hazards</a> section for more details.</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = "0.7"  # meaning `&gt;=0.7.0,&lt;0.8.0`

# Package B
[dependencies]
rand = "0.6"  # meaning `&gt;=0.6.0,&lt;0.7.0`
</code></pre>
<p>Generally, the following two packages will not have their dependencies unified because incompatible versions are available that satisfy the version requirements:
Instead, two different versions (e.g. 0.6.5 and 0.7.3) will be resolved and built.
The application of other constraints or heuristics may cause these to be unified,
picking one version (e.g. 0.6.5).</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = "&gt;=0.6,&lt;0.8.0"

# Package B
[dependencies]
rand = "0.6"  # meaning `&gt;=0.6.0,&lt;0.7.0`
</code></pre>
<h4 id="version-incompatibility-hazards"><a class="header" href="#version-incompatibility-hazards">Version-incompatibility hazards</a></h4>
<p>When multiple versions of a crate appear in the resolve graph, this can cause
problems when types from those crates are exposed by the crates using them.
This is because the types and items are considered different by the Rust
compiler, even if they have the same name. Libraries should take care when
publishing a SemVer-incompatible version (for example, publishing <code>2.0.0</code>
after <code>1.0.0</code> has been in use), particularly for libraries that are widely
used.</p>
<p>The “<a href="https://github.com/dtolnay/semver-trick">semver trick</a>” is a workaround for this problem of publishing a breaking
change while retaining compatibility with older versions. The linked page goes
into detail about what the problem is and how to address it. In short, when a
library wants to publish a SemVer-breaking release, publish the new release,
and also publish a point release of the previous version that reexports the
types from the newer version.</p>
<p>These incompatibilities usually manifest as a compile-time error, but
sometimes they will only appear as a runtime misbehavior. For example, let’s
say there is a common library named <code>foo</code> that ends up appearing with both
version <code>1.0.0</code> and <code>2.0.0</code> in the resolve graph. If <a href="reference/../../std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref</code></a> is used
on an object created by a library using version <code>1.0.0</code>, and the code calling
<code>downcast_ref</code> is downcasting to a type from version <code>2.0.0</code>, the downcast
will fail at runtime.</p>
<p>It is important to make sure that if you have multiple versions of a library
that you are properly using them, especially if it is ever possible for the
types from different versions to be used together. The <a href="reference/../commands/cargo-tree.html"><code>cargo tree -d</code></a> command can be used to identify duplicate versions and
where they come from. Similarly, it is important to consider the impact on the
ecosystem if you publish a SemVer-incompatible version of a popular library.</p>
<h3 id="lock-file"><a class="header" href="#lock-file">Lock file</a></h3>
<p>Cargo gives the highest priority to versions contained in the <a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code> file</a>, when used.
This is intended to balance reproducible builds with adjusting to changes in the manifest.</p>
<p>For example, if you had a package in the resolve graph with:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "*"
</code></pre>
<p>If at the time your <code>Cargo.lock</code> file is generated, the greatest version of
<code>bitflags</code> is <code>1.2.1</code>, then the package will use <code>1.2.1</code> and recorded in the <code>Cargo.lock</code> file.</p>
<p>By the time Cargo next runs, <code>bitflags</code> <code>1.3.5</code> is out.
When resolving dependencies,
<code>1.2.1</code> will still be used because it is present in your <code>Cargo.lock</code> file.</p>
<p>The package is then edited to:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "1.3.0"
</code></pre>
<p><code>bitflags</code> <code>1.2.1</code> does not match this version requirement and so that entry in your <code>Cargo.lock</code> file is ignored and version <code>1.3.5</code> will now be used and recorded in your <code>Cargo.lock</code> file.</p>
<h3 id="rust-version-1"><a class="header" href="#rust-version-1">Rust version</a></h3>
<p>To support developing software with a minimum supported <a href="reference/rust-version.html">Rust version</a>,
the resolver can take into account a dependency version’s compatibility with your Rust version.
This is controlled by the config field <a href="reference/config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a>.</p>
<p>With the <code>fallback</code> setting, the resolver will prefer packages with a Rust version that is
less than or equal to your own Rust version.
For example, you are using Rust 1.85 to develop the following package:</p>
<pre><code class="language-toml">[package]
name = "my-cli"
rust-version = "1.62"

[dependencies]
clap = "4.0"  # resolves to 4.0.32
</code></pre>
<p>The resolver would pick version 4.0.32 because it has a Rust version of 1.60.0.</p>
<ul>
<li>4.0.0 is not picked because it is a <a href="reference/resolver.html#version-numbers">lower version number</a> despite it also having a Rust version of 1.60.0.</li>
<li>4.5.20 is not picked because it is incompatible with <code>my-cli</code>’s Rust version of 1.62 despite having a much <a href="reference/resolver.html#version-numbers">higher version</a> and it has a Rust version of 1.74.0 which is compatible with your 1.85 toolchain.</li>
</ul>
<p>If a version requirement does not include a Rust version compatible dependency version,
the resolver won’t error but will instead pick a version, even if its potentially suboptimal.
For example, you change the dependency on <code>clap</code>:</p>
<pre><code class="language-toml">[package]
name = "my-cli"
rust-version = "1.62"

[dependencies]
clap = "4.2"  # resolves to 4.5.20
</code></pre>
<p>No version of <code>clap</code> matches that <a href="reference/resolver.html#version-requirements">version requirement</a>
that is compatible with Rust version 1.62.
The resolver will then pick an incompatible version, like 4.5.20 despite it having a Rust version of 1.74.</p>
<p>When the resolver selects a dependency version of a package,
it does not know all the workspace members that will eventually have a transitive dependency on that version
and so it cannot take into account only the Rust versions relevant for that dependency.
The resolver has heuristics to find a “good enough” solution when workspace members have different Rust versions.
This applies even for packages in a workspace without a Rust version.</p>
<p>When a workspace has members with different Rust versions,
the resolver may pick a lower dependency version than necessary.
For example, you have the following workspace members:</p>
<pre><code class="language-toml">[package]
name = "a"
rust-version = "1.62"

[package]
name = "b"

[dependencies]
clap = "4.2"  # resolves to 4.5.20
</code></pre>
<p>Though package <code>b</code> does not have a Rust version and could use a higher version like 4.5.20,
4.0.32 will be selected because of package <code>a</code>’s Rust version of 1.62.</p>
<p>Or the resolver may pick too high of a version.
For example, you have the following workspace members:</p>
<pre><code class="language-toml">[package]
name = "a"
rust-version = "1.62"

[dependencies]
clap = "4.2"  # resolves to 4.5.20

[package]
name = "b"

[dependencies]
clap = "4.5"  # resolves to 4.5.20
</code></pre>
<p>Though each package has a version requirement for <code>clap</code> that would meet its own Rust version,
because of <a href="reference/resolver.html#version-numbers">version unification</a>,
the resolver will need to pick one version that works in both cases and that would be a version like 4.5.20.</p>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<p>For the purpose of generating <code>Cargo.lock</code>, the resolver builds the dependency
graph as-if all <a href="reference/features.html">features</a> of all <a href="reference/workspaces.html">workspace</a> members are enabled. This
ensures that any optional dependencies are available and properly resolved
with the rest of the graph when features are added or removed with the
<a href="reference/features.html#command-line-feature-options"><code>--features</code> command-line flag</a>.
The resolver runs a second time to determine the actual features used when
<em>compiling</em> a crate, based on the features selected on the command-line.</p>
<p>Dependencies are resolved with the union of all features enabled on them. For
example, if one package depends on the <a href="https://crates.io/crates/im"><code>im</code></a> package with the <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L46"><code>serde</code>
dependency</a> enabled and another package depends on it with the <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L47"><code>rayon</code>
dependency</a> enabled, then <code>im</code> will be built with both features enabled, and
the <code>serde</code> and <code>rayon</code> crates will be included in the resolve graph. If no
packages depend on <code>im</code> with those features, then those optional dependencies
will be ignored, and they will not affect resolution.</p>
<p>When building multiple packages in a workspace (such as with <code>--workspace</code> or
multiple <code>-p</code> flags), the features of the dependencies of all of those
packages are unified. If you have a circumstance where you want to avoid that
unification for different workspace members, you will need to build them via
separate <code>cargo</code> invocations.</p>
<p>The resolver will skip over versions of packages that are missing required
features. For example, if a package depends on version <code>^1</code> of <a href="https://crates.io/crates/regex"><code>regex</code></a> with
the <a href="https://github.com/rust-lang/regex/blob/1.3.0/Cargo.toml#L56"><code>perf</code> feature</a>, then the oldest version it can select is <code>1.3.0</code>,
because versions prior to that did not contain the <code>perf</code> feature. Similarly,
if a feature is removed from a new release, then packages that require that
feature will be stuck on the older releases that contain that feature. It is
discouraged to remove features in a SemVer-compatible release. Beware that
optional dependencies also define an implicit feature, so removing an optional
dependency or making it non-optional can cause problems, see <a href="reference/semver.html#cargo-remove-opt-dep">removing an
optional dependency</a>.</p>
<h4 id="feature-resolver-version-2"><a class="header" href="#feature-resolver-version-2">Feature resolver version 2</a></h4>
<p>When <code>resolver = "2"</code> is specified in <code>Cargo.toml</code> (see <a href="reference/resolver.html#resolver-versions">resolver
versions</a> below), a different feature resolver is used
which uses a different algorithm for unifying features. The version <code>"1"</code>
resolver will unify features for a package no matter where it is specified.
The version <code>"2"</code> resolver will avoid unifying features in the following
situations:</p>
<ul>
<li>
<p>Features for target-specific dependencies are not enabled if the target is
not currently being built. For example:</p>
<pre><code class="language-toml">[dependencies.common]
version = "1.0"
features = ["f1"]

[target.'cfg(windows)'.dependencies.common]
version = "1.0"
features = ["f2"]
</code></pre>
<p>When building this example for a non-Windows platform, the <code>f2</code> feature will
<em>not</em> be enabled.</p>
</li>
<li>
<p>Features enabled on <a href="reference/specifying-dependencies.html#build-dependencies">build-dependencies</a> or proc-macros will not be unified
when those same dependencies are used as a normal dependency. For example:</p>
<pre><code class="language-toml">[dependencies]
log = "0.4"

[build-dependencies]
log = {version = "0.4", features=['std']}
</code></pre>
<p>When building the build script, the <code>log</code> crate will be built with the <code>std</code>
feature. When building the library of your package, it will not enable the
feature.</p>
</li>
<li>
<p>Features enabled on <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> will not be unified when those same
dependencies are used as a normal dependency, unless those dev-dependencies
are currently being built. For example:</p>
<pre><code class="language-toml">[dependencies]
serde = {version = "1.0", default-features = false}

[dev-dependencies]
serde = {version = "1.0", features = ["std"]}
</code></pre>
<p>In this example, the library will normally link against <code>serde</code> without the
<code>std</code> feature. However, when built as a test or example, it will include the
<code>std</code> feature. For example, <code>cargo test</code> or <code>cargo build --all-targets</code> will
unify these features. Note that dev-dependencies in dependencies are always
ignored, this is only relevant for the top-level package or workspace
members.</p>
</li>
</ul>
<h3 id="links"><a class="header" href="#links"><code>links</code></a></h3>
<p>The <a href="reference/manifest.html#the-links-field"><code>links</code> field</a> is used to ensure only one copy of a native library is
linked into a binary. The resolver will attempt to find a graph where there is
only one instance of each <code>links</code> name. If it is unable to find a graph that
satisfies that constraint, it will return an error.</p>
<p>For example, it is an error if one package depends on <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code></a> version
<code>0.11</code> and another depends on <code>0.12</code>, because Cargo is unable to unify those,
but they both link to the <code>git2</code> native library. Due to this requirement, it
is encouraged to be very careful when making SemVer-incompatible releases with
the <code>links</code> field if your library is in common use.</p>
<h3 id="yanked-versions"><a class="header" href="#yanked-versions">Yanked versions</a></h3>
<p><a href="reference/publishing.html#cargo-yank">Yanked releases</a> are those that are marked that they should not be
used. When the resolver is building the graph, it will ignore all yanked
releases unless they already exist in the <code>Cargo.lock</code> file or are explicitly
requested by the <a href="reference/../commands/cargo-update.html#option-cargo-update---precise"><code>--precise</code></a> flag of <code>cargo update</code> (nightly only).</p>
<h2 id="dependency-updates"><a class="header" href="#dependency-updates">Dependency updates</a></h2>
<p>Dependency resolution is automatically performed by all Cargo commands that
need to know about the dependency graph. For example, <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> will run
the resolver to discover all the dependencies to build. After the first time
it runs, the result is stored in the <code>Cargo.lock</code> file. Subsequent commands
will run the resolver, keeping dependencies locked to the versions in
<code>Cargo.lock</code> <em>if it can</em>.</p>
<p>If the dependency list in <code>Cargo.toml</code> has been modified, for example changing
the version of a dependency from <code>1.0</code> to <code>2.0</code>, then the resolver will select
a new version for that dependency that matches the new requirements. If that
new dependency introduces new requirements, those new requirements may also
trigger additional updates. The <code>Cargo.lock</code> file will be updated with the new
result. The <code>--locked</code> or <code>--frozen</code> flags can be used to change this behavior
to prevent automatic updates when requirements change, and return an error
instead.</p>
<p><a href="reference/../commands/cargo-update.html"><code>cargo update</code></a> can be used to update the entries in <code>Cargo.lock</code> when new
versions are published. Without any options, it will attempt to update all
packages in the lock file. The <code>-p</code> flag can be used to target the update for
a specific package, and other flags such as <code>--recursive</code> or <code>--precise</code> can
be used to control how versions are selected.</p>
<h2 id="overrides"><a class="header" href="#overrides">Overrides</a></h2>
<p>Cargo has several mechanisms to override dependencies within the graph. The
<a href="reference/overriding-dependencies.html">Overriding Dependencies</a> chapter goes into detail on how to use overrides.
The overrides appear as an overlay to a registry, replacing the patched
version with the new entry. Otherwise, resolution is performed like normal.</p>
<h2 id="dependency-kinds"><a class="header" href="#dependency-kinds">Dependency kinds</a></h2>
<p>There are three kinds of dependencies in a package: normal, <a href="reference/specifying-dependencies.html#build-dependencies">build</a>, and
<a href="reference/specifying-dependencies.html#development-dependencies">dev</a>. For the most part these are all treated the same from
the perspective of the resolver. One difference is that dev-dependencies for
non-workspace members are always ignored, and do not influence resolution.</p>
<p><a href="reference/specifying-dependencies.html#platform-specific-dependencies">Platform-specific dependencies</a> with the <code>[target]</code> table are resolved as-if
all platforms are enabled. In other words, the resolver ignores the platform
or <code>cfg</code> expression.</p>
<h3 id="dev-dependency-cycles"><a class="header" href="#dev-dependency-cycles">dev-dependency cycles</a></h3>
<p>Usually the resolver does not allow cycles in the graph, but it does allow
them for <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a>. For example, project “foo” has a dev-dependency
on “bar”, which has a normal dependency on “foo” (usually as a “path”
dependency). This is allowed because there isn’t really a cycle from the
perspective of the build artifacts. In this example, the “foo” library is
built (which does not need “bar” because “bar” is only used for tests), and
then “bar” can be built depending on “foo”, then the “foo” tests can be built
linking to “bar”.</p>
<p>Beware that this can lead to confusing errors. In the case of building library
unit tests, there are actually two copies of the library linked into the final
test binary: the one that was linked with “bar”, and the one built that
contains the unit tests. Similar to the issues highlighted in the
<a href="reference/resolver.html#version-incompatibility-hazards">Version-incompatibility hazards</a> section, the types between the two are not
compatible. Be careful when exposing types of “foo” from “bar” in this
situation, since the “foo” unit tests won’t treat them the same as the local
types.</p>
<p>If possible, try to split your package into multiple packages and restructure
it so that it remains strictly acyclic.</p>
<h2 id="resolver-versions"><a class="header" href="#resolver-versions">Resolver versions</a></h2>
<p>Different resolver behavior can be specified through the resolver
version in <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[package]
name = "my-package"
version = "1.0.0"
resolver = "2"
</code></pre>
<ul>
<li><code>"1"</code> (default)</li>
<li><code>"2"</code> (<a href="reference/manifest.html#the-edition-field"><code>edition = "2021"</code></a> default): Introduces changes in <a href="reference/resolver.html#features">feature
unification</a>. See the <a href="reference/features.html#feature-resolver-version-2">features chapter</a> for more
details.</li>
<li><code>"3"</code> (<a href="reference/manifest.html#the-edition-field"><code>edition = "2024"</code></a> default, requires Rust 1.84+): Change the default for <a href="reference/config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a> from <code>allow</code> to <code>fallback</code></li>
</ul>
<p>The resolver is a global option that affects the entire workspace. The
<code>resolver</code> version in dependencies is ignored, only the value in the top-level
package will be used. If using a <a href="reference/workspaces.html#virtual-workspace">virtual workspace</a>, the version should be
specified in the <code>[workspace]</code> table, for example:</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "member2"]
resolver = "2"
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> Requires 1.51+</p>
</blockquote>
<h2 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h2>
<p>The following are some recommendations for setting the version within your
package, and for specifying dependency requirements. These are general
guidelines that should apply to common situations, but of course some
situations may require specifying unusual requirements.</p>
<ul>
<li>
<p>Follow the <a href="reference/semver.html">SemVer guidelines</a> when deciding how to update your version
number, and whether or not you will need to make a SemVer-incompatible
version change.</p>
</li>
<li>
<p>Use caret requirements for dependencies, such as <code>"1.2.3"</code>, for most
situations. This ensures that the resolver can be maximally flexible in
choosing a version while maintaining build compatibility.</p>
<ul>
<li>Specify all three components with the version you are currently using.
This helps set the minimum version that will be used, and ensures that
other users won’t end up with an older version of the dependency that
might be missing something that your package requires.</li>
<li>Avoid <code>*</code> requirements, as they are not allowed on <a href="https://crates.io/">crates.io</a>, and they
can pull in SemVer-breaking changes during a normal <code>cargo update</code>.</li>
<li>Avoid overly broad version requirements. For example, <code>&gt;=2.0.0</code> can pull
in any SemVer-incompatible version, like version <code>5.0.0</code>, which can result
in broken builds in the future.</li>
<li>Avoid overly narrow version requirements if possible. For example, if you
specify a tilde requirement like <code>bar="~1.3"</code>, and another package
specifies a requirement of <code>bar="1.4"</code>, this will fail to resolve, even
though minor releases should be compatible.</li>
</ul>
</li>
<li>
<p>Try to keep the dependency versions up-to-date with the actual minimum
versions that your library requires. For example, if you have a requirement
of <code>bar="1.0.12"</code>, and then in a future release you start using new features
added in the <code>1.1.0</code> release of “bar”, update your dependency requirement to
<code>bar="1.1.0"</code>.</p>
<p>If you fail to do this, it may not be immediately obvious because Cargo can
opportunistically choose the newest version when you run a blanket <code>cargo update</code>. However, if another user depends on your library, and runs <code>cargo update your-library</code>, it will <em>not</em> automatically update “bar” if it is
locked in their <code>Cargo.lock</code>. It will only update “bar” in that situation if
the dependency declaration is also updated. Failure to do so can cause
confusing build errors for the user using <code>cargo update your-library</code>.</p>
</li>
<li>
<p>If two packages are tightly coupled, then an <code>=</code> dependency requirement may
help ensure that they stay in sync. For example, a library with a companion
proc-macro library will sometimes make assumptions between the two libraries
that won’t work well if the two are out of sync (and it is never expected to
use the two libraries independently). The parent library can use an <code>=</code>
requirement on the proc-macro, and re-export the macros for easy access.</p>
</li>
<li>
<p><code>0.0.x</code> versions can be used for packages that are permanently unstable.</p>
</li>
</ul>
<p>In general, the stricter you make the dependency requirements, the more likely
it will be for the resolver to fail. Conversely, if you use requirements that
are too loose, it may be possible for new versions to be published that will
break the build.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>The following illustrates some problems you may experience, and some possible
solutions.</p>
<h3 id="why-was-a-dependency-included"><a class="header" href="#why-was-a-dependency-included">Why was a dependency included?</a></h3>
<p>Say you see dependency <code>rand</code> in the <code>cargo check</code> output but don’t think it’s needed and want to understand why it’s being pulled in.</p>
<p>You can run</p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --invert rand
rand v0.8.5
└── ...

rand v0.8.5
└── ...
</code></pre>
<h3 id="why-was-that-feature-on-this-dependency-enabled"><a class="header" href="#why-was-that-feature-on-this-dependency-enabled">Why was that feature on this dependency enabled?</a></h3>
<p>You might identify that it was an activated feature that caused <code>rand</code> to show up.  <strong>To figure out which package activated the feature, you can add the <code>--edges features</code></strong></p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --edges features --invert rand
rand v0.8.5
└── ...

rand v0.8.5
└── ...
</code></pre>
<h3 id="unexpected-dependency-duplication"><a class="header" href="#unexpected-dependency-duplication">Unexpected dependency duplication</a></h3>
<p>You see multiple instances of <code>rand</code> when you run</p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --duplicates
rand v0.7.3
└── ...

rand v0.8.5
└── ...
</code></pre>
<p>The resolver algorithm has converged on a solution that includes two copies of a
dependency when one would suffice. For example:</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = "0.7"

# Package B
[dependencies]
rand = "&gt;=0.6"  # note: open requirements such as this are discouraged
</code></pre>
<p>In this example, Cargo may build two copies of the <code>rand</code> crate, even though a
single copy at version <code>0.7.3</code> would meet all requirements. This is because the
resolver’s algorithm favors building the latest available version of <code>rand</code> for
Package B, which is <code>0.8.5</code> at the time of this writing, and that is
incompatible with Package A’s specification. The resolver’s algorithm does not
currently attempt to “deduplicate” in this situation.</p>
<p>The use of open-ended version requirements like <code>&gt;=0.6</code> is discouraged in Cargo.
But, if you run into this situation, the <a href="reference/../commands/cargo-update.html"><code>cargo update</code></a> command with the
<code>--precise</code> flag can be used to manually remove such duplications.</p>
<h3 id="why-wasnt-a-newer-version-selected"><a class="header" href="#why-wasnt-a-newer-version-selected">Why wasn’t a newer version selected?</a></h3>
<p>Say you noticed that the latest version of a dependency wasn’t selected when you ran:</p>
<pre><code class="language-console">$ cargo update
</code></pre>
<p>You can enable some extra logging to see why this happened:</p>
<pre><code class="language-console">$ env CARGO_LOG=cargo::core::resolver=trace cargo update
</code></pre>
<p><strong>Note:</strong> Cargo log targets and levels may change over time.</p>
<h3 id="semver-breaking-patch-release-breaks-the-build"><a class="header" href="#semver-breaking-patch-release-breaks-the-build">SemVer-breaking patch release breaks the build</a></h3>
<p>Sometimes a project may inadvertently publish a point release with a
SemVer-breaking change. When users update with <code>cargo update</code>, they will pick
up this new release, and then their build may break. In this situation, it is
recommended that the project should <a href="reference/publishing.html#cargo-yank">yank</a> the release, and either remove the
SemVer-breaking change, or publish it as a new SemVer-major version increase.</p>
<p>If the change happened in a third-party project, if possible try to
(politely!) work with the project to resolve the issue.</p>
<p>While waiting for the release to be yanked, some workarounds depend on the
circumstances:</p>
<ul>
<li>If your project is the end product (such as a binary executable), just avoid
updating the offending package in <code>Cargo.lock</code>. This can be done with the
<code>--precise</code> flag in <a href="reference/../commands/cargo-update.html"><code>cargo update</code></a>.</li>
<li>If you publish a binary on <a href="https://crates.io/">crates.io</a>, then you can temporarily add an <code>=</code>
requirement to force the dependency to a specific good version.
<ul>
<li>Binary projects can alternatively recommend users to use the <code>--locked</code>
flag with <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> to use the original <code>Cargo.lock</code> that contains
the known good version.</li>
</ul>
</li>
<li>Libraries may also consider publishing a temporary new release with stricter
requirements that avoid the troublesome dependency. You may want to consider
using range requirements (instead of <code>=</code>) to avoid overly-strict
requirements that may conflict with other packages using the same
dependency. Once the problem has been resolved, you can publish another
point release that relaxes the dependency back to a caret requirement.</li>
<li>If it looks like the third-party project is unable or unwilling to yank the
release, then one option is to update your code to be compatible with the
changes, and update the dependency requirement to set the minimum version to
the new release. You will also need to consider if this is a SemVer-breaking
change of your own library, for example if it exposes types from the
dependency.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-1"><a class="header" href="#features-1">Features</a></h1>
<p>Cargo “features” provide a mechanism to express <a href="reference/../../reference/conditional-compilation.html">conditional compilation</a> and
<a href="reference/features.html#optional-dependencies">optional dependencies</a>. A package defines a set of
named features in the <code>[features]</code> table of <code>Cargo.toml</code>, and each feature can
either be enabled or disabled. Features for the package being built can be
enabled on the command-line with flags such as <code>--features</code>. Features for
dependencies can be enabled in the dependency declaration in <code>Cargo.toml</code>.</p>
<blockquote>
<p><strong>Note</strong>: New crates or versions published on crates.io are now limited to
a maximum of 300 features. Exceptions are granted on a case-by-case basis.
See this <a href="https://blog.rust-lang.org/2023/10/26/broken-badges-and-23k-keywords.html">blog post</a> for details. Participation in solution discussions is
encouraged via the crates.io Zulip stream.</p>
</blockquote>
<p>See also the <a href="reference/features-examples.html">Features Examples</a> chapter for some examples of how features can
be used.</p>
<h2 id="the-features-section"><a class="header" href="#the-features-section">The <code>[features]</code> section</a></h2>
<p>Features are defined in the <code>[features]</code> table in <code>Cargo.toml</code>. Each feature
specifies an array of other features or optional dependencies that it enables.
The following examples illustrate how features could be used for a 2D image
processing library where support for different image formats can be optionally
included:</p>
<pre><code class="language-toml">[features]
# Defines a feature named `webp` that does not enable any other features.
webp = []
</code></pre>
<p>With this feature defined, <a href="reference/../../reference/conditional-compilation.html"><code>cfg</code> expressions</a> can be used to conditionally
include code to support the requested feature at compile time. For example,
inside <code>lib.rs</code> of the package could include this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This conditionally includes a module which implements WEBP support.
#[cfg(feature = "webp")]
pub mod webp;
<span class="boring">}</span></code></pre></pre>
<p>Cargo sets features in the package using the <code>rustc</code> <a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> flag</a>, and code
can test for their presence with the <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> or the <a href="reference/../../std/macro.cfg.html"><code>cfg</code> macro</a>.</p>
<p>Features can list other features to enable. For example, the ICO image format
can contain BMP and PNG images, so when it is enabled, it should make sure
those other features are enabled, too:</p>
<pre><code class="language-toml">[features]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
</code></pre>
<p>Feature names may include characters from the <a href="https://unicode.org/reports/tr31/">Unicode XID standard</a> (which
includes most letters), and additionally allows starting with <code>_</code> or digits
<code>0</code> through <code>9</code>, and after the first character may also contain <code>-</code>, <code>+</code>, or
<code>.</code>.</p>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> imposes additional constraints on feature name syntax
that they must only be <a href="reference/../../std/primitive.char.html#method.is_ascii_alphanumeric">ASCII alphanumeric</a> characters or <code>_</code>, <code>-</code>, or <code>+</code>.</p>
</blockquote>
<h2 id="the-default-feature"><a class="header" href="#the-default-feature">The <code>default</code> feature</a></h2>
<p>By default, all features are disabled unless explicitly enabled. This can be
changed by specifying the <code>default</code> feature:</p>
<pre><code class="language-toml">[features]
default = ["ico", "webp"]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
</code></pre>
<p>When the package is built, the <code>default</code> feature is enabled which in turn
enables the listed features. This behavior can be changed by:</p>
<ul>
<li>The <code>--no-default-features</code> <a href="reference/features.html#command-line-feature-options">command-line
flag</a> disables the default features of the
package.</li>
<li>The <code>default-features = false</code> option can be specified in a <a href="reference/features.html#dependency-features">dependency
declaration</a>.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Be careful about choosing the default feature set. The default
features are a convenience that make it easier to use a package without
forcing the user to carefully select which features to enable for common
use, but there are some drawbacks. Dependencies automatically enable default
features unless <code>default-features = false</code> is specified. This can make it
difficult to ensure that the default features are not enabled, especially
for a dependency that appears multiple times in the dependency graph. Every
package must ensure that <code>default-features = false</code> is specified to avoid
enabling them.</p>
<p>Another issue is that it can be a <a href="reference/features.html#semver-compatibility">SemVer incompatible
change</a> to remove a feature from the default set, so
you should be confident that you will keep those features.</p>
</blockquote>
<h2 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional dependencies</a></h2>
<p>Dependencies can be marked “optional”, which means they will not be compiled
by default. For example, let’s say that our 2D image processing library uses
an external package to handle GIF images. This can be expressed like this:</p>
<pre><code class="language-toml">[dependencies]
gif = { version = "0.11.1", optional = true }
</code></pre>
<p>By default, this optional dependency implicitly defines a feature that looks
like this:</p>
<pre><code class="language-toml">[features]
gif = ["dep:gif"]
</code></pre>
<p>This means that this dependency will only be included if the <code>gif</code>
feature is enabled.
The same <code>cfg(feature = "gif")</code> syntax can be used in the code, and the
dependency can be enabled just like any feature such as <code>--features gif</code> (see
<a href="reference/features.html#command-line-feature-options">Command-line feature options</a> below).</p>
<p>In some cases, you may not want to expose a feature that has the same name
as the optional dependency.
For example, perhaps the optional dependency is an internal detail, or you
want to group multiple optional dependencies together, or you just want to use
a better name.
If you specify the optional dependency with the <code>dep:</code> prefix anywhere
in the <code>[features]</code> table, that disables the implicit feature.</p>
<blockquote>
<p><strong>Note</strong>: The <code>dep:</code> syntax is only available starting with Rust 1.60.
Previous versions can only use the implicit feature name.</p>
</blockquote>
<p>For example, let’s say in order to support the AVIF image format, our library
needs two other dependencies to be enabled:</p>
<pre><code class="language-toml">[dependencies]
ravif = { version = "0.6.3", optional = true }
rgb = { version = "0.8.25", optional = true }

[features]
avif = ["dep:ravif", "dep:rgb"]
</code></pre>
<p>In this example, the <code>avif</code> feature will enable the two listed dependencies.
This also avoids creating the implicit <code>ravif</code> and <code>rgb</code> features, since we
don’t want users to enable those individually as they are internal details to
our crate.</p>
<blockquote>
<p><strong>Note</strong>: Another way to optionally include a dependency is to use
<a href="reference/specifying-dependencies.html#platform-specific-dependencies">platform-specific dependencies</a>. Instead of using features, these are
conditional based on the target platform.</p>
</blockquote>
<h2 id="dependency-features"><a class="header" href="#dependency-features">Dependency features</a></h2>
<p>Features of dependencies can be enabled within the dependency declaration. The
<code>features</code> key indicates which features to enable:</p>
<pre><code class="language-toml">[dependencies]
# Enables the `derive` feature of serde.
serde = { version = "1.0.118", features = ["derive"] }
</code></pre>
<p>The <a href="reference/features.html#the-default-feature"><code>default</code> features</a> can be disabled using
<code>default-features = false</code>:</p>
<pre><code class="language-toml">[dependencies]
flate2 = { version = "1.0.3", default-features = false, features = ["zlib-rs"] }
</code></pre>
<blockquote>
<p><strong>Note</strong>: This may not ensure the default features are disabled. If another
dependency includes <code>flate2</code> without specifying <code>default-features = false</code>,
then the default features will be enabled. See <a href="reference/features.html#feature-unification">feature
unification</a> below for more details.</p>
</blockquote>
<p>Features of dependencies can also be enabled in the <code>[features]</code> table. The
syntax is <code>"package-name/feature-name"</code>. For example:</p>
<pre><code class="language-toml">[dependencies]
jpeg-decoder = { version = "0.1.20", default-features = false }

[features]
# Enables parallel processing support by enabling the "rayon" feature of jpeg-decoder.
parallel = ["jpeg-decoder/rayon"]
</code></pre>
<p>The <code>"package-name/feature-name"</code> syntax will also enable <code>package-name</code>
if it is an optional dependency. Often this is not what you want.
You can add a <code>?</code> as in <code>"package-name?/feature-name"</code> which will only enable
the given feature if something else enables the optional dependency.</p>
<blockquote>
<p><strong>Note</strong>: The <code>?</code> syntax is only available starting with Rust 1.60.</p>
</blockquote>
<p>For example, let’s say we have added some serialization support to our
library, and it requires enabling a corresponding feature in some optional
dependencies.
That can be done like this:</p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1.0.133", optional = true }
rgb = { version = "0.8.25", optional = true }

[features]
serde = ["dep:serde", "rgb?/serde"]
</code></pre>
<p>In this example, enabling the <code>serde</code> feature will enable the serde
dependency.
It will also enable the <code>serde</code> feature for the <code>rgb</code> dependency, but only if
something else has enabled the <code>rgb</code> dependency.</p>
<h2 id="command-line-feature-options"><a class="header" href="#command-line-feature-options">Command-line feature options</a></h2>
<p>The following command-line flags can be used to control which features are
enabled:</p>
<ul>
<li><code>--features</code> <em>FEATURES</em>: Enables the listed features. Multiple features may
be separated with commas or spaces. If using spaces, be sure to use quotes
around all the features if running Cargo from a shell (such as <code>--features "foo bar"</code>). If building multiple packages in a <a href="reference/workspaces.html">workspace</a>, the
<code>package-name/feature-name</code> syntax can be used to specify features for
specific workspace members.</li>
<li><code>--all-features</code>: Activates all features of all packages selected on the command line.</li>
<li><code>--no-default-features</code>: Does not activate the <a href="reference/features.html#the-default-feature"><code>default</code>
feature</a> of the selected packages.</li>
</ul>
<p><strong>NOTE</strong>: check the individual subcommand documentation for details. Not all flags are available for all subcommands.</p>
<h2 id="feature-unification"><a class="header" href="#feature-unification">Feature unification</a></h2>
<p>Features are unique to the package that defines them. Enabling a feature on a
package does not enable a feature of the same name on other packages.</p>
<p>When a dependency is used by multiple packages, Cargo will use the union of
all features enabled on that dependency when building it. This helps ensure
that only a single copy of the dependency is used. See the <a href="reference/resolver.html#features">features section</a>
of the resolver documentation for more details.</p>
<p>For example, let’s look at the <a href="https://crates.io/crates/winapi"><code>winapi</code></a> package which uses a <a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">large
number</a> of features. If your package depends on a package
<code>foo</code> which enables the “fileapi” and “handleapi” features of <code>winapi</code>, and
another dependency <code>bar</code> which enables the “std” and “winnt” features of
<code>winapi</code>, then <code>winapi</code> will be built with all four of those features enabled.</p>
<p><img src="reference/../images/winapi-features.svg" alt="winapi features example" /></p>
<p>A consequence of this is that features should be <em>additive</em>. That is, enabling
a feature should not disable functionality, and it should usually be safe to
enable any combination of features. A feature should not introduce a
<a href="reference/features.html#semver-compatibility">SemVer-incompatible change</a>.</p>
<p>For example, if you want to optionally support <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> environments, <strong>do
not</strong> use a <code>no_std</code> feature. Instead, use a <code>std</code> feature that <em>enables</em>
<code>std</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>#[cfg(feature = "std")]
extern crate std;

#[cfg(feature = "std")]
pub fn function_that_requires_std() {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mutually-exclusive-features"><a class="header" href="#mutually-exclusive-features">Mutually exclusive features</a></h3>
<p>There are rare cases where features may be mutually incompatible with one
another. This should be avoided if at all possible, because it requires
coordinating all uses of the package in the dependency graph to cooperate to
avoid enabling them together. If it is not possible, consider adding a compile
error to detect this scenario. For example:</p>
<pre><code class="language-rust ignore">#[cfg(all(feature = "foo", feature = "bar"))]
compile_error!("feature \"foo\" and feature \"bar\" cannot be enabled at the same time");</code></pre>
<p>Instead of using mutually exclusive features, consider some other options:</p>
<ul>
<li>Split the functionality into separate packages.</li>
<li>When there is a conflict, <a href="reference/features-examples.html#feature-precedence">choose one feature over
another</a>. The <a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a> package can help with writing
more complex <code>cfg</code> expressions.</li>
<li>Architect the code to allow the features to be enabled concurrently, and use
runtime options to control which is used. For example, use a config file,
command-line argument, or environment variable to choose which behavior to
enable.</li>
</ul>
<h3 id="inspecting-resolved-features"><a class="header" href="#inspecting-resolved-features">Inspecting resolved features</a></h3>
<p>In complex dependency graphs, it can sometimes be difficult to understand how
different features get enabled on various packages. The <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> command
offers several options to help inspect and visualize which features are
enabled. Some options to try:</p>
<ul>
<li><code>cargo tree -e features</code>: This will show features in the dependency graph.
Each feature will appear showing which package enabled it.</li>
<li><code>cargo tree -f "{p} {f}"</code>: This is a more compact view that shows a
comma-separated list of features enabled on each package.</li>
<li><code>cargo tree -e features -i foo</code>: This will invert the tree, showing how
features flow into the given package “foo”. This can be useful because
viewing the entire graph can be quite large and overwhelming. Use this when
you are trying to figure out which features are enabled on a specific
package and why. See the example at the bottom of the <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> page on
how to read this.</li>
</ul>
<h2 id="feature-resolver-version-2-1"><a class="header" href="#feature-resolver-version-2-1">Feature resolver version 2</a></h2>
<p>A different feature resolver can be specified with the <code>resolver</code> field in
<code>Cargo.toml</code>, like this:</p>
<pre><code class="language-toml">[package]
name = "my-package"
version = "1.0.0"
resolver = "2"
</code></pre>
<p>See the <a href="reference/resolver.html#resolver-versions">resolver versions</a> section for more detail on specifying resolver
versions.</p>
<p>The version <code>"2"</code> resolver avoids unifying features in a few situations where
that unification can be unwanted. The exact situations are described in the
<a href="reference/resolver.html#feature-resolver-version-2">resolver chapter</a>, but in short, it avoids unifying in these
situations:</p>
<ul>
<li>Features enabled on <a href="reference/specifying-dependencies.html#platform-specific-dependencies">platform-specific dependencies</a> for <a href="reference/../appendix/glossary.html#target">target architectures</a> not
currently being built are ignored.</li>
<li><a href="reference/specifying-dependencies.html#build-dependencies">Build-dependencies</a> and proc-macros do not share features with normal
dependencies.</li>
<li><a href="reference/specifying-dependencies.html#development-dependencies">Dev-dependencies</a> do not activate features unless building a <a href="reference/../appendix/glossary.html#target">Cargo target</a> that
needs them (like tests or examples).</li>
</ul>
<p>Avoiding the unification is necessary for some situations. For example, if a
build-dependency enables a <code>std</code> feature, and the same dependency is used as a
normal dependency for a <code>no_std</code> environment, enabling <code>std</code> would break the
build.</p>
<p>However, one drawback is that this can increase build times because the
dependency is built multiple times (each with different features). When using
the version <code>"2"</code> resolver, it is recommended to check for dependencies that
are built multiple times to reduce overall build time. If it is not <em>required</em>
to build those duplicated packages with separate features, consider adding
features to the <code>features</code> list in the <a href="reference/features.html#dependency-features">dependency
declaration</a> so that the duplicates end up with the same
features (and thus Cargo will build it only once). You can detect these
duplicate dependencies with the <a href="reference/../commands/cargo-tree.html"><code>cargo tree --duplicates</code></a>
command. It will show which packages are built multiple times; look for any
entries listed with the same version. See <a href="reference/features.html#inspecting-resolved-features">Inspecting resolved
features</a> for more on fetching information on
the resolved features. For build dependencies, this is not necessary if you
are cross-compiling with the <code>--target</code> flag because build dependencies are
always built separately from normal dependencies in that scenario.</p>
<h3 id="resolver-version-2-command-line-flags"><a class="header" href="#resolver-version-2-command-line-flags">Resolver version 2 command-line flags</a></h3>
<p>The <code>resolver = "2"</code> setting also changes the behavior of the <code>--features</code> and
<code>--no-default-features</code> <a href="reference/features.html#command-line-feature-options">command-line options</a>.</p>
<p>With version <code>"1"</code>, you can only enable features for the package in the
current working directory. For example, in a workspace with packages <code>foo</code> and
<code>bar</code>, and you are in the directory for package <code>foo</code>, and ran the command
<code>cargo build -p bar --features bar-feat</code>, this would fail because the
<code>--features</code> flag only allowed enabling features on <code>foo</code>.</p>
<p>With <code>resolver = "2"</code>, the features flags allow enabling features for any of
the packages selected on the command-line with <code>-p</code> and <code>--workspace</code> flags.
For example:</p>
<pre><code class="language-sh"># This command is allowed with resolver = "2", regardless of which directory
# you are in.
cargo build -p foo -p bar --features foo-feat,bar-feat

# This explicit equivalent works with any resolver version:
cargo build -p foo -p bar --features foo/foo-feat,bar/bar-feat
</code></pre>
<p>Additionally, with <code>resolver = "1"</code>, the <code>--no-default-features</code> flag only
disables the default feature for the package in the current directory. With
version “2”, it will disable the default features for all workspace members.</p>
<h2 id="build-scripts"><a class="header" href="#build-scripts">Build scripts</a></h2>
<p><a href="reference/build-scripts.html">Build scripts</a> can detect which features are enabled on the package by
inspecting the <code>CARGO_FEATURE_&lt;name&gt;</code> environment variable, where <code>&lt;name&gt;</code> is
the feature name converted to uppercase and <code>-</code> converted to <code>_</code>.</p>
<h2 id="required-features"><a class="header" href="#required-features">Required features</a></h2>
<p>The <a href="reference/cargo-targets.html#the-required-features-field"><code>required-features</code> field</a> can be used to disable specific <a href="reference/cargo-targets.html">Cargo
targets</a> if a feature is not enabled. See the linked documentation for more
details.</p>
<h2 id="semver-compatibility-1"><a class="header" href="#semver-compatibility-1">SemVer compatibility</a></h2>
<p>Enabling a feature should not introduce a SemVer-incompatible change. For
example, the feature shouldn’t change an existing API in a way that could
break existing uses. More details about what changes are compatible can be
found in the <a href="reference/semver.html">SemVer Compatibility chapter</a>.</p>
<p>Care should be taken when adding and removing feature definitions and optional
dependencies, as these can sometimes be backwards-incompatible changes. More
details can be found in the <a href="reference/semver.html#cargo">Cargo section</a> of the SemVer
Compatibility chapter. In short, follow these rules:</p>
<ul>
<li>The following is usually safe to do in a minor release:
<ul>
<li>Add a <a href="reference/semver.html#cargo-feature-add">new feature</a> or <a href="reference/semver.html#cargo-dep-add">optional dependency</a>.</li>
<li><a href="reference/semver.html#cargo-change-dep-feature">Change the features used on a dependency</a>.</li>
</ul>
</li>
<li>The following should usually <strong>not</strong> be done in a minor release:
<ul>
<li><a href="reference/semver.html#cargo-feature-remove">Remove a feature</a> or <a href="reference/semver.html#cargo-remove-opt-dep">optional dependency</a>.</li>
<li><a href="reference/semver.html#item-remove">Moving existing public code behind a feature</a>.</li>
<li><a href="reference/semver.html#cargo-feature-remove-another">Remove a feature from a feature list</a>.</li>
</ul>
</li>
</ul>
<p>See the links for caveats and examples.</p>
<h2 id="feature-documentation-and-discovery"><a class="header" href="#feature-documentation-and-discovery">Feature documentation and discovery</a></h2>
<p>You are encouraged to document which features are available in your package.
This can be done by adding <a href="reference/../../rustdoc/how-to-write-documentation.html">doc comments</a> at the top of <code>lib.rs</code>. As an
example, see the <a href="https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583">regex crate source</a>, which when rendered can be viewed on
<a href="https://docs.rs/regex/1.4.2/regex/#crate-features">docs.rs</a>. If you have other documentation, such as a user
guide, consider adding the documentation there (for example, see <a href="https://serde.rs/feature-flags.html">serde.rs</a>).
If you have a binary project, consider documenting the features in the README
or other documentation for the project (for example, see <a href="https://github.com/mozilla/sccache/blob/0.2.13/README.md#build-requirements">sccache</a>).</p>
<p>Clearly documenting the features can set expectations about features that are
considered “unstable” or otherwise shouldn’t be used. For example, if there is
an optional dependency, but you don’t want users to explicitly list that
optional dependency as a feature, exclude it from the documented list.</p>
<p>Documentation published on <a href="https://docs.rs/">docs.rs</a> can use metadata in <code>Cargo.toml</code> to
control which features are enabled when the documentation is built. See
<a href="https://docs.rs/about/metadata">docs.rs metadata documentation</a> for more details.</p>
<blockquote>
<p><strong>Note</strong>: Rustdoc has experimental support for annotating the documentation
to indicate which features are required to use certain APIs. See the
<a href="reference/../../unstable-book/language-features/doc-cfg.html"><code>doc_cfg</code></a> documentation for more details. An example is the <a href="https://docs.rs/syn/1.0.54/syn/#modules"><code>syn</code>
documentation</a>, where you can see colored boxes which note which features
are required to use it.</p>
</blockquote>
<h3 id="discovering-features"><a class="header" href="#discovering-features">Discovering features</a></h3>
<p>When features are documented in the library API, this can make it easier for
your users to discover which features are available and what they do. If the
feature documentation for a package isn’t readily available, you can look at
the <code>Cargo.toml</code> file, but sometimes it can be hard to track it down. The
crate page on <a href="https://crates.io/">crates.io</a> has a link to the source repository if available.
Tools like <a href="reference/../commands/cargo-vendor.html"><code>cargo vendor</code></a> or <a href="https://crates.io/crates/cargo-clone-crate">cargo-clone-crate</a> can be used to download the
source and inspect it.</p>
<h2 id="feature-combinations"><a class="header" href="#feature-combinations">Feature combinations</a></h2>
<p>Because features are a form of conditional compilation, they require an exponential number of configurations and test cases to be 100% covered. By default, tests, docs, and other tooling such as <a href="https://github.com/rust-lang/rust-clippy">Clippy</a> will only run with the default set of features.</p>
<p>We encourage you to consider your strategy and tooling in regards to different feature combinations — Every project will have different requirements in conjunction with time, resources, and the cost-benefit of covering specific scenarios. Common configurations may be with / without default features, specific combinations of features, or all combinations of features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-examples"><a class="header" href="#features-examples">Features Examples</a></h1>
<p>The following illustrates some real-world examples of features in action.</p>
<h2 id="minimizing-build-times-and-file-sizes"><a class="header" href="#minimizing-build-times-and-file-sizes">Minimizing build times and file sizes</a></h2>
<p>Some packages use features so that if the features are not enabled, it reduces
the size of the crate and reduces compile time. Some examples are:</p>
<ul>
<li><a href="https://crates.io/crates/syn"><code>syn</code></a> is a popular crate for parsing Rust code. Since it is so popular, it
is helpful to reduce compile times since it affects so many projects. It has
a <a href="https://docs.rs/syn/1.0.54/syn/#optional-features">clearly documented list</a> of features which can be used to
minimize the amount of code it contains.</li>
<li><a href="https://crates.io/crates/regex"><code>regex</code></a> has a <a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L33-L101">several features</a> that are <a href="https://docs.rs/regex/1.4.2/regex/#crate-features">well
documented</a>. Cutting out Unicode support can reduce the
resulting file size as it can remove some large tables.</li>
<li><a href="https://crates.io/crates/winapi"><code>winapi</code></a> has <a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">a large number</a> of features that
limit which Windows API bindings it supports.</li>
<li><a href="https://crates.io/crates/web-sys"><code>web-sys</code></a> is another example similar to <code>winapi</code> that provides a <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/crates/web-sys/Cargo.toml#L32-L1395">huge
surface area</a> of API bindings that are limited by using
features.</li>
</ul>
<h2 id="extending-behavior"><a class="header" href="#extending-behavior">Extending behavior</a></h2>
<p>The <a href="https://crates.io/crates/serde_json"><code>serde_json</code></a> package has a <a href="https://github.com/serde-rs/json/blob/v1.0.60/Cargo.toml#L53-L56"><code>preserve_order</code> feature</a>
which <a href="https://github.com/serde-rs/json/blob/v1.0.60/src/map.rs#L23-L26">changes the behavior</a> of JSON maps to preserve the
order that keys are inserted. Notice that it enables an optional dependency
<a href="https://crates.io/crates/indexmap"><code>indexmap</code></a> to implement the new behavior.</p>
<p>When changing behavior like this, be careful to make sure the changes are
<a href="reference/features.html#semver-compatibility">SemVer compatible</a>. That is, enabling the feature should not break code that
usually builds with the feature off.</p>
<h2 id="no_std-support"><a class="header" href="#no_std-support"><code>no_std</code> support</a></h2>
<p>Some packages want to support both <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> and <code>std</code> environments. This is
useful for supporting embedded and resource-constrained platforms, but still
allowing extended capabilities for platforms that support the full standard
library.</p>
<p>The <a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a> package defines a <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25"><code>std</code> feature</a> that
is <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L23">enabled by default</a>. At the top of the library, it
<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L8">unconditionally enables the <code>no_std</code> attribute</a>. This
ensures that <code>std</code> and the <a href="reference/../../std/prelude/index.html"><code>std</code> prelude</a> are not automatically in scope.
Then, in various places in the code (<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L270-L273">example1</a>,
<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L67-L75">example2</a>), it uses <code>#[cfg(feature = "std")]</code> attributes
to conditionally enable extra functionality that requires <code>std</code>.</p>
<h2 id="re-exporting-dependency-features"><a class="header" href="#re-exporting-dependency-features">Re-exporting dependency features</a></h2>
<p>It can be convenient to re-export the features from a dependency. This allows
the user depending on the crate to control those features without needing to
specify those dependencies directly. For example, <a href="https://crates.io/crates/regex"><code>regex</code></a> <a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L65-L89">re-exports the
features</a> from the <a href="https://github.com/rust-lang/regex/blob/1.4.2/regex-syntax/Cargo.toml#L17-L32"><code>regex_syntax</code></a>
package. Users of <code>regex</code> don’t need to know about the <code>regex_syntax</code> package,
but they can still access the features it contains.</p>
<h2 id="vendoring-of-c-libraries"><a class="header" href="#vendoring-of-c-libraries">Vendoring of C libraries</a></h2>
<p>Some packages provide bindings to common C libraries (sometimes referred to as
<a href="reference/build-scripts.html#-sys-packages">“sys” crates</a>). Sometimes these packages give you the choice to use the
C library installed on the system, or to build it from source. For example,
the <a href="https://crates.io/crates/openssl"><code>openssl</code></a> package has a <a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl/Cargo.toml#L19"><code>vendored</code> feature</a> which
enables the corresponding <code>vendored</code> feature of <a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code></a>. The
<code>openssl-sys</code> build script has some <a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl-sys/build/main.rs#L47-L54">conditional logic</a> which
causes it to build from a local copy of the OpenSSL source code instead of
using the version from the system.</p>
<p>The <a href="https://crates.io/crates/curl-sys"><code>curl-sys</code></a> package is another example where the <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L49"><code>static-curl</code>
feature</a> causes it to build libcurl from source. Notice that
it also has a <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L52"><code>force-system-lib-on-osx</code></a> feature which forces
it <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/build.rs#L15-L20">to use the system libcurl</a>, overriding the
static-curl setting.</p>
<h2 id="feature-precedence"><a class="header" href="#feature-precedence">Feature precedence</a></h2>
<p>Some packages may have mutually-exclusive features. One option to handle this
is to prefer one feature over another. The <a href="https://crates.io/crates/log"><code>log</code></a> package is an example. It
has <a href="https://github.com/rust-lang/log/blob/0.4.11/Cargo.toml#L29-L42">several features</a> for choosing the maximum logging level at
compile-time described <a href="https://docs.rs/log/0.4.11/log/#compile-time-filters">here</a>. It uses <a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a> to <a href="https://github.com/rust-lang/log/blob/0.4.11/src/lib.rs#L1422-L1448">choose a
precedence</a>. If multiple features are enabled, the higher “max”
levels will be preferred over the lower levels.</p>
<h2 id="proc-macro-companion-package"><a class="header" href="#proc-macro-companion-package">Proc-macro companion package</a></h2>
<p>Some packages have a proc-macro that is intimately tied with it. However, not
all users will need to use the proc-macro. By making the proc-macro an
optional-dependency, this allows you to conveniently choose whether or not it
is included. This is helpful, because sometimes the proc-macro version must
stay in sync with the parent package, and you don’t want to force the users to
have to specify both dependencies and keep them in sync.</p>
<p>An example is <a href="https://crates.io/crates/serde"><code>serde</code></a> which has a <a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L34-L35"><code>derive</code></a> feature which
enables the <a href="https://crates.io/crates/serde_derive"><code>serde_derive</code></a> proc-macro. The <code>serde_derive</code> crate is very
tightly tied to <code>serde</code>, so it uses an <a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L17">equals version
requirement</a> to ensure they stay in sync.</p>
<h2 id="nightly-only-features"><a class="header" href="#nightly-only-features">Nightly-only features</a></h2>
<p>Some packages want to experiment with APIs or language features that are only
available on the Rust <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>. However, they may not want to require
their users to also use the nightly channel. An example is <a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a>
which has a <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L27"><code>nightly</code> feature</a> which enables an
<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/closure.rs#L257-L269">extended API</a> that uses the <a href="reference/../../std/marker/trait.Unsize.html"><code>Unsize</code></a> marker trait that
is only available on the nightly channel at the time of this writing.</p>
<p>Note that at the root of the crate it uses <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L11"><code>cfg_attr</code> to enable the nightly
feature</a>. Keep in mind that the <a href="reference/../../unstable-book/index.html"><code>feature</code> attribute</a>
is unrelated to Cargo features, and is used to opt-in to experimental language
features.</p>
<p>The <a href="https://github.com/rust-random/rand/blob/0.7.3/Cargo.toml#L40"><code>simd_support</code> feature</a> of the <a href="https://crates.io/crates/rand"><code>rand</code></a> package is another example,
which relies on a dependency that only builds on the nightly channel.</p>
<h2 id="experimental-features"><a class="header" href="#experimental-features">Experimental features</a></h2>
<p>Some packages have new functionality that they may want to experiment with,
without having to commit to the stability of those APIs. The features are
usually documented that they are experimental, and thus may change or break in
the future, even during a minor release. An example is the <a href="https://crates.io/crates/async-std"><code>async-std</code></a>
package, which has an <a href="https://github.com/async-rs/async-std/blob/v1.8.0/Cargo.toml#L38-L42"><code>unstable</code> feature</a>, which <a href="https://github.com/async-rs/async-std/blob/v1.8.0/src/macros.rs#L46">gates
new APIs</a> that people can opt-in to using, but may not be
completely ready to be relied upon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiles"><a class="header" href="#profiles">Profiles</a></h1>
<p>Profiles provide a way to alter the compiler settings, influencing things like
optimizations and debugging symbols.</p>
<p>Cargo has 4 built-in profiles: <code>dev</code>, <code>release</code>, <code>test</code>, and <code>bench</code>. The
profile is automatically chosen based on which command is being run if a
profile is not specified on the command-line. In addition to the built-in
profiles, custom user-defined profiles can also be specified.</p>
<p>Profile settings can be changed in <a href="reference/manifest.html"><code>Cargo.toml</code></a> with the
<code>[profile]</code> table. Within each named profile, individual settings can be changed
with key/value pairs like this:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1               # Use slightly better optimizations.
overflow-checks = false     # Disable integer overflow checks.
</code></pre>
<p>Cargo only looks at the profile settings in the <code>Cargo.toml</code> manifest at the
root of the workspace. Profile settings defined in dependencies will be
ignored.</p>
<p>Additionally, profiles can be overridden from a <a href="reference/config.html">config</a> definition.
Specifying a profile in a config file or environment variable will override
the settings from <code>Cargo.toml</code>.</p>
<h2 id="profile-settings"><a class="header" href="#profile-settings">Profile settings</a></h2>
<p>The following is a list of settings that can be controlled in a profile.</p>
<h3 id="opt-level"><a class="header" href="#opt-level">opt-level</a></h3>
<p>The <code>opt-level</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#opt-level"><code>-C opt-level</code> flag</a> which controls the level
of optimization. Higher optimization levels may produce faster runtime code at
the expense of longer compiler times. Higher levels may also change and
rearrange the compiled code which may make it harder to use with a debugger.</p>
<p>The valid options are:</p>
<ul>
<li><code>0</code>: no optimizations</li>
<li><code>1</code>: basic optimizations</li>
<li><code>2</code>: some optimizations</li>
<li><code>3</code>: all optimizations</li>
<li><code>"s"</code>: optimize for binary size</li>
<li><code>"z"</code>: optimize for binary size, but also turn off loop vectorization.</li>
</ul>
<p>It is recommended to experiment with different levels to find the right
balance for your project. There may be surprising results, such as level <code>3</code>
being slower than <code>2</code>, or the <code>"s"</code> and <code>"z"</code> levels not being necessarily
smaller. You may also want to reevaluate your settings over time as newer
versions of <code>rustc</code> change optimization behavior.</p>
<p>See also <a href="reference/../../rustc/profile-guided-optimization.html">Profile Guided Optimization</a> for more advanced optimization
techniques.</p>
<h3 id="debug"><a class="header" href="#debug">debug</a></h3>
<p>The <code>debug</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#debuginfo"><code>-C debuginfo</code> flag</a> which controls the
amount of debug information included in the compiled binary.</p>
<p>The valid options are:</p>
<ul>
<li><code>0</code>, <code>false</code>, or <code>"none"</code>: no debug info at all, default for <a href="reference/profiles.html#release"><code>release</code></a></li>
<li><code>"line-directives-only"</code>: line info directives only. For the nvptx* targets this enables <a href="https://reviews.llvm.org/D46061">profiling</a>. For other use cases, <code>line-tables-only</code> is the better, more compatible choice.</li>
<li><code>"line-tables-only"</code>: line tables only. Generates the minimal amount of debug info for backtraces with filename/line number info, but not anything else, i.e. no variable or function parameter info.</li>
<li><code>1</code> or <code>"limited"</code>: debug info without type or variable-level information. Generates more detailed module-level info than <code>line-tables-only</code>.</li>
<li><code>2</code>, <code>true</code>, or <code>"full"</code>: full debug info, default for <a href="reference/profiles.html#dev"><code>dev</code></a></li>
</ul>
<p>For more information on what each option does see <code>rustc</code>’s docs on <a href="reference/../../rustc/codegen-options/index.html#debuginfo">debuginfo</a>.</p>
<p>You may wish to also configure the <a href="reference/profiles.html#split-debuginfo"><code>split-debuginfo</code></a> option
depending on your needs as well.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.71 is required for <code>none</code>, <code>limited</code>, <code>full</code>, <code>line-directives-only</code>, and <code>line-tables-only</code></p>
</blockquote>
<h3 id="split-debuginfo"><a class="header" href="#split-debuginfo">split-debuginfo</a></h3>
<p>The <code>split-debuginfo</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo"><code>-C split-debuginfo</code> flag</a> which
controls whether debug information, if generated, is either placed in the
executable itself or adjacent to it.</p>
<p>This option is a string and acceptable values are the same as those the
<a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">compiler accepts</a>. The default value for this option
is <code>unpacked</code> on macOS for profiles that have debug information otherwise
enabled. Otherwise the default for this option is <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">documented with rustc</a> and is platform-specific. Some options are only
available on the <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>. The Cargo default may change in the future
once more testing has been performed, and support for DWARF is stabilized.</p>
<p>Be aware that Cargo and rustc have different defaults for this option. This
option exists to allow Cargo to experiment on different combinations of flags
thus providing better debugging and developer experience.</p>
<h3 id="strip"><a class="header" href="#strip">strip</a></h3>
<p>The <code>strip</code> option controls the <a href="reference/../../rustc/codegen-options/index.html#strip"><code>-C strip</code> flag</a>, which directs rustc to
strip either symbols or debuginfo from a binary. This can be enabled like so:</p>
<pre><code class="language-toml">[package]
# ...

[profile.release]
strip = "debuginfo"
</code></pre>
<p>Possible string values of <code>strip</code> are <code>"none"</code>, <code>"debuginfo"</code>, and <code>"symbols"</code>.
The default is <code>"none"</code>.</p>
<p>You can also configure this option with the boolean values <code>true</code> or <code>false</code>.
<code>strip = true</code> is equivalent to <code>strip = "symbols"</code>. <code>strip = false</code> is
equivalent to <code>strip = "none"</code> and disables <code>strip</code> completely.</p>
<h3 id="debug-assertions"><a class="header" href="#debug-assertions">debug-assertions</a></h3>
<p>The <code>debug-assertions</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#debug-assertions"><code>-C debug-assertions</code> flag</a> which
turns <code>cfg(debug_assertions)</code> <a href="reference/../../reference/conditional-compilation.html#debug_assertions">conditional compilation</a> on or off. Debug
assertions are intended to include runtime validation which is only available
in debug/development builds. These may be things that are too expensive or
otherwise undesirable in a release build. Debug assertions enables the
<a href="reference/../../std/macro.debug_assert.html"><code>debug_assert!</code> macro</a> in the standard library.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<h3 id="overflow-checks"><a class="header" href="#overflow-checks">overflow-checks</a></h3>
<p>The <code>overflow-checks</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#overflow-checks"><code>-C overflow-checks</code> flag</a> which
controls the behavior of <a href="reference/../../reference/expressions/operator-expr.html#overflow">runtime integer overflow</a>. When overflow-checks are
enabled, a panic will occur on overflow.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<h3 id="lto"><a class="header" href="#lto">lto</a></h3>
<p>The <code>lto</code> setting controls <code>rustc</code>’s <a href="reference/../../rustc/codegen-options/index.html#lto"><code>-C lto</code></a>, <a href="reference/../../rustc/codegen-options/index.html#linker-plugin-lto"><code>-C linker-plugin-lto</code></a>, and
<a href="reference/../../rustc/codegen-options/index.html#embed-bitcode"><code>-C embed-bitcode</code></a> options, which control LLVM’s <a href="https://llvm.org/docs/LinkTimeOptimization.html">link time optimizations</a>.
LTO can produce better optimized code, using whole-program analysis, at the cost
of longer linking time.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code> or <code>"fat"</code>: Performs “fat” LTO which attempts to perform
optimizations across all crates within the dependency graph.</li>
<li><code>"thin"</code>: Performs <a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">“thin” LTO</a>. This is similar to “fat”, but takes
substantially less time to run while still achieving performance gains
similar to “fat”.</li>
<li><code>false</code>: Performs “thin local LTO” which performs “thin” LTO on the local
crate only across its <a href="reference/profiles.html#codegen-units">codegen units</a>. No LTO is performed
if codegen units is 1 or <a href="reference/profiles.html#opt-level">opt-level</a> is 0.</li>
<li><code>"off"</code>: Disables LTO.</li>
</ul>
<p>See the <a href="reference/../../rustc/linker-plugin-lto.html">linker-plugin-lto chapter</a> if you are interested in cross-language LTO.
This is not yet supported natively in Cargo, but can be performed via
<code>RUSTFLAGS</code>.</p>
<h3 id="panic"><a class="header" href="#panic">panic</a></h3>
<p>The <code>panic</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#panic"><code>-C panic</code> flag</a> which controls which panic
strategy to use.</p>
<p>The valid options are:</p>
<ul>
<li><code>"unwind"</code>: Unwind the stack upon panic.</li>
<li><code>"abort"</code>: Terminate the process upon panic.</li>
</ul>
<p>When set to <code>"unwind"</code>, the actual value depends on the default of the target
platform. For example, the NVPTX platform does not support unwinding, so it
always uses <code>"abort"</code>.</p>
<p>Tests, benchmarks, build scripts, and proc macros ignore the <code>panic</code> setting.
The <code>rustc</code> test harness currently requires <code>unwind</code> behavior. See the
<a href="reference/unstable.html#panic-abort-tests"><code>panic-abort-tests</code></a> unstable flag which enables <code>abort</code> behavior.</p>
<p>Additionally, when using the <code>abort</code> strategy and building a test, all of the
dependencies will also be forced to build with the <code>unwind</code> strategy.</p>
<h3 id="incremental"><a class="header" href="#incremental">incremental</a></h3>
<p>The <code>incremental</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#incremental"><code>-C incremental</code> flag</a> which controls
whether or not incremental compilation is enabled. Incremental compilation
causes <code>rustc</code> to save additional information to disk which will be reused
when recompiling the crate, improving re-compile times. The additional
information is stored in the <code>target</code> directory.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<p>Incremental compilation is only used for workspace members and “path”
dependencies.</p>
<p>The incremental value can be overridden globally with the <code>CARGO_INCREMENTAL</code>
<a href="reference/environment-variables.html">environment variable</a> or the <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> config variable.</p>
<h3 id="codegen-units"><a class="header" href="#codegen-units">codegen-units</a></h3>
<p>The <code>codegen-units</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#codegen-units"><code>-C codegen-units</code> flag</a> which
controls how many “code generation units” a crate will be split into. More
code generation units allows more of a crate to be processed in parallel
possibly reducing compile time, but may produce slower code.</p>
<p>This option takes an integer greater than 0.</p>
<p>The default is 256 for <a href="reference/profiles.html#incremental">incremental</a> builds, and 16 for
non-incremental builds.</p>
<h3 id="rpath"><a class="header" href="#rpath">rpath</a></h3>
<p>The <code>rpath</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#rpath"><code>-C rpath</code> flag</a> which controls
whether or not <a href="https://en.wikipedia.org/wiki/Rpath"><code>rpath</code></a> is enabled.</p>
<h2 id="default-profiles"><a class="header" href="#default-profiles">Default profiles</a></h2>
<h3 id="dev"><a class="header" href="#dev">dev</a></h3>
<p>The <code>dev</code> profile is used for normal development and debugging. It is the
default for build commands like <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>, and is used for <code>cargo install --debug</code>.</p>
<p>The default settings for the <code>dev</code> profile are:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0
debug = true
split-debuginfo = '...'  # Platform-specific.
strip = "none"
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'
incremental = true
codegen-units = 256
rpath = false
</code></pre>
<h3 id="release"><a class="header" href="#release">release</a></h3>
<p>The <code>release</code> profile is intended for optimized artifacts used for releases
and in production. This profile is used when the <code>--release</code> flag is used, and
is the default for <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>.</p>
<p>The default settings for the <code>release</code> profile are:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 3
debug = false
split-debuginfo = '...'  # Platform-specific.
strip = "none"
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'
incremental = false
codegen-units = 16
rpath = false
</code></pre>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<p>The <code>test</code> profile is the default profile used by <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>.
The <code>test</code> profile inherits the settings from the <a href="reference/profiles.html#dev"><code>dev</code></a> profile.</p>
<h3 id="bench"><a class="header" href="#bench">bench</a></h3>
<p>The <code>bench</code> profile is the default profile used by <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a>.
The <code>bench</code> profile inherits the settings from the <a href="reference/profiles.html#release"><code>release</code></a> profile.</p>
<h3 id="build-dependencies-1"><a class="header" href="#build-dependencies-1">Build Dependencies</a></h3>
<p>To compile quickly, all profiles, by default, do not optimize build
dependencies (build scripts, proc macros, and their dependencies), and avoid
computing debug info when a build dependency is not used as a runtime
dependency. The default settings for build overrides are:</p>
<pre><code class="language-toml">[profile.dev.build-override]
opt-level = 0
codegen-units = 256
debug = false # when possible

[profile.release.build-override]
opt-level = 0
codegen-units = 256
</code></pre>
<p>However, if errors occur while running build dependencies, turning full debug
info on will improve backtraces and debuggability when needed:</p>
<pre><code class="language-toml">debug = true
</code></pre>
<p>Build dependencies otherwise inherit settings from the active profile in use, as
described in <a href="reference/profiles.html#profile-selection">Profile selection</a>.</p>
<h2 id="custom-profiles"><a class="header" href="#custom-profiles">Custom profiles</a></h2>
<p>In addition to the built-in profiles, additional custom profiles can be
defined. These may be useful for setting up multiple workflows and build
modes. When defining a custom profile, you must specify the <code>inherits</code> key to
specify which profile the custom profile inherits settings from when the
setting is not specified.</p>
<p>For example, let’s say you want to compare a normal release build with a
release build with <a href="reference/profiles.html#lto">LTO</a> optimizations, you can specify something like
the following in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release-lto]
inherits = "release"
lto = true
</code></pre>
<p>The <code>--profile</code> flag can then be used to choose this custom profile:</p>
<pre><code class="language-console">cargo build --profile release-lto
</code></pre>
<p>The output for each profile will be placed in a directory of the same name
as the profile in the <a href="reference/build-cache.html"><code>target</code> directory</a>. As in the example above, the
output would go into the <code>target/release-lto</code> directory.</p>
<h2 id="profile-selection"><a class="header" href="#profile-selection">Profile selection</a></h2>
<p>The profile used depends on the command, the command-line flags like
<code>--release</code> or <code>--profile</code>, and the package (in the case of
<a href="reference/profiles.html#overrides">overrides</a>). The default profile if none is specified is:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Default Profile</th></tr></thead><tbody>
<tr><td><a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>, <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>,<br><a href="reference/../commands/cargo-check.html"><code>cargo check</code></a>, <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a></td><td><a href="reference/profiles.html#dev"><code>dev</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-test.html"><code>cargo test</code></a></td><td><a href="reference/profiles.html#test"><code>test</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a></td><td><a href="reference/profiles.html#bench"><code>bench</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-install.html"><code>cargo install</code></a></td><td><a href="reference/profiles.html#release"><code>release</code> profile</a></td></tr>
</tbody></table>
</div>
<p>You can switch to a different profile using the <code>--profile=NAME</code> option which will used the given profile.
The <code>--release</code> flag is equivalent to <code>--profile=release</code>.</p>
<p>The selected profile applies to all Cargo targets,
including <a href="reference/./cargo-targets.html#library">library</a>,
<a href="reference/./cargo-targets.html#binaries">binary</a>,
<a href="reference/./cargo-targets.html#examples">example</a>,
<a href="reference/./cargo-targets.html#tests">test</a>,
and <a href="reference/./cargo-targets.html#benchmarks">benchmark</a>.</p>
<p>The profile for specific packages can be specified with
<a href="reference/profiles.html#overrides">overrides</a>, described below.</p>
<h2 id="overrides-1"><a class="header" href="#overrides-1">Overrides</a></h2>
<p>Profile settings can be overridden for specific packages and build-time
crates. To override the settings for a specific package, use the <code>package</code>
table to change the settings for the named package:</p>
<pre><code class="language-toml"># The `foo` package will use the -Copt-level=3 flag.
[profile.dev.package.foo]
opt-level = 3
</code></pre>
<p>The package name is actually a <a href="reference/pkgid-spec.html">Package ID Spec</a>, so you can
target individual versions of a package with syntax such as
<code>[profile.dev.package."foo:2.1.0"]</code>.</p>
<p>To override the settings for all dependencies (but not any workspace member),
use the <code>"*"</code> package name:</p>
<pre><code class="language-toml"># Set the default for dependencies.
[profile.dev.package."*"]
opt-level = 2
</code></pre>
<p>To override the settings for build scripts, proc macros, and their
dependencies, use the <code>build-override</code> table:</p>
<pre><code class="language-toml"># Set the settings for build scripts and proc-macros.
[profile.dev.build-override]
opt-level = 3
</code></pre>
<blockquote>
<p>Note: When a dependency is both a normal dependency and a build dependency,
Cargo will try to only build it once when <code>--target</code> is not specified. When
using <code>build-override</code>, the dependency may need to be built twice, once as a
normal dependency and once with the overridden build settings. This may
increase initial build times.</p>
</blockquote>
<p>The precedence for which value is used is done in the following order (first
match wins):</p>
<ol>
<li><code>[profile.dev.package.name]</code> — A named package.</li>
<li><code>[profile.dev.package."*"]</code> — For any non-workspace member.</li>
<li><code>[profile.dev.build-override]</code> — Only for build scripts, proc macros, and
their dependencies.</li>
<li><code>[profile.dev]</code> — Settings in <code>Cargo.toml</code>.</li>
<li>Default values built-in to Cargo.</li>
</ol>
<p>Overrides cannot specify the <code>panic</code>, <code>lto</code>, or <code>rpath</code> settings.</p>
<h3 id="overrides-and-generics"><a class="header" href="#overrides-and-generics">Overrides and generics</a></h3>
<p>The location where generic code is instantiated will influence the
optimization settings used for that generic code. This can cause subtle
interactions when using profile overrides to change the optimization level of
a specific crate. If you attempt to raise the optimization level of a
dependency which defines generic functions, those generic functions may not be
optimized when used in your local crate. This is because the code may be
generated in the crate where it is instantiated, and thus may use the
optimization settings of that crate.</p>
<p>For example, <a href="https://crates.io/crates/nalgebra">nalgebra</a> is a library which defines vectors and matrices making
heavy use of generic parameters. If your local code defines concrete nalgebra
types like <code>Vector4&lt;f64&gt;</code> and uses their methods, the corresponding nalgebra
code will be instantiated and built within your crate. Thus, if you attempt to
increase the optimization level of <code>nalgebra</code> using a profile override, it may
not result in faster performance.</p>
<p>Further complicating the issue, <code>rustc</code> has some optimizations where it will
attempt to share monomorphized generics between crates. If the opt-level is 2
or 3, then a crate will not use monomorphized generics from other crates, nor
will it export locally defined monomorphized items to be shared with other
crates. When experimenting with optimizing dependencies for development,
consider trying opt-level 1, which will apply some optimizations while still
allowing monomorphized items to be shared.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h1>
<p>This document explains how Cargo’s configuration system works, as well as
available keys or configuration. For configuration of a package through its
manifest, see the <a href="reference/manifest.html">manifest format</a>.</p>
<h2 id="hierarchical-structure"><a class="header" href="#hierarchical-structure">Hierarchical structure</a></h2>
<p>Cargo allows local configuration for a particular package as well as global
configuration. It looks for configuration files in the current directory and
all parent directories. If, for example, Cargo were invoked in
<code>/projects/foo/bar/baz</code>, then the following configuration files would be
probed for and unified in this order:</p>
<ul>
<li><code>/projects/foo/bar/baz/.cargo/config.toml</code></li>
<li><code>/projects/foo/bar/.cargo/config.toml</code></li>
<li><code>/projects/foo/.cargo/config.toml</code></li>
<li><code>/projects/.cargo/config.toml</code></li>
<li><code>/.cargo/config.toml</code></li>
<li><code>$CARGO_HOME/config.toml</code> which defaults to:
<ul>
<li>Windows: <code>%USERPROFILE%\.cargo\config.toml</code></li>
<li>Unix: <code>$HOME/.cargo/config.toml</code></li>
</ul>
</li>
</ul>
<p>With this structure, you can specify configuration per-package, and even
possibly check it into version control. You can also specify personal defaults
with a configuration file in your home directory.</p>
<p>If a key is specified in multiple config files, the values will get merged
together. Numbers, strings, and booleans will use the value in the deeper
config directory taking precedence over ancestor directories, where the
home directory is the lowest priority. Arrays will be joined together
with higher precedence items being placed later in the merged array.</p>
<p>At present, when being invoked from a workspace, Cargo does not read config
files from crates within the workspace. i.e. if a workspace has two crates in
it, named <code>/projects/foo/bar/baz/mylib</code> and <code>/projects/foo/bar/baz/mybin</code>, and
there are Cargo configs at <code>/projects/foo/bar/baz/mylib/.cargo/config.toml</code>
and <code>/projects/foo/bar/baz/mybin/.cargo/config.toml</code>, Cargo does not read
those configuration files if it is invoked from the workspace root
(<code>/projects/foo/bar/baz/</code>).</p>
<blockquote>
<p><strong>Note:</strong> Cargo also reads config files without the <code>.toml</code> extension, such as
<code>.cargo/config</code>. Support for the <code>.toml</code> extension was added in version 1.39
and is the preferred form. If both files exist, Cargo will use the file
without the extension.</p>
</blockquote>
<h2 id="configuration-format"><a class="header" href="#configuration-format">Configuration format</a></h2>
<p>Configuration files are written in the <a href="https://toml.io/">TOML format</a> (like the
manifest), with simple key-value pairs inside of sections (tables). The
following is a quick overview of all settings, with detailed descriptions
found below.</p>
<pre><code class="language-toml">paths = ["/path/to/override"] # path dependency overrides

[alias]     # command aliases
b = "build"
c = "check"
t = "test"
r = "run"
rr = "run --release"
recursive_example = "rr --example recursions"
space_example = ["run", "--release", "--", "\"command list\""]

[build]
jobs = 1                      # number of parallel jobs, defaults to # of CPUs
rustc = "rustc"               # the rust compiler tool
rustc-wrapper = "…"           # run this wrapper instead of `rustc`
rustc-workspace-wrapper = "…" # run this wrapper instead of `rustc` for workspace members
rustdoc = "rustdoc"           # the doc generator tool
target = "triple"             # build for the target triple (ignored by `cargo install`)
target-dir = "target"         # path of where to place generated artifacts
build-dir = "target"          # path of where to place intermediate build artifacts
rustflags = ["…", "…"]        # custom flags to pass to all compiler invocations
rustdocflags = ["…", "…"]     # custom flags to pass to rustdoc
incremental = true            # whether or not to enable incremental compilation
dep-info-basedir = "…"        # path for the base directory for targets in depfiles

[credential-alias]
# Provides a way to define aliases for credential providers.
my-alias = ["/usr/bin/cargo-credential-example", "--argument", "value", "--flag"]

[doc]
browser = "chromium"          # browser to use with `cargo doc --open`,
                              # overrides the `BROWSER` environment variable

[env]
# Set ENV_VAR_NAME=value for any process run by Cargo
ENV_VAR_NAME = "value"
# Set even if already present in environment
ENV_VAR_NAME_2 = { value = "value", force = true }
# `value` is relative to the parent of `.cargo/config.toml`, env var will be the full absolute path
ENV_VAR_NAME_3 = { value = "relative/path", relative = true }

[future-incompat-report]
frequency = 'always' # when to display a notification about a future incompat report

[cache]
auto-clean-frequency = "1 day"   # How often to perform automatic cache cleaning

[cargo-new]
vcs = "none"              # VCS to use ('git', 'hg', 'pijul', 'fossil', 'none')

[http]
debug = false               # HTTP debugging
proxy = "host:port"         # HTTP proxy in libcurl format
ssl-version = "tlsv1.3"     # TLS version to use
ssl-version.max = "tlsv1.3" # maximum TLS version
ssl-version.min = "tlsv1.1" # minimum TLS version
timeout = 30                # timeout for each HTTP request, in seconds
low-speed-limit = 10        # network timeout threshold (bytes/sec)
cainfo = "cert.pem"         # path to Certificate Authority (CA) bundle
proxy-cainfo = "cert.pem"   # path to proxy Certificate Authority (CA) bundle
check-revoke = true         # check for SSL certificate revocation
multiplexing = true         # HTTP/2 multiplexing
user-agent = "…"            # the user-agent header

[install]
root = "/some/path"         # `cargo install` destination directory

[net]
retry = 3                   # network retries
git-fetch-with-cli = true   # use the `git` executable for git operations
offline = true              # do not access the network

[net.ssh]
known-hosts = ["..."]       # known SSH host keys

[patch.&lt;registry&gt;]
# Same keys as for [patch] in Cargo.toml

[profile.&lt;name&gt;]         # Modify profile settings via config.
inherits = "dev"         # Inherits settings from [profile.dev].
opt-level = 0            # Optimization level.
debug = true             # Include debug info.
split-debuginfo = '...'  # Debug info splitting behavior.
strip = "none"           # Removes symbols or debuginfo.
debug-assertions = true  # Enables debug assertions.
overflow-checks = true   # Enables runtime integer overflow checks.
lto = false              # Sets link-time optimization.
panic = 'unwind'         # The panic strategy.
incremental = true       # Incremental compilation.
codegen-units = 16       # Number of code generation units.
rpath = false            # Sets the rpath linking option.
[profile.&lt;name&gt;.build-override]  # Overrides build-script settings.
# Same keys for a normal profile.
[profile.&lt;name&gt;.package.&lt;name&gt;]  # Override profile for a package.
# Same keys for a normal profile (minus `panic`, `lto`, and `rpath`).

[resolver]
incompatible-rust-versions = "allow"  # Specifies how resolver reacts to these

[registries.&lt;name&gt;]  # registries other than crates.io
index = "…"          # URL of the registry index
token = "…"          # authentication token for the registry
credential-provider = "cargo:token" # The credential provider for this registry.

[registries.crates-io]
protocol = "sparse"  # The protocol to use to access crates.io.

[registry]
default = "…"        # name of the default registry
token = "…"          # authentication token for crates.io
credential-provider = "cargo:token"           # The credential provider for crates.io.
global-credential-providers = ["cargo:token"] # The credential providers to use by default.

[source.&lt;name&gt;]      # source definition and replacement
replace-with = "…"   # replace this source with the given named source
directory = "…"      # path to a directory source
registry = "…"       # URL to a registry source
local-registry = "…" # path to a local registry source
git = "…"            # URL of a git repository source
branch = "…"         # branch name for the git repository
tag = "…"            # tag name for the git repository
rev = "…"            # revision for the git repository

[target.&lt;triple&gt;]
linker = "…"              # linker to use
runner = "…"              # wrapper to run executables
rustflags = ["…", "…"]    # custom flags for `rustc`
rustdocflags = ["…", "…"] # custom flags for `rustdoc`

[target.&lt;cfg&gt;]
linker = "…"            # linker to use
runner = "…"            # wrapper to run executables
rustflags = ["…", "…"]  # custom flags for `rustc`

[target.&lt;triple&gt;.&lt;links&gt;] # `links` build script override
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = "-L /some/path"
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["…"]
metadata_key1 = "value"
metadata_key2 = "value"

[term]
quiet = false                    # whether cargo output is quiet
verbose = false                  # whether cargo provides verbose output
color = 'auto'                   # whether cargo colorizes output
hyperlinks = true                # whether cargo inserts links into output
unicode = true                   # whether cargo can render output using non-ASCII unicode characters
progress.when = 'auto'           # whether cargo shows progress bar
progress.width = 80              # width of progress bar
progress.term-integration = true # whether cargo reports progress to terminal emulator
</code></pre>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p>Cargo can also be configured through environment variables in addition to the
TOML configuration files. For each configuration key of the form <code>foo.bar</code> the
environment variable <code>CARGO_FOO_BAR</code> can also be used to define the value.
Keys are converted to uppercase, dots and dashes are converted to underscores.
For example the <code>target.x86_64-unknown-linux-gnu.runner</code> key can also be
defined by the <code>CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER</code> environment
variable.</p>
<p>Environment variables will take precedence over TOML configuration files.
Currently only integer, boolean, string and some array values are supported to
be defined by environment variables. <a href="reference/config.html#configuration-keys">Descriptions below</a>
indicate which keys support environment variables and otherwise they are not
supported due to <a href="https://github.com/rust-lang/cargo/issues/5416">technical issues</a>.</p>
<p>In addition to the system above, Cargo recognizes a few other specific
<a href="reference/environment-variables.html">environment variables</a>.</p>
<h2 id="command-line-overrides"><a class="header" href="#command-line-overrides">Command-line overrides</a></h2>
<p>Cargo also accepts arbitrary configuration overrides through the
<code>--config</code> command-line option. The argument should be in TOML syntax of
<code>KEY=VALUE</code> or provided as a path to an extra configuration file:</p>
<pre><code class="language-console"># With `KEY=VALUE` in TOML syntax
cargo --config net.git-fetch-with-cli=true fetch

# With a path to a configuration file
cargo --config ./path/to/my/extra-config.toml fetch
</code></pre>
<p>The <code>--config</code> option may be specified multiple times, in which case the
values are merged in left-to-right order, using the same merging logic
that is used when multiple configuration files apply. Configuration
values specified this way take precedence over environment variables,
which take precedence over configuration files.</p>
<p>When the <code>--config</code> option is provided as an extra configuration file,
The configuration file loaded this way follow the same precedence rules
as other options specified directly with <code>--config</code>.</p>
<p>Some examples of what it looks like using Bourne shell syntax:</p>
<pre><code class="language-console"># Most shells will require escaping.
cargo --config http.proxy=\"http://example.com\" …

# Spaces may be used.
cargo --config "net.git-fetch-with-cli = true" …

# TOML array example. Single quotes make it easier to read and write.
cargo --config 'build.rustdocflags = ["--html-in-header", "header.html"]' …

# Example of a complex TOML key.
cargo --config "target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))'.runner = 'my-runner'" …

# Example of overriding a profile setting.
cargo --config profile.dev.package.image.opt-level=3 …
</code></pre>
<h2 id="config-relative-paths"><a class="header" href="#config-relative-paths">Config-relative paths</a></h2>
<p>Paths in config files may be absolute, relative, or a bare name without any path separators.
Paths for executables without a path separator will use the <code>PATH</code> environment variable to search for the executable.
Paths for non-executables will be relative to where the config value is defined.</p>
<p>In particular, rules are:</p>
<ul>
<li>For environment variables, paths are relative to the current working directory.</li>
<li>For config values loaded directly from the <a href="reference/config.html#command-line-overrides"><code>--config KEY=VALUE</code></a> option,
paths are relative to the current working directory.</li>
<li>For config files, paths are relative to the parent directory of the directory where the config files were defined,
no matter those files are from either the <a href="reference/config.html#hierarchical-structure">hierarchical probing</a>
or the <a href="reference/config.html#command-line-overrides"><code>--config &lt;path&gt;</code></a> option.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> To maintain consistency with existing <code>.cargo/config.toml</code> probing behavior,
it is by design that a path in a config file passed via <code>--config &lt;path&gt;</code>
is also relative to two levels up from the config file itself.</p>
<p>To avoid unexpected results, the rule of thumb is putting your extra config files
at the same level of discovered <code>.cargo/config.toml</code> in your project.
For instance, given a project <code>/my/project</code>,
it is recommended to put config files under <code>/my/project/.cargo</code>
or a new directory at the same level, such as <code>/my/project/.config</code>.</p>
</blockquote>
<pre><code class="language-toml"># Relative path examples.

[target.x86_64-unknown-linux-gnu]
runner = "foo"  # Searches `PATH` for `foo`.

[source.vendored-sources]
# Directory is relative to the parent where `.cargo/config.toml` is located.
# For example, `/my/project/.cargo/config.toml` would result in `/my/project/vendor`.
directory = "vendor"
</code></pre>
<h2 id="executable-paths-with-arguments"><a class="header" href="#executable-paths-with-arguments">Executable paths with arguments</a></h2>
<p>Some Cargo commands invoke external programs, which can be configured as a path
and some number of arguments.</p>
<p>The value may be an array of strings like <code>['/path/to/program', 'somearg']</code> or
a space-separated string like <code>'/path/to/program somearg'</code>. If the path to the
executable contains a space, the list form must be used.</p>
<p>If Cargo is passing other arguments to the program such as a path to open or
run, they will be passed after the last specified argument in the value of an
option of this format. If the specified program does not have path separators,
Cargo will search <code>PATH</code> for its executable.</p>
<h2 id="credentials"><a class="header" href="#credentials">Credentials</a></h2>
<p>Configuration values with sensitive information are stored in the
<code>$CARGO_HOME/credentials.toml</code> file. This file is automatically created and updated
by <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> and <a href="reference/../commands/cargo-logout.html"><code>cargo logout</code></a> when using the <a href="reference/registry-authentication.html#cargotoken"><code>cargo:token</code></a> credential provider.</p>
<p>Tokens are used by some Cargo commands such as <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> for
authenticating with remote registries. Care should be taken to protect the
tokens and to keep them secret.</p>
<p>It follows the same format as Cargo config files.</p>
<pre><code class="language-toml">[registry]
token = "…"   # Access token for crates.io

[registries.&lt;name&gt;]
token = "…"   # Access token for the named registry
</code></pre>
<p>As with most other config values, tokens may be specified with environment
variables. The token for <a href="https://crates.io/">crates.io</a> may be specified with the
<code>CARGO_REGISTRY_TOKEN</code> environment variable. Tokens for other registries may
be specified with environment variables of the form
<code>CARGO_REGISTRIES_&lt;name&gt;_TOKEN</code> where <code>&lt;name&gt;</code> is the name of the registry in
all capital letters.</p>
<blockquote>
<p><strong>Note:</strong> Cargo also reads and writes credential files without the <code>.toml</code>
extension, such as <code>.cargo/credentials</code>. Support for the <code>.toml</code> extension
was added in version 1.39. In version 1.68, Cargo writes to the file with the
extension by default. However, for backward compatibility reason, when both
files exist, Cargo will read and write the file without the extension.</p>
</blockquote>
<h2 id="configuration-keys"><a class="header" href="#configuration-keys">Configuration keys</a></h2>
<p>This section documents all configuration keys. The description for keys with
variable parts are annotated with angled brackets like <code>target.&lt;triple&gt;</code> where
the <code>&lt;triple&gt;</code> part can be any <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)">target triple</a> like
<code>target.x86_64-pc-windows-msvc</code>.</p>
<h3 id="paths"><a class="header" href="#paths"><code>paths</code></a></h3>
<ul>
<li>Type: array of strings (paths)</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>An array of paths to local packages which are to be used as overrides for
dependencies. For more information see the <a href="reference/overriding-dependencies.html#paths-overrides">Overriding Dependencies
guide</a>.</p>
<h3 id="alias"><a class="header" href="#alias"><code>[alias]</code></a></h3>
<ul>
<li>Type: string or array of strings</li>
<li>Default: see below</li>
<li>Environment: <code>CARGO_ALIAS_&lt;name&gt;</code></li>
</ul>
<p>The <code>[alias]</code> table defines CLI command aliases. For example, running <code>cargo b</code> is an alias for running <code>cargo build</code>. Each key in the table is the
subcommand, and the value is the actual command to run. The value may be an
array of strings, where the first element is the command and the following are
arguments. It may also be a string, which will be split on spaces into
subcommand and arguments. The following aliases are built-in to Cargo:</p>
<pre><code class="language-toml">[alias]
b = "build"
c = "check"
d = "doc"
t = "test"
r = "run"
rm = "remove"
</code></pre>
<p>Aliases are not allowed to redefine existing built-in commands.</p>
<p>Aliases are recursive:</p>
<pre><code class="language-toml">[alias]
rr = "run --release"
recursive_example = "rr --example recursions"
</code></pre>
<h3 id="build"><a class="header" href="#build"><code>[build]</code></a></h3>
<p>The <code>[build]</code> table controls build-time operations and compiler settings.</p>
<h4 id="buildjobs"><a class="header" href="#buildjobs"><code>build.jobs</code></a></h4>
<ul>
<li>Type: integer or string</li>
<li>Default: number of logical CPUs</li>
<li>Environment: <code>CARGO_BUILD_JOBS</code></li>
</ul>
<p>Sets the maximum number of compiler processes to run in parallel. If negative,
it sets the maximum number of compiler processes to the number of logical CPUs
plus provided value. Should not be 0. If a string <code>default</code> is provided, it sets
the value back to defaults.</p>
<p>Can be overridden with the <code>--jobs</code> CLI option.</p>
<h4 id="buildrustc"><a class="header" href="#buildrustc"><code>build.rustc</code></a></h4>
<ul>
<li>Type: string (program path)</li>
<li>Default: <code>"rustc"</code></li>
<li>Environment: <code>CARGO_BUILD_RUSTC</code> or <code>RUSTC</code></li>
</ul>
<p>Sets the executable to use for <code>rustc</code>.</p>
<h4 id="buildrustc-wrapper"><a class="header" href="#buildrustc-wrapper"><code>build.rustc-wrapper</code></a></h4>
<ul>
<li>Type: string (program path)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_RUSTC_WRAPPER</code> or <code>RUSTC_WRAPPER</code></li>
</ul>
<p>Sets a wrapper to execute instead of <code>rustc</code>. The first argument passed to the
wrapper is the path to the actual executable to use
(i.e., <code>build.rustc</code>, if that is set, or <code>"rustc"</code> otherwise).</p>
<h4 id="buildrustc-workspace-wrapper"><a class="header" href="#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a></h4>
<ul>
<li>Type: string (program path)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_RUSTC_WORKSPACE_WRAPPER</code> or <code>RUSTC_WORKSPACE_WRAPPER</code></li>
</ul>
<p>Sets a wrapper to execute instead of <code>rustc</code>, for workspace members only. When building a
single-package project without workspaces, that package is considered to be the workspace. The first
argument passed to the wrapper is the path to the actual executable to use (i.e., <code>build.rustc</code>, if
that is set, or <code>"rustc"</code> otherwise). It affects the filename hash so that artifacts produced by the
wrapper are cached separately.</p>
<p>If both <code>rustc-wrapper</code> and <code>rustc-workspace-wrapper</code> are set, then they will be nested:
the final invocation is <code>$RUSTC_WRAPPER $RUSTC_WORKSPACE_WRAPPER $RUSTC</code>.</p>
<h4 id="buildrustdoc"><a class="header" href="#buildrustdoc"><code>build.rustdoc</code></a></h4>
<ul>
<li>Type: string (program path)</li>
<li>Default: <code>"rustdoc"</code></li>
<li>Environment: <code>CARGO_BUILD_RUSTDOC</code> or <code>RUSTDOC</code></li>
</ul>
<p>Sets the executable to use for <code>rustdoc</code>.</p>
<h4 id="buildtarget"><a class="header" href="#buildtarget"><code>build.target</code></a></h4>
<ul>
<li>Type: string or array of strings</li>
<li>Default: host platform</li>
<li>Environment: <code>CARGO_BUILD_TARGET</code></li>
</ul>
<p>The default <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)">target platform triples</a> to compile to.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="reference/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>Can be overridden with the <code>--target</code> CLI option.</p>
<pre><code class="language-toml">[build]
target = ["x86_64-unknown-linux-gnu", "i686-unknown-linux-gnu"]
</code></pre>
<h4 id="buildtarget-dir"><a class="header" href="#buildtarget-dir"><code>build.target-dir</code></a></h4>
<ul>
<li>Type: string (path)</li>
<li>Default: <code>"target"</code></li>
<li>Environment: <code>CARGO_BUILD_TARGET_DIR</code> or <code>CARGO_TARGET_DIR</code></li>
</ul>
<p>The path to where all compiler output is placed. The default if not specified
is a directory named <code>target</code> located at the root of the workspace.</p>
<p>Can be overridden with the <code>--target-dir</code> CLI option.</p>
<p>For more information see the <a href="reference/../reference/build-cache.html">build cache documentation</a>.</p>
<h4 id="buildbuild-dir"><a class="header" href="#buildbuild-dir"><code>build.build-dir</code></a></h4>
<ul>
<li>Type: string (path)</li>
<li>Default: Defaults to the value of <code>build.target-dir</code></li>
<li>Environment: <code>CARGO_BUILD_BUILD_DIR</code></li>
</ul>
<p>The directory where intermediate build artifacts will be stored.
Intermediate artifacts are produced by Rustc/Cargo during the build process.</p>
<p>This option supports path templating.</p>
<p>Available template variables:</p>
<ul>
<li><code>{workspace-root}</code> resolves to root of the current workspace.</li>
<li><code>{cargo-cache-home}</code> resolves to <code>CARGO_HOME</code></li>
<li><code>{workspace-path-hash}</code> resolves to a hash of the manifest path</li>
</ul>
<p>For more information see the <a href="reference/../reference/build-cache.html">build cache documentation</a>.</p>
<h4 id="buildrustflags"><a class="header" href="#buildrustflags"><code>build.rustflags</code></a></h4>
<ul>
<li>Type: string or array of strings</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_RUSTFLAGS</code> or <code>CARGO_ENCODED_RUSTFLAGS</code> or <code>RUSTFLAGS</code></li>
</ul>
<p>Extra command-line flags to pass to <code>rustc</code>. The value may be an array of
strings or a space-separated string.</p>
<p>There are four mutually exclusive sources of extra flags. They are checked in
order, with the first one being used:</p>
<ol>
<li><code>CARGO_ENCODED_RUSTFLAGS</code> environment variable.</li>
<li><code>RUSTFLAGS</code> environment variable.</li>
<li>All matching <code>target.&lt;triple&gt;.rustflags</code> and <code>target.&lt;cfg&gt;.rustflags</code>
config entries joined together.</li>
<li><code>build.rustflags</code> config value.</li>
</ol>
<p>Additional flags may also be passed with the <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a> command.</p>
<p>If the <code>--target</code> flag (or <a href="reference/config.html#buildtarget"><code>build.target</code></a>) is used, then the
flags will only be passed to the compiler for the target. Things being built
for the host, such as build scripts or proc macros, will not receive the args.
Without <code>--target</code>, the flags will be passed to all compiler invocations
(including build scripts and proc macros) because dependencies are shared. If
you have args that you do not want to pass to build scripts or proc macros and
are building for the host, pass <code>--target</code> with the <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)">host triple</a>.</p>
<p>It is not recommended to pass in flags that Cargo itself usually manages. For
example, the flags driven by <a href="reference/profiles.html">profiles</a> are best handled by setting the
appropriate profile setting.</p>
<blockquote>
<p><strong>Caution</strong>: Due to the low-level nature of passing flags directly to the
compiler, this may cause a conflict with future versions of Cargo which may
issue the same or similar flags on its own which may interfere with the
flags you specify. This is an area where Cargo may not always be backwards
compatible.</p>
</blockquote>
<h4 id="buildrustdocflags"><a class="header" href="#buildrustdocflags"><code>build.rustdocflags</code></a></h4>
<ul>
<li>Type: string or array of strings</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_RUSTDOCFLAGS</code> or <code>CARGO_ENCODED_RUSTDOCFLAGS</code> or <code>RUSTDOCFLAGS</code></li>
</ul>
<p>Extra command-line flags to pass to <code>rustdoc</code>. The value may be an array of
strings or a space-separated string.</p>
<p>There are four mutually exclusive sources of extra flags. They are checked in
order, with the first one being used:</p>
<ol>
<li><code>CARGO_ENCODED_RUSTDOCFLAGS</code> environment variable.</li>
<li><code>RUSTDOCFLAGS</code> environment variable.</li>
<li>All matching <code>target.&lt;triple&gt;.rustdocflags</code> config entries joined together.</li>
<li><code>build.rustdocflags</code> config value.</li>
</ol>
<p>Additional flags may also be passed with the <a href="reference/../commands/cargo-rustdoc.html"><code>cargo rustdoc</code></a> command.</p>
<blockquote>
<p><strong>Caution</strong>: Due to the low-level nature of passing flags directly to the
compiler, this may cause a conflict with future versions of Cargo which may
issue the same or similar flags on its own which may interfere with the
flags you specify. This is an area where Cargo may not always be backwards
compatible.</p>
</blockquote>
<h4 id="buildincremental"><a class="header" href="#buildincremental"><code>build.incremental</code></a></h4>
<ul>
<li>Type: bool</li>
<li>Default: from profile</li>
<li>Environment: <code>CARGO_BUILD_INCREMENTAL</code> or <code>CARGO_INCREMENTAL</code></li>
</ul>
<p>Whether or not to perform <a href="reference/profiles.html#incremental">incremental compilation</a>. The default if not set is
to use the value from the <a href="reference/profiles.html#incremental">profile</a>. Otherwise this overrides the setting of
all profiles.</p>
<p>The <code>CARGO_INCREMENTAL</code> environment variable can be set to <code>1</code> to force enable
incremental compilation for all profiles, or <code>0</code> to disable it. This env var
overrides the config setting.</p>
<h4 id="builddep-info-basedir"><a class="header" href="#builddep-info-basedir"><code>build.dep-info-basedir</code></a></h4>
<ul>
<li>Type: string (path)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_DEP_INFO_BASEDIR</code></li>
</ul>
<p>Strips the given path prefix from <a href="reference/../reference/build-cache.html#dep-info-files">dep
info</a> file paths. This config setting
is intended to convert absolute paths to relative paths for tools that require
relative paths.</p>
<p>The setting itself is a config-relative path. So, for example, a value of
<code>"."</code> would strip all paths starting with the parent directory of the <code>.cargo</code>
directory.</p>
<h4 id="buildpipelining"><a class="header" href="#buildpipelining"><code>build.pipelining</code></a></h4>
<p>This option is deprecated and unused. Cargo always has pipelining enabled.</p>
<h3 id="credential-alias"><a class="header" href="#credential-alias"><code>[credential-alias]</code></a></h3>
<ul>
<li>Type: string or array of strings</li>
<li>Default: empty</li>
<li>Environment: <code>CARGO_CREDENTIAL_ALIAS_&lt;name&gt;</code></li>
</ul>
<p>The <code>[credential-alias]</code> table defines credential provider aliases.
These aliases can be referenced as an element of the <code>registry.global-credential-providers</code>
array, or as a credential provider for a specific registry
under <code>registries.&lt;NAME&gt;.credential-provider</code>.</p>
<p>If specified as a string, the value will be split on spaces into path and arguments.</p>
<p>For example, to define an alias called <code>my-alias</code>:</p>
<pre><code class="language-toml">[credential-alias]
my-alias = ["/usr/bin/cargo-credential-example", "--argument", "value", "--flag"]
</code></pre>
<p>See <a href="reference/registry-authentication.html">Registry Authentication</a> for more information.</p>
<h3 id="doc"><a class="header" href="#doc"><code>[doc]</code></a></h3>
<p>The <code>[doc]</code> table defines options for the <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> command.</p>
<h4 id="docbrowser"><a class="header" href="#docbrowser"><code>doc.browser</code></a></h4>
<ul>
<li>Type: string or array of strings (<a href="reference/config.html#executable-paths-with-arguments">program path with args</a>)</li>
<li>Default: <code>BROWSER</code> environment variable, or, if that is missing,
opening the link in a system specific way</li>
</ul>
<p>This option sets the browser to be used by <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a>, overriding the
<code>BROWSER</code> environment variable when opening documentation with the <code>--open</code>
option.</p>
<h3 id="cargo-new"><a class="header" href="#cargo-new"><code>[cargo-new]</code></a></h3>
<p>The <code>[cargo-new]</code> table defines defaults for the <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> command.</p>
<h4 id="cargo-newname"><a class="header" href="#cargo-newname"><code>cargo-new.name</code></a></h4>
<p>This option is deprecated and unused.</p>
<h4 id="cargo-newemail"><a class="header" href="#cargo-newemail"><code>cargo-new.email</code></a></h4>
<p>This option is deprecated and unused.</p>
<h4 id="cargo-newvcs"><a class="header" href="#cargo-newvcs"><code>cargo-new.vcs</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: <code>"git"</code> or <code>"none"</code></li>
<li>Environment: <code>CARGO_CARGO_NEW_VCS</code></li>
</ul>
<p>Specifies the source control system to use for initializing a new repository.
Valid values are <code>git</code>, <code>hg</code> (for Mercurial), <code>pijul</code>, <code>fossil</code> or <code>none</code> to
disable this behavior. Defaults to <code>git</code>, or <code>none</code> if already inside a VCS
repository. Can be overridden with the <code>--vcs</code> CLI option.</p>
<h3 id="env"><a class="header" href="#env"><code>[env]</code></a></h3>
<p>The <code>[env]</code> section allows you to set additional environment variables for
build scripts, rustc invocations, <code>cargo run</code> and <code>cargo build</code>.</p>
<pre><code class="language-toml">[env]
OPENSSL_DIR = "/opt/openssl"
</code></pre>
<p>By default, the variables specified will not override values that already exist
in the environment. This behavior can be changed by setting the <code>force</code> flag.</p>
<p>Setting the <code>relative</code> flag evaluates the value as a config-relative path that
is relative to the parent directory of the <code>.cargo</code> directory that contains the
<code>config.toml</code> file. The value of the environment variable will be the full
absolute path.</p>
<pre><code class="language-toml">[env]
TMPDIR = { value = "/home/tmp", force = true }
OPENSSL_DIR = { value = "vendor/openssl", relative = true }
</code></pre>
<h3 id="future-incompat-report"><a class="header" href="#future-incompat-report"><code>[future-incompat-report]</code></a></h3>
<p>The <code>[future-incompat-report]</code> table controls setting for <a href="reference/future-incompat-report.html">future incompat reporting</a></p>
<h4 id="future-incompat-reportfrequency"><a class="header" href="#future-incompat-reportfrequency"><code>future-incompat-report.frequency</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: <code>"always"</code></li>
<li>Environment: <code>CARGO_FUTURE_INCOMPAT_REPORT_FREQUENCY</code></li>
</ul>
<p>Controls how often we display a notification to the terminal when a future incompat report is available. Possible values:</p>
<ul>
<li><code>always</code> (default): Always display a notification when a command (e.g. <code>cargo build</code>) produces a future incompat report</li>
<li><code>never</code>: Never display a notification</li>
</ul>
<h3 id="cache"><a class="header" href="#cache"><code>[cache]</code></a></h3>
<p>The <code>[cache]</code> table defines settings for cargo’s caches.</p>
<h4 id="global-caches"><a class="header" href="#global-caches">Global caches</a></h4>
<p>When running <code>cargo</code> commands, Cargo will automatically track which files you are using within the global cache.
Periodically, Cargo will delete files that have not been used for some period of time.
It will delete files that have to be downloaded from the network if they have not been used in 3 months. Files that can be generated without network access will be deleted if they have not been used in 1 month.</p>
<p>The automatic deletion of files only occurs when running commands that are already doing a significant amount of work, such as all of the build commands (<code>cargo build</code>, <code>cargo test</code>, <code>cargo check</code>, etc.), and <code>cargo fetch</code>.</p>
<p>Automatic deletion is disabled if cargo is offline such as with <code>--offline</code> or <code>--frozen</code> to avoid deleting artifacts that may need to be used if you are offline for a long period of time.</p>
<blockquote>
<p><strong>Note</strong>: This tracking is currently only implemented for the global cache in Cargo’s home directory.
This includes registry indexes and source files downloaded from registries and git dependencies.
Support for tracking build artifacts is not yet implemented, and tracked in <a href="https://github.com/rust-lang/cargo/issues/13136">cargo#13136</a>.</p>
<p>Additionally, there is an unstable feature to support <em>manually</em> triggering cache cleaning, and to further customize the configuration options.
See the <a href="reference/unstable.html#gc">Unstable chapter</a> for more information.</p>
</blockquote>
<h4 id="cacheauto-clean-frequency"><a class="header" href="#cacheauto-clean-frequency"><code>cache.auto-clean-frequency</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: <code>"1 day"</code></li>
<li>Environment: <code>CARGO_CACHE_AUTO_CLEAN_FREQUENCY</code></li>
</ul>
<p>This option defines how often Cargo will automatically delete unused files in the global cache.
This does <em>not</em> define how old the files must be, those thresholds are described <a href="reference/config.html#global-caches">above</a>.</p>
<p>It supports the following settings:</p>
<ul>
<li><code>"never"</code> — Never deletes old files.</li>
<li><code>"always"</code> — Checks to delete old files every time Cargo runs.</li>
<li>An integer followed by “seconds”, “minutes”, “hours”, “days”, “weeks”, or “months” — Checks to delete old files at most the given time frame.</li>
</ul>
<h3 id="http"><a class="header" href="#http"><code>[http]</code></a></h3>
<p>The <code>[http]</code> table defines settings for HTTP behavior. This includes fetching
crate dependencies and accessing remote git repositories.</p>
<h4 id="httpdebug"><a class="header" href="#httpdebug"><code>http.debug</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_HTTP_DEBUG</code></li>
</ul>
<p>If <code>true</code>, enables debugging of HTTP requests. The debug information can be
seen by setting the <code>CARGO_LOG=network=debug</code> environment
variable (or use <code>network=trace</code> for even more information).</p>
<p>Be wary when posting logs from this output in a public location. The output
may include headers with authentication tokens which you don’t want to leak!
Be sure to review logs before posting them.</p>
<h4 id="httpproxy"><a class="header" href="#httpproxy"><code>http.proxy</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_HTTP_PROXY</code> or <code>HTTPS_PROXY</code> or <code>https_proxy</code> or <code>http_proxy</code></li>
</ul>
<p>Sets an HTTP and HTTPS proxy to use. The format is in <a href="https://everything.curl.dev/transfers/conn/proxies#proxy-types">libcurl format</a> as in
<code>[protocol://]host[:port]</code>. If not set, Cargo will also check the <code>http.proxy</code>
setting in your global git configuration. If none of those are set, the
<code>HTTPS_PROXY</code> or <code>https_proxy</code> environment variables set the proxy for HTTPS
requests, and <code>http_proxy</code> sets it for HTTP requests.</p>
<h4 id="httptimeout"><a class="header" href="#httptimeout"><code>http.timeout</code></a></h4>
<ul>
<li>Type: integer</li>
<li>Default: 30</li>
<li>Environment: <code>CARGO_HTTP_TIMEOUT</code> or <code>HTTP_TIMEOUT</code></li>
</ul>
<p>Sets the timeout for each HTTP request, in seconds.</p>
<h4 id="httpcainfo"><a class="header" href="#httpcainfo"><code>http.cainfo</code></a></h4>
<ul>
<li>Type: string (path)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_HTTP_CAINFO</code></li>
</ul>
<p>Path to a Certificate Authority (CA) bundle file, used to verify TLS
certificates. If not specified, Cargo attempts to use the system certificates.</p>
<h4 id="httpproxy-cainfo"><a class="header" href="#httpproxy-cainfo"><code>http.proxy-cainfo</code></a></h4>
<ul>
<li>Type: string (path)</li>
<li>Default: falls back to <code>http.cainfo</code> if not set</li>
<li>Environment: <code>CARGO_HTTP_PROXY_CAINFO</code></li>
</ul>
<p>Path to a Certificate Authority (CA) bundle file, used to verify proxy TLS
certificates.</p>
<h4 id="httpcheck-revoke"><a class="header" href="#httpcheck-revoke"><code>http.check-revoke</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: true (Windows) false (all others)</li>
<li>Environment: <code>CARGO_HTTP_CHECK_REVOKE</code></li>
</ul>
<p>This determines whether or not TLS certificate revocation checks should be
performed. This only works on Windows.</p>
<h4 id="httpssl-version"><a class="header" href="#httpssl-version"><code>http.ssl-version</code></a></h4>
<ul>
<li>Type: string or min/max table</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_HTTP_SSL_VERSION</code></li>
</ul>
<p>This sets the minimum TLS version to use. It takes a string, with one of the
possible values of <code>"default"</code>, <code>"tlsv1"</code>, <code>"tlsv1.0"</code>, <code>"tlsv1.1"</code>, <code>"tlsv1.2"</code>, or
<code>"tlsv1.3"</code>.</p>
<p>This may alternatively take a table with two keys, <code>min</code> and <code>max</code>, which each
take a string value of the same kind that specifies the minimum and maximum
range of TLS versions to use.</p>
<p>The default is a minimum version of <code>"tlsv1.0"</code> and a max of the newest version
supported on your platform, typically <code>"tlsv1.3"</code>.</p>
<h4 id="httplow-speed-limit"><a class="header" href="#httplow-speed-limit"><code>http.low-speed-limit</code></a></h4>
<ul>
<li>Type: integer</li>
<li>Default: 10</li>
<li>Environment: <code>CARGO_HTTP_LOW_SPEED_LIMIT</code></li>
</ul>
<p>This setting controls timeout behavior for slow connections. If the average
transfer speed in bytes per second is below the given value for
<a href="reference/config.html#httptimeout"><code>http.timeout</code></a> seconds (default 30 seconds), then the
connection is considered too slow and Cargo will abort and retry.</p>
<h4 id="httpmultiplexing"><a class="header" href="#httpmultiplexing"><code>http.multiplexing</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: true</li>
<li>Environment: <code>CARGO_HTTP_MULTIPLEXING</code></li>
</ul>
<p>When <code>true</code>, Cargo will attempt to use the HTTP2 protocol with multiplexing.
This allows multiple requests to use the same connection, usually improving
performance when fetching multiple files. If <code>false</code>, Cargo will use HTTP 1.1
without pipelining.</p>
<h4 id="httpuser-agent"><a class="header" href="#httpuser-agent"><code>http.user-agent</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: Cargo’s version</li>
<li>Environment: <code>CARGO_HTTP_USER_AGENT</code></li>
</ul>
<p>Specifies a custom user-agent header to use. The default if not specified is a
string that includes Cargo’s version.</p>
<h3 id="install"><a class="header" href="#install"><code>[install]</code></a></h3>
<p>The <code>[install]</code> table defines defaults for the <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> command.</p>
<h4 id="installroot"><a class="header" href="#installroot"><code>install.root</code></a></h4>
<ul>
<li>Type: string (path)</li>
<li>Default: Cargo’s home directory</li>
<li>Environment: <code>CARGO_INSTALL_ROOT</code></li>
</ul>
<p>Sets the path to the root directory for installing executables for <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>. Executables go into a <code>bin</code> directory underneath the root.</p>
<p>To track information of installed executables, some extra files, such as
<code>.crates.toml</code> and <code>.crates2.json</code>, are also created under this root.</p>
<p>The default if not specified is Cargo’s home directory (default <code>.cargo</code> in
your home directory).</p>
<p>Can be overridden with the <code>--root</code> command-line option.</p>
<h3 id="net"><a class="header" href="#net"><code>[net]</code></a></h3>
<p>The <code>[net]</code> table controls networking configuration.</p>
<h4 id="netretry"><a class="header" href="#netretry"><code>net.retry</code></a></h4>
<ul>
<li>Type: integer</li>
<li>Default: 3</li>
<li>Environment: <code>CARGO_NET_RETRY</code></li>
</ul>
<p>Number of times to retry possibly spurious network errors.</p>
<h4 id="netgit-fetch-with-cli"><a class="header" href="#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_NET_GIT_FETCH_WITH_CLI</code></li>
</ul>
<p>If this is <code>true</code>, then Cargo will use the <code>git</code> executable to fetch registry
indexes and git dependencies. If <code>false</code>, then it uses a built-in <code>git</code>
library.</p>
<p>Setting this to <code>true</code> can be helpful if you have special authentication
requirements that Cargo does not support. See <a href="reference/../appendix/git-authentication.html">Git
Authentication</a> for more information about
setting up git authentication.</p>
<h4 id="netoffline"><a class="header" href="#netoffline"><code>net.offline</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_NET_OFFLINE</code></li>
</ul>
<p>If this is <code>true</code>, then Cargo will avoid accessing the network, and attempt to
proceed with locally cached data. If <code>false</code>, Cargo will access the network as
needed, and generate an error if it encounters a network error.</p>
<p>Can be overridden with the <code>--offline</code> command-line option.</p>
<h4 id="netssh"><a class="header" href="#netssh"><code>net.ssh</code></a></h4>
<p>The <code>[net.ssh]</code> table contains settings for SSH connections.</p>
<h4 id="netsshknown-hosts"><a class="header" href="#netsshknown-hosts"><code>net.ssh.known-hosts</code></a></h4>
<ul>
<li>Type: array of strings</li>
<li>Default: see description</li>
<li>Environment: not supported</li>
</ul>
<p>The <code>known-hosts</code> array contains a list of SSH host keys that should be
accepted as valid when connecting to an SSH server (such as for SSH git
dependencies). Each entry should be a string in a format similar to OpenSSH
<code>known_hosts</code> files. Each string should start with one or more hostnames
separated by commas, a space, the key type name, a space, and the
base64-encoded key. For example:</p>
<pre><code class="language-toml">[net.ssh]
known-hosts = [
    "example.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFO4Q5T0UV0SQevair9PFwoxY9dl4pQl3u5phoqJH3cF"
]
</code></pre>
<p>Cargo will attempt to load known hosts keys from common locations supported in
OpenSSH, and will join those with any listed in a Cargo configuration file.
If any matching entry has the correct key, the connection will be allowed.</p>
<p>Cargo comes with the host keys for <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">github.com</a> built-in. If
those ever change, you can add the new keys to the config or known_hosts file.</p>
<p>See <a href="reference/../appendix/git-authentication.html#ssh-known-hosts">Git Authentication</a>
for more details.</p>
<h3 id="patch"><a class="header" href="#patch"><code>[patch]</code></a></h3>
<p>Just as you can override dependencies using <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code> in
<code>Cargo.toml</code></a>, you can
override them in the cargo configuration file to apply those patches to
any affected build. The format is identical to the one used in
<code>Cargo.toml</code>.</p>
<p>Since <code>.cargo/config.toml</code> files are not usually checked into source
control, you should prefer patching using <code>Cargo.toml</code> where possible to
ensure that other developers can compile your crate in their own
environments. Patching through cargo configuration files is generally
only appropriate when the patch section is automatically generated by an
external build tool.</p>
<p>If a given dependency is patched both in a cargo configuration file and
a <code>Cargo.toml</code> file, the patch in the configuration file is used. If
multiple configuration files patch the same dependency, standard cargo
configuration merging is used, which prefers the value defined closest
to the current directory, with <code>$HOME/.cargo/config.toml</code> taking the
lowest precedence.</p>
<p>Relative <code>path</code> dependencies in such a <code>[patch]</code> section are resolved
relative to the configuration file they appear in.</p>
<h3 id="profile"><a class="header" href="#profile"><code>[profile]</code></a></h3>
<p>The <code>[profile]</code> table can be used to globally change profile settings, and
override settings specified in <code>Cargo.toml</code>. It has the same syntax and
options as profiles specified in <code>Cargo.toml</code>. See the <a href="reference/profiles.html">Profiles chapter</a> for
details about the options.</p>
<h4 id="profilenamebuild-override"><a class="header" href="#profilenamebuild-override"><code>[profile.&lt;name&gt;.build-override]</code></a></h4>
<ul>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_BUILD_OVERRIDE_&lt;key&gt;</code></li>
</ul>
<p>The build-override table overrides settings for build scripts, proc macros,
and their dependencies. It has the same keys as a normal profile. See the
<a href="reference/profiles.html#overrides">overrides section</a> for more details.</p>
<h4 id="profilenamepackagename"><a class="header" href="#profilenamepackagename"><code>[profile.&lt;name&gt;.package.&lt;name&gt;]</code></a></h4>
<ul>
<li>Environment: not supported</li>
</ul>
<p>The package table overrides settings for specific packages. It has the same
keys as a normal profile, minus the <code>panic</code>, <code>lto</code>, and <code>rpath</code> settings. See
the <a href="reference/profiles.html#overrides">overrides section</a> for more details.</p>
<h4 id="profilenamecodegen-units"><a class="header" href="#profilenamecodegen-units"><code>profile.&lt;name&gt;.codegen-units</code></a></h4>
<ul>
<li>Type: integer</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_CODEGEN_UNITS</code></li>
</ul>
<p>See <a href="reference/profiles.html#codegen-units">codegen-units</a>.</p>
<h4 id="profilenamedebug"><a class="header" href="#profilenamedebug"><code>profile.&lt;name&gt;.debug</code></a></h4>
<ul>
<li>Type: integer or boolean</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_DEBUG</code></li>
</ul>
<p>See <a href="reference/profiles.html#debug">debug</a>.</p>
<h4 id="profilenamesplit-debuginfo"><a class="header" href="#profilenamesplit-debuginfo"><code>profile.&lt;name&gt;.split-debuginfo</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_SPLIT_DEBUGINFO</code></li>
</ul>
<p>See <a href="reference/profiles.html#split-debuginfo">split-debuginfo</a>.</p>
<h4 id="profilenamedebug-assertions"><a class="header" href="#profilenamedebug-assertions"><code>profile.&lt;name&gt;.debug-assertions</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_DEBUG_ASSERTIONS</code></li>
</ul>
<p>See <a href="reference/profiles.html#debug-assertions">debug-assertions</a>.</p>
<h4 id="profilenameincremental"><a class="header" href="#profilenameincremental"><code>profile.&lt;name&gt;.incremental</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_INCREMENTAL</code></li>
</ul>
<p>See <a href="reference/profiles.html#incremental">incremental</a>.</p>
<h4 id="profilenamelto"><a class="header" href="#profilenamelto"><code>profile.&lt;name&gt;.lto</code></a></h4>
<ul>
<li>Type: string or boolean</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_LTO</code></li>
</ul>
<p>See <a href="reference/profiles.html#lto">lto</a>.</p>
<h4 id="profilenameoverflow-checks"><a class="header" href="#profilenameoverflow-checks"><code>profile.&lt;name&gt;.overflow-checks</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_OVERFLOW_CHECKS</code></li>
</ul>
<p>See <a href="reference/profiles.html#overflow-checks">overflow-checks</a>.</p>
<h4 id="profilenameopt-level"><a class="header" href="#profilenameopt-level"><code>profile.&lt;name&gt;.opt-level</code></a></h4>
<ul>
<li>Type: integer or string</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_OPT_LEVEL</code></li>
</ul>
<p>See <a href="reference/profiles.html#opt-level">opt-level</a>.</p>
<h4 id="profilenamepanic"><a class="header" href="#profilenamepanic"><code>profile.&lt;name&gt;.panic</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_PANIC</code></li>
</ul>
<p>See <a href="reference/profiles.html#panic">panic</a>.</p>
<h4 id="profilenamerpath"><a class="header" href="#profilenamerpath"><code>profile.&lt;name&gt;.rpath</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_RPATH</code></li>
</ul>
<p>See <a href="reference/profiles.html#rpath">rpath</a>.</p>
<h4 id="profilenamestrip"><a class="header" href="#profilenamestrip"><code>profile.&lt;name&gt;.strip</code></a></h4>
<ul>
<li>Type: string or boolean</li>
<li>Default: See profile docs.</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_STRIP</code></li>
</ul>
<p>See <a href="reference/profiles.html#strip">strip</a>.</p>
<h3 id="resolver"><a class="header" href="#resolver"><code>[resolver]</code></a></h3>
<p>The <code>[resolver]</code> table overrides <a href="reference/resolver.html">dependency resolution behavior</a> for local development (e.g. excludes <code>cargo install</code>).</p>
<h4 id="resolverincompatible-rust-versions"><a class="header" href="#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: See <a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> docs</li>
<li>Environment: <code>CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS</code></li>
</ul>
<p>When resolving which version of a dependency to use, select how versions with incompatible <code>package.rust-version</code>s are treated.
Values include:</p>
<ul>
<li><code>allow</code>: treat <code>rust-version</code>-incompatible versions like any other version</li>
<li><code>fallback</code>: only consider <code>rust-version</code>-incompatible versions if no other version matched</li>
</ul>
<p>Can be overridden with</p>
<ul>
<li><code>--ignore-rust-version</code> CLI option</li>
<li>Setting the dependency’s version requirement higher than any version with a compatible <code>rust-version</code></li>
<li>Specifying the version to <code>cargo update</code> with <code>--precise</code></li>
</ul>
<p>See the <a href="reference/resolver.html#rust-version">resolver</a> chapter for more details.</p>
<blockquote>
<p><strong>MSRV:</strong></p>
<ul>
<li><code>allow</code> is supported on any version</li>
<li><code>fallback</code> is respected as of 1.84</li>
</ul>
</blockquote>
<h3 id="registries"><a class="header" href="#registries"><code>[registries]</code></a></h3>
<p>The <code>[registries]</code> table is used for specifying additional <a href="reference/registries.html">registries</a>. It
consists of a sub-table for each named registry.</p>
<h4 id="registriesnameindex"><a class="header" href="#registriesnameindex"><code>registries.&lt;name&gt;.index</code></a></h4>
<ul>
<li>Type: string (url)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_REGISTRIES_&lt;name&gt;_INDEX</code></li>
</ul>
<p>Specifies the URL of the index for the registry.</p>
<h4 id="registriesnametoken"><a class="header" href="#registriesnametoken"><code>registries.&lt;name&gt;.token</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_REGISTRIES_&lt;name&gt;_TOKEN</code></li>
</ul>
<p>Specifies the authentication token for the given registry. This value should
only appear in the <a href="reference/config.html#credentials">credentials</a> file. This is used for registry
commands like <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> that require authentication.</p>
<p>Can be overridden with the <code>--token</code> command-line option.</p>
<h4 id="registriesnamecredential-provider"><a class="header" href="#registriesnamecredential-provider"><code>registries.&lt;name&gt;.credential-provider</code></a></h4>
<ul>
<li>Type: string or array of path and arguments</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_REGISTRIES_&lt;name&gt;_CREDENTIAL_PROVIDER</code></li>
</ul>
<p>Specifies the credential provider for the given registry. If not set, the
providers in <a href="reference/config.html#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a>
will be used.</p>
<p>If specified as a string, path and arguments will be split on spaces. For
paths or arguments that contain spaces, use an array.</p>
<p>If the value exists in the <a href="reference/config.html#credential-alias"><code>[credential-alias]</code></a> table, the alias will be used.</p>
<p>See <a href="reference/registry-authentication.html">Registry Authentication</a> for more information.</p>
<h4 id="registriescrates-ioprotocol"><a class="header" href="#registriescrates-ioprotocol"><code>registries.crates-io.protocol</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: <code>"sparse"</code></li>
<li>Environment: <code>CARGO_REGISTRIES_CRATES_IO_PROTOCOL</code></li>
</ul>
<p>Specifies the protocol used to access crates.io. Allowed values are <code>git</code> or <code>sparse</code>.</p>
<p><code>git</code> causes Cargo to clone the entire index of all packages ever published to <a href="https://crates.io/">crates.io</a> from <a href="https://github.com/rust-lang/crates.io-index/">https://github.com/rust-lang/crates.io-index/</a>.
This can have performance implications due to the size of the index.
<code>sparse</code> is a newer protocol which uses HTTPS to download only what is necessary from <a href="https://index.crates.io/">https://index.crates.io/</a>.
This can result in a significant performance improvement for resolving new dependencies in most situations.</p>
<p>More information about registry protocols may be found in the <a href="reference/registries.html">Registries chapter</a>.</p>
<h3 id="registry"><a class="header" href="#registry"><code>[registry]</code></a></h3>
<p>The <code>[registry]</code> table controls the default registry used when one is not
specified.</p>
<h4 id="registryindex"><a class="header" href="#registryindex"><code>registry.index</code></a></h4>
<p>This value is no longer accepted and should not be used.</p>
<h4 id="registrydefault"><a class="header" href="#registrydefault"><code>registry.default</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: <code>"crates-io"</code></li>
<li>Environment: <code>CARGO_REGISTRY_DEFAULT</code></li>
</ul>
<p>The name of the registry (from the <a href="reference/config.html#registries"><code>registries</code> table</a>) to use
by default for registry commands like <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a>.</p>
<p>Can be overridden with the <code>--registry</code> command-line option.</p>
<h4 id="registrycredential-provider"><a class="header" href="#registrycredential-provider"><code>registry.credential-provider</code></a></h4>
<ul>
<li>Type: string or array of path and arguments</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_REGISTRY_CREDENTIAL_PROVIDER</code></li>
</ul>
<p>Specifies the credential provider for <a href="https://crates.io/">crates.io</a>. If not set, the
providers in <a href="reference/config.html#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a>
will be used.</p>
<p>If specified as a string, path and arguments will be split on spaces. For
paths or arguments that contain spaces, use an array.</p>
<p>If the value exists in the <code>[credential-alias]</code> table, the alias will be used.</p>
<p>See <a href="reference/registry-authentication.html">Registry Authentication</a> for more information.</p>
<h4 id="registrytoken"><a class="header" href="#registrytoken"><code>registry.token</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_REGISTRY_TOKEN</code></li>
</ul>
<p>Specifies the authentication token for <a href="https://crates.io/">crates.io</a>. This value should only
appear in the <a href="reference/config.html#credentials">credentials</a> file. This is used for registry
commands like <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> that require authentication.</p>
<p>Can be overridden with the <code>--token</code> command-line option.</p>
<h4 id="registryglobal-credential-providers"><a class="header" href="#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a></h4>
<ul>
<li>Type: array</li>
<li>Default: <code>["cargo:token"]</code></li>
<li>Environment: <code>CARGO_REGISTRY_GLOBAL_CREDENTIAL_PROVIDERS</code></li>
</ul>
<p>Specifies the list of global credential providers. If credential provider is not set
for a specific registry using <code>registries.&lt;name&gt;.credential-provider</code>, Cargo will use
the credential providers in this list. Providers toward the end of the list have precedence.</p>
<p>Path and arguments are split on spaces. If the path or arguments contains spaces, the credential
provider should be defined in the <a href="reference/config.html#credential-alias"><code>[credential-alias]</code></a> table and
referenced here by its alias.</p>
<p>See <a href="reference/registry-authentication.html">Registry Authentication</a> for more information.</p>
<h3 id="source"><a class="header" href="#source"><code>[source]</code></a></h3>
<p>The <code>[source]</code> table defines the registry sources available. See <a href="reference/source-replacement.html">Source
Replacement</a> for more information. It consists of a sub-table for each named
source. A source should only define one kind (directory, registry,
local-registry, or git).</p>
<h4 id="sourcenamereplace-with"><a class="header" href="#sourcenamereplace-with"><code>source.&lt;name&gt;.replace-with</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>If set, replace this source with the given named source or named registry.</p>
<h4 id="sourcenamedirectory"><a class="header" href="#sourcenamedirectory"><code>source.&lt;name&gt;.directory</code></a></h4>
<ul>
<li>Type: string (path)</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>Sets the path to a directory to use as a directory source.</p>
<h4 id="sourcenameregistry"><a class="header" href="#sourcenameregistry"><code>source.&lt;name&gt;.registry</code></a></h4>
<ul>
<li>Type: string (url)</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>Sets the URL to use for a registry source.</p>
<h4 id="sourcenamelocal-registry"><a class="header" href="#sourcenamelocal-registry"><code>source.&lt;name&gt;.local-registry</code></a></h4>
<ul>
<li>Type: string (path)</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>Sets the path to a directory to use as a local registry source.</p>
<h4 id="sourcenamegit"><a class="header" href="#sourcenamegit"><code>source.&lt;name&gt;.git</code></a></h4>
<ul>
<li>Type: string (url)</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>Sets the URL to use for a git repository source.</p>
<h4 id="sourcenamebranch"><a class="header" href="#sourcenamebranch"><code>source.&lt;name&gt;.branch</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>Sets the branch name to use for a git repository.</p>
<p>If none of <code>branch</code>, <code>tag</code>, or <code>rev</code> is set, defaults to the <code>master</code> branch.</p>
<h4 id="sourcenametag"><a class="header" href="#sourcenametag"><code>source.&lt;name&gt;.tag</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>Sets the tag name to use for a git repository.</p>
<p>If none of <code>branch</code>, <code>tag</code>, or <code>rev</code> is set, defaults to the <code>master</code> branch.</p>
<h4 id="sourcenamerev"><a class="header" href="#sourcenamerev"><code>source.&lt;name&gt;.rev</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: none</li>
<li>Environment: not supported</li>
</ul>
<p>Sets the <a href="https://git-scm.com/docs/gitrevisions">revision</a> to use for a git repository.</p>
<p>If none of <code>branch</code>, <code>tag</code>, or <code>rev</code> is set, defaults to the <code>master</code> branch.</p>
<h3 id="target"><a class="header" href="#target"><code>[target]</code></a></h3>
<p>The <code>[target]</code> table is used for specifying settings for specific platform
targets. It consists of a sub-table which is either a <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)">platform triple</a>
or a <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> expression</a>. The given values will be used if the target platform
matches either the <code>&lt;triple&gt;</code> value or the <code>&lt;cfg&gt;</code> expression.</p>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
linker = "arm-none-eabi-gcc"
runner = "my-emulator"
rustflags = ["…", "…"]

[target.'cfg(all(target_arch = "arm", target_os = "none"))']
runner = "my-arm-wrapper"
rustflags = ["…", "…"]
</code></pre>
<p><code>cfg</code> values come from those built-in to the compiler (run <code>rustc --print=cfg</code>
to view) and extra <code>--cfg</code> flags passed to <code>rustc</code> (such as those defined in
<code>RUSTFLAGS</code>). Do not try to match on <code>debug_assertions</code>, <code>test</code>, Cargo features
like <code>feature="foo"</code>, or values set by <a href="reference/build-scripts.html">build scripts</a>.</p>
<p>If using a target spec JSON file, the <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)"><code>&lt;triple&gt;</code></a> value is the filename stem.
For example <code>--target foo/bar.json</code> would match <code>[target.bar]</code>.</p>
<h4 id="targettriplear"><a class="header" href="#targettriplear"><code>target.&lt;triple&gt;.ar</code></a></h4>
<p>This option is deprecated and unused.</p>
<h4 id="targettriplelinker"><a class="header" href="#targettriplelinker"><code>target.&lt;triple&gt;.linker</code></a></h4>
<ul>
<li>Type: string (program path)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TARGET_&lt;triple&gt;_LINKER</code></li>
</ul>
<p>Specifies the linker which is passed to <code>rustc</code> (via <a href="reference/../../rustc/codegen-options/index.html#linker"><code>-C linker</code></a>) when the
<a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)"><code>&lt;triple&gt;</code></a> is being compiled for. By default, the linker is not overridden.</p>
<h4 id="targetcfglinker"><a class="header" href="#targetcfglinker"><code>target.&lt;cfg&gt;.linker</code></a></h4>
<p>This is similar to the <a href="reference/config.html#targettriplelinker">target linker</a>, but using
a <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> expression</a>. If both a <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)"><code>&lt;triple&gt;</code></a> and <code>&lt;cfg&gt;</code> runner match,
the <code>&lt;triple&gt;</code> will take precedence. It is an error if more than one
<code>&lt;cfg&gt;</code> runner matches the current target.</p>
<h4 id="targettriplerunner"><a class="header" href="#targettriplerunner"><code>target.&lt;triple&gt;.runner</code></a></h4>
<ul>
<li>Type: string or array of strings (<a href="reference/config.html#executable-paths-with-arguments">program path with args</a>)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TARGET_&lt;triple&gt;_RUNNER</code></li>
</ul>
<p>If a runner is provided, executables for the target <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)"><code>&lt;triple&gt;</code></a> will be
executed by invoking the specified runner with the actual executable passed as
an argument. This applies to <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>, <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> and <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a>
commands. By default, compiled executables are executed directly.</p>
<h4 id="targetcfgrunner"><a class="header" href="#targetcfgrunner"><code>target.&lt;cfg&gt;.runner</code></a></h4>
<p>This is similar to the <a href="reference/config.html#targettriplerunner">target runner</a>, but using
a <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> expression</a>. If both a <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)"><code>&lt;triple&gt;</code></a> and <code>&lt;cfg&gt;</code> runner match,
the <code>&lt;triple&gt;</code> will take precedence. It is an error if more than one
<code>&lt;cfg&gt;</code> runner matches the current target.</p>
<h4 id="targettriplerustflags"><a class="header" href="#targettriplerustflags"><code>target.&lt;triple&gt;.rustflags</code></a></h4>
<ul>
<li>Type: string or array of strings</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TARGET_&lt;triple&gt;_RUSTFLAGS</code></li>
</ul>
<p>Passes a set of custom flags to the compiler for this <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)"><code>&lt;triple&gt;</code></a>.
The value may be an array of strings or a space-separated string.</p>
<p>See <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> for more details on the different
ways to specific extra flags.</p>
<h4 id="targetcfgrustflags"><a class="header" href="#targetcfgrustflags"><code>target.&lt;cfg&gt;.rustflags</code></a></h4>
<p>This is similar to the <a href="reference/config.html#targettriplerustflags">target rustflags</a>, but
using a <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> expression</a>. If several <code>&lt;cfg&gt;</code> and <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)"><code>&lt;triple&gt;</code></a> entries
match the current target, the flags are joined together.</p>
<h4 id="targettriplerustdocflags"><a class="header" href="#targettriplerustdocflags"><code>target.&lt;triple&gt;.rustdocflags</code></a></h4>
<ul>
<li>Type: string or array of strings</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TARGET_&lt;triple&gt;_RUSTDOCFLAGS</code></li>
</ul>
<p>Passes a set of custom flags to the compiler for this <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)"><code>&lt;triple&gt;</code></a>.
The value may be an array of strings or a space-separated string.</p>
<p>See <a href="reference/config.html#buildrustdocflags"><code>build.rustdocflags</code></a> for more details on the different
ways to specific extra flags.</p>
<h4 id="targettriplelinks"><a class="header" href="#targettriplelinks"><code>target.&lt;triple&gt;.&lt;links&gt;</code></a></h4>
<p>The links sub-table provides a way to <a href="reference/build-scripts.html#overriding-build-scripts">override a build script</a>. When
specified, the build script for the given <code>links</code> library will not be
run, and the given values will be used instead.</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = "-L /some/path"
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["…"]
metadata_key1 = "value"
metadata_key2 = "value"
</code></pre>
<h3 id="term"><a class="header" href="#term"><code>[term]</code></a></h3>
<p>The <code>[term]</code> table controls terminal output and interaction.</p>
<h4 id="termquiet"><a class="header" href="#termquiet"><code>term.quiet</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_TERM_QUIET</code></li>
</ul>
<p>Controls whether or not log messages are displayed by Cargo.</p>
<p>Specifying the <code>--quiet</code> flag will override and force quiet output.
Specifying the <code>--verbose</code> flag will override and disable quiet output.</p>
<h4 id="termverbose"><a class="header" href="#termverbose"><code>term.verbose</code></a></h4>
<ul>
<li>Type: boolean</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_TERM_VERBOSE</code></li>
</ul>
<p>Controls whether or not extra detailed messages are displayed by Cargo.</p>
<p>Specifying the <code>--quiet</code> flag will override and disable verbose output.
Specifying the <code>--verbose</code> flag will override and force verbose output.</p>
<h4 id="termcolor"><a class="header" href="#termcolor"><code>term.color</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: <code>"auto"</code></li>
<li>Environment: <code>CARGO_TERM_COLOR</code></li>
</ul>
<p>Controls whether or not colored output is used in the terminal. Possible values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>Can be overridden with the <code>--color</code> command-line option.</p>
<h4 id="termhyperlinks"><a class="header" href="#termhyperlinks"><code>term.hyperlinks</code></a></h4>
<ul>
<li>Type: bool</li>
<li>Default: auto-detect</li>
<li>Environment: <code>CARGO_TERM_HYPERLINKS</code></li>
</ul>
<p>Controls whether or not hyperlinks are used in the terminal.</p>
<h4 id="termunicode"><a class="header" href="#termunicode"><code>term.unicode</code></a></h4>
<ul>
<li>Type: bool</li>
<li>Default: auto-detect</li>
<li>Environment: <code>CARGO_TERM_UNICODE</code></li>
</ul>
<p>Control whether output can be rendered using non-ASCII unicode characters.</p>
<h4 id="termprogresswhen"><a class="header" href="#termprogresswhen"><code>term.progress.when</code></a></h4>
<ul>
<li>Type: string</li>
<li>Default: <code>"auto"</code></li>
<li>Environment: <code>CARGO_TERM_PROGRESS_WHEN</code></li>
</ul>
<p>Controls whether or not progress bar is shown in the terminal. Possible values:</p>
<ul>
<li><code>auto</code> (default): Intelligently guess whether to show progress bar.</li>
<li><code>always</code>: Always show progress bar.</li>
<li><code>never</code>: Never show progress bar.</li>
</ul>
<h4 id="termprogresswidth"><a class="header" href="#termprogresswidth"><code>term.progress.width</code></a></h4>
<ul>
<li>Type: integer</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TERM_PROGRESS_WIDTH</code></li>
</ul>
<p>Sets the width for progress bar.</p>
<h4 id="termprogressterm-integration"><a class="header" href="#termprogressterm-integration"><code>term.progress.term-integration</code></a></h4>
<ul>
<li>Type: bool</li>
<li>Default: auto-detect</li>
<li>Environment: <code>CARGO_TERM_PROGRESS_TERM_INTEGRATION</code></li>
</ul>
<p>Report progress to the terminal emulator for display in places like the task bar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h1>
<p>Cargo sets and reads a number of environment variables which your code can detect
or override. Here is a list of the variables Cargo sets, organized by when it interacts
with them:</p>
<h2 id="environment-variables-cargo-reads"><a class="header" href="#environment-variables-cargo-reads">Environment variables Cargo reads</a></h2>
<p>You can override these environment variables to change Cargo’s behavior on your
system:</p>
<ul>
<li><code>CARGO_LOG</code> — Cargo uses the <a href="https://docs.rs/tracing"><code>tracing</code></a> crate to display debug log messages.
The <code>CARGO_LOG</code> environment variable can be set to enable debug logging,
with a value such as <code>trace</code>, <code>debug</code>, or <code>warn</code>.
Usually it is only used during debugging. For more details refer to the
<a href="https://doc.crates.io/contrib/implementation/debugging.html#logging">Debug logging</a>.</li>
<li><code>CARGO_HOME</code> — Cargo maintains a local cache of the registry index and of
git checkouts of crates. By default these are stored under <code>$HOME/.cargo</code>
(<code>%USERPROFILE%\.cargo</code> on Windows), but this variable overrides the
location of this directory. Once a crate is cached it is not removed by the
clean command.
For more details refer to the <a href="reference/../guide/cargo-home.html">guide</a>.</li>
<li><code>CARGO_TARGET_DIR</code> — Location of where to place all generated artifacts,
relative to the current working directory. See <a href="reference/config.html#buildtarget-dir"><code>build.target-dir</code></a> to set
via config.</li>
<li><code>CARGO</code> — If set, Cargo will forward this value instead of setting it
to its own auto-detected path when it builds crates and when it
executes build scripts and external subcommands. This value is not
directly executed by Cargo, and should always point at a command that
behaves exactly like <code>cargo</code>, as that’s what users of the variable
will be expecting.</li>
<li><code>RUSTC</code> — Instead of running <code>rustc</code>, Cargo will execute this specified
compiler instead. See <a href="reference/config.html#buildrustc"><code>build.rustc</code></a> to set via config.</li>
<li><code>RUSTC_WRAPPER</code> — Instead of simply running <code>rustc</code>, Cargo will execute this
specified wrapper, passing as its command-line arguments the rustc
invocation, with the first argument being the path to the actual rustc.
Useful to set up a build cache tool such as <code>sccache</code>. See
<a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a> to set via config. Setting this to the empty string
overwrites the config and resets cargo to not use a wrapper.</li>
<li><code>RUSTC_WORKSPACE_WRAPPER</code> — Instead of simply running <code>rustc</code>, for workspace members Cargo will
execute this specified wrapper, passing as its command-line arguments the rustc invocation, with
the first argument being the path to the actual rustc. When building a single-package project
without workspaces, that package is considered to be the workspace. It affects the filename hash
so that artifacts produced by the wrapper are cached separately. See
<a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a> to set via config. Setting this to the empty string overwrites
the config and resets cargo to not use a wrapper for workspace members. If both <code>RUSTC_WRAPPER</code>
and <code>RUSTC_WORKSPACE_WRAPPER</code> are set, then they will be nested: the final invocation is
<code>$RUSTC_WRAPPER $RUSTC_WORKSPACE_WRAPPER $RUSTC</code>.</li>
<li><code>RUSTDOC</code> — Instead of running <code>rustdoc</code>, Cargo will execute this specified
<code>rustdoc</code> instance instead. See <a href="reference/config.html#buildrustdoc"><code>build.rustdoc</code></a> to set via config.</li>
<li><code>RUSTDOCFLAGS</code> — A space-separated list of custom flags to pass to all <code>rustdoc</code>
invocations that Cargo performs. In contrast with <a href="reference/../commands/cargo-rustdoc.html"><code>cargo rustdoc</code></a>, this is
useful for passing a flag to <em>all</em> <code>rustdoc</code> instances. See
<a href="reference/config.html#buildrustdocflags"><code>build.rustdocflags</code></a> for some more ways to set flags. This string is
split by whitespace; for a more robust encoding of multiple arguments,
see <code>CARGO_ENCODED_RUSTDOCFLAGS</code>.</li>
<li><code>CARGO_ENCODED_RUSTDOCFLAGS</code> —  A list of custom flags separated by <code>0x1f</code>
(ASCII Unit Separator) to pass to all <code>rustdoc</code> invocations that Cargo performs.</li>
<li><code>RUSTFLAGS</code> — A space-separated list of custom flags to pass to all compiler
invocations that Cargo performs. In contrast with <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a>, this is
useful for passing a flag to <em>all</em> compiler instances. See
<a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> for some more ways to set flags. This string is
split by whitespace; for a more robust encoding of multiple arguments,
see <code>CARGO_ENCODED_RUSTFLAGS</code>.</li>
<li><code>CARGO_ENCODED_RUSTFLAGS</code> — A list of custom flags separated by <code>0x1f</code>
(ASCII Unit Separator) to pass to all compiler invocations that Cargo performs.</li>
<li><code>CARGO_INCREMENTAL</code> — If this is set to 1 then Cargo will force <a href="reference/profiles.html#incremental">incremental
compilation</a> to be enabled for the current compilation, and when set to 0 it
will force disabling it. If this env var isn’t present then cargo’s defaults
will otherwise be used. See also <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> config value.</li>
<li><code>CARGO_CACHE_RUSTC_INFO</code> — If this is set to 0 then Cargo will not try to cache
compiler version information.</li>
<li><code>HTTPS_PROXY</code> or <code>https_proxy</code> or <code>http_proxy</code> — The HTTP proxy to use, see
<a href="reference/config.html#httpproxy"><code>http.proxy</code></a> for more detail.</li>
<li><code>HTTP_TIMEOUT</code> — The HTTP timeout in seconds, see <a href="reference/config.html#httptimeout"><code>http.timeout</code></a> for more
detail.</li>
<li><code>TERM</code> — If this is set to <code>dumb</code>, it disables the progress bar.</li>
<li><code>BROWSER</code> — The web browser to execute to open documentation with <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a>’s <code>--open</code> flag, see <a href="reference/config.html#docbrowser"><code>doc.browser</code></a> for more details.</li>
<li><code>RUSTFMT</code> — Instead of running <code>rustfmt</code>,
<a href="https://github.com/rust-lang/rustfmt"><code>cargo fmt</code></a> will execute this specified
<code>rustfmt</code> instance instead.</li>
</ul>
<h3 id="configuration-environment-variables"><a class="header" href="#configuration-environment-variables">Configuration environment variables</a></h3>
<p>Cargo reads environment variables for some configuration values.
See the <a href="reference/config.html#environment-variables">configuration chapter</a> for more details.
In summary, the supported environment variables are:</p>
<ul>
<li><code>CARGO_ALIAS_&lt;name&gt;</code> — Command aliases, see <a href="reference/config.html#alias"><code>alias</code></a>.</li>
<li><code>CARGO_BUILD_JOBS</code> — Number of parallel jobs, see <a href="reference/config.html#buildjobs"><code>build.jobs</code></a>.</li>
<li><code>CARGO_BUILD_RUSTC</code> — The <code>rustc</code> executable, see <a href="reference/config.html#buildrustc"><code>build.rustc</code></a>.</li>
<li><code>CARGO_BUILD_RUSTC_WRAPPER</code> — The <code>rustc</code> wrapper, see <a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a>.</li>
<li><code>CARGO_BUILD_RUSTC_WORKSPACE_WRAPPER</code> — The <code>rustc</code> wrapper for workspace members only, see <a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a>.</li>
<li><code>CARGO_BUILD_RUSTDOC</code> — The <code>rustdoc</code> executable, see <a href="reference/config.html#buildrustdoc"><code>build.rustdoc</code></a>.</li>
<li><code>CARGO_BUILD_TARGET</code> — The default target platform, see <a href="reference/config.html#buildtarget"><code>build.target</code></a>.</li>
<li><code>CARGO_BUILD_TARGET_DIR</code> — The default output directory, see <a href="reference/config.html#buildtarget-dir"><code>build.target-dir</code></a>.</li>
<li><code>CARGO_BUILD_BUILD_DIR</code> — The default build directory, see <a href="reference/config.html#buildbuild-dir"><code>build.build-dir</code></a>.</li>
<li><code>CARGO_BUILD_RUSTFLAGS</code> — Extra <code>rustc</code> flags, see <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a>.</li>
<li><code>CARGO_BUILD_RUSTDOCFLAGS</code> — Extra <code>rustdoc</code> flags, see <a href="reference/config.html#buildrustdocflags"><code>build.rustdocflags</code></a>.</li>
<li><code>CARGO_BUILD_INCREMENTAL</code> — Incremental compilation, see <a href="reference/config.html#buildincremental"><code>build.incremental</code></a>.</li>
<li><code>CARGO_BUILD_DEP_INFO_BASEDIR</code> — Dep-info relative directory, see <a href="reference/config.html#builddep-info-basedir"><code>build.dep-info-basedir</code></a>.</li>
<li><code>CARGO_CACHE_AUTO_CLEAN_FREQUENCY</code> — Configures how often automatic cache cleaning runs, see <a href="reference/config.html#cacheauto-clean-frequency"><code>cache.auto-clean-frequency</code></a>.</li>
<li><code>CARGO_CARGO_NEW_VCS</code> — The default source control system with <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a>, see <a href="reference/config.html#cargo-newvcs"><code>cargo-new.vcs</code></a>.</li>
<li><code>CARGO_FUTURE_INCOMPAT_REPORT_FREQUENCY</code> — How often we should generate a future incompat report notification, see <a href="reference/config.html#future-incompat-reportfrequency"><code>future-incompat-report.frequency</code></a>.</li>
<li><code>CARGO_HTTP_DEBUG</code> — Enables HTTP debugging, see <a href="reference/config.html#httpdebug"><code>http.debug</code></a>.</li>
<li><code>CARGO_HTTP_PROXY</code> — Enables HTTP proxy, see <a href="reference/config.html#httpproxy"><code>http.proxy</code></a>.</li>
<li><code>CARGO_HTTP_TIMEOUT</code> — The HTTP timeout, see <a href="reference/config.html#httptimeout"><code>http.timeout</code></a>.</li>
<li><code>CARGO_HTTP_CAINFO</code> — The TLS certificate Certificate Authority file, see <a href="reference/config.html#httpcainfo"><code>http.cainfo</code></a>.</li>
<li><code>CARGO_HTTP_PROXY_CAINFO</code> — The proxy TLS certificate Certificate Authority file, see <a href="reference/config.html#httpproxy-cainfo"><code>http.proxy-cainfo</code></a>.</li>
<li><code>CARGO_HTTP_CHECK_REVOKE</code> — Disables TLS certificate revocation checks, see <a href="reference/config.html#httpcheck-revoke"><code>http.check-revoke</code></a>.</li>
<li><code>CARGO_HTTP_SSL_VERSION</code> — The TLS version to use, see <a href="reference/config.html#httpssl-version"><code>http.ssl-version</code></a>.</li>
<li><code>CARGO_HTTP_LOW_SPEED_LIMIT</code> — The HTTP low-speed limit, see <a href="reference/config.html#httplow-speed-limit"><code>http.low-speed-limit</code></a>.</li>
<li><code>CARGO_HTTP_MULTIPLEXING</code> — Whether HTTP/2 multiplexing is used, see <a href="reference/config.html#httpmultiplexing"><code>http.multiplexing</code></a>.</li>
<li><code>CARGO_HTTP_USER_AGENT</code> — The HTTP user-agent header, see <a href="reference/config.html#httpuser-agent"><code>http.user-agent</code></a>.</li>
<li><code>CARGO_INSTALL_ROOT</code> — The default directory for <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>, see <a href="reference/config.html#installroot"><code>install.root</code></a>.</li>
<li><code>CARGO_NET_RETRY</code> — Number of times to retry network errors, see <a href="reference/config.html#netretry"><code>net.retry</code></a>.</li>
<li><code>CARGO_NET_GIT_FETCH_WITH_CLI</code> — Enables the use of the <code>git</code> executable to fetch, see <a href="reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a>.</li>
<li><code>CARGO_NET_OFFLINE</code> — Offline mode, see <a href="reference/config.html#netoffline"><code>net.offline</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_BUILD_OVERRIDE_&lt;key&gt;</code> — Override build script profile, see <a href="reference/config.html#profilenamebuild-override"><code>profile.&lt;name&gt;.build-override</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_CODEGEN_UNITS</code> — Set code generation units, see <a href="reference/config.html#profilenamecodegen-units"><code>profile.&lt;name&gt;.codegen-units</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_DEBUG</code> — What kind of debug info to include, see <a href="reference/config.html#profilenamedebug"><code>profile.&lt;name&gt;.debug</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_DEBUG_ASSERTIONS</code> — Enable/disable debug assertions, see <a href="reference/config.html#profilenamedebug-assertions"><code>profile.&lt;name&gt;.debug-assertions</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_INCREMENTAL</code> — Enable/disable incremental compilation, see <a href="reference/config.html#profilenameincremental"><code>profile.&lt;name&gt;.incremental</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_LTO</code> — Link-time optimization, see <a href="reference/config.html#profilenamelto"><code>profile.&lt;name&gt;.lto</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_OVERFLOW_CHECKS</code> — Enable/disable overflow checks, see <a href="reference/config.html#profilenameoverflow-checks"><code>profile.&lt;name&gt;.overflow-checks</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_OPT_LEVEL</code> — Set the optimization level, see <a href="reference/config.html#profilenameopt-level"><code>profile.&lt;name&gt;.opt-level</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_PANIC</code> — The panic strategy to use, see <a href="reference/config.html#profilenamepanic"><code>profile.&lt;name&gt;.panic</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_RPATH</code> — The rpath linking option, see <a href="reference/config.html#profilenamerpath"><code>profile.&lt;name&gt;.rpath</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_SPLIT_DEBUGINFO</code> — Controls debug file output behavior, see <a href="reference/config.html#profilenamesplit-debuginfo"><code>profile.&lt;name&gt;.split-debuginfo</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_STRIP</code> — Controls stripping of symbols and/or debuginfos, see <a href="reference/config.html#profilenamestrip"><code>profile.&lt;name&gt;.strip</code></a>.</li>
<li><code>CARGO_REGISTRIES_&lt;name&gt;_CREDENTIAL_PROVIDER</code> — Credential provider for a registry, see <a href="reference/config.html#registriesnamecredential-provider"><code>registries.&lt;name&gt;.credential-provider</code></a>.</li>
<li><code>CARGO_REGISTRIES_&lt;name&gt;_INDEX</code> — URL of a registry index, see <a href="reference/config.html#registriesnameindex"><code>registries.&lt;name&gt;.index</code></a>.</li>
<li><code>CARGO_REGISTRIES_&lt;name&gt;_TOKEN</code> — Authentication token of a registry, see <a href="reference/config.html#registriesnametoken"><code>registries.&lt;name&gt;.token</code></a>.</li>
<li><code>CARGO_REGISTRY_CREDENTIAL_PROVIDER</code> — Credential provider for <a href="https://crates.io/">crates.io</a>, see <a href="reference/config.html#registrycredential-provider"><code>registry.credential-provider</code></a>.</li>
<li><code>CARGO_REGISTRY_DEFAULT</code> — Default registry for the <code>--registry</code> flag, see <a href="reference/config.html#registrydefault"><code>registry.default</code></a>.</li>
<li><code>CARGO_REGISTRY_GLOBAL_CREDENTIAL_PROVIDERS</code> — Credential providers for registries that do not have a specific provider defined. See <a href="reference/config.html#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a>.</li>
<li><code>CARGO_REGISTRY_TOKEN</code> — Authentication token for <a href="https://crates.io/">crates.io</a>, see <a href="reference/config.html#registrytoken"><code>registry.token</code></a>.</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_LINKER</code> — The linker to use, see <a href="reference/config.html#targettriplelinker"><code>target.&lt;triple&gt;.linker</code></a>. The triple must be <a href="reference/config.html#environment-variables">converted to uppercase and underscores</a>.</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_RUNNER</code> — The executable runner, see <a href="reference/config.html#targettriplerunner"><code>target.&lt;triple&gt;.runner</code></a>.</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_RUSTFLAGS</code> — Extra <code>rustc</code> flags for a target, see <a href="reference/config.html#targettriplerustflags"><code>target.&lt;triple&gt;.rustflags</code></a>.</li>
<li><code>CARGO_TERM_QUIET</code> — Quiet mode, see <a href="reference/config.html#termquiet"><code>term.quiet</code></a>.</li>
<li><code>CARGO_TERM_VERBOSE</code> — The default terminal verbosity, see <a href="reference/config.html#termverbose"><code>term.verbose</code></a>.</li>
<li><code>CARGO_TERM_COLOR</code> — The default color mode, see <a href="reference/config.html#termcolor"><code>term.color</code></a>.</li>
<li><code>CARGO_TERM_PROGRESS_WHEN</code> — The default progress bar showing mode, see <a href="reference/config.html#termprogresswhen"><code>term.progress.when</code></a>.</li>
<li><code>CARGO_TERM_PROGRESS_WIDTH</code> — The default progress bar width, see <a href="reference/config.html#termprogresswidth"><code>term.progress.width</code></a>.</li>
</ul>
<h2 id="environment-variables-cargo-sets-for-crates"><a class="header" href="#environment-variables-cargo-sets-for-crates">Environment variables Cargo sets for crates</a></h2>
<p>Cargo exposes these environment variables to your crate when it is compiled.
Note that this applies for running binaries with <code>cargo run</code> and <code>cargo test</code>
as well. To get the value of any of these variables in a Rust program, do
this:</p>
<pre><code class="language-rust ignore">let version = env!("CARGO_PKG_VERSION");</code></pre>
<p><code>version</code> will now contain the value of <code>CARGO_PKG_VERSION</code>.</p>
<p>Note that if one of these values is not provided in the manifest, the
corresponding environment variable is set to the empty string, <code>""</code>.</p>
<ul>
<li><code>CARGO</code> — Path to the <code>cargo</code> binary performing the build.</li>
<li><code>CARGO_MANIFEST_DIR</code> — The directory containing the manifest of your package.</li>
<li><code>CARGO_MANIFEST_PATH</code> — The path to the manifest of your package.</li>
<li><code>CARGO_PKG_VERSION</code> — The full version of your package.</li>
<li><code>CARGO_PKG_VERSION_MAJOR</code> — The major version of your package.</li>
<li><code>CARGO_PKG_VERSION_MINOR</code> — The minor version of your package.</li>
<li><code>CARGO_PKG_VERSION_PATCH</code> — The patch version of your package.</li>
<li><code>CARGO_PKG_VERSION_PRE</code> — The pre-release version of your package.</li>
<li><code>CARGO_PKG_AUTHORS</code> — Colon separated list of authors from the manifest of your package.</li>
<li><code>CARGO_PKG_NAME</code> — The name of your package.</li>
<li><code>CARGO_PKG_DESCRIPTION</code> — The description from the manifest of your package.</li>
<li><code>CARGO_PKG_HOMEPAGE</code> — The home page from the manifest of your package.</li>
<li><code>CARGO_PKG_REPOSITORY</code> — The repository from the manifest of your package.</li>
<li><code>CARGO_PKG_LICENSE</code> — The license from the manifest of your package.</li>
<li><code>CARGO_PKG_LICENSE_FILE</code> — The license file from the manifest of your package.</li>
<li><code>CARGO_PKG_RUST_VERSION</code> — The Rust version from the manifest of your package.
Note that this is the minimum Rust version supported by the package, not the
current Rust version.</li>
<li><code>CARGO_PKG_README</code> — Path to the README file of your package.</li>
<li><code>CARGO_CRATE_NAME</code> — The name of the crate that is currently being compiled. It is the name of the <a href="reference/cargo-targets.html">Cargo target</a> with <code>-</code> converted to <code>_</code>, such as the name of the library, binary, example, integration test, or benchmark.</li>
<li><code>CARGO_BIN_NAME</code> — The name of the binary that is currently being compiled.
Only set for <a href="reference/cargo-targets.html#binaries">binaries</a> or binary <a href="reference/cargo-targets.html#examples">examples</a>. This name does not include any
file extension, such as <code>.exe</code>.</li>
<li><code>OUT_DIR</code> — If the package has a build script, this is set to the folder
where the build script should place its output. See below for more information.
(Only set during compilation.)</li>
<li><code>CARGO_BIN_EXE_&lt;name&gt;</code> — The absolute path to a binary target’s executable.
This is only set when building an <a href="reference/cargo-targets.html#integration-tests">integration test</a> or benchmark. This may
be used with the <a href="reference/../../std/macro.env.html"><code>env</code> macro</a> to find the executable to run for testing
purposes. The <code>&lt;name&gt;</code> is the name of the binary target, exactly as-is. For
example, <code>CARGO_BIN_EXE_my-program</code> for a binary named <code>my-program</code>.
Binaries are automatically built when the test is built, unless the binary
has required features that are not enabled.</li>
<li><code>CARGO_PRIMARY_PACKAGE</code> — This environment variable will be set if the
package being built is primary. Primary packages are the ones the user
selected on the command-line, either with <code>-p</code> flags or the defaults based
on the current directory and the default workspace members.
This variable will not be set when building dependencies,
unless a dependency is also a workspace member that was also selected on the command-line.
This is only set when compiling the package (not when running binaries or tests).</li>
<li><code>CARGO_TARGET_TMPDIR</code> — Only set when building <a href="reference/cargo-targets.html#integration-tests">integration test</a> or benchmark code.
This is a path to a directory inside the target directory
where integration tests or benchmarks are free to put any data needed by
the tests/benches. Cargo initially creates this directory but doesn’t
manage its content in any way, this is the responsibility of the test code.</li>
</ul>
<h3 id="dynamic-library-paths"><a class="header" href="#dynamic-library-paths">Dynamic library paths</a></h3>
<p>Cargo also sets the dynamic library path when compiling and running binaries
with commands like <code>cargo run</code> and <code>cargo test</code>. This helps with locating
shared libraries that are part of the build process. The variable name depends
on the platform:</p>
<ul>
<li>Windows: <code>PATH</code></li>
<li>macOS: <code>DYLD_FALLBACK_LIBRARY_PATH</code></li>
<li>Unix: <code>LD_LIBRARY_PATH</code></li>
<li>AIX: <code>LIBPATH</code></li>
</ul>
<p>The value is extended from the existing value when Cargo starts. macOS has
special consideration where if <code>DYLD_FALLBACK_LIBRARY_PATH</code> is not already
set, it will add the default <code>$HOME/lib:/usr/local/lib:/usr/lib</code>.</p>
<p>Cargo includes the following paths:</p>
<ul>
<li>Search paths included from any build script with the <a href="reference/build-scripts.html#rustc-link-search"><code>rustc-link-search</code>
instruction</a>. Paths outside of the
<code>target</code> directory are removed. It is the responsibility of the user running
Cargo to properly set the environment if additional libraries on the system
are needed in the search path.</li>
<li>The base output directory, such as <code>target/debug</code>, and the “deps” directory.
This is mostly for support of proc-macros.</li>
<li>The rustc sysroot library path. This generally is not important to most
users.</li>
</ul>
<h2 id="environment-variables-cargo-sets-for-build-scripts"><a class="header" href="#environment-variables-cargo-sets-for-build-scripts">Environment variables Cargo sets for build scripts</a></h2>
<p>Cargo sets several environment variables when build scripts are run. Because these variables
are not yet set when the build script is compiled, the above example using <code>env!</code> won’t work
and instead you’ll need to retrieve the values when the build script is run:</p>
<pre><code class="language-rust ignore">use std::env;
let out_dir = env::var("OUT_DIR").unwrap();</code></pre>
<p><code>out_dir</code> will now contain the value of <code>OUT_DIR</code>.</p>
<ul>
<li><code>CARGO</code> — Path to the <code>cargo</code> binary performing the build.</li>
<li><code>CARGO_MANIFEST_DIR</code> — The directory containing the manifest for the package
being built (the package containing the build script). Also note that this is
the value of the current working directory of the build script when it starts.</li>
<li><code>CARGO_MANIFEST_PATH</code> — The path to the manifest of your package.</li>
<li><code>CARGO_MANIFEST_LINKS</code> — the manifest <code>links</code> value.</li>
<li><code>CARGO_MAKEFLAGS</code> — Contains parameters needed for Cargo’s <a href="https://www.gnu.org/software/make/manual/html_node/Job-Slots.html">jobserver</a>
implementation to parallelize subprocesses. Rustc or cargo invocations from
build.rs can already read <code>CARGO_MAKEFLAGS</code>, but GNU Make requires the flags
to be specified either directly as arguments, or through the <code>MAKEFLAGS</code>
environment variable. Currently Cargo doesn’t set the <code>MAKEFLAGS</code> variable,
but it’s free for build scripts invoking GNU Make to set it to the contents
of <code>CARGO_MAKEFLAGS</code>.</li>
<li><code>CARGO_FEATURE_&lt;name&gt;</code> — For each activated feature of the package being built,
this environment variable will be present where <code>&lt;name&gt;</code> is the name of the
feature uppercased and having <code>-</code> translated to <code>_</code>.</li>
<li><code>CARGO_CFG_&lt;cfg&gt;</code> — For each <a href="reference/../../reference/conditional-compilation.html">configuration option</a> of the
package being built, this environment variable will contain the value of the
configuration, where <code>&lt;cfg&gt;</code> is the name of the configuration uppercased and
having <code>-</code> translated to <code>_</code>. Boolean configurations are present if they are
set, and not present otherwise. Configurations with multiple values are
joined to a single variable with the values delimited by <code>,</code>. This includes
values built-in to the compiler (which can be seen with <code>rustc --print=cfg</code>)
and values set by build scripts and extra flags passed to <code>rustc</code> (such as
those defined in <code>RUSTFLAGS</code>). Some examples of what these variables are:
<ul>
<li><code>CARGO_CFG_FEATURE</code> — Each activated feature of the package being built.</li>
<li><code>CARGO_CFG_UNIX</code> — Set on <a href="reference/../../reference/conditional-compilation.html#unix-and-windows">unix-like platforms</a>.</li>
<li><code>CARGO_CFG_WINDOWS</code> — Set on <a href="reference/../../reference/conditional-compilation.html#unix-and-windows">windows-like platforms</a>.</li>
<li><code>CARGO_CFG_TARGET_FAMILY=unix,wasm</code> — The <a href="reference/../../reference/conditional-compilation.html#target_family">target family</a>.</li>
<li><code>CARGO_CFG_TARGET_OS=macos</code> — The <a href="reference/../../reference/conditional-compilation.html#target_os">target operating system</a>.</li>
<li><code>CARGO_CFG_TARGET_ARCH=x86_64</code> — The CPU <a href="reference/../../reference/conditional-compilation.html#target_arch">target architecture</a>.</li>
<li><code>CARGO_CFG_TARGET_VENDOR=apple</code> — The <a href="reference/../../reference/conditional-compilation.html#target_vendor">target vendor</a>.</li>
<li><code>CARGO_CFG_TARGET_ENV=gnu</code> — The <a href="reference/../../reference/conditional-compilation.html#target_env">target environment</a> ABI.</li>
<li><code>CARGO_CFG_TARGET_ABI=eabihf</code> — The <a href="reference/../../reference/conditional-compilation.html#target_abi">target ABI</a>.</li>
<li><code>CARGO_CFG_TARGET_POINTER_WIDTH=64</code> — The CPU <a href="reference/../../reference/conditional-compilation.html#target_pointer_width">pointer width</a>.</li>
<li><code>CARGO_CFG_TARGET_ENDIAN=little</code> — The CPU <a href="reference/../../reference/conditional-compilation.html#target_endian">target endianness</a>.</li>
<li><code>CARGO_CFG_TARGET_FEATURE=mmx,sse</code> — List of CPU <a href="reference/../../reference/conditional-compilation.html#target_feature">target features</a> enabled.</li>
</ul>
<blockquote>
<p>Note that different <a href="reference/../appendix/glossary.html#target">target triples</a> have different sets of <code>cfg</code> values,
hence variables present in one target triple might not be available in the other.</p>
<p>Some cfg values like <code>debug_assertions</code> and <code>test</code> are not available.</p>
</blockquote>
</li>
<li><code>OUT_DIR</code> — the folder in which all output and intermediate artifacts should
be placed. This folder is inside the build directory for the package being built,
and it is unique for the package in question.</li>
<li><code>TARGET</code> — the target triple that is being compiled for. Native code should be
compiled for this triple. See the <a href="reference/../appendix/glossary.html#target">Target Triple</a> description for more information.</li>
<li><code>HOST</code> — the host triple of the Rust compiler.</li>
<li><code>NUM_JOBS</code> — the parallelism specified as the top-level parallelism. This can
be useful to pass a <code>-j</code> parameter to a system like <code>make</code>. Note that care
should be taken when interpreting this environment variable. For historical
purposes this is still provided but recent versions of Cargo, for example, do
not need to run <code>make -j</code>, and instead can set the <code>MAKEFLAGS</code> env var to the
content of <code>CARGO_MAKEFLAGS</code> to activate the use of Cargo’s GNU Make compatible
<a href="https://www.gnu.org/software/make/manual/html_node/Job-Slots.html">jobserver</a> for sub-make invocations.</li>
<li><code>OPT_LEVEL</code>, <code>DEBUG</code> — values of the corresponding variables for the profile currently being built.</li>
<li><code>PROFILE</code> — <code>release</code> for release builds, <code>debug</code> for other builds. This is
determined based on if the <a href="reference/profiles.html">profile</a> inherits from the <a href="reference/profiles.html#dev"><code>dev</code></a> or
<a href="reference/profiles.html#release"><code>release</code></a> profile. Using this environment variable is not recommended.
Using other environment variables like <code>OPT_LEVEL</code> provide a more correct
view of the actual settings being used.</li>
<li><code>DEP_&lt;name&gt;_&lt;key&gt;</code> — For more information about this set of environment variables,
see build script documentation about <a href="reference/build-scripts.html#the-links-manifest-key"><code>links</code></a>.</li>
<li><code>RUSTC</code>, <code>RUSTDOC</code> — the compiler and documentation generator that Cargo has
resolved to use, passed to the build script so it might use it as well.</li>
<li><code>RUSTC_WRAPPER</code> — the <code>rustc</code> wrapper, if any, that Cargo is using. See <a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a>.</li>
<li><code>RUSTC_WORKSPACE_WRAPPER</code> — the <code>rustc</code> wrapper, if any, that Cargo is using
for workspace members. See <a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a>.</li>
<li><code>RUSTC_LINKER</code> — The path to the linker binary that Cargo has resolved to use
for the current target, if specified. The linker can be changed by editing
<code>.cargo/config.toml</code>; see the documentation about <a href="reference/config.html">cargo configuration</a>
for more information.</li>
<li><code>CARGO_ENCODED_RUSTFLAGS</code> — extra flags that Cargo invokes <code>rustc</code> with,
separated by a <code>0x1f</code> character (ASCII Unit Separator). See
<a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a>. Note that since Rust 1.55, <code>RUSTFLAGS</code> is removed from
the environment; scripts should use <code>CARGO_ENCODED_RUSTFLAGS</code> instead.</li>
<li><code>CARGO_PKG_&lt;var&gt;</code> — The package information variables, with the same names and values as are <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">provided during crate building</a>.</li>
</ul>
<h2 id="environment-variables-cargo-sets-for-3rd-party-subcommands"><a class="header" href="#environment-variables-cargo-sets-for-3rd-party-subcommands">Environment variables Cargo sets for 3rd party subcommands</a></h2>
<p>Cargo exposes this environment variable to 3rd party subcommands
(ie. programs named <code>cargo-foobar</code> placed in <code>$PATH</code>):</p>
<ul>
<li><code>CARGO</code> — Path to the <code>cargo</code> binary performing the build.</li>
<li><code>CARGO_MAKEFLAGS</code> — Contains parameters needed for Cargo’s <a href="https://www.gnu.org/software/make/manual/html_node/Job-Slots.html">jobserver</a>
implementation to parallelize subprocesses.
This is set only when Cargo detects the existence of a jobserver.</li>
</ul>
<p>For extended information about your environment you may run <code>cargo metadata</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-scripts-1"><a class="header" href="#build-scripts-1">Build Scripts</a></h1>
<p>Some packages need to compile third-party non-Rust code, for example C
libraries. Other packages need to link to C libraries which can either be
located on the system or possibly need to be built from source. Others still
need facilities for functionality such as code generation before building (think
parser generators).</p>
<p>Cargo does not aim to replace other tools that are well-optimized for these
tasks, but it does integrate with them with custom build scripts. Placing a
file named <code>build.rs</code> in the root of a package will cause Cargo to compile
that script and execute it just before building the package.</p>
<pre><code class="language-rust ignore">// Example custom build script.
fn main() {
    // Tell Cargo that if the given file changes, to rerun this build script.
    println!("cargo::rerun-if-changed=src/hello.c");
    // Use the `cc` crate to build a C file and statically link it.
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
}</code></pre>
<p>Some example use cases of build scripts are:</p>
<ul>
<li>Building a bundled C library.</li>
<li>Finding a C library on the host system.</li>
<li>Generating a Rust module from a specification.</li>
<li>Performing any platform-specific configuration needed for the crate.</li>
</ul>
<p>The sections below describe how build scripts work, and the <a href="reference/build-script-examples.html">examples
chapter</a> shows a variety of examples on how to write
scripts.</p>
<blockquote>
<p>Note: The <a href="reference/manifest.html#the-build-field"><code>package.build</code> manifest key</a> can be
used to change the name of the build script, or disable it entirely.</p>
</blockquote>
<h2 id="life-cycle-of-a-build-script"><a class="header" href="#life-cycle-of-a-build-script">Life Cycle of a Build Script</a></h2>
<p>Just before a package is built, Cargo will compile a build script into an
executable (if it has not already been built). It will then run the script,
which may perform any number of tasks. The script may communicate with Cargo
by printing specially formatted commands prefixed with <code>cargo::</code> to stdout.</p>
<p>The build script will be rebuilt if any of its source files or dependencies
change.</p>
<p>By default, Cargo will re-run the build script if any of the files in the
package changes. Typically it is best to use the <code>rerun-if</code> commands,
described in the <a href="reference/build-scripts.html#change-detection">change detection</a> section below, to
narrow the focus of what triggers a build script to run again.</p>
<p>Once the build script successfully finishes executing, the rest of the package
will be compiled. Scripts should exit with a non-zero exit code to halt the
build if there is an error, in which case the build script’s output will be
displayed on the terminal.</p>
<h2 id="inputs-to-the-build-script"><a class="header" href="#inputs-to-the-build-script">Inputs to the Build Script</a></h2>
<p>When the build script is run, there are a number of inputs to the build script,
all passed in the form of <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">environment variables</a>.</p>
<p>In addition to environment variables, the build script’s current directory is
the source directory of the build script’s package.</p>
<h2 id="outputs-of-the-build-script"><a class="header" href="#outputs-of-the-build-script">Outputs of the Build Script</a></h2>
<p>Build scripts may save any output files or intermediate artifacts in the
directory specified in the <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts"><code>OUT_DIR</code> environment variable</a>. Scripts
should not modify any files outside of that directory.</p>
<p>Build scripts communicate with Cargo by printing to stdout. Cargo will
interpret each line that starts with <code>cargo::</code> as an instruction that will
influence compilation of the package. All other lines are ignored.</p>
<blockquote>
<p>The order of <code>cargo::</code> instructions printed by the build script <em>may</em>
affect the order of arguments that <code>cargo</code> passes to <code>rustc</code>. In turn, the
order of arguments passed to <code>rustc</code> may affect the order of arguments passed
to the linker. Therefore, you will want to pay attention to the order of the
build script’s instructions. For example, if object <code>foo</code> needs to link against
library <code>bar</code>, you may want to make sure that library <code>bar</code>’s
<a href="reference/build-scripts.html#rustc-link-lib"><code>cargo::rustc-link-lib</code></a> instruction appears <em>after</em>
instructions to link object <code>foo</code>.</p>
</blockquote>
<p>The output of the script is hidden from the terminal during normal
compilation. If you would like to see the output directly in your terminal,
invoke Cargo as “very verbose” with the <code>-vv</code> flag. This only happens when the
build script is run. If Cargo determines nothing has changed, it will not
re-run the script, see <a href="reference/build-scripts.html#change-detection">change detection</a> below for more.</p>
<p>All the lines printed to stdout by a build script are written to a file like
<code>target/debug/build/&lt;pkg&gt;/output</code> (the precise location may depend on your
configuration). The stderr output is also saved in that same directory.</p>
<p>The following is a summary of the instructions that Cargo recognizes, with each
one detailed below.</p>
<ul>
<li><a href="reference/build-scripts.html#rerun-if-changed"><code>cargo::rerun-if-changed=PATH</code></a> — Tells Cargo when to
re-run the script.</li>
<li><a href="reference/build-scripts.html#rerun-if-env-changed"><code>cargo::rerun-if-env-changed=VAR</code></a> — Tells Cargo when
to re-run the script.</li>
<li><a href="reference/build-scripts.html#rustc-link-arg"><code>cargo::rustc-link-arg=FLAG</code></a> — Passes custom flags to a
linker for benchmarks, binaries, <code>cdylib</code> crates, examples, and tests.</li>
<li><a href="reference/build-scripts.html#rustc-cdylib-link-arg"><code>cargo::rustc-link-arg-cdylib=FLAG</code></a> — Passes custom
flags to a linker for cdylib crates.</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-bin"><code>cargo::rustc-link-arg-bin=BIN=FLAG</code></a> — Passes custom
flags to a linker for the binary <code>BIN</code>.</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-bins"><code>cargo::rustc-link-arg-bins=FLAG</code></a> — Passes custom
flags to a linker for binaries.</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-tests"><code>cargo::rustc-link-arg-tests=FLAG</code></a> — Passes custom
flags to a linker for tests.</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-examples"><code>cargo::rustc-link-arg-examples=FLAG</code></a> — Passes custom
flags to a linker for examples.</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-benches"><code>cargo::rustc-link-arg-benches=FLAG</code></a> — Passes custom
flags to a linker for benchmarks.</li>
<li><a href="reference/build-scripts.html#rustc-link-lib"><code>cargo::rustc-link-lib=LIB</code></a> — Adds a library to
link.</li>
<li><a href="reference/build-scripts.html#rustc-link-search"><code>cargo::rustc-link-search=[KIND=]PATH</code></a> — Adds to the
library search path.</li>
<li><a href="reference/build-scripts.html#rustc-flags"><code>cargo::rustc-flags=FLAGS</code></a> — Passes certain flags to the
compiler.</li>
<li><a href="reference/build-scripts.html#rustc-cfg"><code>cargo::rustc-cfg=KEY[="VALUE"]</code></a> — Enables compile-time <code>cfg</code>
settings.</li>
<li><a href="reference/build-scripts.html#rustc-check-cfg"><code>cargo::rustc-check-cfg=CHECK_CFG</code></a> – Register custom <code>cfg</code>s as
expected for compile-time checking of configs.</li>
<li><a href="reference/build-scripts.html#rustc-env"><code>cargo::rustc-env=VAR=VALUE</code></a> — Sets an environment variable.</li>
</ul>
<ul>
<li><a href="reference/build-scripts.html#cargo-error"><code>cargo::error=MESSAGE</code></a> — Displays an error on the terminal.</li>
</ul>
<ul>
<li><a href="reference/build-scripts.html#cargo-warning"><code>cargo::warning=MESSAGE</code></a> — Displays a warning on the
terminal.</li>
<li><a href="reference/build-scripts.html#the-links-manifest-key"><code>cargo::metadata=KEY=VALUE</code></a> — Metadata, used by <code>links</code>
scripts.</li>
</ul>
<blockquote>
<p><strong>MSRV:</strong> 1.77 is required for <code>cargo::KEY=VALUE</code> syntax.
To support older versions, use the <code>cargo:KEY=VALUE</code> syntax.</p>
</blockquote>
<h3 id="rustc-link-arg"><a class="header" href="#rustc-link-arg"><code>cargo::rustc-link-arg=FLAG</code></a></h3>
<p>The <code>rustc-link-arg</code> instruction tells Cargo to pass the <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code>
option</a> to the compiler, but only when building supported targets
(benchmarks, binaries, <code>cdylib</code> crates, examples, and tests). Its usage is
highly platform specific. It is useful to set the shared library version or
linker script.</p>
<h3 id="rustc-cdylib-link-arg"><a class="header" href="#rustc-cdylib-link-arg"><code>cargo::rustc-link-arg-cdylib=FLAG</code></a></h3>
<p>The <code>rustc-link-arg-cdylib</code> instruction tells Cargo to pass the <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> to the compiler, but only when building a
<code>cdylib</code> library target. Its usage is highly platform specific. It is useful
to set the shared library version or the runtime-path.</p>
<p>For historical reasons, the <code>cargo::rustc-cdylib-link-arg</code> form is an alias
for <code>cargo::rustc-link-arg-cdylib</code>, and has the same meaning.</p>
<h3 id="rustc-link-arg-bin"><a class="header" href="#rustc-link-arg-bin"><code>cargo::rustc-link-arg-bin=BIN=FLAG</code></a></h3>
<p>The <code>rustc-link-arg-bin</code> instruction tells Cargo to pass the <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> to the compiler, but only when building
the binary target with name <code>BIN</code>. Its usage is highly platform specific. It is useful
to set a linker script or other linker options.</p>
<h3 id="rustc-link-arg-bins"><a class="header" href="#rustc-link-arg-bins"><code>cargo::rustc-link-arg-bins=FLAG</code></a></h3>
<p>The <code>rustc-link-arg-bins</code> instruction tells Cargo to pass the <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> to the compiler, but only when building a
binary target. Its usage is highly platform specific. It is useful
to set a linker script or other linker options.</p>
<h3 id="rustc-link-arg-tests"><a class="header" href="#rustc-link-arg-tests"><code>cargo::rustc-link-arg-tests=FLAG</code></a></h3>
<p>The <code>rustc-link-arg-tests</code> instruction tells Cargo to pass the <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> to the compiler, but only when building a
tests target.</p>
<h3 id="rustc-link-arg-examples"><a class="header" href="#rustc-link-arg-examples"><code>cargo::rustc-link-arg-examples=FLAG</code></a></h3>
<p>The <code>rustc-link-arg-examples</code> instruction tells Cargo to pass the <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> to the compiler, but only when building an examples
target.</p>
<h3 id="rustc-link-arg-benches"><a class="header" href="#rustc-link-arg-benches"><code>cargo::rustc-link-arg-benches=FLAG</code></a></h3>
<p>The <code>rustc-link-arg-benches</code> instruction tells Cargo to pass the <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> to the compiler, but only when building a benchmark
target.</p>
<h3 id="rustc-link-lib"><a class="header" href="#rustc-link-lib"><code>cargo::rustc-link-lib=LIB</code></a></h3>
<p>The <code>rustc-link-lib</code> instruction tells Cargo to link the given library using
the compiler’s <a href="reference/../../rustc/command-line-arguments.html#option-l-link-lib"><code>-l</code> flag</a>. This is typically used to link a
native library using <a href="reference/../../nomicon/ffi.html">FFI</a>.</p>
<p>The <code>LIB</code> string is passed directly to rustc, so it supports any syntax that
<code>-l</code> does. <br />
Currently the fully supported syntax for <code>LIB</code> is <code>[KIND[:MODIFIERS]=]NAME[:RENAME]</code>.</p>
<p>The <code>-l</code> flag is only passed to the library target of the package, unless
there is no library target, in which case it is passed to all targets. This is
done because all other targets have an implicit dependency on the library
target, and the given library to link should only be included once. This means
that if a package has both a library and a binary target, the <em>library</em> has
access to the symbols from the given lib, and the binary should access them
through the library target’s public API.</p>
<p>The optional <code>KIND</code> may be one of <code>dylib</code>, <code>static</code>, or <code>framework</code>. See the
<a href="reference/../../rustc/command-line-arguments.html#option-l-link-lib">rustc book</a> for more detail.</p>
<h3 id="rustc-link-search"><a class="header" href="#rustc-link-search"><code>cargo::rustc-link-search=[KIND=]PATH</code></a></h3>
<p>The <code>rustc-link-search</code> instruction tells Cargo to pass the <a href="reference/../../rustc/command-line-arguments.html#option-l-search-path"><code>-L</code>
flag</a> to the compiler to add a directory to the library search
path.</p>
<p>The optional <code>KIND</code> may be one of <code>dependency</code>, <code>crate</code>, <code>native</code>,
<code>framework</code>, or <code>all</code>. See the <a href="reference/../../rustc/command-line-arguments.html#option-l-search-path">rustc book</a> for more detail.</p>
<p>These paths are also added to the <a href="reference/environment-variables.html#dynamic-library-paths">dynamic library search path environment
variable</a> if they are within
the <code>OUT_DIR</code>. Depending on this behavior is discouraged since this makes it
difficult to use the resulting binary. In general, it is best to avoid
creating dynamic libraries in a build script (using existing system libraries
is fine).</p>
<h3 id="rustc-flags"><a class="header" href="#rustc-flags"><code>cargo::rustc-flags=FLAGS</code></a></h3>
<p>The <code>rustc-flags</code> instruction tells Cargo to pass the given space-separated
flags to the compiler. This only allows the <code>-l</code> and <code>-L</code> flags, and is
equivalent to using <a href="reference/build-scripts.html#rustc-link-lib"><code>rustc-link-lib</code></a> and
<a href="reference/build-scripts.html#rustc-link-search"><code>rustc-link-search</code></a>.</p>
<h3 id="rustc-cfg"><a class="header" href="#rustc-cfg"><code>cargo::rustc-cfg=KEY[="VALUE"]</code></a></h3>
<p>The <code>rustc-cfg</code> instruction tells Cargo to pass the given value to the
<a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> flag</a> to the compiler. This may be used for compile-time
detection of features to enable <a href="reference/../../reference/conditional-compilation.html">conditional compilation</a>. Custom cfgs
must either be expected using the <a href="reference/build-scripts.html#rustc-check-cfg"><code>cargo::rustc-check-cfg</code></a>
instruction or usage will need to allow the <a href="reference/../../rustc/lints/listing/warn-by-default.html#unexpected-cfgs"><code>unexpected_cfgs</code></a>
lint to avoid unexpected cfgs warnings.</p>
<p>Note that this does <em>not</em> affect Cargo’s dependency resolution. This cannot be
used to enable an optional dependency, or enable other Cargo features.</p>
<p>Be aware that <a href="reference/features.html">Cargo features</a> use the form <code>feature="foo"</code>. <code>cfg</code> values
passed with this flag are not restricted to that form, and may provide just a
single identifier, or any arbitrary key/value pair. For example, emitting
<code>cargo::rustc-cfg=abc</code> will then allow code to use <code>#[cfg(abc)]</code> (note the lack
of <code>feature=</code>). Or an arbitrary key/value pair may be used with an <code>=</code> symbol
like <code>cargo::rustc-cfg=my_component="foo"</code>. The key should be a Rust
identifier, the value should be a string.</p>
<h3 id="rustc-check-cfg"><a class="header" href="#rustc-check-cfg"><code>cargo::rustc-check-cfg=CHECK_CFG</code></a></h3>
<p>Add to the list of expected config names and values that is used when checking
the <em>reachable</em> cfg expressions with the <a href="reference/../../rustc/lints/listing/warn-by-default.html#unexpected-cfgs"><code>unexpected_cfgs</code></a> lint.</p>
<p>The syntax of <code>CHECK_CFG</code> mirrors the <code>rustc</code> <a href="reference/../../rustc/command-line-arguments.html#option-check-cfg"><code>--check-cfg</code> flag</a>, see
<a href="reference/../../rustc/check-cfg.html">Checking conditional configurations</a> for more details.</p>
<p>The instruction can be used like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build.rs
println!("cargo::rustc-check-cfg=cfg(foo, values(\"bar\"))");
if foo_bar_condition {
    println!("cargo::rustc-cfg=foo=\"bar\"");
}
<span class="boring">}</span></code></pre></pre>
<p>Note that all possible cfgs should be defined, regardless of which cfgs are
currently enabled. This includes all possible values of a given cfg name.</p>
<p>It is recommended to group the <code>cargo::rustc-check-cfg</code> and
<a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>cargo::rustc-cfg</code></a> instructions as closely as possible in order to
avoid typos, missing check-cfg, stale cfgs…</p>
<p>See also the
<a href="reference/build-script-examples.html#conditional-compilation">conditional compilation</a> example.</p>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.80</p>
</blockquote>
<h3 id="rustc-env"><a class="header" href="#rustc-env"><code>cargo::rustc-env=VAR=VALUE</code></a></h3>
<p>The <code>rustc-env</code> instruction tells Cargo to set the given environment variable
when compiling the package. The value can be then retrieved by the <a href="reference/../../std/macro.env.html"><code>env!</code>
macro</a> in the compiled crate. This is useful for embedding
additional metadata in crate’s code, such as the hash of git HEAD or the
unique identifier of a continuous integration server.</p>
<p>See also the <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variables automatically included by
Cargo</a>.</p>
<blockquote>
<p><strong>Note</strong>: These environment variables are also set when running an
executable with <code>cargo run</code> or <code>cargo test</code>. However, this usage is
discouraged since it ties the executable to Cargo’s execution environment.
Normally, these environment variables should only be checked at compile-time
with the <code>env!</code> macro.</p>
</blockquote>
<h3 id="cargo-error"><a class="header" href="#cargo-error"><code>cargo::error=MESSAGE</code></a></h3>
<p>The <code>error</code> instruction tells Cargo to display an error after the build script
has finished running, and then fail the build.</p>
<blockquote>
<p>Note: Build script libraries should carefully consider if they want to
use <code>cargo::error</code> versus returning a <code>Result</code>. It may be better to return
a <code>Result</code>, and allow the caller to decide if the error is fatal or not.
The caller can then decide whether or not to display the <code>Err</code> variant
using <code>cargo::error</code>.</p>
</blockquote>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.84</p>
</blockquote>
<h3 id="cargo-warning"><a class="header" href="#cargo-warning"><code>cargo::warning=MESSAGE</code></a></h3>
<p>The <code>warning</code> instruction tells Cargo to display a warning after the build
script has finished running. Warnings are only shown for <code>path</code> dependencies
(that is, those you’re working on locally), so for example warnings printed
out in <a href="https://crates.io/">crates.io</a> crates are not emitted by default, unless the build fails.
The <code>-vv</code> “very verbose” flag may be used to have Cargo display warnings for
all crates.</p>
<h2 id="build-dependencies-2"><a class="header" href="#build-dependencies-2">Build Dependencies</a></h2>
<p>Build scripts are also allowed to have dependencies on other Cargo-based crates.
Dependencies are declared through the <code>build-dependencies</code> section of the
manifest.</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0.46"
</code></pre>
<p>The build script <strong>does not</strong> have access to the dependencies listed in the
<code>dependencies</code> or <code>dev-dependencies</code> section (they’re not built yet!). Also,
build dependencies are not available to the package itself unless also
explicitly added in the <code>[dependencies]</code> table.</p>
<p>It is recommended to carefully consider each dependency you add, weighing
against the impact on compile time, licensing, maintenance, etc. Cargo will
attempt to reuse a dependency if it is shared between build dependencies and
normal dependencies. However, this is not always possible, for example when
cross-compiling, so keep that in consideration of the impact on compile time.</p>
<h2 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h2>
<p>When rebuilding a package, Cargo does not necessarily know if the build script
needs to be run again. By default, it takes a conservative approach of always
re-running the build script if any file within the package is changed (or the
list of files controlled by the <a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code> and <code>include</code> fields</a>). For most
cases, this is not a good choice, so it is recommended that every build script
emit at least one of the <code>rerun-if</code> instructions (described below). If these
are emitted, then Cargo will only re-run the script if the given value has
changed. If Cargo is re-running the build scripts of your own crate or a
dependency and you don’t know why, see <a href="reference/../faq.html#why-is-cargo-rebuilding-my-code">“Why is Cargo rebuilding my code?” in the
FAQ</a>.</p>
<h3 id="rerun-if-changed"><a class="header" href="#rerun-if-changed"><code>cargo::rerun-if-changed=PATH</code></a></h3>
<p>The <code>rerun-if-changed</code> instruction tells Cargo to re-run the build script if
the file at the given path has changed. Currently, Cargo only uses the
filesystem last-modified “mtime” timestamp to determine if the file has
changed. It compares against an internal cached timestamp of when the build
script last ran.</p>
<p>If the path points to a directory, it will scan the entire directory for
any modifications.</p>
<p>If the build script inherently does not need to re-run under any circumstance,
then emitting <code>cargo::rerun-if-changed=build.rs</code> is a simple way to prevent it
from being re-run (otherwise, the default if no <code>rerun-if</code> instructions are
emitted is to scan the entire package directory for changes). Cargo
automatically handles whether or not the script itself needs to be recompiled,
and of course the script will be re-run after it has been recompiled.
Otherwise, specifying <code>build.rs</code> is redundant and unnecessary.</p>
<h3 id="rerun-if-env-changed"><a class="header" href="#rerun-if-env-changed"><code>cargo::rerun-if-env-changed=NAME</code></a></h3>
<p>The <code>rerun-if-env-changed</code> instruction tells Cargo to re-run the build script
if the value of an environment variable of the given name has changed.</p>
<p>Note that the environment variables here are intended for global environment
variables like <code>CC</code> and such, it is not possible to use this for environment
variables like <code>TARGET</code> that <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">Cargo sets for build scripts</a>. The
environment variables in use are those received by <code>cargo</code> invocations, not
those received by the executable of the build script.</p>
<p>As of 1.46, using <a href="reference/../../std/macro.env.html"><code>env!</code></a> and <a href="reference/../../std/macro.option_env.html"><code>option_env!</code></a> in
source code will automatically detect changes and trigger rebuilds.
<code>rerun-if-env-changed</code> is no longer needed for variables already referenced by
these macros.</p>
<h2 id="the-links-manifest-key"><a class="header" href="#the-links-manifest-key">The <code>links</code> Manifest Key</a></h2>
<p>The <code>package.links</code> key may be set in the <code>Cargo.toml</code> manifest to declare
that the package links with the given native library. The purpose of this
manifest key is to give Cargo an understanding about the set of native
dependencies that a package has, as well as providing a principled system of
passing metadata between package build scripts.</p>
<pre><code class="language-toml">[package]
# ...
links = "foo"
</code></pre>
<p>This manifest states that the package links to the <code>libfoo</code> native library.
When using the <code>links</code> key, the package must have a build script, and the
build script should use the <a href="reference/build-scripts.html#rustc-link-lib"><code>rustc-link-lib</code> instruction</a> to
link the library.</p>
<p>Primarily, Cargo requires that there is at most one package per <code>links</code> value.
In other words, it is forbidden to have two packages link to the same native
library. This helps prevent duplicate symbols between crates. Note, however,
that there are <a href="reference/build-scripts.html#-sys-packages">conventions in place</a> to alleviate this.</p>
<p>Build scripts can generate an arbitrary set of metadata in the form of
key-value pairs. This metadata is set with the <code>cargo::metadata=KEY=VALUE</code>
instruction.</p>
<p>The metadata is passed to the build scripts of <strong>dependent</strong> packages. For
example, if the package <code>foo</code> depends on <code>bar</code>, which links <code>baz</code>, then if
<code>bar</code> generates <code>key=value</code> as part of its build script metadata, then the
build script of <code>foo</code> will have the environment variables <code>DEP_BAZ_KEY=value</code>
(note that the value of the <code>links</code> key is used).
See the <a href="reference/build-script-examples.html#using-another-sys-crate">“Using another <code>sys</code> crate”</a> for an example of
how this can be used.</p>
<p>Note that metadata is only passed to immediate dependents, not transitive
dependents.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.77 is required for <code>cargo::metadata=KEY=VALUE</code>.
To support older versions, use <code>cargo:KEY=VALUE</code> (unsupported directives are assumed to be metadata keys).</p>
</blockquote>
<h2 id="-sys-packages"><a class="header" href="#-sys-packages"><code>*-sys</code> Packages</a></h2>
<p>Some Cargo packages that link to system libraries have a naming convention of
having a <code>-sys</code> suffix. Any package named <code>foo-sys</code> should provide two major
pieces of functionality:</p>
<ul>
<li>The library crate should link to the native library <code>libfoo</code>. This will often
probe the current system for <code>libfoo</code> before resorting to building from
source.</li>
<li>The library crate should provide <strong>declarations</strong> for types and functions in
<code>libfoo</code>, but <strong>not</strong> higher-level abstractions.</li>
</ul>
<p>The set of <code>*-sys</code> packages provides a common set of dependencies for linking
to native libraries. There are a number of benefits earned from having this
convention of native-library-related packages:</p>
<ul>
<li>Common dependencies on <code>foo-sys</code> alleviates the rule about one package per
value of <code>links</code>.</li>
<li>Other <code>-sys</code> packages can take advantage of the <code>DEP_NAME_KEY=value</code>
environment variables to better integrate with other packages. See the
<a href="reference/build-script-examples.html#using-another-sys-crate">“Using another <code>sys</code> crate”</a> example.</li>
<li>A common dependency allows centralizing logic on discovering <code>libfoo</code> itself
(or building it from source).</li>
<li>These dependencies are easily <a href="reference/build-scripts.html#overriding-build-scripts">overridable</a>.</li>
</ul>
<p>It is common to have a companion package without the <code>-sys</code> suffix that
provides a safe, high-level abstractions on top of the sys package. For
example, the <a href="https://crates.io/crates/git2"><code>git2</code> crate</a> provides a high-level interface to the
<a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code> crate</a>.</p>
<h2 id="overriding-build-scripts"><a class="header" href="#overriding-build-scripts">Overriding Build Scripts</a></h2>
<p>If a manifest contains a <code>links</code> key, then Cargo supports overriding the build
script specified with a custom library. The purpose of this functionality is to
prevent running the build script in question altogether and instead supply the
metadata ahead of time.</p>
<p>To override a build script, place the following configuration in any acceptable <a href="reference/config.html"><code>config.toml</code></a> file.</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = "-L /some/path"
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["…"]
metadata_key1 = "value"
metadata_key2 = "value"
</code></pre>
<p>With this configuration, if a package declares that it links to <code>foo</code> then the
build script will <strong>not</strong> be compiled or run, and the metadata specified will
be used instead.</p>
<p>The <code>warning</code>, <code>rerun-if-changed</code>, and <code>rerun-if-env-changed</code> keys should not
be used and will be ignored.</p>
<h2 id="jobserver"><a class="header" href="#jobserver">Jobserver</a></h2>
<p>Cargo and <code>rustc</code> use the <a href="http://make.mad-scientist.net/papers/jobserver-implementation/">jobserver protocol</a>, developed for GNU make, to
coordinate concurrency across processes. It is essentially a semaphore that
controls the number of jobs running concurrently. The concurrency may be set
with the <code>--jobs</code> flag, which defaults to the number of logical CPUs.</p>
<p>Each build script inherits one job slot from Cargo, and should endeavor to
only use one CPU while it runs. If the script wants to use more CPUs in
parallel, it should use the <a href="https://crates.io/crates/jobserver"><code>jobserver</code> crate</a> to coordinate with Cargo.</p>
<p>As an example, the <a href="https://crates.io/crates/cc"><code>cc</code> crate</a> may enable the optional <code>parallel</code> feature
which will use the jobserver protocol to attempt to build multiple C files
at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-script-examples"><a class="header" href="#build-script-examples">Build Script Examples</a></h1>
<p>The following sections illustrate some examples of writing build scripts.</p>
<p>Some common build script functionality can be found via crates on <a href="https://crates.io/">crates.io</a>.
Check out the <a href="https://crates.io/keywords/build-dependencies"><code>build-dependencies</code>
keyword</a> to see what is
available. The following is a sample of some popular crates<sup class="footnote-reference" id="fr-†-1"><a href="#footnote-†">1</a></sup>:</p>
<ul>
<li><a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> — Automatically generate Rust
FFI bindings to C libraries.</li>
<li><a href="https://crates.io/crates/cc"><code>cc</code></a> — Compiles C/C++/assembly.</li>
<li><a href="https://crates.io/crates/pkg-config"><code>pkg-config</code></a> — Detect system
libraries using the <code>pkg-config</code> utility.</li>
<li><a href="https://crates.io/crates/cmake"><code>cmake</code></a> — Runs the <code>cmake</code> build tool to build a native library.</li>
<li><a href="https://crates.io/crates/autocfg"><code>autocfg</code></a>,
<a href="https://crates.io/crates/rustc_version"><code>rustc_version</code></a>,
<a href="https://crates.io/crates/version_check"><code>version_check</code></a> — These crates
provide ways to implement conditional compilation based on the current
<code>rustc</code> such as the version of the compiler.</li>
</ul>
<h2 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h2>
<p>Some Cargo packages need to have code generated just before they are compiled
for various reasons. Here we’ll walk through a simple example which generates a
library call as part of the build script.</p>
<p>First, let’s take a look at the directory structure of this package:</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    └── main.rs

1 directory, 3 files
</code></pre>
<p>Here we can see that we have a <code>build.rs</code> build script and our binary in
<code>main.rs</code>. This package has a basic manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "hello-from-generated-code"
version = "0.1.0"
edition = "2024"
</code></pre>
<p>Let’s see what’s inside the build script:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&amp;out_dir).join("hello.rs");
    fs::write(
        &amp;dest_path,
        "pub fn message() -&gt; &amp;'static str {
            \"Hello, World!\"
        }
        "
    ).unwrap();
    println!("cargo::rerun-if-changed=build.rs");
}</code></pre></pre>
<p>There’s a couple of points of note here:</p>
<ul>
<li>The script uses the <code>OUT_DIR</code> environment variable to discover where the
output files should be located. It can use the process’ current working
directory to find where the input files should be located, but in this case we
don’t have any input files.</li>
<li>In general, build scripts should not modify any files outside of <code>OUT_DIR</code>.
It may seem fine on the first blush, but it does cause problems when you use
such crate as a dependency, because there’s an <em>implicit</em> invariant that
sources in <code>.cargo/registry</code> should be immutable. <code>cargo</code> won’t allow such
scripts when packaging.</li>
<li>This script is relatively simple as it just writes out a small generated file.
One could imagine that other more complex operations could take place such as
generating a Rust module from a C header file or another language definition,
for example.</li>
<li>The <a href="reference/build-scripts.html#rerun-if-changed"><code>rerun-if-changed</code> instruction</a>
tells Cargo that the build script only needs to re-run if the build script
itself changes. Without this line, Cargo will automatically run the build
script if any file in the package changes. If your code generation uses some
input files, this is where you would print a list of each of those files.</li>
</ul>
<p>Next, let’s peek at the library itself:</p>
<pre><code class="language-rust ignore">// src/main.rs

include!(concat!(env!("OUT_DIR"), "/hello.rs"));

fn main() {
    println!("{}", message());
}</code></pre>
<p>This is where the real magic happens. The library is using the rustc-defined
<a href="reference/../../std/macro.include.html"><code>include!</code> macro</a> in combination with the
<a href="reference/../../std/macro.concat.html"><code>concat!</code></a> and <a href="reference/../../std/macro.env.html"><code>env!</code></a> macros to include the
generated file (<code>hello.rs</code>) into the crate’s compilation.</p>
<p>Using the structure shown here, crates can include any number of generated files
from the build script itself.</p>
<h2 id="building-a-native-library"><a class="header" href="#building-a-native-library">Building a native library</a></h2>
<p>Sometimes it’s necessary to build some native C or C++ code as part of a
package. This is another excellent use case of leveraging the build script to
build a native library before the Rust crate itself. As an example, we’ll create
a Rust library which calls into C to print “Hello, World!”.</p>
<p>Like above, let’s first take a look at the package layout:</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    ├── hello.c
    └── main.rs

1 directory, 4 files
</code></pre>
<p>Pretty similar to before! Next, the manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "hello-world-from-c"
version = "0.1.0"
edition = "2024"
</code></pre>
<p>For now we’re not going to use any build dependencies, so let’s take a look at
the build script now:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::process::Command;
use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();

    // Note that there are a number of downsides to this approach, the comments
    // below detail how to improve the portability of these commands.
    Command::new("gcc").args(&amp;["src/hello.c", "-c", "-fPIC", "-o"])
                       .arg(&amp;format!("{}/hello.o", out_dir))
                       .status().unwrap();
    Command::new("ar").args(&amp;["crus", "libhello.a", "hello.o"])
                      .current_dir(&amp;Path::new(&amp;out_dir))
                      .status().unwrap();

    println!("cargo::rustc-link-search=native={}", out_dir);
    println!("cargo::rustc-link-lib=static=hello");
    println!("cargo::rerun-if-changed=src/hello.c");
}</code></pre></pre>
<p>This build script starts out by compiling our C file into an object file (by
invoking <code>gcc</code>) and then converting this object file into a static library (by
invoking <code>ar</code>). The final step is feedback to Cargo itself to say that our
output was in <code>out_dir</code> and the compiler should link the crate to <code>libhello.a</code>
statically via the <code>-l static=hello</code> flag.</p>
<p>Note that there are a number of drawbacks to this hard-coded approach:</p>
<ul>
<li>The <code>gcc</code> command itself is not portable across platforms. For example it’s
unlikely that Windows platforms have <code>gcc</code>, and not even all Unix platforms
may have <code>gcc</code>. The <code>ar</code> command is also in a similar situation.</li>
<li>These commands do not take cross-compilation into account. If we’re cross
compiling for a platform such as Android it’s unlikely that <code>gcc</code> will produce
an ARM executable.</li>
</ul>
<p>Not to fear, though, this is where a <code>build-dependencies</code> entry would help!
The Cargo ecosystem has a number of packages to make this sort of task much
easier, portable, and standardized. Let’s try the <a href="https://crates.io/crates/cc"><code>cc</code>
crate</a> from <a href="https://crates.io/">crates.io</a>. First, add it to the
<code>build-dependencies</code> in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0"
</code></pre>
<p>And rewrite the build script to use this crate:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
    println!("cargo::rerun-if-changed=src/hello.c");
}</code></pre>
<p>The <a href="https://crates.io/crates/cc"><code>cc</code> crate</a> abstracts a range of build script requirements for C code:</p>
<ul>
<li>It invokes the appropriate compiler (MSVC for windows, <code>gcc</code> for MinGW, <code>cc</code>
for Unix platforms, etc.).</li>
<li>It takes the <code>TARGET</code> variable into account by passing appropriate flags to
the compiler being used.</li>
<li>Other environment variables, such as <code>OPT_LEVEL</code>, <code>DEBUG</code>, etc., are all
handled automatically.</li>
<li>The stdout output and <code>OUT_DIR</code> locations are also handled by the <code>cc</code>
library.</li>
</ul>
<p>Here we can start to see some of the major benefits of farming as much
functionality as possible out to common build dependencies rather than
duplicating logic across all build scripts!</p>
<p>Back to the case study though, let’s take a quick look at the contents of the
<code>src</code> directory:</p>
<pre><code class="language-c">// src/hello.c

#include &lt;stdio.h&gt;

void hello() {
    printf("Hello, World!\n");
}
</code></pre>
<pre><code class="language-rust ignore">// src/main.rs

// Note the lack of the `#[link]` attribute. We’re delegating the responsibility
// of selecting what to link over to the build script rather than hard-coding
// it in the source file.
unsafe extern { fn hello(); }

fn main() {
    unsafe { hello(); }
}</code></pre>
<p>And there we go! This should complete our example of building some C code from a
Cargo package using the build script itself. This also shows why using a build
dependency can be crucial in many situations and even much more concise!</p>
<p>We’ve also seen a brief example of how a build script can use a crate as a
dependency purely for the build process and not for the crate itself at runtime.</p>
<h2 id="linking-to-system-libraries"><a class="header" href="#linking-to-system-libraries">Linking to system libraries</a></h2>
<p>This example demonstrates how to link a system library and how the build
script is used to support this use case.</p>
<p>Quite frequently a Rust crate wants to link to a native library provided on
the system to bind its functionality or just use it as part of an
implementation detail. This is quite a nuanced problem when it comes to
performing this in a platform-agnostic fashion. It is best, if possible, to
farm out as much of this as possible to make this as easy as possible for
consumers.</p>
<p>For this example, we will be creating a binding to the system’s zlib library.
This is a library that is commonly found on most Unix-like systems that
provides data compression. This is already wrapped up in the <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code>
crate</a>, but for this example, we’ll do an extremely simplified version. Check
out <a href="https://github.com/rust-lang/libz-sys">the source code</a> for the full example.</p>
<p>To make it easy to find the location of the library, we will use the
<a href="https://crates.io/crates/pkg-config"><code>pkg-config</code> crate</a>. This crate uses the system’s <code>pkg-config</code> utility to
discover information about a library. It will automatically tell Cargo what is
needed to link the library. This will likely only work on Unix-like systems
with <code>pkg-config</code> installed. Let’s start by setting up the manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "libz-sys"
version = "0.1.0"
edition = "2024"
links = "z"

[build-dependencies]
pkg-config = "0.3.16"
</code></pre>
<p>Take note that we included the <code>links</code> key in the <code>package</code> table. This tells
Cargo that we are linking to the <code>libz</code> library. See <a href="reference/build-script-examples.html#using-another-sys-crate">“Using another sys
crate”</a> for an example that will leverage this.</p>
<p>The build script is fairly simple:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    pkg_config::Config::new().probe("zlib").unwrap();
    println!("cargo::rerun-if-changed=build.rs");
}</code></pre>
<p>Let’s round out the example with a basic FFI binding:</p>
<pre><code class="language-rust ignore">// src/lib.rs

use std::os::raw::{c_uint, c_ulong};

unsafe extern "C" {
    pub fn crc32(crc: c_ulong, buf: *const u8, len: c_uint) -&gt; c_ulong;
}

#[test]
fn test_crc32() {
    let s = "hello";
    unsafe {
        assert_eq!(crc32(0, s.as_ptr(), s.len() as c_uint), 0x3610a686);
    }
}</code></pre>
<p>Run <code>cargo build -vv</code> to see the output from the build script. On a system
with <code>libz</code> already installed, it may look something like this:</p>
<pre><code class="language-text">[libz-sys 0.1.0] cargo::rustc-link-search=native=/usr/lib
[libz-sys 0.1.0] cargo::rustc-link-lib=z
[libz-sys 0.1.0] cargo::rerun-if-changed=build.rs
</code></pre>
<p>Nice! <code>pkg-config</code> did all the work of finding the library and telling Cargo
where it is.</p>
<p>It is not unusual for packages to include the source for the library, and
build it statically if it is not found on the system, or if a feature or
environment variable is set. For example, the real <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a> checks the
environment variable <code>LIBZ_SYS_STATIC</code> or the <code>static</code> feature to build it
from source instead of using the system library. Check out <a href="https://github.com/rust-lang/libz-sys">the
source</a> for a more complete example.</p>
<h2 id="using-another-sys-crate"><a class="header" href="#using-another-sys-crate">Using another <code>sys</code> crate</a></h2>
<p>When using the <code>links</code> key, crates may set metadata that can be read by other
crates that depend on it. This provides a mechanism to communicate information
between crates. In this example, we’ll be creating a C library that makes use
of zlib from the real <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a>.</p>
<p>If you have a C library that depends on zlib, you can leverage the <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code>
crate</a> to automatically find it or build it. This is great for cross-platform
support, such as Windows where zlib is not usually installed. <code>libz-sys</code> <a href="https://github.com/rust-lang/libz-sys/blob/3c594e677c79584500da673f918c4d2101ac97a1/build.rs#L156">sets
the <code>include</code>
metadata</a>
to tell other packages where to find the header files for zlib. Our build
script can read that metadata with the <code>DEP_Z_INCLUDE</code> environment variable.
Here’s an example:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "zuser"
version = "0.1.0"
edition = "2024"

[dependencies]
libz-sys = "1.0.25"

[build-dependencies]
cc = "1.0.46"
</code></pre>
<p>Here we have included <code>libz-sys</code> which will ensure that there is only one
<code>libz</code> used in the final library, and give us access to it from our build
script:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    let mut cfg = cc::Build::new();
    cfg.file("src/zuser.c");
    if let Some(include) = std::env::var_os("DEP_Z_INCLUDE") {
        cfg.include(include);
    }
    cfg.compile("zuser");
    println!("cargo::rerun-if-changed=src/zuser.c");
}</code></pre>
<p>With <code>libz-sys</code> doing all the heavy lifting, the C source code may now include
the zlib header, and it should find the header, even on systems where it isn’t
already installed.</p>
<pre><code class="language-c">// src/zuser.c

#include "zlib.h"

// … rest of code that makes use of zlib.
</code></pre>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>A build script may emit <a href="reference/build-scripts.html#rustc-cfg"><code>rustc-cfg</code> instructions</a> which can enable conditions
that can be checked at compile time. In this example, we’ll take a look at how
the <a href="https://crates.io/crates/openssl"><code>openssl</code> crate</a> uses this to support multiple versions of the OpenSSL
library.</p>
<p>The <a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code> crate</a> implements building and linking the OpenSSL library.
It supports multiple different implementations (like LibreSSL) and multiple
versions. It makes use of the <code>links</code> key so that it may pass information to
other build scripts. One of the things it passes is the <code>version_number</code> key,
which is the version of OpenSSL that was detected. The code in the build
script looks something <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl-sys/build/main.rs#L216">like
this</a>:</p>
<pre><code class="language-rust ignore">println!("cargo::metadata=version_number={openssl_version:x}");</code></pre>
<p>This instruction causes the <code>DEP_OPENSSL_VERSION_NUMBER</code> environment variable
to be set in any crates that directly depend on <code>openssl-sys</code>.</p>
<p>The <code>openssl</code> crate, which provides the higher-level interface, specifies
<code>openssl-sys</code> as a dependency. The <code>openssl</code> build script can read the
version information generated by the <code>openssl-sys</code> build script with the
<code>DEP_OPENSSL_VERSION_NUMBER</code> environment variable. It uses this to generate
some <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/build.rs#L18-L36"><code>cfg</code>
values</a>:</p>
<pre><code class="language-rust ignore">// (portion of build.rs)

println!("cargo::rustc-check-cfg=cfg(ossl101,ossl102)");
println!("cargo::rustc-check-cfg=cfg(ossl110,ossl110g,ossl111)");

if let Ok(version) = env::var("DEP_OPENSSL_VERSION_NUMBER") {
    let version = u64::from_str_radix(&amp;version, 16).unwrap();

    if version &gt;= 0x1_00_01_00_0 {
        println!("cargo::rustc-cfg=ossl101");
    }
    if version &gt;= 0x1_00_02_00_0 {
        println!("cargo::rustc-cfg=ossl102");
    }
    if version &gt;= 0x1_01_00_00_0 {
        println!("cargo::rustc-cfg=ossl110");
    }
    if version &gt;= 0x1_01_00_07_0 {
        println!("cargo::rustc-cfg=ossl110g");
    }
    if version &gt;= 0x1_01_01_00_0 {
        println!("cargo::rustc-cfg=ossl111");
    }
}</code></pre>
<p>These <code>cfg</code> values can then be used with the <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> or the <a href="reference/../../std/macro.cfg.html"><code>cfg</code>
macro</a> to conditionally include code. For example, SHA3 support was added in
OpenSSL 1.1.1, so it is <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/src/hash.rs#L67-L85">conditionally
excluded</a>
for older versions:</p>
<pre><code class="language-rust ignore">// (portion of openssl crate)

#[cfg(ossl111)]
pub fn sha3_224() -&gt; MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_224()) }
}</code></pre>
<p>Of course, one should be careful when using this, since it makes the resulting
binary even more dependent on the build environment. In this example, if the
binary is distributed to another system, it may not have the exact same shared
libraries, which could cause problems.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-†">
<p>This list is not an endorsement. Evaluate your dependencies to see which
is right for your project. <a href="#fr-†-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="build-cache"><a class="header" href="#build-cache">Build cache</a></h1>
<p>Cargo stores the output of a build into the “target” and “build” directories. By default,
both directories point to a directory named <code>target</code> in the root of your
<a href="reference/../appendix/glossary.html#workspace" title="&quot;workspace&quot; (glossary entry)"><em>workspace</em></a>. To change the location of the target-dir, you can set the
<code>CARGO_TARGET_DIR</code> <a href="reference/../reference/environment-variables.html">environment variable</a>, the <a href="reference/../reference/config.html#buildtarget-dir"><code>build.target-dir</code></a> config
value, or the <code>--target-dir</code> command-line flag. To change the location of the build-dir, you can set the
<code>CARGO_BUILD_BUILD_DIR</code> <a href="reference/../reference/environment-variables.html">environment variable</a> or the <a href="reference/../reference/config.html#buildbuild-dir"><code>build.build-dir</code></a> config value.</p>
<p>Artifacts are split in two categories:</p>
<ul>
<li>Final build artifacts
<ul>
<li>Final build artifacts are output meant for end users of Cargo</li>
<li>e.g. binaries for bin crates, output of <code>cargo doc</code>, Cargo <code>--timings</code> reports</li>
<li>Stored in the target-dir</li>
</ul>
</li>
<li>Intermediate build artifacts
<ul>
<li>Intermediate build artifacts are internal to Cargo and the Rust compiler</li>
<li>End users will generally not need to interact with intermediate build artifacts</li>
<li>Stored in the Cargo build-dir</li>
</ul>
</li>
</ul>
<p>The directory layout depends on whether or not you are using the <code>--target</code>
flag to build for a specific platform. If <code>--target</code> is not specified, Cargo
runs in a mode where it builds for the host architecture. The output goes into
the root of the target directory, with each <a href="reference/../reference/profiles.html">profile</a> stored in a separate
subdirectory:</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th>Description</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/</code></td><td>Contains output for the <code>dev</code> profile.</td></tr>
<tr><td><code style="white-space: nowrap">target/release/</code></td><td>Contains output for the <code>release</code> profile (with the <code>--release</code> option).</td></tr>
<tr><td><code style="white-space: nowrap">target/foo/</code></td><td>Contains build output for the <code>foo</code> profile (with the <code>--profile=foo</code> option).</td></tr>
</tbody></table>
</div>
<p>For historical reasons, the <code>dev</code> and <code>test</code> profiles are stored in the
<code>debug</code> directory, and the <code>release</code> and <code>bench</code> profiles are stored in the
<code>release</code> directory. User-defined profiles are stored in a directory with the
same name as the profile.</p>
<p>When building for another target with <code>--target</code>, the output is placed in a
directory with the name of the <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary entry)">target</a>:</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th>Example</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/&lt;triple&gt;/debug/</code></td><td><code style="white-space: nowrap">target/thumbv7em-none-eabihf/debug/</code></td></tr>
<tr><td><code style="white-space: nowrap">target/&lt;triple&gt;/release/</code></td><td><code style="white-space: nowrap">target/thumbv7em-none-eabihf/release/</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note</strong>: When not using <code>--target</code>, this has a consequence that Cargo will
share your dependencies with build scripts and proc macros. <a href="reference/../reference/config.html#buildrustflags"><code>RUSTFLAGS</code></a>
will be shared with every <code>rustc</code> invocation. With the <code>--target</code> flag,
build scripts and proc macros are built separately (for the host
architecture), and do not share <code>RUSTFLAGS</code>.</p>
</blockquote>
<p>Within the profile directory (such as <code>debug</code> or <code>release</code>), artifacts are
placed into the following directories:</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th>Description</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/</code></td><td>Contains the output of the package being built (the <a href="reference/../reference/cargo-targets.html#binaries">binary executables</a> and <a href="reference/../reference/cargo-targets.html#library">library targets</a>).</td></tr>
<tr><td><code style="white-space: nowrap">target/debug/examples/</code></td><td>Contains <a href="reference/../reference/cargo-targets.html#examples">example targets</a>.</td></tr>
</tbody></table>
</div>
<p>Some commands place their output in dedicated directories in the top level of
the <code>target</code> directory:</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th>Description</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/doc/</code></td><td>Contains rustdoc documentation (<a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a>).</td></tr>
<tr><td><code style="white-space: nowrap">target/package/</code></td><td>Contains the output of the <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a>.</td></tr>
</tbody></table>
</div>
<p>Cargo also creates several other directories and files in the build-dir needed for the build
process. The build-dir layout is considered internal to Cargo, and is subject to
change. Some of these directories are:</p>
<div class="table-wrapper"><table><thead><tr><th>Directory</th><th>Description</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">&lt;build-dir&gt;/debug/deps/</code></td><td>Dependencies and other artifacts.</td></tr>
<tr><td><code style="white-space: nowrap">&lt;build-dir&gt;/debug/incremental/</code></td><td><code>rustc</code> <a href="reference/../reference/profiles.html#incremental">incremental output</a>, a cache used to speed up subsequent builds.</td></tr>
<tr><td><code style="white-space: nowrap">&lt;build-dir&gt;/debug/build/</code></td><td>Output from <a href="reference/../reference/build-scripts.html">build scripts</a>.</td></tr>
</tbody></table>
</div>
<h2 id="dep-info-files"><a class="header" href="#dep-info-files">Dep-info files</a></h2>
<p>Next to each compiled artifact is a file called a “dep info” file with a <code>.d</code>
suffix. This file is a Makefile-like syntax that indicates all of the file
dependencies required to rebuild the artifact. These are intended to be used
with external build systems so that they can detect if Cargo needs to be
re-executed. The paths in the file are absolute by default. See the
<a href="reference/../reference/config.html#builddep-info-basedir"><code>build.dep-info-basedir</code></a> config option to use relative paths.</p>
<pre><code class="language-Makefile"># Example dep-info file found in target/debug/foo.d
/path/to/myproj/target/debug/foo: /path/to/myproj/src/lib.rs /path/to/myproj/src/main.rs
</code></pre>
<h2 id="shared-cache"><a class="header" href="#shared-cache">Shared cache</a></h2>
<p>A third party tool, <a href="https://github.com/mozilla/sccache">sccache</a>, can be used to share built dependencies across
different workspaces.</p>
<p>To setup <code>sccache</code>, install it with <code>cargo install sccache</code> and set
<code>RUSTC_WRAPPER</code> environment variable to <code>sccache</code> before invoking Cargo. If
you use bash, it makes sense to add <code>export RUSTC_WRAPPER=sccache</code> to
<code>.bashrc</code>. Alternatively, you can set <a href="reference/../reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a> in the <a href="reference/../reference/config.html">Cargo
configuration</a>. Refer to sccache documentation for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-id-specifications"><a class="header" href="#package-id-specifications">Package ID Specifications</a></h1>
<h2 id="package-id-specifications-1"><a class="header" href="#package-id-specifications-1">Package ID specifications</a></h2>
<p>Subcommands of Cargo frequently need to refer to a particular package within a
dependency graph for various operations like updating, cleaning, building, etc.
To solve this problem, Cargo supports <em>Package ID Specifications</em>. A specification
is a string which is used to uniquely refer to one package within a graph of
packages.</p>
<p>The specification may be fully qualified, such as
<code>registry+https://github.com/rust-lang/crates.io-index#regex@1.4.3</code> or it may be
abbreviated, such as <code>regex</code>. The abbreviated form may be used as long as it
uniquely identifies a single package in the dependency graph. If there is
ambiguity, additional qualifiers can be added to make it unique. For example,
if there are two versions of the <code>regex</code> package in the graph, then it can be
qualified with a version to make it unique, such as <code>regex@1.4.3</code>.</p>
<p>Package ID specifications output by cargo, for example in <a href="reference/../commands/cargo-metadata.html">cargo metadata</a> output, are fully qualified.</p>
<h3 id="specification-grammar"><a class="header" href="#specification-grammar">Specification grammar</a></h3>
<p>The formal grammar for a Package Id Specification is:</p>
<pre><code class="language-notrust">spec := pkgname |
        [ kind "+" ] proto "://" hostname-and-path [ "?" query] [ "#" ( pkgname | semver ) ]
query = ( "branch" | "tag" | "rev" ) "=" ref
pkgname := name [ ("@" | ":" ) semver ]
semver := digits [ "." digits [ "." digits [ "-" prerelease ] [ "+" build ]]]

kind = "registry" | "git" | "path"
proto := "http" | "git" | "file" | ...
</code></pre>
<p>Here, brackets indicate that the contents are optional.</p>
<p>The URL form can be used for git dependencies, or to differentiate packages
that come from different sources such as different registries.</p>
<h3 id="example-specifications"><a class="header" href="#example-specifications">Example specifications</a></h3>
<p>The following are references to the <code>regex</code> package on <code>crates.io</code>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Spec</th><th style="text-align: center">Name</th><th style="text-align: center">Version</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>regex</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>regex@1.4</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.*</code></td></tr>
<tr><td style="text-align: left"><code>regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/crates.io-index#regex</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/crates.io-index#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>registry+https://github.com/rust-lang/crates.io-index#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
</tbody></table>
</div>
<p>The following are some examples of specs for several different git dependencies:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Spec</th><th style="text-align: center">Name</th><th style="text-align: center">Version</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/cargo#0.52.0</code></td><td style="text-align: center"><code>cargo</code></td><td style="text-align: center"><code>0.52.0</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/cargo#cargo-platform@0.1.2</code></td><td style="text-align: center"><nobr><code>cargo-platform</code></nobr></td><td style="text-align: center"><code>0.1.2</code></td></tr>
<tr><td style="text-align: left"><code>ssh://git@github.com/rust-lang/regex.git#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>git+ssh://git@github.com/rust-lang/regex.git#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>git+ssh://git@github.com/rust-lang/regex.git?branch=dev#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
</tbody></table>
</div>
<p>Local packages on the filesystem can use <code>file://</code> URLs to reference them:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Spec</th><th style="text-align: center">Name</th><th style="text-align: center">Version</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>file:///path/to/my/project/foo</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>file:///path/to/my/project/foo#1.1.8</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.1.8</code></td></tr>
<tr><td style="text-align: left"><code>path+file:///path/to/my/project/foo#1.1.8</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.1.8</code></td></tr>
</tbody></table>
</div>
<h3 id="brevity-of-specifications"><a class="header" href="#brevity-of-specifications">Brevity of specifications</a></h3>
<p>The goal of this is to enable both succinct and exhaustive syntaxes for
referring to packages in a dependency graph. Ambiguous references may refer to
one or more packages. Most commands generate an error if more than one package
could be referred to with the same specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-tools"><a class="header" href="#external-tools">External tools</a></h1>
<p>One of the goals of Cargo is simple integration with third-party tools, like
IDEs and other build systems. To make integration easier, Cargo has several
facilities:</p>
<ul>
<li>
<p>a <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> command, which outputs package structure and dependencies
information in JSON,</p>
</li>
<li>
<p>a <code>--message-format</code> flag, which outputs information about a particular build,
and</p>
</li>
<li>
<p>support for custom subcommands.</p>
</li>
</ul>
<h2 id="information-about-package-structure"><a class="header" href="#information-about-package-structure">Information about package structure</a></h2>
<p>You can use <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> command to get information about package
structure and dependencies. See the <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> documentation
for details on the format of the output.</p>
<p>The format is stable and versioned. When calling <code>cargo metadata</code>, you should
pass <code>--format-version</code> flag explicitly to avoid forward incompatibility
hazard.</p>
<p>If you are using Rust, the <a href="https://crates.io/crates/cargo_metadata">cargo_metadata</a> crate can be used to parse the
output.</p>
<h2 id="json-messages"><a class="header" href="#json-messages">JSON messages</a></h2>
<p>When passing <code>--message-format=json</code>, Cargo will output the following
information during the build:</p>
<ul>
<li>
<p>compiler errors and warnings,</p>
</li>
<li>
<p>produced artifacts,</p>
</li>
<li>
<p>results of the build scripts (for example, native dependencies).</p>
</li>
</ul>
<p>The output goes to stdout in the JSON object per line format. The <code>reason</code> field
distinguishes different kinds of messages.
The <code>package_id</code> field is a unique identifier for referring to the package, and
as the <code>--package</code> argument to many commands. The syntax grammar can be found in
chapter <a href="reference/./pkgid-spec.html">Package ID Specifications</a>.</p>
<blockquote>
<p><strong>Note:</strong> <code>--message-format=json</code> only controls Cargo and Rustc’s output.
This cannot control the output of other tools,
e.g. <code>cargo run --message-format=json</code>,
or arbitrary output from procedural macros.
A possible workaround in these situations is to only interpret a line as JSON if it starts with <code>{</code>.</p>
</blockquote>
<p>The <code>--message-format</code> option can also take additional formatting values which
alter the way the JSON messages are computed and rendered. See the description
of the <code>--message-format</code> option in the <a href="reference/../commands/cargo-build.html">build command documentation</a> for more
details.</p>
<p>If you are using Rust, the <a href="https://crates.io/crates/cargo_metadata">cargo_metadata</a> crate can be used to parse these
messages.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.77 is required for <code>package_id</code> to be a Package ID Specification. Before that, it was opaque.</p>
</blockquote>
<h3 id="compiler-messages"><a class="header" href="#compiler-messages">Compiler messages</a></h3>
<p>The “compiler-message” message includes output from the compiler, such as
warnings and errors. See the <a href="reference/../../rustc/json.html">rustc JSON chapter</a> for
details on <code>rustc</code>’s message format, which is embedded in the following
structure:</p>
<pre><code class="language-javascript">{
    /* The "reason" indicates the kind of message. */
    "reason": "compiler-message",
    /* The Package ID, a unique identifier for referring to the package. */
    "package_id": "file:///path/to/my-package#0.1.0",
    /* Absolute path to the package manifest. */
    "manifest_path": "/path/to/my-package/Cargo.toml",
    /* The Cargo target (lib, bin, example, etc.) that generated the message. */
    "target": {
        /* Array of target kinds.
           - lib targets list the `crate-type` values from the
             manifest such as "lib", "rlib", "dylib",
             "proc-macro", etc. (default ["lib"])
           - binary is ["bin"]
           - example is ["example"]
           - integration test is ["test"]
           - benchmark is ["bench"]
           - build script is ["custom-build"]
        */
        "kind": [
            "lib"
        ],
        /* Array of crate types.
           - lib and example libraries list the `crate-type` values
             from the manifest such as "lib", "rlib", "dylib",
             "proc-macro", etc. (default ["lib"])
           - all other target kinds are ["bin"]
        */
        "crate_types": [
            "lib"
        ],
        /* The name of the target.
           For lib targets, dashes will be replaced with underscores.
        */
        "name": "my_package",
        /* Absolute path to the root source file of the target. */
        "src_path": "/path/to/my-package/src/lib.rs",
        /* The Rust edition of the target.
           Defaults to the package edition.
        */
        "edition": "2018",
        /* Array of required features.
           This property is not included if no required features are set.
        */
        "required-features": ["feat1"],
        /* Whether the target should be documented by `cargo doc`. */
        "doc": true,
        /* Whether or not this target has doc tests enabled, and
           the target is compatible with doc testing.
        */
        "doctest": true
        /* Whether or not this target should be built and run with `--test`
        */
        "test": true
    },
    /* The message emitted by the compiler.

    See https://doc.rust-lang.org/rustc/json.html for details.
    */
    "message": {
        /* ... */
    }
}
</code></pre>
<h3 id="artifact-messages"><a class="header" href="#artifact-messages">Artifact messages</a></h3>
<p>For every compilation step, a “compiler-artifact” message is emitted with the
following structure:</p>
<pre><code class="language-javascript">{
    /* The "reason" indicates the kind of message. */
    "reason": "compiler-artifact",
    /* The Package ID, a unique identifier for referring to the package. */
    "package_id": "file:///path/to/my-package#0.1.0",
    /* Absolute path to the package manifest. */
    "manifest_path": "/path/to/my-package/Cargo.toml",
    /* The Cargo target (lib, bin, example, etc.) that generated the artifacts.
       See the definition above for `compiler-message` for details.
    */
    "target": {
        "kind": [
            "lib"
        ],
        "crate_types": [
            "lib"
        ],
        "name": "my_package",
        "src_path": "/path/to/my-package/src/lib.rs",
        "edition": "2018",
        "doc": true,
        "doctest": true,
        "test": true
    },
    /* The profile indicates which compiler settings were used. */
    "profile": {
        /* The optimization level. */
        "opt_level": "0",
        /* The debug level, an integer of 0, 1, or 2, or a string
           "line-directives-only" or "line-tables-only". If `null`, it implies
           rustc's default of 0.
        */
        "debuginfo": 2,
        /* Whether or not debug assertions are enabled. */
        "debug_assertions": true,
        /* Whether or not overflow checks are enabled. */
        "overflow_checks": true,
        /* Whether or not the `--test` flag is used. */
        "test": false
    },
    /* Array of features enabled. */
    "features": ["feat1", "feat2"],
    /* Array of files generated by this step. */
    "filenames": [
        "/path/to/my-package/target/debug/libmy_package.rlib",
        "/path/to/my-package/target/debug/deps/libmy_package-be9f3faac0a26ef0.rmeta"
    ],
    /* A string of the path to the executable that was created, or null if
       this step did not generate an executable.
    */
    "executable": null,
    /* Whether or not this step was actually executed.
       When `true`, this means that the pre-existing artifacts were
       up-to-date, and `rustc` was not executed. When `false`, this means that
       `rustc` was run to generate the artifacts.
    */
    "fresh": true
}

</code></pre>
<h3 id="build-script-output"><a class="header" href="#build-script-output">Build script output</a></h3>
<p>The “build-script-executed” message includes the parsed output of a build
script. Note that this is emitted even if the build script is not run; it will
display the previously cached value. More details about build script output
may be found in <a href="reference/build-scripts.html">the chapter on build scripts</a>.</p>
<pre><code class="language-javascript">{
    /* The "reason" indicates the kind of message. */
    "reason": "build-script-executed",
    /* The Package ID, a unique identifier for referring to the package. */
    "package_id": "file:///path/to/my-package#0.1.0",
    /* Array of libraries to link, as indicated by the `cargo::rustc-link-lib`
       instruction. Note that this may include a "KIND=" prefix in the string
       where KIND is the library kind.
    */
    "linked_libs": ["foo", "static=bar"],
    /* Array of paths to include in the library search path, as indicated by
       the `cargo::rustc-link-search` instruction. Note that this may include a
       "KIND=" prefix in the string where KIND is the library kind.
    */
    "linked_paths": ["/some/path", "native=/another/path"],
    /* Array of cfg values to enable, as indicated by the `cargo::rustc-cfg`
       instruction.
    */
    "cfgs": ["cfg1", "cfg2=\"string\""],
    /* Array of [KEY, VALUE] arrays of environment variables to set, as
       indicated by the `cargo::rustc-env` instruction.
    */
    "env": [
        ["SOME_KEY", "some value"],
        ["ANOTHER_KEY", "another value"]
    ],
    /* An absolute path which is used as a value of `OUT_DIR` environmental
       variable when compiling current package.
    */
    "out_dir": "/some/path/in/target/dir"
}
</code></pre>
<h3 id="build-finished"><a class="header" href="#build-finished">Build finished</a></h3>
<p>The “build-finished” message is emitted at the end of the build.</p>
<pre><code class="language-javascript">{
    /* The "reason" indicates the kind of message. */
    "reason": "build-finished",
    /* Whether or not the build finished successfully. */
    "success": true,
}
</code></pre>
<p>This message can be helpful for tools to know when to stop reading JSON
messages. Commands such as <code>cargo test</code> or <code>cargo run</code> can produce additional
output after the build has finished. This message lets a tool know that Cargo
will not produce additional JSON messages, but there may be additional output
that may be generated afterwards (such as the output generated by the program
executed by <code>cargo run</code>).</p>
<blockquote>
<p>Note: There is experimental nightly-only support for JSON output for tests,
so additional test-specific JSON messages may begin arriving after the
“build-finished” message if that is enabled.</p>
</blockquote>
<h2 id="custom-subcommands"><a class="header" href="#custom-subcommands">Custom subcommands</a></h2>
<p>Cargo is designed to be extensible with new subcommands without having to modify
Cargo itself. This is achieved by translating a cargo invocation of the form
cargo <code>(?&lt;command&gt;[^ ]+)</code> into an invocation of an external tool
<code>cargo-${command}</code>. The external tool must be present in one of the user’s
<code>$PATH</code> directories.</p>
<blockquote>
<p><strong>Note</strong>: Cargo defaults to prioritizing external tools in <code>$CARGO_HOME/bin</code>
over <code>$PATH</code>. Users can override this precedence by adding <code>$CARGO_HOME/bin</code>
to <code>$PATH</code>.</p>
</blockquote>
<p>When Cargo invokes a custom subcommand, the first argument to the subcommand
will be the filename of the custom subcommand, as usual. The second argument
will be the subcommand name itself. For example, the second argument would be
<code>${command}</code> when invoking <code>cargo-${command}</code>. Any additional arguments on the
command line will be forwarded unchanged.</p>
<p>Cargo can also display the help output of a custom subcommand with <code>cargo help ${command}</code>. Cargo assumes that the subcommand will print a help message if its
third argument is <code>--help</code>. So, <code>cargo help ${command}</code> would invoke
<code>cargo-${command} ${command} --help</code>.</p>
<p>Custom subcommands may use the <code>CARGO</code> environment variable to call back to
Cargo. Alternatively, it can link to <code>cargo</code> crate as a library, but this
approach has drawbacks:</p>
<ul>
<li>Cargo as a library is unstable: the  API may change without deprecation</li>
<li>versions of the linked Cargo library may be different from the Cargo binary</li>
</ul>
<p>Instead, it is encouraged to use the CLI interface to drive Cargo. The <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> command can be used to obtain information about the current project
(the <a href="https://crates.io/crates/cargo_metadata"><code>cargo_metadata</code></a> crate provides a Rust interface to this command).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registries-1"><a class="header" href="#registries-1">Registries</a></h1>
<p>Cargo installs crates and fetches dependencies from a “registry”. The default
registry is <a href="https://crates.io/">crates.io</a>. A registry contains an “index” which contains a
searchable list of available crates. A registry may also provide a web API to
support publishing new crates directly from Cargo.</p>
<blockquote>
<p>Note: If you are interested in mirroring or vendoring an existing registry,
take a look at <a href="reference/source-replacement.html">Source Replacement</a>.</p>
</blockquote>
<p>If you are implementing a registry server, see <a href="reference/running-a-registry.html">Running a Registry</a> for more
details about the protocol between Cargo and a registry.</p>
<p>If you’re using a registry that requires authentication, see <a href="reference/registry-authentication.html">Registry Authentication</a>.
If you are implementing a credential provider, see <a href="reference/credential-provider-protocol.html">Credential Provider Protocol</a>
for details.</p>
<h2 id="using-an-alternate-registry"><a class="header" href="#using-an-alternate-registry">Using an Alternate Registry</a></h2>
<p>To use a registry other than <a href="https://crates.io/">crates.io</a>, the name and index URL of the
registry must be added to a <a href="reference/config.html"><code>.cargo/config.toml</code> file</a>. The <code>registries</code>
table has a key for each registry, for example:</p>
<pre><code class="language-toml">[registries]
my-registry = { index = "https://my-intranet:8080/git/index" }
</code></pre>
<p>The <code>index</code> key should be a URL to a git repository with the registry’s index or a
Cargo sparse registry URL with the <code>sparse+</code> prefix.</p>
<p>A crate can then depend on a crate from another registry by specifying the
<code>registry</code> key and a value of the registry’s name in that dependency’s entry
in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># Sample Cargo.toml
[package]
name = "my-project"
version = "0.1.0"
edition = "2024"

[dependencies]
other-crate = { version = "1.0", registry = "my-registry" }
</code></pre>
<p>As with most config values, the index may be specified with an environment
variable instead of a config file. For example, setting the following
environment variable will accomplish the same thing as defining a config file:</p>
<pre><code class="language-ignore">CARGO_REGISTRIES_MY_REGISTRY_INDEX=https://my-intranet:8080/git/index
</code></pre>
<blockquote>
<p>Note: <a href="https://crates.io/">crates.io</a> does not accept packages that depend on crates from other
registries.</p>
</blockquote>
<h2 id="publishing-to-an-alternate-registry"><a class="header" href="#publishing-to-an-alternate-registry">Publishing to an Alternate Registry</a></h2>
<p>If the registry supports web API access, then packages can be published
directly to the registry from Cargo. Several of Cargo’s commands such as
<a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> take a <code>--registry</code> command-line flag to indicate which
registry to use. For example, to publish the package in the current directory:</p>
<ol>
<li>
<p><code>cargo login --registry=my-registry</code></p>
<p>This only needs to be done once. You must enter the secret API token
retrieved from the registry’s website. Alternatively the token may be
passed directly to the <code>publish</code> command with the <code>--token</code> command-line
flag or an environment variable with the name of the registry such as
<code>CARGO_REGISTRIES_MY_REGISTRY_TOKEN</code>.</p>
</li>
<li>
<p><code>cargo publish --registry=my-registry</code></p>
</li>
</ol>
<p>Instead of always passing the <code>--registry</code> command-line option, the default
registry may be set in <a href="reference/config.html"><code>.cargo/config.toml</code></a> with the <code>registry.default</code>
key. For example:</p>
<pre><code class="language-toml">[registry]
default = "my-registry"
</code></pre>
<p>Setting the <code>package.publish</code> key in the <code>Cargo.toml</code> manifest restricts which
registries the package is allowed to be published to. This is useful to
prevent accidentally publishing a closed-source package to <a href="https://crates.io/">crates.io</a>. The
value may be a list of registry names, for example:</p>
<pre><code class="language-toml">[package]
# ...
publish = ["my-registry"]
</code></pre>
<p>The <code>publish</code> value may also be <code>false</code> to restrict all publishing, which is
the same as an empty list.</p>
<p>The authentication information saved by <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> is stored in the
<code>credentials.toml</code> file in the Cargo home directory (default <code>$HOME/.cargo</code>). It
has a separate table for each registry, for example:</p>
<pre><code class="language-toml">[registries.my-registry]
token = "854DvwSlUwEHtIo3kWy6x7UCPKHfzCmy"
</code></pre>
<h2 id="registry-protocols"><a class="header" href="#registry-protocols">Registry Protocols</a></h2>
<p>Cargo supports two remote registry protocols: <code>git</code> and <code>sparse</code>. If the registry
index URL starts with <code>sparse+</code>, Cargo uses the sparse protocol. Otherwise
Cargo uses the <code>git</code> protocol.</p>
<p>The <code>git</code> protocol stores index metadata in a git repository and requires Cargo to clone
the entire repo.</p>
<p>The <code>sparse</code> protocol fetches individual metadata files using plain HTTP requests.
Since Cargo only downloads the metadata for relevant crates, the <code>sparse</code> protocol can
save significant time and bandwidth.</p>
<p>The <a href="https://crates.io/">crates.io</a> registry supports both protocols. The protocol for crates.io is
controlled via the <a href="reference/config.html#registriescrates-ioprotocol"><code>registries.crates-io.protocol</code></a> config key.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registry-authentication"><a class="header" href="#registry-authentication">Registry Authentication</a></h1>
<p>Cargo authenticates to registries with credential providers. These
credential providers are external executables or built-in providers that Cargo
uses to store and retrieve credentials.</p>
<p>Using alternative registries with authentication <em>requires</em> a credential provider to be configured
to avoid unknowingly storing unencrypted credentials on disk. For historical reasons, public
(non-authenticated) registries do not require credential provider configuration, and the <code>cargo:token</code>
provider is used if no providers are configured.</p>
<p>Cargo also includes platform-specific providers that use the operating system to securely store
tokens. The <code>cargo:token</code> provider is also included which stores credentials in unencrypted plain
text in the <a href="reference/config.html#credentials">credentials</a> file.</p>
<h2 id="recommended-configuration"><a class="header" href="#recommended-configuration">Recommended configuration</a></h2>
<p>It’s recommended to configure a global credential provider list in <code>$CARGO_HOME/config.toml</code>
which defaults to:</p>
<ul>
<li>Windows: <code>%USERPROFILE%\.cargo\config.toml</code></li>
<li>Unix: <code>~/.cargo/config.toml</code></li>
</ul>
<p>This recommended configuration uses the operating system provider, with a fallback to <code>cargo:token</code>
to look in Cargo’s <a href="reference/config.html#credentials">credentials</a> file or environment variables:</p>
<pre><code class="language-toml"># ~/.cargo/config.toml
[registry]
global-credential-providers = ["cargo:token", "cargo:libsecret", "cargo:macos-keychain", "cargo:wincred"]
</code></pre>
<p><em>Note that later entries have higher precedence.
See <a href="reference/config.html#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a>
for more details.</em></p>
<p>Some private registries may also recommend a registry-specific credential-provider. Check your
registry’s documentation to see if this is the case.</p>
<h2 id="built-in-providers"><a class="header" href="#built-in-providers">Built-in providers</a></h2>
<p>Cargo includes several built-in credential providers. The available built-in providers
may change in future Cargo releases (though there are currently no plans to do so).</p>
<h3 id="cargotoken"><a class="header" href="#cargotoken"><code>cargo:token</code></a></h3>
<p>Uses Cargo’s <a href="reference/config.html#credentials">credentials</a> file to store tokens unencrypted in plain text.
When retrieving tokens, checks the <code>CARGO_REGISTRIES_&lt;NAME&gt;_TOKEN</code> environment variable.
If this credential provider is not listed, then the <code>*_TOKEN</code> environment variables will not work.</p>
<h3 id="cargowincred"><a class="header" href="#cargowincred"><code>cargo:wincred</code></a></h3>
<p>Uses the Windows Credential Manager to store tokens.</p>
<p>The credentials are stored as <code>cargo-registry:&lt;index-url&gt;</code> in the Credential Manager
under “Windows Credentials”.</p>
<h3 id="cargomacos-keychain"><a class="header" href="#cargomacos-keychain"><code>cargo:macos-keychain</code></a></h3>
<p>Uses the macOS Keychain to store tokens.</p>
<p>The Keychain Access app can be used to view stored tokens.</p>
<h3 id="cargolibsecret"><a class="header" href="#cargolibsecret"><code>cargo:libsecret</code></a></h3>
<p>Uses <a href="https://wiki.gnome.org/Projects/Libsecret">libsecret</a> to store tokens.</p>
<p>Any password manager with libsecret support can be used to view stored tokens.
The following are a few examples (non-exhaustive):</p>
<ul>
<li><a href="https://wiki.gnome.org/Projects/GnomeKeyring">GNOME Keyring</a></li>
<li><a href="https://apps.kde.org/kwalletmanager5/">KDE Wallet Manager</a> (since KDE Frameworks 5.97.0)</li>
<li><a href="https://keepassxc.org/">KeePassXC</a> (since 2.5.0)</li>
</ul>
<h3 id="cargotoken-from-stdout-command-args"><a class="header" href="#cargotoken-from-stdout-command-args"><code>cargo:token-from-stdout &lt;command&gt; &lt;args&gt;</code></a></h3>
<p>Launch a subprocess that returns a token on stdout. Newlines will be trimmed.</p>
<ul>
<li>The process inherits the user’s stdin and stderr.</li>
<li>It should exit 0 on success, and nonzero on error.</li>
<li><a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> and <a href="reference/../commands/cargo-logout.html"><code>cargo logout</code></a> are not supported and return an error if used.</li>
</ul>
<p>The following environment variables will be provided to the executed command:</p>
<ul>
<li><code>CARGO</code> — Path to the <code>cargo</code> binary executing the command.</li>
<li><code>CARGO_REGISTRY_INDEX_URL</code> — The URL of the registry index.</li>
<li><code>CARGO_REGISTRY_NAME_OPT</code> — Optional name of the registry. Should not be used as a lookup key.</li>
</ul>
<p>Arguments will be passed on to the subcommand.</p>
<h2 id="credential-plugins"><a class="header" href="#credential-plugins">Credential plugins</a></h2>
<p>For credential provider plugins that follow Cargo’s <a href="reference/credential-provider-protocol.html">credential provider protocol</a>,
the configuration value should be a string with the path to the executable (or the executable name if on the <code>PATH</code>).</p>
<p>For example, to install <a href="https://crates.io/crates/cargo-credential-1password">cargo-credential-1password</a>
from crates.io do the following:</p>
<p>Install the provider with <code>cargo install cargo-credential-1password</code></p>
<p>In the config, add to (or create) <code>registry.global-credential-providers</code>:</p>
<pre><code class="language-toml">[registry]
global-credential-providers = ["cargo:token", "cargo-credential-1password --account my.1password.com"]
</code></pre>
<p>The values in <code>global-credential-providers</code> are split on spaces into path and command-line arguments. To
define a global credential provider where the path or arguments contain spaces, use
the <a href="reference/config.html#credential-alias"><code>[credential-alias]</code> table</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credential-provider-protocol"><a class="header" href="#credential-provider-protocol">Credential Provider Protocol</a></h1>
<p>This document describes information for building a Cargo credential provider. For information on
setting up or using a credential provider, see <a href="reference/registry-authentication.html">Registry Authentication</a>.</p>
<p>When using an external credential provider, Cargo communicates with the credential
provider using stdin/stdout messages passed as single lines of JSON.</p>
<p>Cargo will always execute the credential provider with the <code>--cargo-plugin</code> argument.
This enables a credential provider executable to have additional functionality beyond
what Cargo needs. Additional arguments are included in the JSON via the <code>args</code> field.</p>
<h2 id="json-messages-1"><a class="header" href="#json-messages-1">JSON messages</a></h2>
<p>The JSON messages in this document have newlines added for readability.
Actual messages must not contain newlines.</p>
<h3 id="credential-hello"><a class="header" href="#credential-hello">Credential hello</a></h3>
<ul>
<li>Sent by: credential provider</li>
<li>Purpose: used to identify the supported protocols on process startup</li>
</ul>
<pre><code class="language-javascript">{
    "v":[1]
}
</code></pre>
<p>Requests sent by Cargo will include a <code>v</code> field set to one of the versions listed here.
If Cargo does not support any of the versions offered by the credential provider, it will issue an
error and shut down the credential process.</p>
<h3 id="registry-information"><a class="header" href="#registry-information">Registry information</a></h3>
<ul>
<li>Sent by: Cargo
Not a message by itself. Included in all messages sent by Cargo as the <code>registry</code> field.</li>
</ul>
<pre><code class="language-javascript">{
    // Index URL of the registry
    "index-url":"https://github.com/rust-lang/crates.io-index",
    // Name of the registry in configuration (optional)
    "name": "crates-io",
    // HTTP headers received from attempting to access an authenticated registry (optional)
    "headers": ["WWW-Authenticate: cargo"]
}
</code></pre>
<h3 id="login-request"><a class="header" href="#login-request">Login request</a></h3>
<ul>
<li>Sent by: Cargo</li>
<li>Purpose: collect and store credentials</li>
</ul>
<pre><code class="language-javascript">{
    // Protocol version
    "v":1,
    // Action to perform: login
    "kind":"login",
    // Registry information (see Registry information)
    "registry":{"index-url":"sparse+https://registry-url/index/", "name": "my-registry"},
    // User-specified token from stdin or command line (optional)
    "token": "&lt;the token value&gt;",
    // URL that the user could visit to get a token (optional)
    "login-url": "http://registry-url/login",
    // Additional command-line args (optional)
    "args":[]
}
</code></pre>
<p>If the <code>token</code> field is set, then the credential provider should use the token provided. If
the <code>token</code> is not set, then the credential provider should prompt the user for a token.</p>
<p>In addition to the arguments that may be passed to the credential provider in
configuration, <code>cargo login</code> also supports passing additional command line args
via <code>cargo login -- &lt;additional args&gt;</code>. These additional arguments will be included
in the <code>args</code> field after any args from Cargo configuration.</p>
<h3 id="read-request"><a class="header" href="#read-request">Read request</a></h3>
<ul>
<li>Sent by: Cargo</li>
<li>Purpose: Get the credential for reading crate information</li>
</ul>
<pre><code class="language-javascript">{
    // Protocol version
    "v":1,
    // Request kind: get credentials
    "kind":"get",
    // Action to perform: read crate information
    "operation":"read",
    // Registry information (see Registry information)
    "registry":{"index-url":"sparse+https://registry-url/index/", "name": "my-registry"},
    // Additional command-line args (optional)
    "args":[]
}
</code></pre>
<h3 id="publish-request"><a class="header" href="#publish-request">Publish request</a></h3>
<ul>
<li>Sent by: Cargo</li>
<li>Purpose: Get the credential for publishing a crate</li>
</ul>
<pre><code class="language-javascript">{
    // Protocol version
    "v":1,
    // Request kind: get credentials
    "kind":"get",
    // Action to perform: publish crate
    "operation":"publish",
    // Crate name
    "name":"sample",
    // Crate version
    "vers":"0.1.0",
    // Crate checksum
    "cksum":"...",
    // Registry information (see Registry information)
    "registry":{"index-url":"sparse+https://registry-url/index/", "name": "my-registry"},
    // Additional command-line args (optional)
    "args":[]
}
</code></pre>
<h3 id="get-success-response"><a class="header" href="#get-success-response">Get success response</a></h3>
<ul>
<li>Sent by: credential provider</li>
<li>Purpose: Gives the credential to Cargo</li>
</ul>
<pre><code class="language-javascript">{"Ok":{
    // Response kind: this was a get request
    "kind":"get",
    // Token to send to the registry
    "token":"...",
    // Cache control. Can be one of the following:
    // * "never": do not cache
    // * "session": cache for the current cargo session
    // * "expires": cache for the current cargo session until expiration
    "cache":"expires",
    // Unix timestamp (only for "cache": "expires")
    "expiration":1693942857,
    // Is the token operation independent?
    "operation_independent":true
}}
</code></pre>
<p>The <code>token</code> will be sent to the registry as the value of the <code>Authorization</code> HTTP header.</p>
<p><code>operation_independent</code> indicates whether the token can be cached across different
operations (such as publishing or fetching). In general, this should be <code>true</code> unless
the provider wants to generate tokens that are scoped to specific operations.</p>
<h3 id="login-success-response"><a class="header" href="#login-success-response">Login success response</a></h3>
<ul>
<li>Sent by: credential provider</li>
<li>Purpose: Indicates the login was successful</li>
</ul>
<pre><code class="language-javascript">{"Ok":{
    // Response kind: this was a login request
    "kind":"login"
}}
</code></pre>
<h3 id="logout-success-response"><a class="header" href="#logout-success-response">Logout success response</a></h3>
<ul>
<li>Sent by: credential provider</li>
<li>Purpose: Indicates the logout was successful</li>
</ul>
<pre><code class="language-javascript">{"Ok":{
    // Response kind: this was a logout request
    "kind":"logout"
}}
</code></pre>
<h3 id="failure-response-url-not-supported"><a class="header" href="#failure-response-url-not-supported">Failure response (URL not supported)</a></h3>
<ul>
<li>Sent by: credential provider</li>
<li>Purpose: Gives error information to Cargo</li>
</ul>
<pre><code class="language-javascript">{"Err":{
    "kind":"url-not-supported"
}}
</code></pre>
<p>Sent if the credential provider is designed
to only handle specific registry URLs and the given URL
is not supported. Cargo will attempt another provider if
available.</p>
<h3 id="failure-response-not-found"><a class="header" href="#failure-response-not-found">Failure response (not found)</a></h3>
<ul>
<li>Sent by: credential provider</li>
<li>Purpose: Gives error information to Cargo</li>
</ul>
<pre><code class="language-javascript">{"Err":{
    // Error: The credential could not be found in the provider.
    "kind":"not-found"
}}
</code></pre>
<p>Sent if the credential could not be found. This is expected for
<code>get</code> requests where the credential is not available, or <code>logout</code>
requests where there is nothing found to erase.</p>
<h3 id="failure-response-operation-not-supported"><a class="header" href="#failure-response-operation-not-supported">Failure response (operation not supported)</a></h3>
<ul>
<li>Sent by: credential provider</li>
<li>Purpose: Gives error information to Cargo</li>
</ul>
<pre><code class="language-javascript">{"Err":{
    // Error: The credential could not be found in the provider.
    "kind":"operation-not-supported"
}}
</code></pre>
<p>Sent if the credential provider does not support the requested operation.
If a provider only supports <code>get</code> and a <code>login</code> is requested, the
provider should respond with this error.</p>
<h3 id="failure-response-other"><a class="header" href="#failure-response-other">Failure response (other)</a></h3>
<ul>
<li>Sent by: credential provider</li>
<li>Purpose: Gives error information to Cargo</li>
</ul>
<pre><code class="language-javascript">{"Err":{
    // Error: something else has failed
    "kind":"other",
    // Error message string to be displayed
    "message": "free form string error message",
    // Detailed cause chain for the error (optional)
    "caused-by": ["cause 1", "cause 2"]
}}
</code></pre>
<h2 id="example-communication-to-request-a-token-for-reading"><a class="header" href="#example-communication-to-request-a-token-for-reading">Example communication to request a token for reading:</a></h2>
<ol>
<li>Cargo spawns the credential process, capturing stdin and stdout.</li>
<li>Credential process sends the Hello message to Cargo
<pre><code class="language-javascript">{ "v": [1] }
</code></pre>
</li>
<li>Cargo sends the CredentialRequest message to the credential process (newlines added for readability).
<pre><code class="language-javascript">{
    "v": 1,
    "kind": "get",
    "operation": "read",
    "registry":{"index-url":"sparse+https://registry-url/index/"}
}
</code></pre>
</li>
<li>Credential process sends the CredentialResponse to Cargo (newlines added for readability).
<pre><code class="language-javascript">{
    "token": "...",
    "cache": "session",
    "operation_independent": true
}
</code></pre>
</li>
<li>Cargo closes the stdin pipe to the credential provider and it exits.</li>
<li>Cargo uses the token for the remainder of the session (until Cargo exits) when interacting with this registry.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-registry"><a class="header" href="#running-a-registry">Running a Registry</a></h1>
<p>A minimal registry can be implemented by having a git repository that contains
an index, and a server that contains the compressed <code>.crate</code> files created by
<a href="reference/../commands/cargo-package.html"><code>cargo package</code></a>. Users won’t be able to use Cargo to publish to it, but this
may be sufficient for closed environments. The index format is described in
<a href="reference/registry-index.html">Registry Index</a>.</p>
<p>A full-featured registry that supports publishing will additionally need to
have a web API service that conforms to the API used by Cargo. The web API is
described in <a href="reference/registry-web-api.html">Registry Web API</a>.</p>
<p>Commercial and community projects are available for building and running a
registry. See <a href="https://github.com/rust-lang/cargo/wiki/Third-party-registries">https://github.com/rust-lang/cargo/wiki/Third-party-registries</a>
for a list of what is available.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-format"><a class="header" href="#index-format">Index Format</a></h1>
<p>The following defines the format of the index. New features are occasionally
added, which are only understood starting with the version of Cargo that
introduced them. Older versions of Cargo may not be able to use packages that
make use of new features. However, the format for older packages should not
change, so older versions of Cargo should be able to use them.</p>
<h2 id="index-configuration"><a class="header" href="#index-configuration">Index Configuration</a></h2>
<p>The root of the index contains a file named <code>config.json</code> which contains JSON
information used by Cargo for accessing the registry. This is an example of
what the <a href="https://crates.io/">crates.io</a> config file looks like:</p>
<pre><code class="language-javascript">{
    "dl": "https://crates.io/api/v1/crates",
    "api": "https://crates.io"
}
</code></pre>
<p>The keys are:</p>
<ul>
<li>
<p><code>dl</code>: This is the URL for downloading crates listed in the index. The value
may have the following markers which will be replaced with their
corresponding value:</p>
<ul>
<li><code>{crate}</code>: The name of crate.</li>
<li><code>{version}</code>: The crate version.</li>
<li><code>{prefix}</code>: A directory prefix computed from the crate name. For example,
a crate named <code>cargo</code> has a prefix of <code>ca/rg</code>. See below for details.</li>
<li><code>{lowerprefix}</code>: Lowercase variant of <code>{prefix}</code>.</li>
<li><code>{sha256-checksum}</code>: The crate’s sha256 checksum.</li>
</ul>
<p>If none of the markers are present, then the value
<code>/{crate}/{version}/download</code> is appended to the end.</p>
</li>
<li>
<p><code>api</code>: This is the base URL for the web API. This key is optional, but if it
is not specified, commands such as <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> will not work. The web
API is described below.</p>
</li>
<li>
<p><code>auth-required</code>: indicates whether this is a private registry that requires
all operations to be authenticated including API requests, crate downloads
and sparse index updates.</p>
</li>
</ul>
<h2 id="download-endpoint"><a class="header" href="#download-endpoint">Download Endpoint</a></h2>
<p>The download endpoint should send the <code>.crate</code> file for the requested package.
Cargo supports https, http, and file URLs, HTTP redirects, HTTP1 and HTTP2.
The exact specifics of TLS support depend on the platform that Cargo is
running on, the version of Cargo, and how it was compiled.</p>
<p>If <code>auth-required: true</code> is set in <code>config.json</code>, the <code>Authorization</code> header
will be included with http(s) download requests.</p>
<h2 id="index-files"><a class="header" href="#index-files">Index files</a></h2>
<p>The rest of the index repository contains one file for each package, where the
filename is the name of the package in lowercase. Each version of the package
has a separate line in the file. The files are organized in a tier of
directories:</p>
<ul>
<li>Packages with 1 character names are placed in a directory named <code>1</code>.</li>
<li>Packages with 2 character names are placed in a directory named <code>2</code>.</li>
<li>Packages with 3 character names are placed in the directory
<code>3/{first-character}</code> where <code>{first-character}</code> is the first character of
the package name.</li>
<li>All other packages are stored in directories named
<code>{first-two}/{second-two}</code> where the top directory is the first two
characters of the package name, and the next subdirectory is the third and
fourth characters of the package name. For example, <code>cargo</code> would be stored
in a file named <code>ca/rg/cargo</code>.</li>
</ul>
<blockquote>
<p>Note: Although the index filenames are in lowercase, the fields that contain
package names in <code>Cargo.toml</code> and the index JSON data are case-sensitive and
may contain upper and lower case characters.</p>
</blockquote>
<p>The directory name above is calculated based on the package name converted to
lowercase; it is represented by the marker <code>{lowerprefix}</code>.  When the original
package name is used without case conversion, the resulting directory name is
represented by the marker <code>{prefix}</code>.  For example, the package <code>MyCrate</code> would
have a <code>{prefix}</code> of <code>My/Cr</code> and a <code>{lowerprefix}</code> of <code>my/cr</code>.  In general,
using <code>{prefix}</code> is recommended over <code>{lowerprefix}</code>, but there are pros and
cons to each choice.  Using <code>{prefix}</code> on case-insensitive filesystems results
in (harmless-but-inelegant) directory aliasing.  For example, <code>crate</code> and
<code>CrateTwo</code> have <code>{prefix}</code> values of <code>cr/at</code> and <code>Cr/at</code>; these are distinct on
Unix machines but alias to the same directory on Windows.  Using directories
with normalized case avoids aliasing, but on case-sensitive filesystems it’s
harder to support older versions of Cargo that lack <code>{prefix}</code>/<code>{lowerprefix}</code>.
For example, nginx rewrite rules can easily construct <code>{prefix}</code> but can’t
perform case-conversion to construct <code>{lowerprefix}</code>.</p>
<h2 id="name-restrictions"><a class="header" href="#name-restrictions">Name restrictions</a></h2>
<p>Registries should consider enforcing limitations on package names added to
their index. Cargo itself allows names with any <a href="reference/../../std/primitive.char.html#method.is_alphanumeric">alphanumeric</a>, <code>-</code>, or <code>_</code>
characters. <a href="https://crates.io/">crates.io</a> imposes its own limitations, including the following:</p>
<ul>
<li>Only allows ASCII characters.</li>
<li>Only alphanumeric, <code>-</code>, and <code>_</code> characters.</li>
<li>First character must be alphabetic.</li>
<li>Case-insensitive collision detection.</li>
<li>Prevent differences of <code>-</code> vs <code>_</code>.</li>
<li>Under a specific length (max 64).</li>
<li>Rejects reserved names, such as Windows special filenames like “nul”.</li>
</ul>
<p>Registries should consider incorporating similar restrictions, and consider
the security implications, such as <a href="https://en.wikipedia.org/wiki/IDN_homograph_attack">IDN homograph
attacks</a> and other
concerns in <a href="https://www.unicode.org/reports/tr36/">UTR36</a> and
<a href="https://www.unicode.org/reports/tr39/">UTS39</a>.</p>
<h2 id="version-uniqueness"><a class="header" href="#version-uniqueness">Version uniqueness</a></h2>
<p>Indexes <em>must</em> ensure that each version only appears once for each package.
This includes ignoring SemVer build metadata.
For example, the index must <em>not</em> contain two entries with a version <code>1.0.7</code> and <code>1.0.7+extra</code>.</p>
<h2 id="json-schema"><a class="header" href="#json-schema">JSON schema</a></h2>
<p>Each line in a package file contains a JSON object that describes a published
version of the package. The following is a pretty-printed example with comments
explaining the format of the entry.</p>
<pre><code class="language-javascript">{
    // The name of the package.
    // This must only contain alphanumeric, `-`, or `_` characters.
    "name": "foo",
    // The version of the package this row is describing.
    // This must be a valid version number according to the Semantic
    // Versioning 2.0.0 spec at https://semver.org/.
    "vers": "0.1.0",
    // Array of direct dependencies of the package.
    "deps": [
        {
            // Name of the dependency.
            // If the dependency is renamed from the original package name,
            // this is the new name. The original package name is stored in
            // the `package` field.
            "name": "rand",
            // The SemVer requirement for this dependency.
            // This must be a valid version requirement defined at
            // https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html.
            "req": "^0.6",
            // Array of features (as strings) enabled for this dependency.
            // Since Cargo 1.84, defaults to `[]` if not specified.
            "features": ["i128_support"],
            // Boolean of whether or not this is an optional dependency.
            // Since Cargo 1.84, defaults to `false` if not specified.
            "optional": false,
            // Boolean of whether or not default features are enabled.
            // Since Cargo 1.84, defaults to `true` if not specified.
            "default_features": true,
            // The target platform for the dependency.
            // If not specified or `null`, it is not a target dependency.
            // Otherwise, a string such as "cfg(windows)".
            "target": null,
            // The dependency kind.
            // "dev", "build", or "normal".
            // If not specified or `null`, it defaults to "normal".
            "kind": "normal",
            // The URL of the index of the registry where this dependency is
            // from as a string. If not specified or `null`, it is assumed the
            // dependency is in the current registry.
            "registry": null,
            // If the dependency is renamed, this is a string of the actual
            // package name. If not specified or `null`, this dependency is not
            // renamed.
            "package": null,
        }
    ],
    // A SHA256 checksum of the `.crate` file.
    "cksum": "d867001db0e2b6e0496f9fac96930e2d42233ecd3ca0413e0753d4c7695d289c",
    // Set of features defined for the package.
    // Each feature maps to an array of features or dependencies it enables.
    // Since Cargo 1.84, defaults to `{}` if not specified.
    "features": {
        "extras": ["rand/simd_support"]
    },
    // Boolean of whether or not this version has been yanked.
    "yanked": false,
    // The `links` string value from the package's manifest, or null if not
    // specified. This field is optional and defaults to null.
    "links": null,
    // An unsigned 32-bit integer value indicating the schema version of this
    // entry.
    //
    // If this is not specified, it should be interpreted as the default of 1.
    //
    // Cargo (starting with version 1.51) will ignore versions it does not
    // recognize. This provides a method to safely introduce changes to index
    // entries and allow older versions of cargo to ignore newer entries it
    // doesn't understand. Versions older than 1.51 ignore this field, and
    // thus may misinterpret the meaning of the index entry.
    //
    // The current values are:
    //
    // * 1: The schema as documented here, not including newer additions.
    //      This is honored in Rust version 1.51 and newer.
    // * 2: The addition of the `features2` field.
    //      This is honored in Rust version 1.60 and newer.
    "v": 2,
    // This optional field contains features with new, extended syntax.
    // Specifically, namespaced features (`dep:`) and weak dependencies
    // (`pkg?/feat`).
    //
    // This is separated from `features` because versions older than 1.19
    // will fail to load due to not being able to parse the new syntax, even
    // with a `Cargo.lock` file.
    //
    // Cargo will merge any values listed here with the "features" field.
    //
    // If this field is included, the "v" field should be set to at least 2.
    //
    // Registries are not required to use this field for extended feature
    // syntax, they are allowed to include those in the "features" field.
    // Using this is only necessary if the registry wants to support cargo
    // versions older than 1.19, which in practice is only crates.io since
    // those older versions do not support other registries.
    "features2": {
        "serde": ["dep:serde", "chrono?/serde"]
    }
    // The minimal supported Rust version (optional)
    // This must be a valid version requirement without an operator (e.g. no `=`)
    "rust_version": "1.60"
}
</code></pre>
<p>The JSON objects should not be modified after they are added except for the
<code>yanked</code> field whose value may change at any time.</p>
<blockquote>
<p><strong>Note</strong>: The index JSON format has subtle differences from the JSON format of the <a href="reference/registry-web-api.html#publish">Publish API</a> and <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a>.
If you are using one of those as a source to generate index entries, you are encouraged to carefully inspect the documentation differences between them.</p>
<p>For the <a href="reference/registry-web-api.html#publish">Publish API</a>, the differences are:</p>
<ul>
<li><code>deps</code>
<ul>
<li><code>name</code> — When the dependency is <a href="reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">renamed</a> in <code>Cargo.toml</code>, the publish API puts the original package name in the <code>name</code> field and the aliased name in the <code>explicit_name_in_toml</code> field.
The index places the aliased name in the <code>name</code> field, and the original package name in the <code>package</code> field.</li>
<li><code>req</code> — The Publish API field is called <code>version_req</code>.</li>
</ul>
</li>
<li><code>cksum</code> — The publish API does not specify the checksum, it must be computed by the registry before adding to the index.</li>
<li><code>features</code> — Some features may be placed in the <code>features2</code> field.
Note: This is only a legacy requirement for <a href="https://crates.io/">crates.io</a>; other registries should not need to bother with modifying the features map.
The <code>v</code> field indicates the presence of the <code>features2</code> field.</li>
<li>The publish API includes several other fields, such as <code>description</code> and <code>readme</code>, which don’t appear in the index.
These are intended to make it easier for a registry to obtain the metadata about the crate to display on a website without needing to extract and parse the <code>.crate</code> file.
This additional information is typically added to a database on the registry server.</li>
<li>Although <code>rust_version</code> is included here, <a href="https://crates.io/">crates.io</a> will ignore this field
and instead read it from the <code>Cargo.toml</code> contained in the <code>.crate</code> file.</li>
</ul>
<p>For <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a>, the differences are:</p>
<ul>
<li><code>vers</code> — The <code>cargo metadata</code> field is called <code>version</code>.</li>
<li><code>deps</code>
<ul>
<li><code>name</code> — When the dependency is <a href="reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">renamed</a> in <code>Cargo.toml</code>, <code>cargo metadata</code> puts the original package name in the <code>name</code> field and the aliased name in the <code>rename</code> field.
The index places the aliased name in the <code>name</code> field, and the original package name in the <code>package</code> field.</li>
<li><code>default_features</code> — The <code>cargo metadata</code> field is called <code>uses_default_features</code>.</li>
<li><code>registry</code> — <code>cargo metadata</code> uses a value of <code>null</code> to indicate that the dependency comes from <a href="https://crates.io/">crates.io</a>.
The index uses a value of <code>null</code> to indicate that the dependency comes from the same registry as the index.
When creating an index entry, a registry other than <a href="https://crates.io/">crates.io</a> should translate a value of <code>null</code> to be <code>https://github.com/rust-lang/crates.io-index</code> and translate a URL that matches the current index to be <code>null</code>.</li>
<li><code>cargo metadata</code> includes some extra fields, such as <code>source</code> and <code>path</code>.</li>
</ul>
</li>
<li>The index includes additional fields such as <code>yanked</code>, <code>cksum</code>, and <code>v</code>.</li>
</ul>
</blockquote>
<h2 id="index-protocols"><a class="header" href="#index-protocols">Index Protocols</a></h2>
<p>Cargo supports two remote registry protocols: <code>git</code> and <code>sparse</code>. The <code>git</code> protocol
stores index files in a git repository and the <code>sparse</code> protocol fetches individual
files over HTTP.</p>
<h3 id="git-protocol"><a class="header" href="#git-protocol">Git Protocol</a></h3>
<p>The git protocol has no protocol prefix in the index url. For example the git index URL
for <a href="https://crates.io/">crates.io</a> is <code>https://github.com/rust-lang/crates.io-index</code>.</p>
<p>Cargo caches the git repository on disk so that it can efficiently incrementally fetch
updates.</p>
<h3 id="sparse-protocol"><a class="header" href="#sparse-protocol">Sparse Protocol</a></h3>
<p>The sparse protocol uses the <code>sparse+</code> protocol prefix in the registry URL. For example,
the sparse index URL for <a href="https://crates.io/">crates.io</a> is <code>sparse+https://index.crates.io/</code>.</p>
<p>The sparse protocol downloads each index file using an individual HTTP request. Since
this results in a large number of small HTTP requests, performance is significantly
improved with a server that supports pipelining and HTTP/2.</p>
<h4 id="sparse-authentication"><a class="header" href="#sparse-authentication">Sparse authentication</a></h4>
<p>Cargo will attempt to fetch the <code>config.json</code> file before
fetching any other files. If the server responds with an HTTP 401, then Cargo will assume
that the registry requires authentication and re-attempt the request for <code>config.json</code>
with the authentication token included.</p>
<p>On authentication failure (or a missing authentication token) the server may include a
<code>www-authenticate</code> header with a <code>Cargo login_url="&lt;URL&gt;"</code> challenge to indicate where the user
can go to get a token.</p>
<p>Registries that require authentication must set <code>auth-required: true</code> in <code>config.json</code>.</p>
<h4 id="caching"><a class="header" href="#caching">Caching</a></h4>
<p>Cargo caches the crate metadata files, and captures the <code>ETag</code> or <code>Last-Modified</code>
HTTP header from the server for each entry. When refreshing crate metadata, Cargo
sends the <code>If-None-Match</code> or <code>If-Modified-Since</code> header to allow the server to respond
with HTTP 304 “Not Modified” if the local cache is valid, saving time and bandwidth.
If both <code>ETag</code> and <code>Last-Modified</code> headers are present, Cargo uses the <code>ETag</code> only.</p>
<h4 id="cache-invalidation"><a class="header" href="#cache-invalidation">Cache Invalidation</a></h4>
<p>If a registry is using some kind of CDN or proxy which caches access to the index files,
then it is recommended that registries implement some form of cache invalidation when
the files are updated. If these caches are not updated, then users may not be able to
access new crates until the cache is cleared.</p>
<h4 id="nonexistent-crates"><a class="header" href="#nonexistent-crates">Nonexistent Crates</a></h4>
<p>For crates that do not exist, the registry should respond with a 404 “Not Found”, 410 “Gone”
or 451 “Unavailable For Legal Reasons” code.</p>
<h4 id="sparse-limitations"><a class="header" href="#sparse-limitations">Sparse Limitations</a></h4>
<p>Since the URL of the registry is stored in the lockfile, it’s not recommended to offer
a registry with both protocols. Discussion about a transition plan is ongoing in issue
<a href="https://github.com/rust-lang/cargo/issues/10964">#10964</a>. The <a href="https://crates.io/">crates.io</a> registry is an exception, since Cargo internally substitutes
the equivalent git URL when the sparse protocol is used.</p>
<p>If a registry does offer both protocols, it’s currently recommended to choose one protocol
as the canonical protocol and use <a href="reference/../reference/source-replacement.html">source replacement</a> for the other protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-api"><a class="header" href="#web-api">Web API</a></h1>
<p>A registry may host a web API at the location defined in <code>config.json</code> to
support any of the actions listed below.</p>
<p>Cargo includes the <code>Authorization</code> header for requests that require
authentication. The header value is the API token. The server should respond
with a 403 response code if the token is not valid. Users are expected to
visit the registry’s website to obtain a token, and Cargo can store the token
using the <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> command, or by passing the token on the
command-line.</p>
<p>Responses use a 2xx response code for success.
Errors should use an appropriate response code, such as 404.
Failure
responses should have a JSON object with the following structure:</p>
<pre><code class="language-javascript">{
    // Array of errors to display to the user.
    "errors": [
        {
            // The error message as a string.
            "detail": "error message text"
        }
    ]
}
</code></pre>
<p>If the response has this structure Cargo will display the detailed message to the user, even if the response code is 200.
If the response code indicates an error and the content does not have this structure, Cargo will display to the user a
message intended to help debugging the server error. A server returning an <code>errors</code> object allows a registry to provide a more
detailed or user-centric error message.</p>
<p>For backwards compatibility, servers should ignore any unexpected query
parameters or JSON fields. If a JSON field is missing, it should be assumed to
be null. The endpoints are versioned with the <code>v1</code> component of the path, and
Cargo is responsible for handling backwards compatibility fallbacks should any
be required in the future.</p>
<p>Cargo sets the following headers for all requests:</p>
<ul>
<li><code>Content-Type</code>: <code>application/json</code> (for requests with a body payload)</li>
<li><code>Accept</code>: <code>application/json</code></li>
<li><code>User-Agent</code>: The Cargo version such as <code>cargo/1.32.0 (8610973aa 2019-01-02)</code>. This may be modified by the user in a configuration value.
Added in 1.29.</li>
</ul>
<h2 id="publish"><a class="header" href="#publish">Publish</a></h2>
<ul>
<li>Endpoint: <code>/api/v1/crates/new</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>The publish endpoint is used to publish a new version of a crate. The server
should validate the crate, make it available for download, and add it to the
index.</p>
<p>It is not required for the index to be updated before the successful response is sent.
After a successful response, Cargo will poll the index for a short period of time to identify that the new crate has been added.
If the crate does not appear in the index after a short period of time, then Cargo will display a warning letting the user know that the new crate is not yet available.</p>
<p>The body of the data sent by Cargo is:</p>
<ul>
<li>32-bit unsigned little-endian integer of the length of JSON data.</li>
<li>Metadata of the package as a JSON object.</li>
<li>32-bit unsigned little-endian integer of the length of the <code>.crate</code> file.</li>
<li>The <code>.crate</code> file.</li>
</ul>
<p>The following is a commented example of the JSON object. Some notes of some
restrictions imposed by <a href="https://crates.io/">crates.io</a> are included only to illustrate some
suggestions on types of validation that may be done, and should not be
considered as an exhaustive list of restrictions <a href="https://crates.io/">crates.io</a> imposes.</p>
<pre><code class="language-javascript">{
    // The name of the package.
    "name": "foo",
    // The version of the package being published.
    "vers": "0.1.0",
    // Array of direct dependencies of the package.
    "deps": [
        {
            // Name of the dependency.
            // If the dependency is renamed from the original package name,
            // this is the original name. The new package name is stored in
            // the `explicit_name_in_toml` field.
            "name": "rand",
            // The semver requirement for this dependency.
            "version_req": "^0.6",
            // Array of features (as strings) enabled for this dependency.
            "features": ["i128_support"],
            // Boolean of whether or not this is an optional dependency.
            "optional": false,
            // Boolean of whether or not default features are enabled.
            "default_features": true,
            // The target platform for the dependency.
            // null if not a target dependency.
            // Otherwise, a string such as "cfg(windows)".
            "target": null,
            // The dependency kind.
            // "dev", "build", or "normal".
            "kind": "normal",
            // The URL of the index of the registry where this dependency is
            // from as a string. If not specified or null, it is assumed the
            // dependency is in the current registry.
            "registry": null,
            // If the dependency is renamed, this is a string of the new
            // package name. If not specified or null, this dependency is not
            // renamed.
            "explicit_name_in_toml": null,
        }
    ],
    // Set of features defined for the package.
    // Each feature maps to an array of features or dependencies it enables.
    // Cargo does not impose limitations on feature names, but crates.io
    // requires alphanumeric ASCII, `_` or `-` characters.
    "features": {
        "extras": ["rand/simd_support"]
    },
    // List of strings of the authors.
    // May be empty.
    "authors": ["Alice &lt;a@example.com&gt;"],
    // Description field from the manifest.
    // May be null. crates.io requires at least some content.
    "description": null,
    // String of the URL to the website for this package's documentation.
    // May be null.
    "documentation": null,
    // String of the URL to the website for this package's home page.
    // May be null.
    "homepage": null,
    // String of the content of the README file.
    // May be null.
    "readme": null,
    // String of a relative path to a README file in the crate.
    // May be null.
    "readme_file": null,
    // Array of strings of keywords for the package.
    "keywords": [],
    // Array of strings of categories for the package.
    "categories": [],
    // String of the license for the package.
    // May be null. crates.io requires either `license` or `license_file` to be set.
    "license": null,
    // String of a relative path to a license file in the crate.
    // May be null.
    "license_file": null,
    // String of the URL to the website for the source repository of this package.
    // May be null.
    "repository": null,
    // Optional object of "status" badges. Each value is an object of
    // arbitrary string to string mappings.
    // crates.io has special interpretation of the format of the badges.
    "badges": {
        "travis-ci": {
            "branch": "master",
            "repository": "rust-lang/cargo"
        }
    },
    // The `links` string value from the package's manifest, or null if not
    // specified. This field is optional and defaults to null.
    "links": null,
    // The minimal supported Rust version (optional)
    // This must be a valid version requirement without an operator (e.g. no `=`)
    "rust_version": null
}
</code></pre>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Optional object of warnings to display to the user.
    "warnings": {
        // Array of strings of categories that are invalid and ignored.
        "invalid_categories": [],
        // Array of strings of badge names that are invalid and ignored.
        "invalid_badges": [],
        // Array of strings of arbitrary warnings to display to the user.
        "other": []
    }
}
</code></pre>
<h2 id="yank"><a class="header" href="#yank">Yank</a></h2>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/{version}/yank</code></li>
<li>Method: DELETE</li>
<li>Authorization: Included</li>
</ul>
<p>The yank endpoint will set the <code>yank</code> field of the given version of a crate to
<code>true</code> in the index.</p>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Indicates the yank succeeded, always true.
    "ok": true,
}
</code></pre>
<h2 id="unyank"><a class="header" href="#unyank">Unyank</a></h2>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/{version}/unyank</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>The unyank endpoint will set the <code>yank</code> field of the given version of a crate
to <code>false</code> in the index.</p>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Indicates the unyank succeeded, always true.
    "ok": true,
}
</code></pre>
<h2 id="owners"><a class="header" href="#owners">Owners</a></h2>
<p>Cargo does not have an inherent notion of users and owners, but it does
provide the <code>owner</code> command to assist managing who has authorization to
control a crate. It is up to the registry to decide exactly how users and
owners are handled. See the <a href="reference/publishing.html#cargo-owner">publishing documentation</a> for a description of
how <a href="https://crates.io/">crates.io</a> handles owners via GitHub users and teams.</p>
<h3 id="owners-list"><a class="header" href="#owners-list">Owners: List</a></h3>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: GET</li>
<li>Authorization: Included</li>
</ul>
<p>The owners endpoint returns a list of owners of the crate.</p>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Array of owners of the crate.
    "users": [
        {
            // Unique unsigned 32-bit integer of the owner.
            "id": 70,
            // The unique username of the owner.
            "login": "github:rust-lang:core",
            // Name of the owner.
            // This is optional and may be null.
            "name": "Core",
        }
    ]
}
</code></pre>
<h3 id="owners-add"><a class="header" href="#owners-add">Owners: Add</a></h3>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>A PUT request will send a request to the registry to add a new owner to a
crate. It is up to the registry how to handle the request. For example,
<a href="https://crates.io/">crates.io</a> sends an invite to the user that they must accept before being
added.</p>
<p>The request should include the following JSON object:</p>
<pre><code class="language-javascript">{
    // Array of `login` strings of owners to add.
    "users": ["login_name"]
}
</code></pre>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Indicates the add succeeded, always true.
    "ok": true,
    // A string to be displayed to the user.
    "msg": "user ehuss has been invited to be an owner of crate cargo"
}
</code></pre>
<h3 id="owners-remove"><a class="header" href="#owners-remove">Owners: Remove</a></h3>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: DELETE</li>
<li>Authorization: Included</li>
</ul>
<p>A DELETE request will remove an owner from a crate. The request should include
the following JSON object:</p>
<pre><code class="language-javascript">{
    // Array of `login` strings of owners to remove.
    "users": ["login_name"]
}
</code></pre>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Indicates the remove succeeded, always true.
    "ok": true
    // A string to be displayed to the user. Currently ignored by cargo.
    "msg": "owners successfully removed",
}
</code></pre>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<ul>
<li>Endpoint: <code>/api/v1/crates</code></li>
<li>Method: GET</li>
<li>Query Parameters:
<ul>
<li><code>q</code>: The search query string.</li>
<li><code>per_page</code>: Number of results, default 10, max 100.</li>
</ul>
</li>
</ul>
<p>The search request will perform a search for crates, using criteria defined on
the server.</p>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Array of results.
    "crates": [
        {
            // Name of the crate.
            "name": "rand",
            // The highest version available.
            "max_version": "0.6.1",
            // Textual description of the crate.
            "description": "Random number generators and other randomness functionality.\n",
        }
    ],
    "meta": {
        // Total number of results available on the server.
        "total": 119
    }
}
</code></pre>
<h2 id="login"><a class="header" href="#login">Login</a></h2>
<ul>
<li>Endpoint: <code>/me</code></li>
</ul>
<p>The “login” endpoint is not an actual API request. It exists solely for the
<a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> command to display a URL to instruct a user to visit in a web
browser to log in and retrieve an API token.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semver-compatibility-2"><a class="header" href="#semver-compatibility-2">SemVer Compatibility</a></h1>
<p>This chapter provides details on what is conventionally considered a
compatible or breaking SemVer change for new releases of a package. See the
<a href="reference/resolver.html#semver-compatibility">SemVer compatibility</a> section for details on what SemVer is, and how Cargo
uses it to ensure compatibility of libraries.</p>
<p>These are only <em>guidelines</em>, and not necessarily hard-and-fast rules that all
projects will obey. The <a href="reference/semver.html#change-categories">Change categories</a> section details how this guide
classifies the level and severity of a change. Most of this guide focuses on
changes that will cause <code>cargo</code> and <code>rustc</code> to fail to build something that
previously worked. Almost every change carries some risk that it will
negatively affect the runtime behavior, and for those cases it is usually a
judgment call by the project maintainers whether or not it is a
SemVer-incompatible change.</p>
<h2 id="change-categories"><a class="header" href="#change-categories">Change categories</a></h2>
<p>All of the policies listed below are categorized by the level of change:</p>
<ul>
<li><strong>Major change</strong>: a change that requires a major SemVer bump.</li>
<li><strong>Minor change</strong>: a change that requires only a minor SemVer bump.</li>
<li><strong>Possibly-breaking change</strong>: a change that some projects may consider major
and others consider minor.</li>
</ul>
<p>The “Possibly-breaking” category covers changes that have the <em>potential</em> to
break during an update, but may not necessarily cause a breakage. The impact
of these changes should be considered carefully. The exact nature will depend
on the change and the principles of the project maintainers.</p>
<p>Some projects may choose to only bump the patch number on a minor change. It
is encouraged to follow the SemVer spec, and only apply bug fixes in patch
releases. However, a bug fix may require an API change that is marked as a
“minor change”, and shouldn’t affect compatibility. This guide does not take a
stance on how each individual “minor change” should be treated, as the
difference between minor and patch changes are conventions that depend on the
nature of the change.</p>
<p>Some changes are marked as “minor”, even though they carry the potential risk
of breaking a build. This is for situations where the potential is extremely
low, and the potentially breaking code is unlikely to be written in idiomatic
Rust, or is specifically discouraged from use.</p>
<p>This guide uses the terms “major” and “minor” assuming this relates to a
“1.0.0” release or later. Initial development releases starting with “0.y.z”
can treat changes in “y” as a major release, and “z” as a minor release.
“0.0.z” releases are always major changes. This is because Cargo uses the
convention that only changes in the left-most non-zero component are
considered incompatible.</p>
<ul>
<li>API compatibility
<ul>
<li>Items
<ul>
<li><a href="reference/semver.html#item-remove">Major: renaming/moving/removing any public items</a></li>
<li><a href="reference/semver.html#item-new">Minor: adding new public items</a></li>
</ul>
</li>
<li>Types
<ul>
<li><a href="reference/semver.html#type-layout">Major: Changing the alignment, layout, or size of a well-defined type</a></li>
</ul>
</li>
<li>Structs
<ul>
<li><a href="reference/semver.html#struct-add-private-field-when-public">Major: adding a private struct field when all current fields are public</a></li>
<li><a href="reference/semver.html#struct-add-public-field-when-no-private">Major: adding a public field when no private field exists</a></li>
<li><a href="reference/semver.html#struct-private-fields-with-private">Minor: adding or removing private fields when at least one already exists</a></li>
<li><a href="reference/semver.html#struct-tuple-normal-with-private">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></li>
</ul>
</li>
<li>Enums
<ul>
<li><a href="reference/semver.html#enum-variant-new">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></li>
<li><a href="reference/semver.html#enum-fields-new">Major: adding new fields to an enum variant</a></li>
</ul>
</li>
<li>Traits
<ul>
<li><a href="reference/semver.html#trait-new-item-no-default">Major: adding a non-defaulted trait item</a></li>
<li><a href="reference/semver.html#trait-item-signature">Major: any change to trait item signatures</a></li>
<li><a href="reference/semver.html#trait-new-default-item">Possibly-breaking: adding a defaulted trait item</a></li>
<li><a href="reference/semver.html#trait-object-safety">Major: adding a trait item that makes the trait non-object safe</a></li>
<li><a href="reference/semver.html#trait-new-parameter-no-default">Major: adding a type parameter without a default</a></li>
<li><a href="reference/semver.html#trait-new-parameter-default">Minor: adding a defaulted trait type parameter</a></li>
</ul>
</li>
<li>Implementations
<ul>
<li><a href="reference/semver.html#impl-item-new">Possibly-breaking change: adding any inherent items</a></li>
</ul>
</li>
<li>Generics
<ul>
<li><a href="reference/semver.html#generic-bounds-tighten">Major: tightening generic bounds</a></li>
<li><a href="reference/semver.html#generic-bounds-loosen">Minor: loosening generic bounds</a></li>
<li><a href="reference/semver.html#generic-new-default">Minor: adding defaulted type parameters</a></li>
<li><a href="reference/semver.html#generic-generalize-identical">Minor: generalizing a type to use generics (with identical types)</a></li>
<li><a href="reference/semver.html#generic-generalize-different">Major: generalizing a type to use generics (with possibly different types)</a></li>
<li><a href="reference/semver.html#generic-more-generic">Minor: changing a generic type to a more generic type</a></li>
<li><a href="reference/semver.html#generic-rpit-capture">Major: capturing more generic parameters in RPIT</a></li>
</ul>
</li>
<li>Functions
<ul>
<li><a href="reference/semver.html#fn-change-arity">Major: adding/removing function parameters</a></li>
<li><a href="reference/semver.html#fn-generic-new">Possibly-breaking: introducing a new function type parameter</a></li>
<li><a href="reference/semver.html#fn-generalize-compatible">Minor: generalizing a function to use generics (supporting original type)</a></li>
<li><a href="reference/semver.html#fn-generalize-mismatch">Major: generalizing a function to use generics with type mismatch</a></li>
<li><a href="reference/semver.html#fn-unsafe-safe">Minor: making an <code>unsafe</code> function safe</a></li>
</ul>
</li>
<li>Attributes
<ul>
<li><a href="reference/semver.html#attr-no-std-to-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></li>
<li><a href="reference/semver.html#attr-adding-non-exhaustive">Major: adding <code>non_exhaustive</code> to an existing enum, variant, or struct with no private fields</a></li>
</ul>
</li>
</ul>
</li>
<li>Tooling and environment compatibility
<ul>
<li><a href="reference/semver.html#env-new-rust">Possibly-breaking: changing the minimum version of Rust required</a></li>
<li><a href="reference/semver.html#env-change-requirements">Possibly-breaking: changing the platform and environment requirements</a></li>
<li><a href="reference/semver.html#new-lints">Minor: introducing new lints</a></li>
<li>Cargo
<ul>
<li><a href="reference/semver.html#cargo-feature-add">Minor: adding a new Cargo feature</a></li>
<li><a href="reference/semver.html#cargo-feature-remove">Major: removing a Cargo feature</a></li>
<li><a href="reference/semver.html#cargo-feature-remove-another">Major: removing a feature from a feature list if that changes functionality or public items</a></li>
<li><a href="reference/semver.html#cargo-remove-opt-dep">Possibly-breaking: removing an optional dependency</a></li>
<li><a href="reference/semver.html#cargo-change-dep-feature">Minor: changing dependency features</a></li>
<li><a href="reference/semver.html#cargo-dep-add">Minor: adding dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="reference/semver.html#application-compatibility">Application compatibility</a></li>
</ul>
<h2 id="api-compatibility"><a class="header" href="#api-compatibility">API compatibility</a></h2>
<p>All of the examples below contain three parts: the original code, the code
after it has been modified, and an example usage of the code that could appear
in another project. In a minor change, the example usage should successfully
build with both the before and after versions.</p>
<h3 id="item-remove"><a class="header" href="#item-remove">Major: renaming/moving/removing any public items</a></h3>
<p>The absence of a publicly exposed <a href="reference/../../reference/items.html">item</a> will cause any uses of that item to
fail to compile.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
// ... item has been removed

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: cannot find function `foo`
}</code></pre>
<p>This includes adding any sort of <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> which can change which
items or behavior is available based on <a href="reference/../../reference/conditional-compilation.html">conditional compilation</a>.</p>
<p>Mitigating strategies:</p>
<ul>
<li>Mark items to be removed as <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>, and then remove them at a later
date in a SemVer-breaking release.</li>
<li>Mark renamed items as <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>, and use a <a href="reference/../../reference/items/use-declarations.html"><code>pub use</code></a> item to re-export
to the old name.</li>
</ul>
<h3 id="item-new"><a class="header" href="#item-new">Minor: adding new public items</a></h3>
<p>Adding new, public <a href="reference/../../reference/items.html">items</a> is a minor change.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
// ... absence of item

///////////////////////////////////////////////////////////
// After
pub fn foo() {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
// `foo` is not used since it didn't previously exist.</code></pre>
<p>Note that in some rare cases this can be a <strong>breaking change</strong> due to glob
imports. For example, if you add a new trait, and a project has used a glob
import that brings that trait into scope, and the new trait introduces an
associated item that conflicts with any types it is implemented on, this can
cause a compile-time error due to the ambiguity. Example:</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
// ... absence of trait

///////////////////////////////////////////////////////////
// After
pub trait NewTrait {
    fn foo(&amp;self) {}
}

impl NewTrait for i32 {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::*;

pub trait LocalTrait {
    fn foo(&amp;self) {}
}

impl LocalTrait for i32 {}

fn main() {
    123i32.foo(); // Error:  multiple applicable items in scope
}</code></pre>
<p>This is not considered a major change because conventionally glob imports are
a known forwards-compatibility hazard. Glob imports of items from external
crates should be avoided.</p>
<h3 id="type-layout"><a class="header" href="#type-layout">Major: Changing the alignment, layout, or size of a well-defined type</a></h3>
<p>It is a breaking change to change the alignment, layout, or size of a type that was previously well-defined.</p>
<p>In general, types that use the <a href="reference/../../reference/type-layout.html#the-default-representation">the default representation</a> do not have a well-defined alignment, layout, or size.
The compiler is free to alter the alignment, layout, or size, so code should not make any assumptions about it.</p>
<blockquote>
<p><strong>Note</strong>: It may be possible for external crates to break if they make assumptions about the alignment, layout, or size of a type even if it is not well-defined.
This is not considered a SemVer breaking change since those assumptions should not be made.</p>
</blockquote>
<p>Some examples of changes that are not a breaking change are (assuming no other rules in this guide are violated):</p>
<ul>
<li>Adding, removing, reordering, or changing fields of a default representation struct, union, or enum in such a way that the change follows the other rules in this guide (for example, using <code>non_exhaustive</code> to allow those changes, or changes to private fields that are already private).
See <a href="reference/semver.html#struct-add-private-field-when-public">struct-add-private-field-when-public</a>, <a href="reference/semver.html#struct-add-public-field-when-no-private">struct-add-public-field-when-no-private</a>, <a href="reference/semver.html#struct-private-fields-with-private">struct-private-fields-with-private</a>, <a href="reference/semver.html#enum-fields-new">enum-fields-new</a>.</li>
<li>Adding variants to a default representation enum, if the enum uses <code>non_exhaustive</code>.
This may change the alignment or size of the enumeration, but those are not well-defined.
See <a href="reference/semver.html#enum-variant-new">enum-variant-new</a>.</li>
<li>Adding, removing, reordering, or changing private fields of a <code>repr(C)</code> struct, union, or enum, following the other rules in this guide (for example, using <code>non_exhaustive</code>, or adding private fields when other private fields already exist).
See <a href="reference/semver.html#repr-c-private-change">repr-c-private-change</a>.</li>
<li>Adding variants to a <code>repr(C)</code> enum, if the enum uses <code>non_exhaustive</code>.
See <a href="reference/semver.html#repr-c-enum-variant-new">repr-c-enum-variant-new</a>.</li>
<li>Adding <code>repr(C)</code> to a default representation struct, union, or enum.
See <a href="reference/semver.html#repr-c-add">repr-c-add</a>.</li>
<li>Adding <code>repr(&lt;int&gt;)</code> <a href="reference/../../reference/type-layout.html#primitive-representations">primitive representation</a> to an enum.
See <a href="reference/semver.html#repr-int-enum-add">repr-int-enum-add</a>.</li>
<li>Adding <code>repr(transparent)</code> to a default representation struct or enum.
See <a href="reference/semver.html#repr-transparent-add">repr-transparent-add</a>.</li>
</ul>
<p>Types that use the <a href="reference/../../reference/type-layout.html#representations"><code>repr</code> attribute</a> can be said to have an alignment and layout that is defined in some way that code may make some assumptions about that may break as a result of changing that type.</p>
<p>In some cases, types with a <code>repr</code> attribute may not have an alignment, layout, or size that is well-defined.
In these cases, it may be safe to make changes to the types, though care should be exercised.
For example, types with private fields that do not otherwise document their alignment, layout, or size guarantees cannot be relied upon by external crates since the public API does not fully define the alignment, layout, or size of the type.</p>
<p>A common example where a type with <em>private</em> fields is well-defined is a type with a single private field with a generic type, using <code>repr(transparent)</code>,
and the prose of the documentation discusses that it is transparent to the generic type.
For example, see <a href="reference/../../std/cell/struct.UnsafeCell.html#memory-layout"><code>UnsafeCell</code></a>.</p>
<p>Some examples of breaking changes are:</p>
<ul>
<li>Adding <code>repr(packed)</code> to a struct or union.
See <a href="reference/semver.html#repr-packed-add">repr-packed-add</a>.</li>
<li>Adding <code>repr(align)</code> to a struct, union, or enum.
See <a href="reference/semver.html#repr-align-add">repr-align-add</a>.</li>
<li>Removing <code>repr(packed)</code> from a struct or union.
See <a href="reference/semver.html#repr-packed-remove">repr-packed-remove</a>.</li>
<li>Changing the value N of <code>repr(packed(N))</code> if that changes the alignment or layout.
See <a href="reference/semver.html#repr-packed-n-change">repr-packed-n-change</a>.</li>
<li>Changing the value N of <code>repr(align(N))</code> if that changes the alignment.
See <a href="reference/semver.html#repr-align-n-change">repr-align-n-change</a>.</li>
<li>Removing <code>repr(align)</code> from a struct, union, or enum.
See <a href="reference/semver.html#repr-align-remove">repr-align-remove</a>.</li>
<li>Changing the order of public fields of a <code>repr(C)</code> type.
See <a href="reference/semver.html#repr-c-shuffle">repr-c-shuffle</a>.</li>
<li>Removing <code>repr(C)</code> from a struct, union, or enum.
See <a href="reference/semver.html#repr-c-remove">repr-c-remove</a>.</li>
<li>Removing <code>repr(&lt;int&gt;)</code> from an enum.
See <a href="reference/semver.html#repr-int-enum-remove">repr-int-enum-remove</a>.</li>
<li>Changing the primitive representation of a <code>repr(&lt;int&gt;)</code> enum.
See <a href="reference/semver.html#repr-int-enum-change">repr-int-enum-change</a>.</li>
<li>Removing <code>repr(transparent)</code> from a struct or enum.
See <a href="reference/semver.html#repr-transparent-remove">repr-transparent-remove</a>.</li>
</ul>
<h4 id="repr-c-private-change"><a class="header" href="#repr-c-private-change">Minor: <code>repr(C)</code> add, remove, or change a private field</a></h4>
<p>It is usually safe to add, remove, or change a private field of a <code>repr(C)</code> struct, union, or enum, assuming it follows the other guidelines in this guide (see <a href="reference/semver.html#struct-add-private-field-when-public">struct-add-private-field-when-public</a>, <a href="reference/semver.html#struct-add-public-field-when-no-private">struct-add-public-field-when-no-private</a>, <a href="reference/semver.html#struct-private-fields-with-private">struct-private-fields-with-private</a>, <a href="reference/semver.html#enum-fields-new">enum-fields-new</a>).</p>
<p>For example, adding private fields can only be done if there are already other private fields, or it is <code>non_exhaustive</code>.
Public fields may be added if there are private fields, or it is <code>non_exhaustive</code>, and the addition does not alter the layout of the other fields.</p>
<p>However, this may change the size and alignment of the type.
Care should be taken if the size or alignment changes.
Code should not make assumptions about the size or alignment of types with private fields or <code>non_exhaustive</code> unless it has a documented size or alignment.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
#[repr(C)]
pub struct Example {
    pub f1: i32,
    f2: i32, // a private field
}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
#[repr(C)]
pub struct Example {
    pub f1: i32,
    f2: i32,
    f3: i32, // a new field
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // NOTE: Users should not make assumptions about the size or alignment
    // since they are not documented.
    let f = updated_crate::Example::default();
}</code></pre>
<h4 id="repr-c-enum-variant-new"><a class="header" href="#repr-c-enum-variant-new">Minor: <code>repr(C)</code> add enum variant</a></h4>
<p>It is usually safe to add variants to a <code>repr(C)</code> enum, if the enum uses <code>non_exhaustive</code>.
See <a href="reference/semver.html#enum-variant-new">enum-variant-new</a> for more discussion.</p>
<p>Note that this may be a breaking change since it changes the size and alignment of the type.
See <a href="reference/semver.html#repr-c-private-change">repr-c-private-change</a> for similar concerns.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(C)]
#[non_exhaustive]
pub enum Example {
    Variant1 { f1: i16 },
    Variant2 { f1: i32 },
}

///////////////////////////////////////////////////////////
// After
#[repr(C)]
#[non_exhaustive]
pub enum Example {
    Variant1 { f1: i16 },
    Variant2 { f1: i32 },
    Variant3 { f1: i64 }, // added
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // NOTE: Users should not make assumptions about the size or alignment
    // since they are not specified. For example, this raised the size from 8
    // to 16 bytes.
    let f = updated_crate::Example::Variant2 { f1: 123 };
}</code></pre>
<h4 id="repr-c-add"><a class="header" href="#repr-c-add">Minor: Adding <code>repr(C)</code> to a default representation</a></h4>
<p>It is safe to add <code>repr(C)</code> to a struct, union, or enum with <a href="reference/../../reference/type-layout.html#the-default-representation">the default representation</a>.
This is safe because users should not make assumptions about the alignment, layout, or size of types with the default representation.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Example {
    pub f1: i32,
    pub f2: i16,
}

///////////////////////////////////////////////////////////
// After
#[repr(C)] // added
pub struct Example {
    pub f1: i32,
    pub f2: i16,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    let f = updated_crate::Example { f1: 123, f2: 456 };
}</code></pre>
<h4 id="repr-int-enum-add"><a class="header" href="#repr-int-enum-add">Minor: Adding <code>repr(&lt;int&gt;)</code> to an enum</a></h4>
<p>It is safe to add <code>repr(&lt;int&gt;)</code> <a href="reference/../../reference/type-layout.html#primitive-representations">primitive representation</a> to an enum with <a href="reference/../../reference/type-layout.html#the-default-representation">the default representation</a>.
This is safe because users should not make assumptions about the alignment, layout, or size of an enum with the default representation.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1,
    Variant2(i32),
    Variant3 { f1: f64 },
}

///////////////////////////////////////////////////////////
// After
#[repr(i32)] // added
pub enum E {
    Variant1,
    Variant2(i32),
    Variant3 { f1: f64 },
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    let x = updated_crate::E::Variant3 { f1: 1.23 };
}</code></pre>
<h4 id="repr-transparent-add"><a class="header" href="#repr-transparent-add">Minor: Adding <code>repr(transparent)</code> to a default representation struct or enum</a></h4>
<p>It is safe to add <code>repr(transparent)</code> to a struct or enum with <a href="reference/../../reference/type-layout.html#the-default-representation">the default representation</a>.
This is safe because users should not make assumptions about the alignment, layout, or size of a struct or enum with the default representation.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Example&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
#[repr(transparent)] // added
pub struct Example&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    let x = updated_crate::Example::&lt;i32&gt;::default();
}</code></pre>
<h4 id="repr-packed-add"><a class="header" href="#repr-packed-add">Major: Adding <code>repr(packed)</code> to a struct or union</a></h4>
<p>It is a breaking change to add <code>repr(packed)</code> to a struct or union.
Making a type <code>repr(packed)</code> makes changes that can break code, such as being invalid to take a reference to a field, or causing truncation of disjoint closure captures.</p>
<!-- TODO: If all fields are private, should this be safe to do? -->
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Example {
    pub f1: u8,
    pub f2: u16,
}

///////////////////////////////////////////////////////////
// After
#[repr(packed)] // added
pub struct Example {
    pub f1: u8,
    pub f2: u16,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let f = updated_crate::Example { f1: 1, f2: 2 };
    let x = &amp;f.f2; // Error: reference to packed field is unaligned
}</code></pre>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Example(pub i32, pub i32);

///////////////////////////////////////////////////////////
// After
#[repr(packed)]
pub struct Example(pub i32, pub i32);

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let mut f = updated_crate::Example(123, 456);
    let c = || {
        // Without repr(packed), the closure precisely captures `&amp;f.0`.
        // With repr(packed), the closure captures `&amp;f` to avoid undefined behavior.
        let a = f.0;
    };
    f.1 = 789; // Error: cannot assign to `f.1` because it is borrowed
    c();
}</code></pre>
<h4 id="repr-align-add"><a class="header" href="#repr-align-add">Major: Adding <code>repr(align)</code> to a struct, union, or enum</a></h4>
<p>It is a breaking change to add <code>repr(align)</code> to a struct, union, or enum.
Making a type <code>repr(align)</code> would break any use of that type in a <code>repr(packed)</code> type because that combination is not allowed.</p>
<!-- TODO: This seems like it should be extraordinarily rare. Should there be any exceptions carved out for this? -->
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Aligned {
    pub a: i32,
}

///////////////////////////////////////////////////////////
// After
#[repr(align(8))] // added
pub struct Aligned {
    pub a: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Aligned;

#[repr(packed)]
pub struct Packed { // Error: packed type cannot transitively contain a `#[repr(align)]` type
    f1: Aligned,
}

fn main() {
    let p = Packed {
        f1: Aligned { a: 123 },
    };
}</code></pre>
<h4 id="repr-packed-remove"><a class="header" href="#repr-packed-remove">Major: Removing <code>repr(packed)</code> from a struct or union</a></h4>
<p>It is a breaking change to remove <code>repr(packed)</code> from a struct or union.
This may change the alignment or layout that extern crates are relying on.</p>
<p>If any fields are public, then removing <code>repr(packed)</code> may change the way disjoint closure captures work.
In some cases, this can cause code to break, similar to those outlined in the <a href="reference/../../edition-guide/rust-2021/disjoint-capture-in-closures.html">edition guide</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(C, packed)]
pub struct Packed {
    pub a: u8,
    pub b: u16,
}

///////////////////////////////////////////////////////////
// After
#[repr(C)] // removed packed
pub struct Packed {
    pub a: u8,
    pub b: u16,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // Some assumption about the size of the type.
    // Without `packed`, this fails since the size is 4.
    const _: () = assert!(std::mem::size_of::&lt;Packed&gt;() == 3); // Error: assertion failed
}</code></pre>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(C, packed)]
pub struct Packed {
    pub a: *mut i32,
    pub b: i32,
}
unsafe impl Send for Packed {}

///////////////////////////////////////////////////////////
// After
#[repr(C)] // removed packed
pub struct Packed {
    pub a: *mut i32,
    pub b: i32,
}
unsafe impl Send for Packed {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Packed;

fn main() {
    let mut x = 123;

    let p = Packed {
        a: &amp;mut x as *mut i32,
        b: 456,
    };

    // When the structure was packed, the closure captures `p` which is Send.
    // When `packed` is removed, this ends up capturing `p.a` which is not Send.
    std::thread::spawn(move || unsafe {
        *(p.a) += 1; // Error: cannot be sent between threads safely
    });
}</code></pre>
<h4 id="repr-packed-n-change"><a class="header" href="#repr-packed-n-change">Major: Changing the value N of <code>repr(packed(N))</code> if that changes the alignment or layout</a></h4>
<p>It is a breaking change to change the value of N of <code>repr(packed(N))</code> if that changes the alignment or layout.
This may change the alignment or layout that external crates are relying on.</p>
<p>If the value <code>N</code> is lowered below the alignment of a public field, then that would break any code that attempts to take a reference of that field.</p>
<p>Note that some changes to <code>N</code> may not change the alignment or layout, for example increasing it when the current value is already equal to the natural alignment of the type.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(packed(4))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// After
#[repr(packed(2))] // changed to 2
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    let x = &amp;p.b; // Error: reference to packed field is unaligned
}</code></pre>
<h4 id="repr-align-n-change"><a class="header" href="#repr-align-n-change">Major: Changing the value N of <code>repr(align(N))</code> if that changes the alignment</a></h4>
<p>It is a breaking change to change the value <code>N</code> of <code>repr(align(N))</code> if that changes the alignment.
This may change the alignment that external crates are relying on.</p>
<p>This change should be safe to make if the type is not well-defined as discussed in <a href="reference/semver.html#type-layout">type layout</a> (such as having any private fields and having an undocumented alignment or layout).</p>
<p>Note that some changes to <code>N</code> may not change the alignment or layout, for example decreasing it when the current value is already equal to or less than the natural alignment of the type.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(align(8))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// After
#[repr(align(4))] // changed to 4
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // Some assumption about the size of the type.
    // The alignment has changed from 8 to 4.
    const _: () = assert!(std::mem::align_of::&lt;Packed&gt;() == 8); // Error: assertion failed
}</code></pre>
<h4 id="repr-align-remove"><a class="header" href="#repr-align-remove">Major: Removing <code>repr(align)</code> from a struct, union, or enum</a></h4>
<p>It is a breaking change to remove <code>repr(align)</code> from a struct, union, or enum, if their layout was well-defined.
This may change the alignment or layout that external crates are relying on.</p>
<p>This change should be safe to make if the type is not well-defined as discussed in <a href="reference/semver.html#type-layout">type layout</a> (such as having any private fields and having an undocumented alignment).</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(C, align(8))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// After
#[repr(C)] // removed align
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // Some assumption about the size of the type.
    // The alignment has changed from 8 to 4.
    const _: () = assert!(std::mem::align_of::&lt;Packed&gt;() == 8); // Error: assertion failed
}</code></pre>
<h4 id="repr-c-shuffle"><a class="header" href="#repr-c-shuffle">Major: Changing the order of public fields of a <code>repr(C)</code> type</a></h4>
<p>It is a breaking change to change the order of public fields of a <code>repr(C)</code> type.
External crates may be relying on the specific ordering of the fields.</p>
<pre><code class="language-rust ignore run-fail">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(C)]
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// After
#[repr(C)]
pub struct SpecificLayout {
    pub b: u32, // changed order
    pub a: u8,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::SpecificLayout;

unsafe extern "C" {
    // This C function is assuming a specific layout defined in a C header.
    fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32;
}

fn main() {
    let p = SpecificLayout { a: 1, b: 2 };
    unsafe { assert_eq!(c_fn_get_b(&amp;p), 2) } // Error: value not equal to 2
}

<span class="boring">mod cdep {
</span><span class="boring">    // This simulates what would normally be something included from a build script.
</span><span class="boring">    // This definition would be in a C header.
</span><span class="boring">    #[repr(C)]
</span><span class="boring">    pub struct SpecificLayout {
</span><span class="boring">        pub a: u8,
</span><span class="boring">        pub b: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[no_mangle]
</span><span class="boring">    pub fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32 {
</span><span class="boring">        x.b
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h4 id="repr-c-remove"><a class="header" href="#repr-c-remove">Major: Removing <code>repr(C)</code> from a struct, union, or enum</a></h4>
<p>It is a breaking change to remove <code>repr(C)</code> from a struct, union, or enum.
External crates may be relying on the specific layout of the type.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(C)]
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// After
// removed repr(C)
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::SpecificLayout;

unsafe extern "C" {
    // This C function is assuming a specific layout defined in a C header.
    fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32; // Error: is not FFI-safe
}

fn main() {
    let p = SpecificLayout { a: 1, b: 2 };
    unsafe { assert_eq!(c_fn_get_b(&amp;p), 2) }
}

<span class="boring">mod cdep {
</span><span class="boring">    // This simulates what would normally be something included from a build script.
</span><span class="boring">    // This definition would be in a C header.
</span><span class="boring">    #[repr(C)]
</span><span class="boring">    pub struct SpecificLayout {
</span><span class="boring">        pub a: u8,
</span><span class="boring">        pub b: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[no_mangle]
</span><span class="boring">    pub fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32 {
</span><span class="boring">        x.b
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h4 id="repr-int-enum-remove"><a class="header" href="#repr-int-enum-remove">Major: Removing <code>repr(&lt;int&gt;)</code> from an enum</a></h4>
<p>It is a breaking change to remove <code>repr(&lt;int&gt;)</code> from an enum.
External crates may be assuming that the discriminant is a specific size.
For example, <a href="reference/../../std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> of an enum may fail.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(u16)]
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// After
// removed repr(u16)
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// Example usage that will break.

fn main() {
    let e = updated_crate::Example::Variant2;
    let i: u16 = unsafe { std::mem::transmute(e) }; // Error: cannot transmute between types of different sizes
}</code></pre>
<h4 id="repr-int-enum-change"><a class="header" href="#repr-int-enum-change">Major: Changing the primitive representation of a <code>repr(&lt;int&gt;)</code> enum</a></h4>
<p>It is a breaking change to change the primitive representation of a <code>repr(&lt;int&gt;)</code> enum.
External crates may be assuming that the discriminant is a specific size.
For example, <a href="reference/../../std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> of an enum may fail.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(u16)]
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// After
#[repr(u8)] // changed repr size
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// Example usage that will break.

fn main() {
    let e = updated_crate::Example::Variant2;
    let i: u16 = unsafe { std::mem::transmute(e) }; // Error: cannot transmute between types of different sizes
}</code></pre>
<h4 id="repr-transparent-remove"><a class="header" href="#repr-transparent-remove">Major: Removing <code>repr(transparent)</code> from a struct or enum</a></h4>
<p>It is a breaking change to remove <code>repr(transparent)</code> from a struct or enum.
External crates may be relying on the type having the alignment, layout, or size of the transparent field.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[repr(transparent)]
pub struct Transparent&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// After
// removed repr
pub struct Transparent&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// Example usage that will break.
#![deny(improper_ctypes)]
use updated_crate::Transparent;

unsafe extern "C" {
    fn c_fn() -&gt; Transparent&lt;f64&gt;; // Error: is not FFI-safe
}

fn main() {}</code></pre>
<h3 id="struct-add-private-field-when-public"><a class="header" href="#struct-add-private-field-when-public">Major: adding a private struct field when all current fields are public</a></h3>
<p>When a private field is added to a struct that previously had all public fields,
this will break any code that attempts to construct it with a <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: cannot construct `Foo`
}</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Do not add new fields to all-public field structs.</li>
<li>Mark structs as <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> when first introducing
a struct to prevent users from using struct literal syntax, and instead
provide a constructor method and/or <a href="reference/../../std/default/trait.Default.html">Default</a> implementation.</li>
</ul>
<h3 id="struct-add-public-field-when-no-private"><a class="header" href="#struct-add-public-field-when-no-private">Major: adding a public field when no private field exists</a></h3>
<p>When a public field is added to a struct that has all public fields, this will
break any code that attempts to construct it with a <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    pub f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: missing field `f2`
}</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Do not add new fields to all-public field structs.</li>
<li>Mark structs as <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> when first introducing
a struct to prevent users from using struct literal syntax, and instead
provide a constructor method and/or <a href="reference/../../std/default/trait.Default.html">Default</a> implementation.</li>
</ul>
<h3 id="struct-private-fields-with-private"><a class="header" href="#struct-private-fields-with-private">Minor: adding or removing private fields when at least one already exists</a></h3>
<p>It is safe to add or remove private fields from a struct when the struct
already has at least one private field.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f2: f64,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}</code></pre>
<p>This is safe because existing code cannot use a <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a> to construct
it, nor exhaustively match its contents.</p>
<p>Note that for tuple structs, this is a <strong>major change</strong> if the tuple contains
public fields, and the addition or removal of a private field changes the
index of any public field.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(pub i32, i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo(f64, pub i32, i32);

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo::default();
    let y = x.0; // Error: is private
}</code></pre>
<h3 id="struct-tuple-normal-with-private"><a class="header" href="#struct-tuple-normal-with-private">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></h3>
<p>Changing a tuple struct to a normal struct (or vice-versa) is safe if all
fields are private.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}</code></pre>
<p>This is safe because existing code cannot use a <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a> to construct
it, nor match its contents.</p>
<h3 id="enum-variant-new"><a class="header" href="#enum-variant-new">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></h3>
<p>It is a breaking change to add a new enum variant if the enum does not use the
<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> attribute.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1,
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1,
    Variant2,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1;
    match x { // Error: `E::Variant2` not covered
        E::Variant1 =&gt; {}
    }
}</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>When introducing the enum, mark it as <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>
to force users to use <a href="reference/../../reference/patterns.html#wildcard-pattern">wildcard patterns</a> to catch new variants.</li>
</ul>
<h3 id="enum-fields-new"><a class="header" href="#enum-fields-new">Major: adding new fields to an enum variant</a></h3>
<p>It is a breaking change to add new fields to an enum variant because all
fields are public, and constructors and matching will fail to compile.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1 { f1: i32 },
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1 { f1: i32, f2: i32 },
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1 { f1: 1 }; // Error: missing f2
    match x {
        E::Variant1 { f1 } =&gt; {} // Error: missing f2
    }
}</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>When introducing the enum, mark the variant as <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>
so that it cannot be constructed or matched without wildcards.
<pre><code class="language-rust ignore skip">pub enum E {
    #[non_exhaustive]
    Variant1{f1: i32}
}</code></pre>
</li>
<li>When introducing the enum, use an explicit struct as a value, where you can
have control over the field visibility.
<pre><code class="language-rust ignore skip">pub struct Foo {
   f1: i32,
   f2: i32,
}
pub enum E {
    Variant1(Foo)
}</code></pre>
</li>
</ul>
<h3 id="trait-new-item-no-default"><a class="header" href="#trait-new-item-no-default">Major: adding a non-defaulted trait item</a></h3>
<p>It is a breaking change to add a non-defaulted item to a trait. This will
break any implementors of the trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self);
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: not all trait items implemented</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Always provide a default implementation or value for new associated trait
items.</li>
<li>When introducing the trait, use the <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a> technique to prevent
users outside of the crate from implementing the trait.</li>
</ul>
<h3 id="trait-item-signature"><a class="header" href="#trait-item-signature">Major: any change to trait item signatures</a></h3>
<p>It is a breaking change to make any change to a trait item signature. This can
break external implementors of the trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {
    fn f(&amp;self, x: i32) {}
}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // For sealed traits or normal functions, this would be a minor change
    // because generalizing with generics strictly expands the possible uses.
    // But in this case, trait implementations must use the same signature.
    fn f&lt;V&gt;(&amp;self, x: V) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {
    fn f(&amp;self, x: i32) {}  // Error: trait declaration has 1 type parameter
}</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Introduce new items with default implementations to cover the new
functionality instead of modifying existing items.</li>
<li>When introducing the trait, use the <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a> technique to prevent
users outside of the crate from implementing the trait.</li>
</ul>
<h3 id="trait-new-default-item"><a class="header" href="#trait-new-default-item">Possibly-breaking: adding a defaulted trait item</a></h3>
<p>It is usually safe to add a defaulted trait item. However, this can sometimes
cause a compile error. For example, this can introduce an ambiguity if a
method of the same name exists in another trait.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

trait LocalTrait {
    fn foo(&amp;self) {}
}

impl Trait for Foo {}
impl LocalTrait for Foo {}

fn main() {
    let x = Foo;
    x.foo(); // Error: multiple applicable items in scope
}</code></pre>
<p>Note that this ambiguity does <em>not</em> exist for name collisions on <a href="reference/../../reference/items/implementations.html#inherent-implementations">inherent
implementations</a>, as they take priority over trait items.</p>
<p>See <a href="reference/semver.html#trait-object-safety">trait-object-safety</a> for a special case to consider
when adding trait items.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Some projects may deem this acceptable breakage, particularly if the new
item name is unlikely to collide with any existing code. Choose names
carefully to help avoid these collisions. Additionally, it may be acceptable
to require downstream users to add <a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a> to select the
correct function when updating the dependency.</li>
</ul>
<h3 id="trait-object-safety"><a class="header" href="#trait-object-safety">Major: adding a trait item that makes the trait non-object safe</a></h3>
<p>It is a breaking change to add a trait item that changes the trait to not be
<a href="reference/../../reference/items/traits.html#object-safety">object safe</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // An associated const makes the trait not object-safe.
    const CONST: i32 = 123;
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}

fn main() {
    let obj: Box&lt;dyn Trait&gt; = Box::new(Foo); // Error: the trait `Trait` is not dyn compatible
}</code></pre>
<p>It is safe to do the converse (making a non-object safe trait into a safe
one).</p>
<h3 id="trait-new-parameter-no-default"><a class="header" href="#trait-new-parameter-no-default">Major: adding a type parameter without a default</a></h3>
<p>It is a breaking change to add a type parameter without a default to a trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T&gt; {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: missing generics</code></pre>
<p>Mitigating strategies:</p>
<ul>
<li>See <a href="reference/semver.html#trait-new-parameter-default">adding a defaulted trait type parameter</a>.</li>
</ul>
<h3 id="trait-new-parameter-default"><a class="header" href="#trait-new-parameter-default">Minor: adding a defaulted trait type parameter</a></h3>
<p>It is safe to add a type parameter to a trait as long as it has a default.
External implementors will use the default without needing to specify the
parameter.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T = i32&gt; {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}</code></pre>
<h3 id="impl-item-new"><a class="header" href="#impl-item-new">Possibly-breaking change: adding any inherent items</a></h3>
<p>Usually adding inherent items to an implementation should be safe because
inherent items take priority over trait items. However, in some cases the
collision can cause problems if the name is the same as an implemented trait
item with a different signature.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub struct Foo;

///////////////////////////////////////////////////////////
// After
pub struct Foo;

impl Foo {
    pub fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

trait Trait {
    fn foo(&amp;self, x: i32) {}
}

impl Trait for Foo {}

fn main() {
    let x = Foo;
    x.foo(1); // Error: this method takes 0 arguments but 1 argument was supplied
}</code></pre>
<p>Note that if the signatures match, there would not be a compile-time error,
but possibly a silent change in runtime behavior (because it is now executing
a different function).</p>
<p>Mitigation strategies:</p>
<ul>
<li>Some projects may deem this acceptable breakage, particularly if the new
item name is unlikely to collide with any existing code. Choose names
carefully to help avoid these collisions. Additionally, it may be acceptable
to require downstream users to add <a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a> to select the
correct function when updating the dependency.</li>
</ul>
<h3 id="generic-bounds-tighten"><a class="header" href="#generic-bounds-tighten">Major: tightening generic bounds</a></h3>
<p>It is a breaking change to tighten generic bounds on a type since this can
break users expecting the looser bounds.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A: Eq&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 1.23 }; // Error: the trait bound `{float}: Eq` is not satisfied
}</code></pre>
<h3 id="generic-bounds-loosen"><a class="header" href="#generic-bounds-loosen">Minor: loosening generic bounds</a></h3>
<p>It is safe to loosen the generic bounds on a type, as it only expands what is
allowed.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A: Clone&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 123 };
}</code></pre>
<h3 id="generic-new-default"><a class="header" href="#generic-new-default">Minor: adding defaulted type parameters</a></h3>
<p>It is safe to add a type parameter to a type as long as it has a default. All
existing references will use the default without needing to specify the
parameter.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo&lt;A = i32&gt; {
    f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Default::default();
}</code></pre>
<h3 id="generic-generalize-identical"><a class="header" href="#generic-generalize-identical">Minor: generalizing a type to use generics (with identical types)</a></h3>
<p>A struct or enum field can change from a concrete type to a generic type
parameter, provided that the change results in an identical type for all
existing use cases. For example, the following change is permitted:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo(pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Foo(123);
}</code></pre>
<p>because existing uses of <code>Foo</code> are shorthand for <code>Foo&lt;u8&gt;</code> which yields the
identical field type.</p>
<h3 id="generic-generalize-different"><a class="header" href="#generic-generalize-different">Major: generalizing a type to use generics (with possibly different types)</a></h3>
<p>Changing a struct or enum field from a concrete type to a generic type
parameter can break if the type can change.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T = u8&gt;(pub T, pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(3.14, 123); // Error: mismatched types
}</code></pre>
<h3 id="generic-more-generic"><a class="header" href="#generic-more-generic">Minor: changing a generic type to a more generic type</a></h3>
<p>It is safe to change a generic type to a more generic one. For example, the
following adds a generic parameter that defaults to the original type, which
is safe because all existing users will be using the same type for both
fields, the defaulted parameter does not need to be specified.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T, U = T&gt;(pub T, pub U);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(1.0, 2.0);
}</code></pre>
<h3 id="generic-rpit-capture"><a class="header" href="#generic-rpit-capture">Major: capturing more generic parameters in RPIT</a></h3>
<p>It is a breaking change to capture additional generic parameters in an <a href="reference/../../reference/types/impl-trait.html#abstract-return-types">RPIT</a> (return-position impl trait).</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn f&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; impl Iterator&lt;Item = char&gt; + use&lt;'a&gt; {
    x.chars()
}

///////////////////////////////////////////////////////////
// After
pub fn f&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; impl Iterator&lt;Item = char&gt; + use&lt;'a, 'b&gt; {
    x.chars().chain(y.chars())
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let a = String::new();
    let b = String::new();
    let iter = updated_crate::f(&amp;a, &amp;b);
    drop(b); // Error: cannot move out of `b` because it is borrowed
}</code></pre>
<p>Adding generic parameters to an RPIT places additional constraints on how the resulting type may be used.</p>
<p>Note that there are implicit captures when the <code>use&lt;&gt;</code> syntax is not specified. In Rust 2021 and earlier editions, the lifetime parameters are only captured if they appear syntactically within a bound in the RPIT type signature. Starting in Rust 2024, all lifetime parameters are unconditionally captured. This means that starting in Rust 2024, the default is maximally compatible, requiring you to be explicit when you want to capture less, which is a SemVer commitment.</p>
<p>See the <a href="reference/../../edition-guide/rust-2024/rpit-lifetime-capture.html">edition guide</a> and the <a href="reference/../../reference/types/impl-trait.html#capturing">reference</a> for more information on RPIT capturing.</p>
<p>It is a minor change to capture fewer generic parameters in an RPIT.</p>
<blockquote>
<p>Note: All in-scope type and const generic parameters must be either implicitly captured (no <code>+ use&lt;…&gt;</code> specified) or explicitly captured (must be listed in <code>+ use&lt;…&gt;</code>), and thus currently it is not allowed to change what is captured of those kinds of generics.</p>
</blockquote>
<h3 id="fn-change-arity"><a class="header" href="#fn-change-arity">Major: adding/removing function parameters</a></h3>
<p>Changing the arity of a function is a breaking change.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo(x: i32) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: this function takes 1 argument
}</code></pre>
<p>Mitigating strategies:</p>
<ul>
<li>Introduce a new function with the new signature and possibly
<a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecate</a> the old one.</li>
<li>Introduce functions that take a struct argument, where the struct is built
with the builder pattern. This allows new fields to be added to the struct
in the future.</li>
</ul>
<h3 id="fn-generic-new"><a class="header" href="#fn-generic-new">Possibly-breaking: introducing a new function type parameter</a></h3>
<p>Usually, adding a non-defaulted type parameter is safe, but in some
cases it can be a breaking change:</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo&lt;T&gt;() {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T, U&gt;() {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo::&lt;u8&gt;(); // Error: function takes 2 generic arguments but 1 generic argument was supplied
}</code></pre>
<p>However, such explicit calls are rare enough (and can usually be written in
other ways) that this breakage is usually acceptable. One should take into
account how likely it is that the function in question is being called with
explicit type arguments.</p>
<h3 id="fn-generalize-compatible"><a class="header" href="#fn-generalize-compatible">Minor: generalizing a function to use generics (supporting original type)</a></h3>
<p>The type of a parameter to a function, or its return value, can be
<em>generalized</em> to use generics, including by introducing a new type parameter,
as long as it can be instantiated to the original type. For example, the
following changes are allowed:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: u8) -&gt; u8 {
    x
}
pub fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// After
use std::ops::Add;
pub fn foo&lt;T: Add&gt;(x: T) -&gt; T {
    x
}
pub fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{bar, foo};

fn main() {
    foo(1);
    bar(vec![1, 2, 3].into_iter());
}</code></pre>
<p>because all existing uses are instantiations of the new signature.</p>
<p>Perhaps somewhat surprisingly, generalization applies to trait objects as
well, given that every trait implements itself:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}
pub fn foo(t: &amp;dyn Trait) {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {}
pub fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{foo, Trait};

struct Foo;
impl Trait for Foo {}

fn main() {
    let obj = Foo;
    foo(&amp;obj);
}</code></pre>
<p>(The use of <code>?Sized</code> is essential; otherwise you couldn’t recover the original
signature.)</p>
<p>Introducing generics in this way can potentially create type inference
failures. These are usually rare, and may be acceptable breakage for some
projects, as this can be fixed with additional type annotations.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo() -&gt; i32 {
    0
}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Default&gt;() -&gt; T {
    Default::default()
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    let x = foo(); // Error: type annotations needed
}</code></pre>
<h3 id="fn-generalize-mismatch"><a class="header" href="#fn-generalize-mismatch">Major: generalizing a function to use generics with type mismatch</a></h3>
<p>It is a breaking change to change a function parameter or return type if the
generic type constrains or changes the types previously allowed. For example,
the following adds a generic constraint that may not be satisfied by existing
code:</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: Vec&lt;u8&gt;) {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo(vec![1, 2, 3]); // Error: `Copy` is not implemented for `Vec&lt;u8&gt;`
}</code></pre>
<h3 id="fn-unsafe-safe"><a class="header" href="#fn-unsafe-safe">Minor: making an <code>unsafe</code> function safe</a></h3>
<p>A previously <code>unsafe</code> function can be made safe without breaking code.</p>
<p>Note however that it may cause the <a href="reference/../../rustc/lints/listing/warn-by-default.html#unused-unsafe"><code>unused_unsafe</code></a> lint to
trigger as in the example below, which will cause local crates that have
specified <code>#![deny(warnings)]</code> to stop compiling. Per <a href="reference/semver.html#new-lints">introducing new
lints</a>, it is allowed for updates to introduce new warnings.</p>
<p>Going the other way (making a safe function <code>unsafe</code>) is a breaking change.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub unsafe fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo() {}

///////////////////////////////////////////////////////////
// Example use of the library that will trigger a lint.
use updated_crate::foo;

unsafe fn bar(f: unsafe fn()) {
    f()
}

fn main() {
    unsafe { foo() }; // The `unused_unsafe` lint will trigger here
    unsafe { bar(foo) };
}</code></pre>
<p>Making a previously <code>unsafe</code> associated function or method on structs / enums
safe is also a minor change, while the same is not true for associated
function on traits (see <a href="reference/semver.html#trait-item-signature">any change to trait item signatures</a>).</p>
<h3 id="attr-no-std-to-std"><a class="header" href="#attr-no-std-to-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></h3>
<p>If your library specifically supports a <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> environment, it is a
breaking change to make a new release that requires <code>std</code>.</p>
<pre><code class="language-rust ignore skip">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#![no_std]
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo() {
    std::time::SystemTime::now();
}

///////////////////////////////////////////////////////////
// Example usage that will break.
// This will fail to link for no_std targets because they don't have a `std` crate.
#![no_std]
use updated_crate::foo;

fn example() {
    foo();
}</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>A common idiom to avoid this is to include a <code>std</code> <a href="reference/features.html">Cargo feature</a> that
optionally enables <code>std</code> support, and when the feature is off, the library
can be used in a <code>no_std</code> environment.</li>
</ul>
<h3 id="attr-adding-non-exhaustive"><a class="header" href="#attr-adding-non-exhaustive">Major: adding <code>non_exhaustive</code> to an existing enum, variant, or struct with no private fields</a></h3>
<p>Making items <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> changes how they may
be used outside the crate where they are defined:</p>
<ul>
<li>Non-exhaustive structs and enum variants cannot be constructed
using <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a> syntax, including <a href="reference/../../reference/expressions/struct-expr.html#functional-update-syntax">functional update syntax</a>.</li>
<li>Pattern matching on non-exhaustive structs requires <code>..</code> and
matching on enums does not count towards exhaustiveness.</li>
<li>Casting enum variants to their discriminant with <code>as</code> is not allowed.</li>
</ul>
<p>Structs with private fields cannot be constructed using <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a> syntax
regardless of whether <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> is used.
Adding <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> to such a struct is not
a breaking change.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub bar: usize,
}

pub enum Bar {
    X,
    Y(usize),
    Z { a: usize },
}

pub enum Quux {
    Var,
}

///////////////////////////////////////////////////////////
// After
#[non_exhaustive]
pub struct Foo {
    pub bar: usize,
}

pub enum Bar {
    #[non_exhaustive]
    X,

    #[non_exhaustive]
    Y(usize),

    #[non_exhaustive]
    Z { a: usize },
}

#[non_exhaustive]
pub enum Quux {
    Var,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::{Bar, Foo, Quux};

fn main() {
    let foo = Foo { bar: 0 }; // Error: cannot create non-exhaustive struct using struct expression

    let bar_x = Bar::X; // Error: unit variant `X` is private
    let bar_y = Bar::Y(0); // Error: tuple variant `Y` is private
    let bar_z = Bar::Z { a: 0 }; // Error: cannot create non-exhaustive variant using struct expression

    let q = Quux::Var;
    match q {
        Quux::Var =&gt; 0,
        // Error: non-exhaustive patterns: `_` not covered
    };
}</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Mark structs, enums, and enum variants as
<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> when first introducing them,
rather than adding <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> later on.</li>
</ul>
<h2 id="tooling-and-environment-compatibility"><a class="header" href="#tooling-and-environment-compatibility">Tooling and environment compatibility</a></h2>
<h3 id="env-new-rust"><a class="header" href="#env-new-rust">Possibly-breaking: changing the minimum version of Rust required</a></h3>
<p>Introducing the use of new features in a new release of Rust can break
projects that are using older versions of Rust. This also includes using new
features in a new release of Cargo, and requiring the use of a nightly-only
feature in a crate that previously worked on stable.</p>
<p>It is generally recommended to treat this as a minor change, rather than as
a major change, for <a href="https://github.com/rust-lang/api-guidelines/discussions/231">various reasons</a>. It
is usually relatively easy to update to a newer version of Rust. Rust also has
a rapid 6-week release cycle, and some projects will provide compatibility
within a window of releases (such as the current stable release plus N
previous releases). Just keep in mind that some large projects may not be able
to update their Rust toolchain rapidly.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Document your package’s minimum-supported Rust version by setting
<a href="https://doc.rust-lang.org/cargo/reference/rust-version.html"><code>package.rust-version</code></a>, allowing Cargo’s dependency resolution to
attempt to <a href="https://doc.rust-lang.org/cargo/reference/resolver.html#rust-version">select older versions of your package</a> when needed.
Be sure to consider the <a href="https://doc.rust-lang.org/cargo/reference/rust-version.html#support-expectations">support expectations</a> when doing so.</li>
<li>Use <a href="reference/features.html">Cargo features</a> to make the new features opt-in.</li>
<li>Provide a large window of support for older releases.</li>
<li>Copy the source of new standard library items if possible so that you
can continue to use an older version but take advantage of the new feature.</li>
<li>Provide a separate branch of older minor releases that can receive backports
of important bugfixes.</li>
<li>Keep an eye out for the <a href="https://github.com/rust-lang/rust/issues/64796"><code>[cfg(version(..))]</code></a> and
<a href="https://github.com/rust-lang/rust/issues/64797"><code>#[cfg(accessible(..))]</code></a> features which provide an opt-in
mechanism for new features. These are currently unstable and only available
in the nightly channel.</li>
</ul>
<h3 id="env-change-requirements"><a class="header" href="#env-change-requirements">Possibly-breaking: changing the platform and environment requirements</a></h3>
<p>There is a very wide range of assumptions a library makes about the
environment that it runs in, such as the host platform, operating system
version, available services, filesystem support, etc. It can be a breaking
change if you make a new release that restricts what was previously supported,
for example requiring a newer version of an operating system. These changes
can be difficult to track, since you may not always know if a change breaks in
an environment that is not automatically tested.</p>
<p>Some projects may deem this acceptable breakage, particularly if the breakage
is unlikely for most users, or the project doesn’t have the resources to
support all environments. Another notable situation is when a vendor
discontinues support for some hardware or OS, the project may deem it
reasonable to also discontinue support.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Document the platforms and environments you specifically support.</li>
<li>Test your code on a wide range of environments in CI.</li>
</ul>
<h3 id="new-lints"><a class="header" href="#new-lints">Minor: introducing new lints</a></h3>
<p>Some changes to a library may cause new lints to be triggered in users of that library.
This should generally be considered a compatible change.</p>
<pre><code class="language-rust ignore dont-deny">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
#[deprecated]
pub fn foo() {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.

fn main() {
    updated_crate::foo(); // Warning: use of deprecated function
}</code></pre>
<p>Beware that it may be possible for this to technically cause a project to fail if they have explicitly denied the warning, and the updated crate is a direct dependency.
Denying warnings should be done with care and the understanding that new lints may be introduced over time.
However, library authors should be cautious about introducing new warnings and may want to consider the potential impact on their users.</p>
<p>The following lints are examples of those that may be introduced when updating a dependency:</p>
<ul>
<li><a href="reference/../../rustc/lints/listing/warn-by-default.html#deprecated"><code>deprecated</code></a> — Introduced when a dependency adds the <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute"><code>#[deprecated]</code> attribute</a> to an item you are using.</li>
<li><a href="reference/../../rustc/lints/listing/warn-by-default.html#unused-must-use"><code>unused_must_use</code></a> — Introduced when a dependency adds the <a href="reference/../../reference/attributes/diagnostics.html#the-must_use-attribute"><code>#[must_use]</code> attribute</a> to an item where you are not consuming the result.</li>
<li><a href="reference/../../rustc/lints/listing/warn-by-default.html#unused-unsafe"><code>unused_unsafe</code></a> — Introduced when a dependency <em>removes</em> the <code>unsafe</code> qualifier from a function, and that is the only unsafe function called in an unsafe block.</li>
</ul>
<p>Additionally, updating <code>rustc</code> to a new version may introduce new lints.</p>
<p>Transitive dependencies which introduce new lints should not usually cause a failure because Cargo uses <a href="reference/../../rustc/lints/levels.html#capping-lints"><code>--cap-lints</code></a> to suppress all lints in dependencies.</p>
<p>Mitigating strategies:</p>
<ul>
<li>If you build with warnings denied, understand you may need to deal with resolving new warnings whenever you update your dependencies.
If using RUSTFLAGS to pass <code>-Dwarnings</code>, also add the <code>-A</code> flag to allow lints that are likely to cause issues, such as <code>-Adeprecated</code>.</li>
<li>Introduce deprecations behind a <a href="reference/features.html">feature</a>.
For example <code>#[cfg_attr(feature = "deprecated", deprecated="use bar instead")]</code>.
Then, when you plan to remove an item in a future SemVer breaking change, you can communicate with your users that they should enable the <code>deprecated</code> feature <em>before</em> updating to remove the use of the deprecated items.
This allows users to choose when to respond to deprecations without needing to immediately respond to them.
A downside is that it can be difficult to communicate to users that they need to take these manual steps to prepare for a major update.</li>
</ul>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<h4 id="cargo-feature-add"><a class="header" href="#cargo-feature-add">Minor: adding a new Cargo feature</a></h4>
<p>It is usually safe to add new <a href="reference/features.html">Cargo features</a>. If the feature introduces new
changes that cause a breaking change, this can cause difficulties for projects
that have stricter backwards-compatibility needs. In that scenario, avoid
adding the feature to the “default” list, and possibly document the
consequences of enabling the feature.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[features]
# ..empty

###########################################################
# After
[features]
std = []
</code></pre>
<h4 id="cargo-feature-remove"><a class="header" href="#cargo-feature-remove">Major: removing a Cargo feature</a></h4>
<p>It is usually a breaking change to remove <a href="reference/features.html">Cargo features</a>. This will cause
an error for any project that enabled the feature.</p>
<pre><code class="language-toml"># MAJOR CHANGE

###########################################################
# Before
[features]
logging = []

###########################################################
# After
[dependencies]
# ..logging removed
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Clearly document your features. If there is an internal or experimental
feature, mark it as such, so that users know the status of the feature.</li>
<li>Leave the old feature in <code>Cargo.toml</code>, but otherwise remove its
functionality. Document that the feature is deprecated, and remove it in a
future major SemVer release.</li>
</ul>
<h4 id="cargo-feature-remove-another"><a class="header" href="#cargo-feature-remove-another">Major: removing a feature from a feature list if that changes functionality or public items</a></h4>
<p>If removing a feature from another feature, this can break existing users if
they are expecting that functionality to be available through that feature.</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[features]
default = ["std"]
std = []

###########################################################
# After
[features]
default = []  # This may cause packages to fail if they are expecting std to be enabled.
std = []
</code></pre>
<h4 id="cargo-remove-opt-dep"><a class="header" href="#cargo-remove-opt-dep">Possibly-breaking: removing an optional dependency</a></h4>
<p>Removing an <a href="reference/features.html#optional-dependencies">optional dependency</a> can break a project using your library because
another project may be enabling that dependency via <a href="reference/features.html">Cargo features</a>.</p>
<p>When there is an optional dependency, cargo implicitly defines a feature of
the same name to provide a mechanism to enable the dependency and to check
when it is enabled. This problem can be avoided by using the <code>dep:</code> syntax in
the <code>[features]</code> table, which disables this implicit feature. Using <code>dep:</code>
makes it possible to hide the existence of optional dependencies under more
semantically-relevant names which can be more safely modified.</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[dependencies]
curl = { version = "0.4.31", optional = true }

###########################################################
# After
[dependencies]
# ..curl removed
</code></pre>
<pre><code class="language-toml"># MINOR CHANGE
#
# This example shows how to avoid breaking changes with optional dependencies.

###########################################################
# Before
[dependencies]
curl = { version = "0.4.31", optional = true }

[features]
networking = ["dep:curl"]

###########################################################
# After
[dependencies]
# Here, one optional dependency was replaced with another.
hyper = { version = "0.14.27", optional = true }

[features]
networking = ["dep:hyper"]
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Use the <code>dep:</code> syntax in the <code>[features]</code> table to avoid exposing optional
dependencies in the first place. See <a href="reference/features.html#optional-dependencies">optional dependencies</a> for
more information.</li>
<li>Clearly document your features. If the optional dependency is not included
in the documented list of features, then you may decide to consider it safe
to change undocumented entries.</li>
<li>Leave the optional dependency, and just don’t use it within your library.</li>
<li>Replace the optional dependency with a <a href="reference/features.html">Cargo feature</a> that does nothing,
and document that it is deprecated.</li>
<li>Use high-level features which enable optional dependencies, and document
those as the preferred way to enable the extended functionality. For
example, if your library has optional support for something like
“networking”, create a generic feature name “networking” that enables the
optional dependencies necessary to implement “networking”. Then document the
“networking” feature.</li>
</ul>
<h4 id="cargo-change-dep-feature"><a class="header" href="#cargo-change-dep-feature">Minor: changing dependency features</a></h4>
<p>It is usually safe to change the features on a dependency, as long as the
feature does not introduce a breaking change.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
rand = { version = "0.7.3", features = ["small_rng"] }


###########################################################
# After
[dependencies]
rand = "0.7.3"
</code></pre>
<h4 id="cargo-dep-add"><a class="header" href="#cargo-dep-add">Minor: adding dependencies</a></h4>
<p>It is usually safe to add new dependencies, as long as the new dependency
does not introduce new requirements that result in a breaking change.
For example, adding a new dependency that requires nightly in a project
that previously worked on stable is a major change.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
# ..empty

###########################################################
# After
[dependencies]
log = "0.4.11"
</code></pre>
<h2 id="application-compatibility"><a class="header" href="#application-compatibility">Application compatibility</a></h2>
<p>Cargo projects may also include executable binaries which have their own
interfaces (such as a CLI interface, OS-level interaction, etc.). Since these
are part of the Cargo package, they often use and share the same version as
the package. You will need to decide if and how you want to employ a SemVer
contract with your users in the changes you make to your application. The
potential breaking and compatible changes to an application are too numerous
to list, so you are encouraged to use the spirit of the <a href="https://semver.org/">SemVer</a> spec to guide
your decisions on how to apply versioning to your application, or at least
document what your commitments are.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-incompat-report-1"><a class="header" href="#future-incompat-report-1">Future incompat report</a></h1>
<p>Cargo checks for future-incompatible warnings in all dependencies. These are warnings for
changes that may become hard errors in the future, causing the dependency to
stop building in a future version of rustc. If any warnings are found, a small
notice is displayed indicating that the warnings were found, and provides
instructions on how to display a full report.</p>
<p>For example, you may see something like this at the end of a build:</p>
<pre><code class="language-text">warning: the following packages contain code that will be rejected by a future
         version of Rust: rental v0.5.5
note: to see what the problems were, use the option `--future-incompat-report`,
      or run `cargo report future-incompatibilities --id 1`
</code></pre>
<p>A full report can be displayed with the <code>cargo report future-incompatibilities --id ID</code> command, or by running the build again with
the <code>--future-incompat-report</code> flag. The developer should then update their
dependencies to a version where the issue is fixed, or work with the
developers of the dependencies to help resolve the issue.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>This feature can be configured through a <a href="reference/config.html#future-incompat-report"><code>[future-incompat-report]</code></a>
section in <code>.cargo/config.toml</code>. Currently, the supported options are:</p>
<pre><code class="language-toml">[future-incompat-report]
frequency = "always"
</code></pre>
<p>The supported values for the frequency are <code>"always"</code> and <code>"never"</code>, which control
whether or not a message is printed out at the end of <code>cargo build</code> / <code>cargo check</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reporting-build-timings"><a class="header" href="#reporting-build-timings">Reporting build timings</a></h1>
<p>The <code>--timings</code> option gives some information about how long each compilation
takes, and tracks concurrency information over time.</p>
<pre><code class="language-sh">cargo build --timings
</code></pre>
<p>This writes an HTML report in <code>target/cargo-timings/cargo-timing.html</code>. This
also writes a copy of the report to the same directory with a timestamp in the
filename, if you want to look at older runs.</p>
<h2 id="reading-the-graphs"><a class="header" href="#reading-the-graphs">Reading the graphs</a></h2>
<p>There are two tables and two graphs in the output.</p>
<p>The first table displays the build information of the project, including the
number of units built, the maximum number of concurrency, build time, and the
version information of the currently used compiler.</p>
<p><img src="reference/../images/build-info.png" alt="build-info" /></p>
<p>The “unit” graph shows the duration of each unit over time. A “unit” is a single
compiler invocation. There are lines that show which additional units are
“unlocked” when a unit finishes. That is, it shows the new units that are now
allowed to run because their dependencies are all finished. Hover the mouse over
a unit to highlight the lines. This can help visualize the critical path of
dependencies. This may change between runs because the units may finish in
different orders.</p>
<p>The “codegen” times are highlighted in a lavender color. In some cases, build
pipelining allows units to start when their dependencies are performing code
generation. This information is not always displayed (for example, binary
units do not show when code generation starts).</p>
<p>The “custom build” units are <code>build.rs</code> scripts, which when run are
highlighted in orange.</p>
<p><img src="reference/../images/build-unit-time.png" alt="build-unit-time" /></p>
<p>The second graph shows Cargo’s concurrency over time. The background
indicates CPU usage. The three lines are:</p>
<ul>
<li>“Waiting” (red) — This is the number of units waiting for a CPU slot to
open.</li>
<li>“Inactive” (blue) — This is the number of units that are waiting for their
dependencies to finish.</li>
<li>“Active” (green) — This is the number of units currently running.</li>
</ul>
<p><img src="reference/../images/cargo-concurrency-over-time.png" alt="cargo-concurrency-over-time" /></p>
<p>Note: This does not show the concurrency in the compiler itself. <code>rustc</code>
coordinates with Cargo via the “job server” to stay within the concurrency
limit. This currently mostly applies to the code generation phase.</p>
<p>Tips for addressing compile times:</p>
<ul>
<li>Look for slow dependencies.
<ul>
<li>Check if they have features that you may wish to consider disabling.</li>
<li>Consider trying to remove the dependency completely.</li>
</ul>
</li>
<li>Look for a crate being built multiple times with different versions. Try to
remove the older versions from the dependency graph.</li>
<li>Split large crates into smaller pieces.</li>
<li>If there are a large number of crates bottlenecked on a single crate, focus
your attention on improving that one crate to improve parallelism.</li>
</ul>
<p>The last table lists the total time and “codegen” time spent on each unit,
as well as the features that were enabled during each unit’s compilation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lints"><a class="header" href="#lints">Lints</a></h1>
<p>Note: <a href="reference/unstable.html#lintscargo">Cargo’s linting system is unstable</a> and can only be used on nightly toolchains</p>
<h2 id="warn-by-default"><a class="header" href="#warn-by-default">Warn-by-default</a></h2>
<p>These lints are all set to the ‘warn’ level by default.</p>
<ul>
<li><a href="reference/lints.html#blanket_hint_mostly_unused"><code>blanket_hint_mostly_unused</code></a></li>
<li><a href="reference/lints.html#unknown_lints"><code>unknown_lints</code></a></li>
</ul>
<h2 id="blanket_hint_mostly_unused"><a class="header" href="#blanket_hint_mostly_unused"><code>blanket_hint_mostly_unused</code></a></h2>
<p>Set to <code>warn</code> by default</p>
<h3 id="what-it-does"><a class="header" href="#what-it-does">What it does</a></h3>
<p>Checks if <code>hint-mostly-unused</code> being applied to all dependencies.</p>
<h3 id="why-it-is-bad"><a class="header" href="#why-it-is-bad">Why it is bad</a></h3>
<p><code>hint-mostly-unused</code> indicates that most of a crate’s API surface will go
unused by anything depending on it; this hint can speed up the build by
attempting to minimize compilation time for items that aren’t used at all.
Misapplication to crates that don’t fit that criteria will slow down the build
rather than speeding it up. It should be selectively applied to dependencies
that meet these criteria. Applying it globally is always a misapplication and
will likely slow down the build.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-toml">[profile.dev.package."*"]
hint-mostly-unused = true
</code></pre>
<p>Should instead be:</p>
<pre><code class="language-toml">[profile.dev.package.huge-mostly-unused-dependency]
hint-mostly-unused = true
</code></pre>
<h2 id="unknown_lints"><a class="header" href="#unknown_lints"><code>unknown_lints</code></a></h2>
<p>Set to <code>warn</code> by default</p>
<h3 id="what-it-does-1"><a class="header" href="#what-it-does-1">What it does</a></h3>
<p>Checks for unknown lints in the <code>[lints.cargo]</code> table</p>
<h3 id="why-it-is-bad-1"><a class="header" href="#why-it-is-bad-1">Why it is bad</a></h3>
<ul>
<li>The lint name could be misspelled, leading to confusion as to why it is
not working as expected</li>
<li>The unknown lint could end up causing an error if <code>cargo</code> decides to make
a lint with the same name in the future</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-toml">[lints.cargo]
this-lint-does-not-exist = "warn"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unstable-features"><a class="header" href="#unstable-features">Unstable Features</a></h1>
<p>Experimental Cargo features are only available on the <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>. You
are encouraged to experiment with these features to see if they meet your
needs, and if there are any issues or problems. Check the linked tracking
issues listed below for more information on the feature, and click the GitHub
subscribe button if you want future updates.</p>
<p>After some period of time, if the feature does not have any major concerns, it
can be <a href="https://doc.crates.io/contrib/process/unstable.html#stabilization">stabilized</a>, which will make it available on stable once the current
nightly release reaches the stable channel (anywhere from 6 to 12 weeks).</p>
<p>There are three different ways that unstable features can be enabled based on
how the feature works:</p>
<ul>
<li>
<p>New syntax in <code>Cargo.toml</code> requires a <code>cargo-features</code> key at the top of
<code>Cargo.toml</code>, before any tables. For example:</p>
<pre><code class="language-toml"># This specifies which new Cargo.toml features are enabled.
cargo-features = ["test-dummy-unstable"]

[package]
name = "my-package"
version = "0.1.0"
im-a-teapot = true  # This is a new option enabled by test-dummy-unstable.
</code></pre>
</li>
<li>
<p>New command-line flags, options, and subcommands require the <code>-Z unstable-options</code> CLI option to also be included. For example, the new
<code>--artifact-dir</code> option is only available on nightly:</p>
<p><code>cargo +nightly build --artifact-dir=out -Z unstable-options</code></p>
</li>
<li>
<p><code>-Z</code> command-line flags are used to enable new functionality that may not
have an interface, or the interface has not yet been designed, or for more
complex features that affect multiple parts of Cargo. For example, the
<a href="reference/unstable.html#mtime-on-use">mtime-on-use</a> feature can be enabled with:</p>
<p><code>cargo +nightly build -Z mtime-on-use</code></p>
<p>Run <code>cargo -Z help</code> to see a list of flags available.</p>
<p>Anything which can be configured with a <code>-Z</code> flag can also be set in the
cargo <a href="reference/config.html">config file</a> (<code>.cargo/config.toml</code>) in the <code>unstable</code> table. For
example:</p>
<pre><code class="language-toml">[unstable]
mtime-on-use = true
build-std = ["core", "alloc"]
</code></pre>
</li>
</ul>
<p>Each new feature described below should explain how to use it.</p>
<p><em>For the latest nightly, see the <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html">nightly version</a> of this page.</em></p>
<h2 id="list-of-unstable-features"><a class="header" href="#list-of-unstable-features">List of unstable features</a></h2>
<ul>
<li>Unstable-specific features
<ul>
<li><a href="reference/unstable.html#allow-features">-Z allow-features</a> — Provides a way to restrict which unstable features are used.</li>
</ul>
</li>
<li>Build scripts and linking
<ul>
<li><a href="reference/unstable.html#metabuild">Metabuild</a> — Provides declarative build scripts.</li>
<li><a href="reference/unstable.html#multiple-build-scripts">Multiple Build Scripts</a> — Allows use of multiple build scripts.</li>
</ul>
</li>
<li>Resolver and features
<ul>
<li><a href="reference/unstable.html#no-index-update">no-index-update</a> — Prevents cargo from updating the index cache.</li>
<li><a href="reference/unstable.html#avoid-dev-deps">avoid-dev-deps</a> — Prevents the resolver from including dev-dependencies during resolution.</li>
<li><a href="reference/unstable.html#minimal-versions">minimal-versions</a> — Forces the resolver to use the lowest compatible version instead of the highest.</li>
<li><a href="reference/unstable.html#direct-minimal-versions">direct-minimal-versions</a> — Forces the resolver to use the lowest compatible version instead of the highest.</li>
<li><a href="reference/unstable.html#public-dependency">public-dependency</a> — Allows dependencies to be classified as either public or private.</li>
<li><a href="reference/unstable.html#msrv-policy">msrv-policy</a> — MSRV-aware resolver and version selection</li>
<li><a href="reference/unstable.html#precise-pre-release">precise-pre-release</a> — Allows pre-release versions to be selected with <code>update --precise</code></li>
<li><a href="reference/unstable.html#sbom">sbom</a> — Generates SBOM pre-cursor files for compiled artifacts</li>
<li><a href="reference/unstable.html#update-breaking">update-breaking</a> — Allows upgrading to breaking versions with <code>update --breaking</code></li>
<li><a href="reference/unstable.html#feature-unification">feature-unification</a> — Enable new feature unification modes in workspaces</li>
</ul>
</li>
<li>Output behavior
<ul>
<li><a href="reference/unstable.html#artifact-dir">artifact-dir</a> — Adds a directory where artifacts are copied to.</li>
<li><a href="reference/unstable.html#build-dir-new-layout">build-dir-new-layout</a> — Enables the new build-dir filesystem layout</li>
<li><a href="reference/unstable.html#different-binary-name">Different binary name</a> — Assign a name to the built binary that is separate from the crate name.</li>
<li><a href="reference/unstable.html#root-dir">root-dir</a> — Controls the root directory relative to which paths are printed</li>
</ul>
</li>
<li>Compile behavior
<ul>
<li><a href="reference/unstable.html#mtime-on-use">mtime-on-use</a> — Updates the last-modified timestamp on every dependency every time it is used, to provide a mechanism to delete unused artifacts.</li>
<li><a href="reference/unstable.html#build-std">build-std</a> — Builds the standard library instead of using pre-built binaries.</li>
<li><a href="reference/unstable.html#build-std-features">build-std-features</a> — Sets features to use with the standard library.</li>
<li><a href="reference/unstable.html#binary-dep-depinfo">binary-dep-depinfo</a> — Causes the dep-info file to track binary dependencies.</li>
<li><a href="reference/unstable.html#checksum-freshness">checksum-freshness</a> — When passed, the decision as to whether a crate needs to be rebuilt is made using file checksums instead of the file mtime.</li>
<li><a href="reference/unstable.html#panic-abort-tests">panic-abort-tests</a> — Allows running tests with the “abort” panic strategy.</li>
<li><a href="reference/unstable.html#host-config">host-config</a> — Allows setting <code>[target]</code>-like configuration settings for host build targets.</li>
<li><a href="reference/unstable.html#no-embed-metadata">no-embed-metadata</a> — Passes <code>-Zembed-metadata=no</code> to the compiler, which avoid embedding metadata into rlib and dylib artifacts, to save disk space.</li>
<li><a href="reference/unstable.html#target-applies-to-host">target-applies-to-host</a> — Alters whether certain flags will be passed to host build targets.</li>
<li><a href="reference/unstable.html#gc">gc</a> — Global cache garbage collection.</li>
<li><a href="reference/unstable.html#open-namespaces">open-namespaces</a> — Allow multiple packages to participate in the same API namespace</li>
<li><a href="reference/unstable.html#panic-immediate-abort">panic-immediate-abort</a> — Passes <code>-Cpanic=immediate-abort</code> to the compiler.</li>
</ul>
</li>
<li>rustdoc
<ul>
<li><a href="reference/unstable.html#rustdoc-map">rustdoc-map</a> — Provides mappings for documentation to link to external sites like <a href="https://docs.rs/">docs.rs</a>.</li>
<li><a href="reference/unstable.html#scrape-examples">scrape-examples</a> — Shows examples within documentation.</li>
<li><a href="reference/unstable.html#output-format-for-rustdoc">output-format</a> — Allows documentation to also be emitted in the experimental <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/">JSON format</a>.</li>
<li><a href="reference/unstable.html#rustdoc-depinfo">rustdoc-depinfo</a> — Use dep-info files in rustdoc rebuild detection.</li>
</ul>
</li>
<li><code>Cargo.toml</code> extensions
<ul>
<li><a href="reference/unstable.html#profile-rustflags-option">Profile <code>rustflags</code> option</a> — Passed directly to rustc.</li>
<li><a href="reference/unstable.html#profile-hint-mostly-unused-option">Profile <code>hint-mostly-unused</code> option</a> — Hint that a dependency is mostly unused, to optimize compilation time.</li>
<li><a href="reference/unstable.html#codegen-backend">codegen-backend</a> — Select the codegen backend used by rustc.</li>
<li><a href="reference/unstable.html#per-package-target">per-package-target</a> — Sets the <code>--target</code> to use for each individual package.</li>
<li><a href="reference/unstable.html#artifact-dependencies">artifact dependencies</a> — Allow build artifacts to be included into other build artifacts and build them for different targets.</li>
<li><a href="reference/unstable.html#profile-trim-paths-option">Profile <code>trim-paths</code> option</a> — Control the sanitization of file paths in build outputs.</li>
<li><a href="reference/unstable.html#lintscargo"><code>[lints.cargo]</code></a> — Allows configuring lints for Cargo.</li>
<li><a href="reference/unstable.html#path-bases">path bases</a> — Named base directories for path dependencies.</li>
<li><a href="reference/unstable.html#unstable-editions"><code>unstable-editions</code></a> — Allows use of editions that are not yet stable.</li>
</ul>
</li>
<li>Information and metadata
<ul>
<li><a href="reference/unstable.html#build-plan">Build-plan</a> — Emits JSON information on which commands will be run.</li>
<li><a href="reference/unstable.html#unit-graph">unit-graph</a> — Emits JSON for Cargo’s internal graph structure.</li>
<li><a href="reference/unstable.html#rustc---print"><code>cargo rustc --print</code></a> — Calls rustc with <code>--print</code> to display information from rustc.</li>
<li><a href="reference/unstable.html#build-analysis">Build analysis</a> — Record and persist detailed build metrics across runs, with new commands to query past builds.</li>
</ul>
</li>
<li>Configuration
<ul>
<li><a href="reference/unstable.html#config-include">config-include</a> — Adds the ability for config files to include other files.</li>
<li><a href="reference/unstable.html#cargo-config"><code>cargo config</code></a> — Adds a new subcommand for viewing config files.</li>
</ul>
</li>
<li>Registries
<ul>
<li><a href="reference/unstable.html#publish-timeout">publish-timeout</a> — Controls the timeout between uploading the crate and being available in the index</li>
<li><a href="reference/unstable.html#asymmetric-token">asymmetric-token</a> — Adds support for authentication tokens using asymmetric cryptography (<code>cargo:paseto</code> provider).</li>
</ul>
</li>
<li>Other
<ul>
<li><a href="reference/unstable.html#gitoxide">gitoxide</a> — Use <code>gitoxide</code> instead of <code>git2</code> for a set of operations.</li>
<li><a href="reference/unstable.html#script">script</a> — Enable support for single-file <code>.rs</code> packages.</li>
<li><a href="reference/unstable.html#lockfile-path">lockfile-path</a> — Allows to specify a path to lockfile other than the default path <code>&lt;workspace_root&gt;/Cargo.lock</code>.</li>
<li><a href="reference/unstable.html#native-completions">native-completions</a> — Move cargo shell completions to native completions.</li>
<li><a href="reference/unstable.html#warnings">warnings</a> — controls warning behavior; options for allowing or denying warnings.</li>
<li><a href="reference/unstable.html#package-message-format">Package message format</a> — Message format for <code>cargo package</code>.</li>
<li><a href="reference/unstable.html#fix-edition"><code>fix-edition</code></a> — A permanently unstable edition migration helper.</li>
<li><a href="https://github.com/crate-ci/cargo-plumbing">Plumbing subcommands</a> — Low, level commands that act as APIs for Cargo, like <code>cargo metadata</code></li>
</ul>
</li>
</ul>
<h2 id="allow-features"><a class="header" href="#allow-features">allow-features</a></h2>
<p>This permanently-unstable flag makes it so that only a listed set of
unstable features can be used. Specifically, if you pass
<code>-Zallow-features=foo,bar</code>, you’ll continue to be able to pass <code>-Zfoo</code>
and <code>-Zbar</code> to <code>cargo</code>, but you will be unable to pass <code>-Zbaz</code>. You can
pass an empty string (<code>-Zallow-features=</code>) to disallow all unstable
features.</p>
<p><code>-Zallow-features</code> also restricts which unstable features can be passed
to the <code>cargo-features</code> entry in <code>Cargo.toml</code>. If, for example, you want
to allow</p>
<pre><code class="language-toml">cargo-features = ["test-dummy-unstable"]
</code></pre>
<p>where <code>test-dummy-unstable</code> is unstable, that features would also be
disallowed by <code>-Zallow-features=</code>, and allowed with
<code>-Zallow-features=test-dummy-unstable</code>.</p>
<p>The list of features passed to cargo’s <code>-Zallow-features</code> is also passed
to any Rust tools that cargo ends up calling (like <code>rustc</code> or
<code>rustdoc</code>). Thus, if you run <code>cargo -Zallow-features=</code>, no unstable
Cargo <em>or</em> Rust features can be used.</p>
<h2 id="no-index-update"><a class="header" href="#no-index-update">no-index-update</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/3479">#3479</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/7404">#7404</a></li>
</ul>
<p>The <code>-Z no-index-update</code> flag ensures that Cargo does not attempt to update
the registry index. This is intended for tools such as Crater that issue many
Cargo commands, and you want to avoid the network latency for updating the
index each time.</p>
<h2 id="mtime-on-use"><a class="header" href="#mtime-on-use">mtime-on-use</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/pull/6477">#6477</a></li>
<li>Cache usage meta tracking issue: <a href="https://github.com/rust-lang/cargo/issues/7150">#7150</a></li>
</ul>
<p>The <code>-Z mtime-on-use</code> flag is an experiment to have Cargo update the mtime of
used files to make it easier for tools like cargo-sweep to detect which files
are stale. For many workflows this needs to be set on <em>all</em> invocations of cargo.
To make this more practical setting the <code>unstable.mtime_on_use</code> flag in <code>.cargo/config.toml</code>
or the corresponding ENV variable will apply the <code>-Z mtime-on-use</code> to all
invocations of nightly cargo. (the config flag is ignored by stable)</p>
<h2 id="avoid-dev-deps"><a class="header" href="#avoid-dev-deps">avoid-dev-deps</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4988">#4988</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5133">#5133</a></li>
</ul>
<p>When running commands such as <code>cargo install</code> or <code>cargo build</code>, Cargo
currently requires dev-dependencies to be downloaded, even if they are not
used. The <code>-Z avoid-dev-deps</code> flag allows Cargo to avoid downloading
dev-dependencies if they are not needed. The <code>Cargo.lock</code> file will not be
generated if dev-dependencies are skipped.</p>
<h2 id="minimal-versions"><a class="header" href="#minimal-versions">minimal-versions</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<blockquote>
<p>Note: It is not recommended to use this feature. Because it enforces minimal
versions for all transitive dependencies, its usefulness is limited since
not all external dependencies declare proper lower version bounds. It is
intended that it will be changed in the future to only enforce minimal
versions for direct dependencies.</p>
</blockquote>
<p>When a <code>Cargo.lock</code> file is generated, the <code>-Z minimal-versions</code> flag will
resolve the dependencies to the minimum SemVer version that will satisfy the
requirements (instead of the greatest version).</p>
<p>The intended use-case of this flag is to check, during continuous integration,
that the versions specified in Cargo.toml are a correct reflection of the
minimum versions that you are actually using. That is, if Cargo.toml says
<code>foo = "1.0.0"</code> that you don’t accidentally depend on features added only in
<code>foo 1.5.0</code>.</p>
<h2 id="direct-minimal-versions"><a class="header" href="#direct-minimal-versions">direct-minimal-versions</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<p>When a <code>Cargo.lock</code> file is generated, the <code>-Z direct-minimal-versions</code> flag will
resolve the dependencies to the minimum SemVer version that will satisfy the
requirements (instead of the greatest version) for direct dependencies only.</p>
<p>The intended use-case of this flag is to check, during continuous integration,
that the versions specified in Cargo.toml are a correct reflection of the
minimum versions that you are actually using. That is, if Cargo.toml says
<code>foo = "1.0.0"</code> that you don’t accidentally depend on features added only in
<code>foo 1.5.0</code>.</p>
<p>Indirect dependencies are resolved as normal so as not to be blocked on their
minimal version validation.</p>
<h2 id="artifact-dir"><a class="header" href="#artifact-dir">artifact-dir</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4875">#4875</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/6790">#6790</a></li>
</ul>
<p>This feature allows you to specify the directory where artifacts will be copied
to after they are built. Typically artifacts are only written to the
<code>target/release</code> or <code>target/debug</code> directories. However, determining the exact
filename can be tricky since you need to parse JSON output. The <code>--artifact-dir</code>
flag makes it easier to predictably access the artifacts. Note that the
artifacts are copied, so the originals are still in the <code>target</code> directory.
Example:</p>
<pre><code class="language-sh">cargo +nightly build --artifact-dir=out -Z unstable-options
</code></pre>
<p>This can also be specified in <code>.cargo/config.toml</code> files.</p>
<pre><code class="language-toml">[build]
artifact-dir = "out"
</code></pre>
<h2 id="root-dir"><a class="header" href="#root-dir">root-dir</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/9887">#9887</a></li>
<li>Tracking Issue: None (not currently slated for stabilization)</li>
</ul>
<p>The <code>-Zroot-dir</code> flag sets the root directory relative to which paths are printed.
This affects both diagnostics and paths emitted by the <code>file!()</code> macro.</p>
<h2 id="build-plan"><a class="header" href="#build-plan">Build-plan</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5579">#5579</a></li>
</ul>
<div class="warning">
<blockquote>
<p>The build-plan feature is deprecated and may be removed in a future version.
See <a href="https://github.com/rust-lang/cargo/issues/7614">https://github.com/rust-lang/cargo/issues/7614</a>.</p>
</blockquote>
</div>
<p>The <code>--build-plan</code> argument for the <code>build</code> command will output JSON with
information about which commands would be run without actually executing
anything. This can be useful when integrating with another build tool.
Example:</p>
<pre><code class="language-sh">cargo +nightly build --build-plan -Z unstable-options
</code></pre>
<h2 id="metabuild"><a class="header" href="#metabuild">Metabuild</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/49803">rust-lang/rust#49803</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2196-metabuild.md">#2196</a></li>
</ul>
<p>Metabuild is a feature to have declarative build scripts. Instead of writing
a <code>build.rs</code> script, you specify a list of build dependencies in the
<code>metabuild</code> key in <code>Cargo.toml</code>. A build script is automatically generated
that runs each build dependency in order. Metabuild packages can then read
metadata from <code>Cargo.toml</code> to specify their behavior.</p>
<p>Include <code>cargo-features</code> at the top of <code>Cargo.toml</code>, a <code>metabuild</code> key in the
<code>package</code>, list the dependencies in <code>build-dependencies</code>, and add any metadata
that the metabuild packages require under <code>package.metadata</code>. Example:</p>
<pre><code class="language-toml">cargo-features = ["metabuild"]

[package]
name = "mypackage"
version = "0.0.1"
metabuild = ["foo", "bar"]

[build-dependencies]
foo = "1.0"
bar = "1.0"

[package.metadata.foo]
extra-info = "qwerty"
</code></pre>
<p>Metabuild packages should have a public function called <code>metabuild</code> that
performs the same actions as a regular <code>build.rs</code> script would perform.</p>
<h2 id="multiple-build-scripts"><a class="header" href="#multiple-build-scripts">Multiple Build Scripts</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/14903">#14903</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15630">#15630</a></li>
</ul>
<p>Multiple Build Scripts feature allows you to have multiple build scripts in your package.</p>
<p>Include <code>cargo-features</code> at the top of <code>Cargo.toml</code> and add <code>multiple-build-scripts</code> to enable feature.
Add the paths of the build scripts as an array in <code>package.build</code>. For example:</p>
<pre><code class="language-toml">cargo-features = ["multiple-build-scripts"]

[package]
name = "mypackage"
version = "0.0.1"
build = ["foo.rs", "bar.rs"]
</code></pre>
<p><strong>Accessing Output Directories</strong>:  Output directory of each build script can be accessed by using <code>&lt;script-name&gt;_OUT_DIR</code>
where the <code>&lt;script-name&gt;</code> is the file-stem of the build script, exactly as-is.
For example, <code>bar_OUT_DIR</code> for script at <code>foo/bar.rs</code>. (Only set during compilation, can be accessed via <code>env!</code> macro)</p>
<h2 id="public-dependency"><a class="header" href="#public-dependency">public-dependency</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/44663">#44663</a></li>
</ul>
<p>The ‘public-dependency’ feature allows marking dependencies as ‘public’
or ‘private’. When this feature is enabled, additional information is passed to rustc to allow
the <a href="reference/../../rustc/lints/listing/warn-by-default.html#exported-private-dependencies">exported_private_dependencies</a> lint to function properly.</p>
<p>To enable this feature, you can either use <code>-Zpublic-dependency</code></p>
<pre><code class="language-sh">cargo +nightly run -Zpublic-dependency
</code></pre>
<p>or <code>[unstable]</code> table, for example,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
public-dependency = true
</code></pre>
<p><code>public-dependency</code> could also be enabled in <code>cargo-features</code>, <strong>though this is deprecated and will be removed soon</strong>.</p>
<pre><code class="language-toml">cargo-features = ["public-dependency"]

[dependencies]
my_dep = { version = "1.2.3", public = true }
private_dep = "2.0.0" # Will be 'private' by default
</code></pre>
<p>Documentation updates:</p>
<ul>
<li>For workspace’s “The <code>dependencies</code> table” section, include <code>public</code> as an unsupported field for <code>workspace.dependencies</code></li>
</ul>
<h2 id="msrv-policy"><a class="header" href="#msrv-policy">msrv-policy</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/3537-msrv-resolver.html">RFC: MSRV-aware Resolver</a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/9930">#9930</a> (MSRV-aware resolver)</li>
</ul>
<p>Catch-all unstable feature for MSRV-aware cargo features under
<a href="https://github.com/rust-lang/rfcs/pull/2495">RFC 2495</a>.</p>
<h3 id="msrv-aware-cargo-add"><a class="header" href="#msrv-aware-cargo-add">MSRV-aware cargo add</a></h3>
<p>This was stabilized in 1.79 in <a href="https://github.com/rust-lang/cargo/pull/13608">#13608</a>.</p>
<h3 id="msrv-aware-resolver"><a class="header" href="#msrv-aware-resolver">MSRV-aware resolver</a></h3>
<p>This was stabilized in 1.84 in <a href="https://github.com/rust-lang/cargo/pull/14639">#14639</a>.</p>
<h3 id="convert-incompatible_toolchain-error-into-a-lint"><a class="header" href="#convert-incompatible_toolchain-error-into-a-lint">Convert <code>incompatible_toolchain</code> error into a lint</a></h3>
<p>Unimplemented</p>
<h3 id="--update-rust-version-flag-for-cargo-add-cargo-update"><a class="header" href="#--update-rust-version-flag-for-cargo-add-cargo-update"><code>--update-rust-version</code> flag for <code>cargo add</code>, <code>cargo update</code></a></h3>
<p>Unimplemented</p>
<h3 id="packagerust-version--toolchain"><a class="header" href="#packagerust-version--toolchain"><code>package.rust-version = "toolchain"</code></a></h3>
<p>Unimplemented</p>
<h3 id="update-cargo-new-template-to-set-packagerust-version--toolchain"><a class="header" href="#update-cargo-new-template-to-set-packagerust-version--toolchain">Update <code>cargo new</code> template to set <code>package.rust-version = "toolchain"</code></a></h3>
<p>Unimplemented</p>
<h2 id="precise-pre-release"><a class="header" href="#precise-pre-release">precise-pre-release</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/13290">#13290</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3493">#3493</a></li>
</ul>
<p>The <code>precise-pre-release</code> feature allows pre-release versions to be selected with <code>update --precise</code>
even when a pre-release is not specified by a projects <code>Cargo.toml</code>.</p>
<p>Take for example this <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
my-dependency = "0.1.1"
</code></pre>
<p>It’s possible to update <code>my-dependency</code> to a pre-release with <code>update -Zunstable-options my-dependency --precise 0.1.2-pre.0</code>.
This is because <code>0.1.2-pre.0</code> is considered compatible with <code>0.1.1</code>.
It would not be possible to upgrade to <code>0.2.0-pre.0</code> from <code>0.1.1</code> in the same way.</p>
<h2 id="sbom"><a class="header" href="#sbom">sbom</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/pull/13709">#13709</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3553">#3553</a></li>
</ul>
<p>The <code>sbom</code> build config allows to generate so-called SBOM pre-cursor files
alongside each compiled artifact. A Software Bill Of Material (SBOM) tool can
incorporate these generated files to collect important information from the cargo
build process that are difficult or impossible to obtain in another way.</p>
<p>To enable this feature either set the <code>sbom</code> field in the <code>.cargo/config.toml</code></p>
<pre><code class="language-toml">[unstable]
sbom = true

[build]
sbom = true
</code></pre>
<p>or set the <code>CARGO_BUILD_SBOM</code> environment variable to <code>true</code>. The functionality
is available behind the flag <code>-Z sbom</code>.</p>
<p>The generated output files are in JSON format and follow the naming scheme
<code>&lt;artifact&gt;.cargo-sbom.json</code>. The JSON file contains information about dependencies,
target, features and the used <code>rustc</code> compiler.</p>
<p>SBOM pre-cursor files are generated for all executable and linkable outputs
that are uplifted into the target or artifact directories.</p>
<h3 id="environment-variables-cargo-sets-for-crates-1"><a class="header" href="#environment-variables-cargo-sets-for-crates-1">Environment variables Cargo sets for crates</a></h3>
<ul>
<li><code>CARGO_SBOM_PATH</code> – a list of generated SBOM precursor files, separated by the platform PATH separator. The list can be split with <code>std::env::split_paths</code>.</li>
</ul>
<h3 id="sbom-pre-cursor-schema"><a class="header" href="#sbom-pre-cursor-schema">SBOM pre-cursor schema</a></h3>
<pre><code class="language-json5">{
  // Schema version.
  "version": 1,
  // Index into the crates array for the root crate.
  "root": 0,
  // Array of all crates. There may be duplicates of the same crate if that
  // crate is compiled differently (different opt-level, features, etc).
  "crates": [
    {
      // Fully qualified package ID specification
      "id": "path+file:///sample-package#0.1.0",
      // List of target kinds: bin, lib, rlib, dylib, cdylib, staticlib, proc-macro, example, test, bench, custom-build
      "kind": ["bin"],
      // Enabled feature flags.
      "features": [],
      // Dependencies for this crate.
      "dependencies": [
        {
          // Index in to the crates array.
          "index": 1,
          // Dependency kind: 
          // Normal: A dependency linked to the artifact produced by this crate.
          // Build: A compile-time dependency used to build this crate (build-script or proc-macro).
          "kind": "normal"
        },
        {
          // A crate can depend on another crate with both normal and build edges.
          "index": 1,
          "kind": "build"
        }
      ]
    },
    {
      "id": "registry+https://github.com/rust-lang/crates.io-index#zerocopy@0.8.16",
      "kind": ["bin"],
      "features": [],
      "dependencies": []
    }
  ],
  // Information about rustc used to perform the compilation.
  "rustc": {
    // Compiler version
    "version": "1.86.0-nightly",
    // Compiler wrapper
    "wrapper": null,
    // Compiler workspace wrapper
    "workspace_wrapper": null,
    // Commit hash for rustc
    "commit_hash": "bef3c3b01f690de16738b1c9f36470fbfc6ac623",
    // Host target triple
    "host": "x86_64-pc-windows-msvc",
    // Verbose version string: `rustc -vV`
    "verbose_version": "rustc 1.86.0-nightly (bef3c3b01 2025-02-04)\nbinary: rustc\ncommit-hash: bef3c3b01f690de16738b1c9f36470fbfc6ac623\ncommit-date: 2025-02-04\nhost: x86_64-pc-windows-msvc\nrelease: 1.86.0-nightly\nLLVM version: 19.1.7\n"
  }
}
</code></pre>
<h2 id="update-breaking"><a class="header" href="#update-breaking">update-breaking</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/12425">#12425</a></li>
</ul>
<p>Allow upgrading dependencies version requirements in <code>Cargo.toml</code> across SemVer
incompatible versions using with the <code>--breaking</code> flag.</p>
<p>This only applies to dependencies when</p>
<ul>
<li>The package is a dependency of a workspace member</li>
<li>The dependency is not renamed</li>
<li>A SemVer-incompatible version is available</li>
<li>The “SemVer operator” is used (<code>^</code> which is the default)</li>
</ul>
<p>Users may further restrict which packages get upgraded by specifying them on
the command line.</p>
<p>Example:</p>
<pre><code class="language-console">$ cargo +nightly -Zunstable-options update --breaking
$ cargo +nightly -Zunstable-options update --breaking clap
</code></pre>
<p><em>This is meant to fill a similar role as <a href="https://github.com/killercup/cargo-edit/">cargo-upgrade</a></em></p>
<h2 id="build-std"><a class="header" href="#build-std">build-std</a></h2>
<ul>
<li>Tracking Repository: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p>The <code>build-std</code> feature enables Cargo to compile the standard library itself as
part of a crate graph compilation. This feature has also historically been known
as “std-aware Cargo”. This feature is still in very early stages of development,
and is also a possible massive feature addition to Cargo. This is a very large
feature to document, even in the minimal form that it exists in today, so if
you’re curious to stay up to date you’ll want to follow the <a href="https://github.com/rust-lang/wg-cargo-std-aware">tracking
repository</a> and its set of
issues.</p>
<p>The functionality implemented today is behind a flag called <code>-Z build-std</code>. This
flag indicates that Cargo should compile the standard library from source code
using the same profile as the main build itself. Note that for this to work you
need to have the source code for the standard library available, and at this
time the only supported method of doing so is to add the <code>rust-src</code> rust rustup
component:</p>
<pre><code class="language-console">$ rustup component add rust-src --toolchain nightly
</code></pre>
<p>Usage looks like:</p>
<pre><code class="language-console">$ cargo new foo
$ cd foo
$ cargo +nightly run -Z build-std --target x86_64-unknown-linux-gnu
   Compiling core v0.0.0 (...)
   ...
   Compiling foo v0.1.0 (...)
    Finished dev [unoptimized + debuginfo] target(s) in 21.00s
     Running `target/x86_64-unknown-linux-gnu/debug/foo`
Hello, world!
</code></pre>
<p>Here we recompiled the standard library in debug mode with debug assertions
(like <code>src/main.rs</code> is compiled) and everything was linked together at the end.</p>
<p>Using <code>-Z build-std</code> will implicitly compile the stable crates <code>core</code>, <code>std</code>,
<code>alloc</code>, and <code>proc_macro</code>. If you’re using <code>cargo test</code> it will also compile the
<code>test</code> crate. If you’re working with an environment which does not support some
of these crates, then you can pass an argument to <code>-Zbuild-std</code> as well:</p>
<pre><code class="language-console">$ cargo +nightly build -Z build-std=core,alloc
</code></pre>
<p>The value here is a comma-separated list of standard library crates to build.</p>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<p>As a summary, a list of requirements today to use <code>-Z build-std</code> are:</p>
<ul>
<li>You must install libstd’s source code through <code>rustup component add rust-src</code></li>
<li>You must use both a nightly Cargo and a nightly rustc</li>
<li>The <code>-Z build-std</code> flag must be passed to all <code>cargo</code> invocations.</li>
</ul>
<h3 id="reporting-bugs-and-helping-out"><a class="header" href="#reporting-bugs-and-helping-out">Reporting bugs and helping out</a></h3>
<p>The <code>-Z build-std</code> feature is in the very early stages of development! This
feature for Cargo has an extremely long history and is very large in scope, and
this is just the beginning. If you’d like to report bugs please either report
them to:</p>
<ul>
<li>Cargo — <a href="https://github.com/rust-lang/cargo/issues/new">https://github.com/rust-lang/cargo/issues/new</a> — for implementation bugs</li>
<li>The tracking repository —
<a href="https://github.com/rust-lang/wg-cargo-std-aware/issues/new">https://github.com/rust-lang/wg-cargo-std-aware/issues/new</a> — for larger design
questions.</li>
</ul>
<p>Also if you’d like to see a feature that’s not yet implemented and/or if
something doesn’t quite work the way you’d like it to, feel free to check out
the <a href="https://github.com/rust-lang/wg-cargo-std-aware/issues">issue tracker</a> of
the tracking repository, and if it’s not there please file a new issue!</p>
<h2 id="build-std-features"><a class="header" href="#build-std-features">build-std-features</a></h2>
<ul>
<li>Tracking Repository: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p>This flag is a sibling to the <code>-Zbuild-std</code> feature flag. This will configure
the features enabled for the standard library itself when building the standard
library. The default enabled features, at this time, are <code>backtrace</code> and
<code>panic-unwind</code>. This flag expects a comma-separated list and, if provided, will
override the default list of features enabled.</p>
<h2 id="binary-dep-depinfo"><a class="header" href="#binary-dep-depinfo">binary-dep-depinfo</a></h2>
<ul>
<li>Tracking rustc issue: <a href="https://github.com/rust-lang/rust/issues/63012">#63012</a></li>
</ul>
<p>The <code>-Z binary-dep-depinfo</code> flag causes Cargo to forward the same flag to
<code>rustc</code> which will then cause <code>rustc</code> to include the paths of all binary
dependencies in the “dep info” file (with the <code>.d</code> extension). Cargo then uses
that information for change-detection (if any binary dependency changes, then
the crate will be rebuilt). The primary use case is for building the compiler
itself, which has implicit dependencies on the standard library that would
otherwise be untracked for change-detection.</p>
<h2 id="checksum-freshness"><a class="header" href="#checksum-freshness">checksum-freshness</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/cargo/issues/14136">#14136</a></li>
</ul>
<p>The <code>-Z checksum-freshness</code> flag will replace the use of file mtimes in cargo’s
fingerprints with a file checksum value. This is most useful on systems with a poor
mtime implementation, or in CI/CD. The checksum algorithm can change without notice
between cargo versions. Fingerprints are used by cargo to determine when a crate needs to be rebuilt.</p>
<p>For the time being files ingested by build script will continue to use mtimes, even when <code>checksum-freshness</code>
is enabled. This is not intended as a long term solution.</p>
<h2 id="panic-abort-tests"><a class="header" href="#panic-abort-tests">panic-abort-tests</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/67650">#67650</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/7460">#7460</a></li>
</ul>
<p>The <code>-Z panic-abort-tests</code> flag will enable nightly support to compile test
harness crates with <code>-Cpanic=abort</code>. Without this flag Cargo will compile tests,
and everything they depend on, with <code>-Cpanic=unwind</code> because it’s the only way
<code>test</code>-the-crate knows how to operate. As of <a href="https://github.com/rust-lang/rust/pull/64158">rust-lang/rust#64158</a>, however,
the <code>test</code> crate supports <code>-C panic=abort</code> with a test-per-process, and can help
avoid compiling crate graphs multiple times.</p>
<p>It’s currently unclear how this feature will be stabilized in Cargo, but we’d
like to stabilize it somehow!</p>
<h2 id="config-include"><a class="header" href="#config-include">config-include</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/7723">#7723</a></li>
</ul>
<p>This feature requires the <code>-Zconfig-include</code> command-line option.</p>
<p>The <code>include</code> key in a config file can be used to load another config file. It
takes a string for a path to another file relative to the config file, or an
array of config file paths. Only path ending with <code>.toml</code> is accepted.</p>
<pre><code class="language-toml"># a path ending with `.toml`
include = "path/to/mordor.toml"

# or an array of paths
include = ["frodo.toml", "samwise.toml"]
</code></pre>
<p>Unlike other config values, the merge behavior of the <code>include</code> key is
different. When a config file contains an <code>include</code> key:</p>
<ol>
<li>The config values are first loaded from the <code>include</code> path.
<ul>
<li>If the value of the <code>include</code> key is an array of paths, the config values
are loaded and merged from left to right for each path.</li>
<li>Recurse this step if the config values from the <code>include</code> path also
contain an <code>include</code> key.</li>
</ul>
</li>
<li>Then, the config file’s own values are merged on top of the config
from the <code>include</code> path.</li>
</ol>
<h2 id="target-applies-to-host"><a class="header" href="#target-applies-to-host">target-applies-to-host</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9453">#9453</a></li>
</ul>
<p>Historically, Cargo’s behavior for whether the <code>linker</code> and <code>rustflags</code>
configuration options from environment variables and
<a href="reference/config.html#target"><code>[target]</code></a> are respected for build scripts, plugins,
and other artifacts that are <em>always</em> built for the host platform has
been somewhat inconsistent.
When <code>--target</code> is <em>not</em> passed, Cargo respects the same <code>linker</code> and
<code>rustflags</code> for build scripts as for all other compile artifacts. When
<code>--target</code> <em>is</em> passed, however, Cargo respects <code>linker</code> from
<a href="reference/config.html#targettriplelinker"><code>[target.&lt;host triple&gt;]</code></a>, and does not
pick up any <code>rustflags</code> configuration.
This dual behavior is confusing, but also makes it difficult to correctly
configure builds where the host triple and the <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (glossary)">target triple</a> happen to
be the same, but artifacts intended to run on the build host should still
be configured differently.</p>
<p><code>-Ztarget-applies-to-host</code> enables the top-level
<code>target-applies-to-host</code> setting in Cargo configuration files which
allows users to opt into different (and more consistent) behavior for
these properties. When <code>target-applies-to-host</code> is unset, or set to
<code>true</code>, in the configuration file, the existing Cargo behavior is
preserved (though see <code>-Zhost-config</code>, which changes that default). When
it is set to <code>false</code>, no options from <code>[target.&lt;host triple&gt;]</code>,
<code>RUSTFLAGS</code>, or <code>[build]</code> are respected for host artifacts regardless of
whether <code>--target</code> is passed to Cargo. To customize artifacts intended
to be run on the host, use <code>[host]</code> (<a href="reference/unstable.html#host-config"><code>host-config</code></a>).</p>
<p>In the future, <code>target-applies-to-host</code> may end up defaulting to <code>false</code>
to provide more sane and consistent default behavior.</p>
<pre><code class="language-toml"># config.toml
target-applies-to-host = false
</code></pre>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host build --target x86_64-unknown-linux-gnu
</code></pre>
<h2 id="host-config"><a class="header" href="#host-config">host-config</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9452">#9452</a></li>
</ul>
<p>The <code>host</code> key in a config file can be used to pass flags to host build targets
such as build scripts that must run on the host system instead of the target
system when cross compiling. It supports both generic and host arch specific
tables. Matching host arch tables take precedence over generic host tables.</p>
<p>It requires the <code>-Zhost-config</code> and <code>-Ztarget-applies-to-host</code>
command-line options to be set, and that <code>target-applies-to-host = false</code> is set in the Cargo configuration file.</p>
<pre><code class="language-toml"># config.toml
[host]
linker = "/path/to/host/linker"
[host.x86_64-unknown-linux-gnu]
linker = "/path/to/host/arch/linker"
rustflags = ["-Clink-arg=--verbose"]
[target.x86_64-unknown-linux-gnu]
linker = "/path/to/target/linker"
</code></pre>
<p>The generic <code>host</code> table above will be entirely ignored when building on an
<code>x86_64-unknown-linux-gnu</code> host as the <code>host.x86_64-unknown-linux-gnu</code> table
takes precedence.</p>
<p>Setting <code>-Zhost-config</code> changes the default for <code>target-applies-to-host</code> to
<code>false</code> from <code>true</code>.</p>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host -Zhost-config build --target x86_64-unknown-linux-gnu
</code></pre>
<h2 id="unit-graph"><a class="header" href="#unit-graph">unit-graph</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/8002">#8002</a></li>
</ul>
<p>The <code>--unit-graph</code> flag can be passed to any build command (<code>build</code>, <code>check</code>,
<code>run</code>, <code>test</code>, <code>bench</code>, <code>doc</code>, etc.) to emit a JSON object to stdout which
represents Cargo’s internal unit graph. Nothing is actually built, and the
command returns immediately after printing. Each “unit” corresponds to an
execution of the compiler. These objects also include which unit each unit
depends on.</p>
<pre><code>cargo +nightly build --unit-graph -Z unstable-options
</code></pre>
<p>This structure provides a more complete view of the dependency relationship as
Cargo sees it. In particular, the “features” field supports the new feature
resolver where a dependency can be built multiple times with different
features. <code>cargo metadata</code> fundamentally cannot represent the relationship of
features between different dependency kinds, and features now depend on which
command is run and which packages and targets are selected. Additionally it
can provide details about intra-package dependencies like build scripts or
tests.</p>
<p>The following is a description of the JSON structure:</p>
<pre><code class="language-javascript">{
  /* Version of the JSON output structure. If any backwards incompatible
     changes are made, this value will be increased.
  */
  "version": 1,
  /* Array of all build units. */
  "units": [
    {
      /* An opaque string which indicates the package.
         Information about the package can be obtained from `cargo metadata`.
      */
      "pkg_id": "my-package 0.1.0 (path+file:///path/to/my-package)",
      /* The Cargo target. See the `cargo metadata` documentation for more
         information about these fields.
         https://doc.rust-lang.org/cargo/commands/cargo-metadata.html
      */
      "target": {
        "kind": ["lib"],
        "crate_types": ["lib"],
        "name": "my_package",
        "src_path": "/path/to/my-package/src/lib.rs",
        "edition": "2018",
        "test": true,
        "doctest": true
      },
      /* The profile settings for this unit.
         These values may not match the profile defined in the manifest.
         Units can use modified profile settings. For example, the "panic"
         setting can be overridden for tests to force it to "unwind".
      */
      "profile": {
        /* The profile name these settings are derived from. */
        "name": "dev",
        /* The optimization level as a string. */
        "opt_level": "0",
        /* The LTO setting as a string. */
        "lto": "false",
        /* The codegen units as an integer.
           `null` if it should use the compiler's default.
        */
        "codegen_units": null,
        /* The debug information level as an integer.
           `null` if it should use the compiler's default (0).
        */
        "debuginfo": 2,
        /* Whether or not debug-assertions are enabled. */
        "debug_assertions": true,
        /* Whether or not overflow-checks are enabled. */
        "overflow_checks": true,
        /* Whether or not rpath is enabled. */
        "rpath": false,
        /* Whether or not incremental is enabled. */
        "incremental": true,
        /* The panic strategy, "unwind" or "abort". */
        "panic": "unwind"
      },
      /* Which platform this target is being built for.
         A value of `null` indicates it is for the host.
         Otherwise it is a string of the target triple (such as
         "x86_64-unknown-linux-gnu").
      */
      "platform": null,
      /* The "mode" for this unit. Valid values:

         * "test" --- Build using `rustc` as a test.
         * "build" --- Build using `rustc`.
         * "check" --- Build using `rustc` in "check" mode.
         * "doc" --- Build using `rustdoc`.
         * "doctest" --- Test using `rustdoc`.
         * "run-custom-build" --- Represents the execution of a build script.
      */
      "mode": "build",
      /* Array of features enabled on this unit as strings. */
      "features": ["somefeat"],
      /* Whether or not this is a standard-library unit,
         part of the unstable build-std feature.
         If not set, treat as `false`.
      */
      "is_std": false,
      /* Array of dependencies of this unit. */
      "dependencies": [
        {
          /* Index in the "units" array for the dependency. */
          "index": 1,
          /* The name that this dependency will be referred as. */
          "extern_crate_name": "unicode_xid",
          /* Whether or not this dependency is "public",
             part of the unstable public-dependency feature.
             If not set, the public-dependency feature is not enabled.
          */
          "public": false,
          /* Whether or not this dependency is injected into the prelude,
             currently used by the build-std feature.
             If not set, treat as `false`.
          */
          "noprelude": false
        }
      ]
    },
    // ...
  ],
  /* Array of indices in the "units" array that are the "roots" of the
     dependency graph.
  */
  "roots": [0],
}
</code></pre>
<h2 id="profile-rustflags-option"><a class="header" href="#profile-rustflags-option">Profile <code>rustflags</code> option</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/7878">rust-lang/cargo#7878</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10271">rust-lang/cargo#10271</a></li>
</ul>
<p>This feature provides a new option in the <code>[profile]</code> section to specify flags
that are passed directly to rustc.
This can be enabled like so:</p>
<pre><code class="language-toml">cargo-features = ["profile-rustflags"]

[package]
# ...

[profile.release]
rustflags = [ "-C", "..." ]
</code></pre>
<p>To set this in a profile in Cargo configuration, you need to use either
<code>-Z profile-rustflags</code> or <code>[unstable]</code> table to enable it. For example,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
profile-rustflags = true

[profile.release]
rustflags = [ "-C", "..." ]
</code></pre>
<h2 id="profile-hint-mostly-unused-option"><a class="header" href="#profile-hint-mostly-unused-option">Profile <code>hint-mostly-unused</code> option</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15644">#15644</a></li>
</ul>
<p>This feature provides a new option in the <code>[profile]</code> section to enable the
rustc <code>hint-mostly-unused</code> option. This is primarily useful to enable for
specific dependencies:</p>
<pre><code class="language-toml">[profile.dev.package.huge-mostly-unused-dependency]
hint-mostly-unused = true
</code></pre>
<p>To enable this feature, pass <code>-Zprofile-hint-mostly-unused</code>. However, since
this option is a hint, using it without passing <code>-Zprofile-hint-mostly-unused</code>
will only warn and ignore the profile option. Versions of Cargo prior to the
introduction of this feature will give an “unused manifest key” warning, but
will otherwise function without erroring. This allows using the hint in a
crate’s <code>Cargo.toml</code> without mandating the use of a newer Cargo to build it.</p>
<p>A crate can also provide this hint automatically for crates that depend on it,
using the <code>[hints]</code> table (which will likewise be ignored by older Cargo):</p>
<pre><code class="language-toml">[hints]
mostly-unused = true
</code></pre>
<p>This will cause the crate to default to hint-mostly-unused, unless overridden
via <code>profile</code>, which takes precedence, and which can only be specified in the
top-level crate being built.</p>
<h2 id="rustdoc-map"><a class="header" href="#rustdoc-map">rustdoc-map</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/8296">#8296</a></li>
</ul>
<p>This feature adds configuration settings that are passed to <code>rustdoc</code> so that
it can generate links to dependencies whose documentation is hosted elsewhere
when the dependency is not documented. First, add this to <code>.cargo/config</code>:</p>
<pre><code class="language-toml">[doc.extern-map.registries]
crates-io = "https://docs.rs/"
</code></pre>
<p>Then, when building documentation, use the following flags to cause links
to dependencies to link to <a href="https://docs.rs/">docs.rs</a>:</p>
<pre><code>cargo +nightly doc --no-deps -Zrustdoc-map
</code></pre>
<p>The <code>registries</code> table contains a mapping of registry name to the URL to link
to. The URL may have the markers <code>{pkg_name}</code> and <code>{version}</code> which will get
replaced with the corresponding values. If neither are specified, then Cargo
defaults to appending <code>{pkg_name}/{version}/</code> to the end of the URL.</p>
<p>Another config setting is available to redirect standard library links. By
default, rustdoc creates links to <a href="https://doc.rust-lang.org/nightly/">https://doc.rust-lang.org/nightly/</a>. To
change this behavior, use the <code>doc.extern-map.std</code> setting:</p>
<pre><code class="language-toml">[doc.extern-map]
std = "local"
</code></pre>
<p>A value of <code>"local"</code> means to link to the documentation found in the <code>rustc</code>
sysroot. If you are using rustup, this documentation can be installed with
<code>rustup component add rust-docs</code>.</p>
<p>The default value is <code>"remote"</code>.</p>
<p>The value may also take a URL for a custom location.</p>
<h2 id="per-package-target"><a class="header" href="#per-package-target">per-package-target</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/pull/9406">#9406</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9030">#9030</a></li>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/pull/7004">#7004</a></li>
</ul>
<p>The <code>per-package-target</code> feature adds two keys to the manifest:
<code>package.default-target</code> and <code>package.forced-target</code>. The first makes
the package be compiled by default (ie. when no <code>--target</code> argument is
passed) for some target. The second one makes the package always be
compiled for the target.</p>
<p>Example:</p>
<pre><code class="language-toml">[package]
forced-target = "wasm32-unknown-unknown"
</code></pre>
<p>In this example, the crate is always built for
<code>wasm32-unknown-unknown</code>, for instance because it is going to be used
as a plugin for a main program that runs on the host (or provided on
the command line) target.</p>
<h2 id="artifact-dependencies"><a class="header" href="#artifact-dependencies">artifact-dependencies</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/pull/9096">#9096</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9992">#9992</a></li>
</ul>
<p>Artifact dependencies allow Cargo packages to depend on <code>bin</code>, <code>cdylib</code>, and <code>staticlib</code> crates,
and use the artifacts built by those crates at compile time.</p>
<p>Run <code>cargo</code> with <code>-Z bindeps</code> to enable this functionality.</p>
<h3 id="artifact-dependencies-dependency-declarations"><a class="header" href="#artifact-dependencies-dependency-declarations">artifact-dependencies: Dependency declarations</a></h3>
<p>Artifact-dependencies adds the following keys to a dependency declaration in <code>Cargo.toml</code>:</p>
<ul>
<li>
<p><code>artifact</code> — This specifies the <a href="reference/cargo-targets.html">Cargo Target</a> to build.
Normally without this field, Cargo will only build the <code>[lib]</code> target from a dependency.
This field allows specifying which target will be built, and made available as a binary at build time:</p>
<ul>
<li><code>"bin"</code> — Compiled executable binaries, corresponding to all of the <code>[[bin]]</code> sections in the dependency’s manifest.</li>
<li><code>"bin:&lt;bin-name&gt;"</code> — Compiled executable binary, corresponding to a specific binary target specified by the given <code>&lt;bin-name&gt;</code>.</li>
<li><code>"cdylib"</code> — A C-compatible dynamic library, corresponding to a <code>[lib]</code> section with <code>crate-type = ["cdylib"]</code> in the dependency’s manifest.</li>
<li><code>"staticlib"</code> — A C-compatible static library, corresponding to a <code>[lib]</code> section with <code>crate-type = ["staticlib"]</code> in the dependency’s manifest.</li>
</ul>
<p>The <code>artifact</code> value can be a string, or it can be an array of strings to specify multiple targets.</p>
<p>Example:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = "1.0", artifact = "staticlib" }
zoo = { version = "1.0", artifact = ["bin:cat", "bin:dog"]}
</code></pre>
</li>
<li>
<p><code>lib</code> — This is a Boolean value which indicates whether or not to also build the dependency’s library as a normal Rust <code>lib</code> dependency.
This field can only be specified when <code>artifact</code> is specified.</p>
<p>The default for this field is <code>false</code> when <code>artifact</code> is specified.
If this is set to <code>true</code>, then the dependency’s <code>[lib]</code> target will also be built for the platform target the declaring package is being built for.
This allows the package to use the dependency from Rust code like a normal dependency in addition to an artifact dependency.</p>
<p>Example:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = "1.0", artifact = "bin", lib = true }
</code></pre>
</li>
<li>
<p><code>target</code> — The platform target to build the dependency for.
This field can only be specified when <code>artifact</code> is specified.</p>
<p>The default if this is not specified depends on the dependency kind.
For build dependencies, it will be built for the host target.
For all other dependencies, it will be built for the same targets the declaring package is built for.</p>
<p>For a build dependency, this can also take the special value of <code>"target"</code> which means to build the dependency for the same targets that the package is being built for.</p>
<pre><code class="language-toml">[build-dependencies]
bar = { version = "1.0", artifact = "cdylib", target = "wasm32-unknown-unknown"}
same-target = { version = "1.0", artifact = "bin", target = "target" }
</code></pre>
</li>
</ul>
<h3 id="artifact-dependencies-environment-variables"><a class="header" href="#artifact-dependencies-environment-variables">artifact-dependencies: Environment variables</a></h3>
<p>After building an artifact dependency, Cargo provides the following environment variables that you can use to access the artifact:</p>
<ul>
<li>
<p><code>CARGO_&lt;ARTIFACT-TYPE&gt;_DIR_&lt;DEP&gt;</code> — This is the directory containing all the artifacts from the dependency.</p>
<p><code>&lt;ARTIFACT-TYPE&gt;</code> is the <code>artifact</code> specified for the dependency (uppercased as in <code>CDYLIB</code>, <code>STATICLIB</code>, or <code>BIN</code>) and <code>&lt;DEP&gt;</code> is the name of the dependency.
As with other Cargo environment variables, dependency names are converted to uppercase, with dashes replaced by underscores.</p>
<p>If your manifest renames the dependency, <code>&lt;DEP&gt;</code> corresponds to the name you specify, not the original package name.</p>
</li>
<li>
<p><code>CARGO_&lt;ARTIFACT-TYPE&gt;_FILE_&lt;DEP&gt;_&lt;NAME&gt;</code> — This is the full path to the artifact.</p>
<p><code>&lt;ARTIFACT-TYPE&gt;</code> is the <code>artifact</code> specified for the dependency (uppercased as above), <code>&lt;DEP&gt;</code> is the name of the dependency (transformed as above), and <code>&lt;NAME&gt;</code> is the name of the artifact from the dependency.</p>
<p>Note that <code>&lt;NAME&gt;</code> is not modified in any way from the <code>name</code> specified in the crate supplying the artifact, or the crate name if not specified; for instance, it may be in lowercase, or contain dashes.</p>
<p>For convenience, if the artifact name matches the original package name, cargo additionally supplies a copy of this variable with the <code>_&lt;NAME&gt;</code> suffix omitted.
For instance, if the <code>cmake</code> crate supplies a binary named <code>cmake</code>, Cargo supplies both <code>CARGO_BIN_FILE_CMAKE</code> and <code>CARGO_BIN_FILE_CMAKE_cmake</code>.</p>
</li>
</ul>
<p>For each kind of dependency, these variables are supplied to the same part of the build process that has access to that kind of dependency:</p>
<ul>
<li>For build-dependencies, these variables are supplied to the <code>build.rs</code> script, and can be accessed using <a href="https://doc.rust-lang.org/std/env/fn.var_os.html"><code>std::env::var_os</code></a>.
(As with any OS file path, these may or may not be valid UTF-8.)</li>
<li>For normal dependencies, these variables are supplied during the compilation of the crate, and can be accessed using the <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a> macro.</li>
<li>For dev-dependencies, these variables are supplied during the compilation of examples, tests, and benchmarks, and can be accessed using the <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a> macro.</li>
</ul>
<h3 id="artifact-dependencies-examples"><a class="header" href="#artifact-dependencies-examples">artifact-dependencies: Examples</a></h3>
<h4 id="example-use-a-binary-executable-from-a-build-script"><a class="header" href="#example-use-a-binary-executable-from-a-build-script">Example: use a binary executable from a build script</a></h4>
<p>In the <code>Cargo.toml</code> file, you can specify a dependency on a binary to make available for a build script:</p>
<pre><code class="language-toml">[build-dependencies]
some-build-tool = { version = "1.0", artifact = "bin" }
</code></pre>
<p>Then inside the build script, the binary can be executed at build time:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let build_tool = std::env::var_os("CARGO_BIN_FILE_SOME_BUILD_TOOL").unwrap();
    let status = std::process::Command::new(build_tool)
        .arg("do-stuff")
        .status()
        .unwrap();
    if !status.success() {
        eprintln!("failed!");
        std::process::exit(1);
    }
}</code></pre></pre>
<h4 id="example-use-cdylib-artifact-in-build-script"><a class="header" href="#example-use-cdylib-artifact-in-build-script">Example: use <em>cdylib</em> artifact in build script</a></h4>
<p>The <code>Cargo.toml</code> in the consuming package, building the <code>bar</code> library as <code>cdylib</code>
for a specific build target…</p>
<pre><code class="language-toml">[build-dependencies]
bar = { artifact = "cdylib", version = "1.0", target = "wasm32-unknown-unknown" }
</code></pre>
<p>…along with the build script in <code>build.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    wasm::run_file(std::env::var("CARGO_CDYLIB_FILE_BAR").unwrap());
}</code></pre></pre>
<h4 id="example-use-binary-artifact-and-its-library-in-a-binary"><a class="header" href="#example-use-binary-artifact-and-its-library-in-a-binary">Example: use <em>binary</em> artifact and its library in a binary</a></h4>
<p>The <code>Cargo.toml</code> in the consuming package, building the <code>bar</code> binary for inclusion
as artifact while making it available as library as well…</p>
<pre><code class="language-toml">[dependencies]
bar = { artifact = "bin", version = "1.0", lib = true }
</code></pre>
<p>…along with the executable using <code>main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    bar::init();
    command::run(env!("CARGO_BIN_FILE_BAR"));
}</code></pre></pre>
<h2 id="publish-timeout"><a class="header" href="#publish-timeout">publish-timeout</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/11222">11222</a></li>
</ul>
<p>The <code>publish.timeout</code> key in a config file can be used to control how long
<code>cargo publish</code> waits between posting a package to the registry and it being
available in the local index.</p>
<p>A timeout of <code>0</code> prevents any checks from occurring. The current default is
<code>60</code> seconds.</p>
<p>It requires the <code>-Zpublish-timeout</code> command-line options to be set.</p>
<pre><code class="language-toml"># config.toml
[publish]
timeout = 300  # in seconds
</code></pre>
<h2 id="asymmetric-token"><a class="header" href="#asymmetric-token">asymmetric-token</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10519">10519</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3231">#3231</a></li>
</ul>
<p>The <code>-Z asymmetric-token</code> flag enables the <code>cargo:paseto</code> credential provider which allows Cargo to authenticate to registries without sending secrets over the network.</p>
<p>In <a href="reference/config.html"><code>config.toml</code></a> and <code>credentials.toml</code> files there is a field called <code>private-key</code>, which is a private key formatted in the secret <a href="https://github.com/paseto-standard/paserk/blob/master/types/secret.md">subset of <code>PASERK</code></a> and is used to sign asymmetric tokens</p>
<p>A keypair can be generated with <code>cargo login --generate-keypair</code> which will:</p>
<ul>
<li>generate a public/private keypair in the currently recommended fashion.</li>
<li>save the private key in <code>credentials.toml</code>.</li>
<li>print the public key in <a href="https://github.com/paseto-standard/paserk/blob/master/types/public.md">PASERK public</a> format.</li>
</ul>
<p>It is recommended that the <code>private-key</code> be saved in <code>credentials.toml</code>. It is also supported in <code>config.toml</code>, primarily so that it can be set using the associated environment variable, which is the recommended way to provide it in CI contexts. This setup is what we have for the <code>token</code> field for setting a secret token.</p>
<p>There is also an optional field called <code>private-key-subject</code> which is a string chosen by the registry.
This string will be included as part of an asymmetric token and should not be secret.
It is intended for the rare use cases like “cryptographic proof that the central CA server authorized this action”. Cargo requires it to be non-whitespace printable ASCII. Registries that need non-ASCII data should base64 encode it.</p>
<p>Both fields can be set with <code>cargo login --registry=name --private-key --private-key-subject="subject"</code> which will prompt you to put in the key value.</p>
<p>A registry can have at most one of <code>private-key</code> or <code>token</code> set.</p>
<p>All PASETOs will include <code>iat</code>, the current time in ISO 8601 format. Cargo will include the following where appropriate:</p>
<ul>
<li><code>sub</code> an optional, non-secret string chosen by the registry that is expected to be claimed with every request. The value will be the <code>private-key-subject</code> from the <code>config.toml</code> file.</li>
<li><code>mutation</code> if present, indicates that this request is a mutating operation (or a read-only operation if not present), must be one of the strings <code>publish</code>, <code>yank</code>, or <code>unyank</code>.
<ul>
<li><code>name</code> name of the crate related to this request.</li>
<li><code>vers</code> version string of the crate related to this request.</li>
<li><code>cksum</code> the SHA256 hash of the crate contents, as a string of 64 lowercase hexadecimal digits, must be present only when <code>mutation</code> is equal to <code>publish</code></li>
</ul>
</li>
<li><code>challenge</code> the challenge string received from a 401/403 from this server this session. Registries that issue challenges must track which challenges have been issued/used and never accept a given challenge more than once within the same validity period (avoiding the need to track every challenge ever issued).</li>
</ul>
<p>The “footer” (which is part of the signature) will be a JSON string in UTF-8 and include:</p>
<ul>
<li><code>url</code> the RFC 3986 compliant URL where cargo got the config.json file,
<ul>
<li>If this is a registry with an HTTP index, then this is the base URL that all index queries are relative to.</li>
<li>If this is a registry with a GIT index, it is the URL Cargo used to clone the index.</li>
</ul>
</li>
<li><code>kid</code> the identifier of the private key used to sign the request, using the <a href="https://github.com/paseto-standard/paserk/blob/master/operations/ID.md">PASERK IDs</a> standard.</li>
</ul>
<p>PASETO includes the message that was signed, so the server does not have to reconstruct the exact string from the request in order to check the signature. The server does need to check that the signature is valid for the string in the PASETO and that the contents of that string matches the request.
If a claim should be expected for the request but is missing in the PASETO then the request must be rejected.</p>
<h2 id="cargo-config"><a class="header" href="#cargo-config"><code>cargo config</code></a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/2362">#2362</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9301">#9301</a></li>
</ul>
<p>The <code>cargo config</code> subcommand provides a way to display the configuration
files that cargo loads. It currently includes the <code>get</code> subcommand which
can take an optional config value to display.</p>
<pre><code class="language-console">cargo +nightly -Zunstable-options config get build.rustflags
</code></pre>
<p>If no config value is included, it will display all config values. See the
<code>--help</code> output for more options available.</p>
<h2 id="rustc---print"><a class="header" href="#rustc---print">rustc <code>--print</code></a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9357">#9357</a></li>
</ul>
<p><code>cargo rustc --print=VAL</code> forwards the <code>--print</code> flag to <code>rustc</code> in order to
extract information from <code>rustc</code>. This runs <code>rustc</code> with the corresponding
<a href="https://doc.rust-lang.org/rustc/command-line-arguments.html#--print-print-compiler-information"><code>--print</code></a>
flag, and then immediately exits without compiling. Exposing this as a cargo
flag allows cargo to inject the correct target and RUSTFLAGS based on the
current configuration.</p>
<p>The primary use case is to run <code>cargo rustc --print=cfg</code> to get config values
for the appropriate target and influenced by any other RUSTFLAGS.</p>
<h2 id="different-binary-name"><a class="header" href="#different-binary-name">Different binary name</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9778">#9778</a></li>
<li>PR: <a href="https://github.com/rust-lang/cargo/pull/9627">#9627</a></li>
</ul>
<p>The <code>different-binary-name</code> feature allows setting the filename of the binary without having to obey the
restrictions placed on crate names. For example, the crate name must use only <code>alphanumeric</code> characters
or <code>-</code> or <code>_</code>, and cannot be empty.</p>
<p>The <code>filename</code> parameter should <strong>not</strong> include the binary extension, <code>cargo</code> will figure out the appropriate
extension and use that for the binary on its own.</p>
<p>The <code>filename</code> parameter is only available in the <code>[[bin]]</code> section of the manifest.</p>
<pre><code class="language-toml">cargo-features = ["different-binary-name"]

[package]
name =  "foo"
version = "0.0.1"

[[bin]]
name = "foo"
filename = "007bar"
path = "src/main.rs"
</code></pre>
<h2 id="scrape-examples"><a class="header" href="#scrape-examples">scrape-examples</a></h2>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3123">#3123</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9910">#9910</a></li>
</ul>
<p>The <code>-Z rustdoc-scrape-examples</code> flag tells Rustdoc to search crates in the current workspace
for calls to functions. Those call-sites are then included as documentation. You can use the flag
like this:</p>
<pre><code>cargo doc -Z unstable-options -Z rustdoc-scrape-examples
</code></pre>
<p>By default, Cargo will scrape examples from the example targets of packages being documented.
You can individually enable or disable targets from being scraped with the <code>doc-scrape-examples</code> flag, such as:</p>
<pre><code class="language-toml"># Enable scraping examples from a library
[lib]
doc-scrape-examples = true

# Disable scraping examples from an example target
[[example]]
name = "my-example"
doc-scrape-examples = false
</code></pre>
<p><strong>Note on tests:</strong> enabling <code>doc-scrape-examples</code> on test targets will not currently have any effect. Scraping
examples from tests is a work-in-progress.</p>
<p><strong>Note on dev-dependencies:</strong> documenting a library does not normally require the crate’s dev-dependencies. However,
example targets require dev-deps. For backwards compatibility, <code>-Z rustdoc-scrape-examples</code> will <em>not</em> introduce a
dev-deps requirement for <code>cargo doc</code>. Therefore examples will <em>not</em> be scraped from example targets under the
following conditions:</p>
<ol>
<li>No target being documented requires dev-deps, AND</li>
<li>At least one crate with targets being documented has dev-deps, AND</li>
<li>The <code>doc-scrape-examples</code> parameter is unset or false for all <code>[[example]]</code> targets.</li>
</ol>
<p>If you want examples to be scraped from example targets, then you must not satisfy one of the above conditions.
For example, you can set <code>doc-scrape-examples</code> to true for one example target, and that signals to Cargo that
you are ok with dev-deps being build for <code>cargo doc</code>.</p>
<h2 id="output-format-for-rustdoc"><a class="header" href="#output-format-for-rustdoc">output-format for rustdoc</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/13283">#13283</a></li>
</ul>
<p>This flag determines the output format of <code>cargo rustdoc</code>, accepting <code>html</code> or <code>json</code>, providing tools with a way to lean on <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/">rustdoc’s experimental JSON format</a>.</p>
<p>You can use the flag like this:</p>
<pre><code>cargo rustdoc -Z unstable-options --output-format json
</code></pre>
<h2 id="codegen-backend"><a class="header" href="#codegen-backend">codegen-backend</a></h2>
<p>The <code>codegen-backend</code> feature makes it possible to select the codegen backend used by rustc using a profile.</p>
<p>Example:</p>
<pre><code class="language-toml">[package]
name = "foo"

[dependencies]
serde = "1.0.117"

[profile.dev.package.foo]
codegen-backend = "cranelift"
</code></pre>
<p>To set this in a profile in Cargo configuration, you need to use either
<code>-Z codegen-backend</code> or <code>[unstable]</code> table to enable it. For example,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
codegen-backend = true

[profile.dev.package.foo]
codegen-backend = "cranelift"
</code></pre>
<h2 id="gitoxide"><a class="header" href="#gitoxide">gitoxide</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/11813">#11813</a></li>
</ul>
<p>With the ‘gitoxide’ unstable feature, all or the specified git operations will be performed by
the <code>gitoxide</code> crate instead of <code>git2</code>.</p>
<p>While <code>-Zgitoxide</code> enables all currently implemented features, one can individually select git operations
to run with <code>gitoxide</code> with the <code>-Zgitoxide=operation[,operationN]</code> syntax.</p>
<p>Valid operations are the following:</p>
<ul>
<li><code>fetch</code> - All fetches are done with <code>gitoxide</code>, which includes git dependencies as well as the crates index.</li>
<li><code>checkout</code> <em>(planned)</em> - checkout the worktree, with support for filters and submodules.</li>
</ul>
<h2 id="git"><a class="header" href="#git">git</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/13285">#13285</a></li>
</ul>
<p>With the ‘git’ unstable feature, both <code>gitoxide</code> and <code>git2</code> will perform shallow fetches of the crate
index and git dependencies.</p>
<p>While <code>-Zgit</code> enables all currently implemented features, one can individually select when to perform
shallow fetches with the <code>-Zgit=operation[,operationN]</code> syntax.</p>
<p>Valid operations are the following:</p>
<ul>
<li><code>shallow-index</code> - perform a shallow clone of the index.</li>
<li><code>shallow-deps</code> - perform a shallow clone of git dependencies.</li>
</ul>
<p><strong>Details on shallow clones</strong></p>
<ul>
<li>To enable shallow clones, add <code>-Zgit=shallow-deps</code> for fetching git dependencies or <code>-Zgit=shallow-index</code> for fetching registry index.</li>
<li>Shallow-cloned and shallow-checked-out git repositories reside at their own <code>-shallow</code> suffixed directories, i.e,
<ul>
<li><code>~/.cargo/registry/index/*-shallow</code></li>
<li><code>~/.cargo/git/db/*-shallow</code></li>
<li><code>~/.cargo/git/checkouts/*-shallow</code></li>
</ul>
</li>
<li>When the unstable feature is on, fetching/cloning a git repository is always a shallow fetch. This roughly equals to <code>git fetch --depth 1</code> everywhere.</li>
<li>Even with the presence of <code>Cargo.lock</code> or specifying a commit <code>{ rev = "…" }</code>, gitoxide and libgit2 are still smart enough to shallow fetch without unshallowing the existing repository.</li>
</ul>
<h2 id="script"><a class="header" href="#script">script</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/12207">#12207</a></li>
</ul>
<p>Cargo can directly run <code>.rs</code> files as:</p>
<pre><code class="language-console">$ cargo +nightly -Zscript file.rs
</code></pre>
<p>where <code>file.rs</code> can be as simple as:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {}</code></pre></pre>
<p>A user may optionally specify a manifest in a <code>cargo</code> code fence in a module-level comment, like:</p>
<pre><pre class="playground"><code class="language-rust">#!/usr/bin/env -S cargo +nightly -Zscript
---cargo
[dependencies]
clap = { version = "4.2", features = ["derive"] }
---

use clap::Parser;

#[derive(Parser, Debug)]
#[clap(version)]
struct Args {
    #[clap(short, long, help = "Path to config")]
    config: Option&lt;std::path::PathBuf&gt;,
}

fn main() {
    let args = Args::parse();
    println!("{:?}", args);
}</code></pre></pre>
<h3 id="single-file-packages"><a class="header" href="#single-file-packages">Single-file packages</a></h3>
<p>In addition to today’s multi-file packages (<code>Cargo.toml</code> file with other <code>.rs</code>
files), we are adding the concept of single-file packages which may contain an
embedded manifest.  There is no required distinguishment for a single-file
<code>.rs</code> package from any other <code>.rs</code> file.</p>
<p>Single-file packages may be selected via <code>--manifest-path</code>, like
<code>cargo test --manifest-path foo.rs</code>. Unlike <code>Cargo.toml</code>, these files cannot be auto-discovered.</p>
<p>A single-file package may contain an embedded manifest.  An embedded manifest
is stored using <code>TOML</code> in rust “frontmatter”, a markdown code-fence with <code>cargo</code>
at the start of the infostring at the top of the file.</p>
<p>Inferred / defaulted manifest fields:</p>
<ul>
<li><code>package.name = &lt;slugified file stem&gt;</code></li>
<li><code>package.edition = &lt;current&gt;</code> to avoid always having to add an embedded
manifest at the cost of potentially breaking scripts on rust upgrades
<ul>
<li>Warn when <code>edition</code> is unspecified to raise awareness of this</li>
</ul>
</li>
</ul>
<p>Disallowed manifest fields:</p>
<ul>
<li><code>[workspace]</code>, <code>[lib]</code>, <code>[[bin]]</code>, <code>[[example]]</code>, <code>[[test]]</code>, <code>[[bench]]</code></li>
<li><code>package.workspace</code>, <code>package.build</code>, <code>package.links</code>, <code>package.autolib</code>, <code>package.autobins</code>, <code>package.autoexamples</code>, <code>package.autotests</code>, <code>package.autobenches</code></li>
</ul>
<p>The default <code>CARGO_TARGET_DIR</code> for single-file packages is at <code>$CARGO_HOME/target/&lt;hash&gt;</code>:</p>
<ul>
<li>Avoid conflicts from multiple single-file packages being in the same directory</li>
<li>Avoid problems with the single-file package’s parent directory being read-only</li>
<li>Avoid cluttering the user’s directory</li>
</ul>
<p>The lockfile for single-file packages will be placed in <code>CARGO_TARGET_DIR</code>.  In
the future, when workspaces are supported, that will allow a user to have a
persistent lockfile.</p>
<h3 id="manifest-commands"><a class="header" href="#manifest-commands">Manifest-commands</a></h3>
<p>You may pass a manifest directly to the <code>cargo</code> command, without a subcommand,
like <code>foo/Cargo.toml</code> or a single-file package like <code>foo.rs</code>.  This is mostly
intended for being put in <code>#!</code> lines.</p>
<p>The precedence for how to interpret <code>cargo &lt;subcommand&gt;</code> is</p>
<ol>
<li>Built-in xor single-file packages</li>
<li>Aliases</li>
<li>External subcommands</li>
</ol>
<p>A parameter is identified as a manifest-command if it has one of:</p>
<ul>
<li>Path separators</li>
<li>A <code>.rs</code> extension</li>
<li>The file name is <code>Cargo.toml</code></li>
</ul>
<p>Differences between <code>cargo run --manifest-path &lt;path&gt;</code> and <code>cargo &lt;path&gt;</code></p>
<ul>
<li><code>cargo &lt;path&gt;</code> runs with the config for <code>&lt;path&gt;</code> and not the current dir, more like <code>cargo install --path &lt;path&gt;</code></li>
<li><code>cargo &lt;path&gt;</code> is at a verbosity level below the normal default.  Pass <code>-v</code> to get normal output.</li>
</ul>
<p>When running a package with an embedded manifest,
<a href="https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.arg0"><code>arg0</code></a> will be the scripts path.
To get the executable’s path, see <a href="https://doc.rust-lang.org/std/env/fn.current_exe.html"><code>current_exe</code></a>.</p>
<h3 id="documentation-updates"><a class="header" href="#documentation-updates">Documentation Updates</a></h3>
<h2 id="profile-trim-paths-option"><a class="header" href="#profile-trim-paths-option">Profile <code>trim-paths</code> option</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/12137">rust-lang/cargo#12137</a></li>
<li>Tracking Rustc Issue: <a href="https://github.com/rust-lang/rust/issues/111540">rust-lang/rust#111540</a></li>
</ul>
<p>This adds a new profile setting to control how paths are sanitized in the resulting binary.
This can be enabled like so:</p>
<pre><code class="language-toml">cargo-features = ["trim-paths"]

[package]
# ...

[profile.release]
trim-paths = ["diagnostics", "object"]
</code></pre>
<p>To set this in a profile in Cargo configuration,
you need to use either <code>-Z trim-paths</code> or <code>[unstable]</code> table to enable it.
For example,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
trim-paths = true

[profile.release]
trim-paths = ["diagnostics", "object"]
</code></pre>
<h3 id="documentation-updates-1"><a class="header" href="#documentation-updates-1">Documentation updates</a></h3>
<h4 id="trim-paths"><a class="header" href="#trim-paths">trim-paths</a></h4>
<p><em>as a new <a href="reference/./profiles.html#profile-settings">“Profiles settings” entry</a></em></p>
<p><code>trim-paths</code> is a profile setting which enables and controls the sanitization of file paths in build outputs.
It takes the following values:</p>
<ul>
<li><code>"none"</code> and <code>false</code> — disable path sanitization</li>
<li><code>"macro"</code> — sanitize paths in the expansion of <code>std::file!()</code> macro.
This is where paths in embedded panic messages come from</li>
<li><code>"diagnostics"</code> — sanitize paths in printed compiler diagnostics</li>
<li><code>"object"</code> — sanitize paths in compiled executables or libraries</li>
<li><code>"all"</code> and <code>true</code> — sanitize paths in all possible locations</li>
</ul>
<p>It also takes an array with the combinations of <code>"macro"</code>, <code>"diagnostics"</code>, and <code>"object"</code>.</p>
<p>It is defaulted to <code>none</code> for the <code>dev</code> profile, and <code>object</code> for the <code>release</code> profile.
You can manually override it by specifying this option in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.dev]
trim-paths = "all"

[profile.release]
trim-paths = ["object", "diagnostics"]
</code></pre>
<p>The default <code>release</code> profile setting (<code>object</code>) sanitizes only the paths in emitted executable or library files.
It always affects paths from macros such as panic messages, and in debug information only if they will be embedded together with the binary
(the default on platforms with ELF binaries, such as Linux and windows-gnu),
but will not touch them if they are in separate files (the default on Windows MSVC and macOS).
But the paths to these separate files are sanitized.</p>
<p>If <code>trim-paths</code> is not <code>none</code> or <code>false</code>, then the following paths are sanitized if they appear in a selected scope:</p>
<ol>
<li>Path to the source files of the standard and core library (sysroot) will begin with <code>/rustc/[rustc commit hash]</code>,
e.g. <code>/home/username/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs</code> -&gt;
<code>/rustc/fe72845f7bb6a77b9e671e6a4f32fe714962cec4/library/core/src/result.rs</code></li>
<li>Path to the current package will be stripped, relatively to the current workspace root, e.g. <code>/home/username/crate/src/lib.rs</code> -&gt; <code>src/lib.rs</code>.</li>
<li>Path to dependency packages will be replaced with <code>[package name]-[version]</code>. E.g. <code>/home/username/deps/foo/src/lib.rs</code> -&gt; <code>foo-0.1.0/src/lib.rs</code></li>
</ol>
<p>When a path to the source files of the standard and core library is <em>not</em> in scope for sanitization,
the emitted path will depend on if <code>rust-src</code> component is present.
If it is, then some paths will point to the copy of the source files on your file system;
if it isn’t, then they will show up as <code>/rustc/[rustc commit hash]/library/...</code>
(just like when it is selected for sanitization).
Paths to all other source files will not be affected.</p>
<p>This will not affect any hard-coded paths in the source code, such as in strings.</p>
<h4 id="environment-variable"><a class="header" href="#environment-variable">Environment variable</a></h4>
<p><em>as a new entry of <a href="reference/./environment-variables.html#environment-variables-cargo-sets-for-crates">“Environment variables Cargo sets for build scripts”</a></em></p>
<ul>
<li><code>CARGO_TRIM_PATHS</code> — The value of <code>trim-paths</code> profile option.
<code>false</code>, <code>"none"</code>, and empty arrays would be converted to <code>none</code>.
<code>true</code> and <code>"all"</code> become <code>all</code>.
Values in a non-empty array would be joined into a comma-separated list.
If the build script introduces absolute paths to built artifacts (such as by invoking a compiler),
the user may request them to be sanitized in different types of artifacts.
Common paths requiring sanitization include <code>OUT_DIR</code>, <code>CARGO_MANIFEST_DIR</code> and <code>CARGO_MANIFEST_PATH</code>,
plus any other introduced by the build script, such as include directories.</li>
</ul>
<h2 id="gc"><a class="header" href="#gc">gc</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/12633">#12633</a></li>
</ul>
<p>The <code>-Zgc</code> flag is used to enable certain features related to garbage-collection of cargo’s global cache within the cargo home directory.</p>
<h4 id="automatic-gc-configuration"><a class="header" href="#automatic-gc-configuration">Automatic gc configuration</a></h4>
<p>The <code>-Zgc</code> flag will enable Cargo to read extra configuration options related to garbage collection.
The settings available are:</p>
<pre><code class="language-toml"># Example config.toml file.

# Sub-table for defining specific settings for cleaning the global cache.
[cache.global-clean]
# Anything older than this duration will be deleted in the source cache.
max-src-age = "1 month"
# Anything older than this duration will be deleted in the compressed crate cache.
max-crate-age = "3 months"
# Any index older than this duration will be deleted from the index cache.
max-index-age = "3 months"
# Any git checkout older than this duration will be deleted from the checkout cache.
max-git-co-age = "1 month"
# Any git clone older than this duration will be deleted from the git cache.
max-git-db-age = "3 months"
</code></pre>
<p>Note that the <a href="reference/config.html#cacheauto-clean-frequency"><code>cache.auto-clean-frequency</code></a> option was stabilized in Rust 1.88.</p>
<h3 id="manual-garbage-collection-with-cargo-clean"><a class="header" href="#manual-garbage-collection-with-cargo-clean">Manual garbage collection with <code>cargo clean</code></a></h3>
<p>Manual deletion can be done with the <code>cargo clean gc -Zgc</code> command.
Deletion of cache contents can be performed by passing one of the cache options:</p>
<ul>
<li><code>--max-src-age=DURATION</code> — Deletes source cache files that have not been used since the given age.</li>
<li><code>--max-crate-age=DURATION</code> — Deletes crate cache files that have not been used since the given age.</li>
<li><code>--max-index-age=DURATION</code> — Deletes registry indexes that have not been used since then given age (including their <code>.crate</code> and <code>src</code> files).</li>
<li><code>--max-git-co-age=DURATION</code> — Deletes git dependency checkouts that have not been used since then given age.</li>
<li><code>--max-git-db-age=DURATION</code> — Deletes git dependency clones that have not been used since then given age.</li>
<li><code>--max-download-age=DURATION</code> — Deletes any downloaded cache data that has not been used since then given age.</li>
<li><code>--max-src-size=SIZE</code> — Deletes the oldest source cache files until the cache is under the given size.</li>
<li><code>--max-crate-size=SIZE</code> — Deletes the oldest crate cache files until the cache is under the given size.</li>
<li><code>--max-git-size=SIZE</code> — Deletes the oldest git dependency caches until the cache is under the given size.</li>
<li><code>--max-download-size=SIZE</code> — Deletes the oldest downloaded cache data until the cache is under the given size.</li>
</ul>
<p>A DURATION is specified in the form “N seconds/minutes/days/weeks/months” where N is an integer.</p>
<p>A SIZE is specified in the form “N <em>suffix</em>” where <em>suffix</em> is B, kB, MB, GB, kiB, MiB, or GiB, and N is an integer or floating point number. If no suffix is specified, the number is the number of bytes.</p>
<pre><code class="language-sh">cargo clean gc -Zgc
cargo clean gc -Zgc --max-download-age=1week
cargo clean gc -Zgc --max-git-size=0 --max-download-size=100MB
</code></pre>
<h2 id="open-namespaces"><a class="header" href="#open-namespaces">open-namespaces</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/13576">#13576</a></li>
</ul>
<p>Allow multiple packages to participate in the same API namespace</p>
<p>This can be enabled like so:</p>
<pre><code class="language-toml">cargo-features = ["open-namespaces"]

[package]
# ...
</code></pre>
<h2 id="panic-immediate-abort"><a class="header" href="#panic-immediate-abort">panic-immediate-abort</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/16042">#16042</a></li>
<li>Upstream Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/147286">rust-lang/rust#147286</a></li>
</ul>
<p>Extends the <code>panic</code> profile setting to support the
<a href="reference/../../rustc/codegen-options/index.html#panic"><code>immediate-abort</code></a> panic strategy.
This can be enabled like so:</p>
<pre><code class="language-toml"># Cargo.toml
cargo-features = ["panic-immediate-abort"]

[package]
# ...

[profile.release]
panic = "immediate-abort"
</code></pre>
<p>To set this in a profile in Cargo configuration,
you need to use either <code>-Z panic-immediate-abort</code> CLI flag
or the <code>[unstable]</code> table to enable it.
For example,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
panic-immediate-abort = true

[profile.release]
panic = "immediate-abort"
</code></pre>
<h2 id="lintscargo"><a class="header" href="#lintscargo"><code>[lints.cargo]</code></a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/12235">#12235</a></li>
</ul>
<p>A new <code>lints</code> tool table for <code>cargo</code> that can be used to configure lints emitted
by <code>cargo</code> itself when <code>-Zcargo-lints</code> is used</p>
<pre><code class="language-toml">[lints.cargo]
implicit-features = "warn"
</code></pre>
<p>This will work with
<a href="https://rust-lang.github.io/rfcs/2906-cargo-workspace-deduplicate.html">RFC 2906 <code>workspace-deduplicate</code></a>:</p>
<pre><code class="language-toml">[workspace.lints.cargo]
implicit-features = "warn"

[lints]
workspace = true
</code></pre>
<h2 id="path-bases"><a class="header" href="#path-bases">Path Bases</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/14355">#14355</a></li>
</ul>
<p>A <code>path</code> dependency may optionally specify a base by setting the <code>base</code> key to
the name of a path base from the <code>[path-bases]</code> table in either the
<a href="reference/config.html">configuration</a> or one of the <a href="reference/unstable.html#built-in-path-bases">built-in path bases</a>.
The value of that path base is prepended to the <code>path</code> value (along with a path
separator if necessary) to produce the actual location where Cargo will look for
the dependency.</p>
<p>For example, if the <code>Cargo.toml</code> contains:</p>
<pre><code class="language-toml">cargo-features = ["path-bases"]

[dependencies]
foo = { base = "dev", path = "foo" }
</code></pre>
<p>Given a <code>[path-bases]</code> table in the configuration that contains:</p>
<pre><code class="language-toml">[path-bases]
dev = "/home/user/dev/rust/libraries/"
</code></pre>
<p>This will produce a <code>path</code> dependency <code>foo</code> located at
<code>/home/user/dev/rust/libraries/foo</code>.</p>
<p>Path bases can be either absolute or relative. Relative path bases are relative
to the parent directory of the configuration file that declared that path base.</p>
<p>The name of a path base must use only <a href="https://doc.rust-lang.org/std/primitive.char.html#method.is_alphanumeric">alphanumeric</a>
characters or <code>-</code> or <code>_</code>, must start with an <a href="https://doc.rust-lang.org/std/primitive.char.html#method.is_alphabetic">alphabetic</a>
character, and must not be empty.</p>
<p>If the name of path base used in a dependency is neither in the configuration
nor one of the built-in path base, then Cargo will raise an error.</p>
<h4 id="built-in-path-bases"><a class="header" href="#built-in-path-bases">Built-in path bases</a></h4>
<p>Cargo provides implicit path bases that can be used without the need to specify
them in a <code>[path-bases]</code> table.</p>
<ul>
<li><code>workspace</code> - If a project is <a href="reference/workspaces.html">a workspace or workspace member</a>
then this path base is defined as the parent directory of the root <code>Cargo.toml</code>
of the workspace.</li>
</ul>
<p>If a built-in path base name is also declared in the configuration, then Cargo
will prefer the value in the configuration. The allows Cargo to add new built-in
path bases without compatibility issues (as existing uses will shadow the
built-in name).</p>
<h2 id="lockfile-path"><a class="header" href="#lockfile-path">lockfile-path</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/5707">#5707</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/14421">#14421</a></li>
</ul>
<p>This feature allows you to specify the path of lockfile Cargo.lock.
By default, lockfile is written into <code>&lt;workspace_root&gt;/Cargo.lock</code>.
However, when sources are stored in read-only directory, most of the cargo commands
would fail, trying to write a lockfile. The <code>--lockfile-path</code>
flag makes it easier to work with readonly sources.
Note, that currently path must end with <code>Cargo.lock</code>. Meaning, if you want to use
this feature in multiple projects, lockfiles should be stored in different directories.
Example:</p>
<pre><code class="language-sh">cargo +nightly metadata --lockfile-path=$LOCKFILES_ROOT/my-project/Cargo.lock -Z unstable-options
</code></pre>
<h2 id="native-completions"><a class="header" href="#native-completions">native-completions</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/6645">#6645</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a></li>
</ul>
<p>This feature moves the handwritten completion scripts to Rust native, making it
easier for us to add, extend and test new completions. This feature is enabled with the
nightly channel, without requiring additional <code>-Z</code> options.</p>
<p>Areas of particular interest for feedback</p>
<ul>
<li>Arguments that need escaping or quoting that aren’t handled correctly</li>
<li>Inaccuracies in the information</li>
<li>Bugs in parsing of the command-line</li>
<li>Arguments that don’t report their completions</li>
<li>If a known issue is being problematic</li>
</ul>
<p>Feedback can be broken down into</p>
<ul>
<li>What completion candidates are reported
<ul>
<li>Known issues: <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a>, <a href="https://github.com/rust-lang/cargo/labels/A-completions"><code>A-completions</code></a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/new">Report an issue</a> or <a href="https://github.com/rust-lang/cargo/issues/14520">discuss the behavior</a></li>
</ul>
</li>
<li>Shell integration, command-line parsing, and completion filtering
<ul>
<li>Known issues: <a href="https://github.com/clap-rs/clap/issues/3166">clap#3166</a>, <a href="https://github.com/clap-rs/clap/labels/A-completion">clap’s <code>A-completions</code></a></li>
<li><a href="https://github.com/clap-rs/clap/issues/new/choose">Report an issue</a> or <a href="https://github.com/clap-rs/clap/discussions/new/choose">discuss the behavior</a></li>
</ul>
</li>
</ul>
<p>When in doubt, you can discuss this in <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a> or on <a href="https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo">zulip</a></p>
<h3 id="how-to-use-native-completions-feature"><a class="header" href="#how-to-use-native-completions-feature">How to use native-completions feature:</a></h3>
<ul>
<li>
<p>bash:
Add <code>source &lt;(CARGO_COMPLETE=bash cargo +nightly)</code> to <code>~/.local/share/bash-completion/completions/cargo</code>.</p>
</li>
<li>
<p>zsh:
Add <code>source &lt;(CARGO_COMPLETE=zsh cargo +nightly)</code> to your <code>.zshrc</code>.</p>
</li>
<li>
<p>fish:
Add <code>source (CARGO_COMPLETE=fish cargo +nightly | psub)</code> to <code>$XDG_CONFIG_HOME/fish/completions/cargo.fish</code></p>
</li>
<li>
<p>elvish:
Add <code>eval (E:CARGO_COMPLETE=elvish cargo +nightly | slurp)</code> to <code>$XDG_CONFIG_HOME/elvish/rc.elv</code></p>
</li>
<li>
<p>powershell:
Add <code>CARGO_COMPLETE=powershell cargo +nightly | Invoke-Expression</code> to <code>$PROFILE</code>.</p>
</li>
</ul>
<h2 id="warnings"><a class="header" href="#warnings">warnings</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/8424">#8424</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/14802">#14802</a></li>
</ul>
<p>The <code>-Z warnings</code> feature enables the <code>build.warnings</code> configuration option to control how
Cargo handles warnings. If the <code>-Z warnings</code> unstable flag is not enabled, then
the <code>build.warnings</code> config will be ignored.</p>
<p>This setting currently only applies to rustc warnings. It may apply to additional warnings (such as Cargo lints or Cargo warnings)
in the future.</p>
<h3 id="buildwarnings"><a class="header" href="#buildwarnings"><code>build.warnings</code></a></h3>
<ul>
<li>Type: string</li>
<li>Default: <code>warn</code></li>
<li>Environment: <code>CARGO_BUILD_WARNINGS</code></li>
</ul>
<p>Controls how Cargo handles warnings. Allowed values are:</p>
<ul>
<li><code>warn</code>: warnings are emitted as warnings (default).</li>
<li><code>allow</code>: warnings are hidden.</li>
<li><code>deny</code>: if warnings are emitted, an error will be raised at the end of the operation and the process will exit with a failure exit code.</li>
</ul>
<h2 id="feature-unification-1"><a class="header" href="#feature-unification-1">feature unification</a></h2>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/3692-feature-unification.md">#3692</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/14774">#14774</a></li>
</ul>
<p>The <code>-Z feature-unification</code> enables the <code>resolver.feature-unification</code>
configuration option to control how features are unified across a workspace.
If the <code>-Z feature-unification</code> unstable flag is not enabled,
then the <code>resolver.feature-unification</code> configuration will be ignored.</p>
<h3 id="resolverfeature-unification"><a class="header" href="#resolverfeature-unification"><code>resolver.feature-unification</code></a></h3>
<ul>
<li>Type: string</li>
<li>Default: <code>"selected"</code></li>
<li>Environment: <code>CARGO_RESOLVER_FEATURE_UNIFICATION</code></li>
</ul>
<p>Specify which packages participate in <a href="reference/../reference/features.html#feature-unification">feature unification</a>.</p>
<ul>
<li><code>selected</code>: Merge dependency features from all packages specified for the current build.</li>
<li><code>workspace</code>: Merge dependency features across all workspace members,
regardless of which packages are specified for the current build.</li>
<li><code>package</code>: Dependency features are considered on a package-by-package basis,
preferring duplicate builds of dependencies when different sets of features are activated by the packages.</li>
</ul>
<h2 id="package-message-format"><a class="header" href="#package-message-format">Package message format</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/11666">#11666</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15353">#15353</a></li>
</ul>
<p>The <code>--message-format</code> flag in <code>cargo package</code> controls the output message format.
Currently, it only works with the <code>--list</code> flag and affects the file listing format,
Requires <code>-Zunstable-options</code>.
See <a href="reference/../commands/cargo-package.html#option-cargo-package---message-format"><code>cargo package --message-format</code></a>
for more information.</p>
<h2 id="rustdoc-depinfo"><a class="header" href="#rustdoc-depinfo">rustdoc depinfo</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/12266">#12266</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15370">#15370</a></li>
</ul>
<p>The <code>-Z rustdoc-depinfo</code> flag leverages rustdoc’s dep-info files to determine
whether documentations are required to re-generate. This can be combined with
<code>-Z checksum-freshness</code> to detect checksum changes rather than file mtime.</p>
<h2 id="no-embed-metadata"><a class="header" href="#no-embed-metadata">no-embed-metadata</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15378">#15378</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15495">#15495</a></li>
</ul>
<p>The default behavior of Rust is to embed crate metadata into <code>rlib</code> and <code>dylib</code> artifacts.
Since Cargo also passes <code>--emit=metadata</code> to these intermediate artifacts to enable pipelined
compilation, this means that a lot of metadata ends up being duplicated on disk, which wastes
disk space in the target directory.</p>
<p>This feature tells Cargo to pass the <code>-Zembed-metadata=no</code> flag to the compiler, which instructs
it not to embed metadata within rlib and dylib artifacts. In this case, the metadata will only
be stored in <code>.rmeta</code> files.</p>
<pre><code class="language-console">cargo +nightly -Zno-embed-metadata build
</code></pre>
<h2 id="unstable-editions"><a class="header" href="#unstable-editions"><code>unstable-editions</code></a></h2>
<p>The <code>unstable-editions</code> value in the <code>cargo-features</code> list allows a <code>Cargo.toml</code> manifest to specify an edition that is not yet stable.</p>
<pre><code class="language-toml">cargo-features = ["unstable-editions"]

[package]
name = "my-package"
edition = "future"
</code></pre>
<p>When new editions are introduced, the <code>unstable-editions</code> feature is required until the edition is stabilized.</p>
<p>The special “future” edition is a home for new features that are under development, and is permanently unstable. The “future” edition also has no new behavior by itself. Each change in the future edition requires an opt-in such as a <code>#![feature(...)]</code> attribute.</p>
<h2 id="fix-edition"><a class="header" href="#fix-edition"><code>fix-edition</code></a></h2>
<p><code>-Zfix-edition</code> is a permanently unstable flag to assist with testing edition migrations, particularly with the use of crater. It only works with the <code>cargo fix</code> subcommand. It takes two different forms:</p>
<ul>
<li><code>-Zfix-edition=start=$INITIAL</code> — This form checks if the current edition is equal to the given number. If not, it exits with success (because we want to ignore older editions). If it is, then it runs the equivalent of <code>cargo check</code>. This is intended to be used with crater’s “start” toolchain to set a baseline for the “before” toolchain.</li>
<li><code>-Zfix-edition=end=$INITIAL,$NEXT</code> — This form checks if the current edition is equal to the given <code>$INITIAL</code> value. If not, it exits with success. If it is, then it performs an edition migration to the edition specified in <code>$NEXT</code>. Afterwards, it will modify <code>Cargo.toml</code> to add the appropriate <code>cargo-features = ["unstable-edition"]</code>, update the <code>edition</code> field, and run the equivalent of <code>cargo check</code> to verify that the migration works on the new edition.</li>
</ul>
<p>For example:</p>
<pre><code class="language-console">cargo +nightly fix -Zfix-edition=end=2024,future
</code></pre>
<h2 id="section-timings"><a class="header" href="#section-timings">section-timings</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15780">#15780</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15817">#15817</a></li>
</ul>
<p>This feature can be used to extend the output of <code>cargo build --timings</code>. It will tell rustc
to produce timings of individual compilation sections, which will be then displayed in the timings
HTML/JSON output.</p>
<pre><code class="language-console">cargo +nightly -Zsection-timings build --timings
</code></pre>
<h2 id="build-analysis"><a class="header" href="#build-analysis">Build analysis</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/rust-project-goals/pull/332">rust-lang/rust-project-goals#332</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15844">#15844</a></li>
</ul>
<p>The <code>-Zbuild-analysis</code> feature records and persists detailed build metrics
(timings, rebuild reasons, etc.) across runs, with new commands to query past builds.</p>
<pre><code class="language-toml"># Example config.toml file.

# Enable the build metric collection
[build.analysis]
enabled = true
</code></pre>
<h2 id="build-dir-new-layout"><a class="header" href="#build-dir-new-layout">build-dir-new-layout</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15010">#15010</a></li>
</ul>
<p>Enables the new build-dir filesystem layout.
This layout change unblocks work towards caching and locking improvements.</p>
<h1 id="stabilized-and-removed-features"><a class="header" href="#stabilized-and-removed-features">Stabilized and removed features</a></h1>
<h2 id="compile-progress"><a class="header" href="#compile-progress">Compile progress</a></h2>
<p>The compile-progress feature has been stabilized in the 1.30 release.
Progress bars are now enabled by default.
See <a href="reference/config.html#termprogresswhen"><code>term.progress</code></a> for more information about
controlling this feature.</p>
<h2 id="edition"><a class="header" href="#edition">Edition</a></h2>
<p>Specifying the <code>edition</code> in <code>Cargo.toml</code> has been stabilized in the 1.31 release.
See <a href="reference/manifest.html#the-edition-field">the edition field</a> for more information
about specifying this field.</p>
<h2 id="rename-dependency"><a class="header" href="#rename-dependency">rename-dependency</a></h2>
<p>Specifying renamed dependencies in <code>Cargo.toml</code> has been stabilized in the 1.31 release.
See <a href="reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">renaming dependencies</a>
for more information about renaming dependencies.</p>
<h2 id="alternate-registries"><a class="header" href="#alternate-registries">Alternate Registries</a></h2>
<p>Support for alternate registries has been stabilized in the 1.34 release.
See the <a href="reference/registries.html">Registries chapter</a> for more information about alternate registries.</p>
<h2 id="offline-mode"><a class="header" href="#offline-mode">Offline Mode</a></h2>
<p>The offline feature has been stabilized in the 1.36 release.
See the <a href="reference/../commands/cargo.html#option-cargo---offline"><code>--offline</code> flag</a> for
more information on using the offline mode.</p>
<h2 id="publish-lockfile"><a class="header" href="#publish-lockfile">publish-lockfile</a></h2>
<p>The <code>publish-lockfile</code> feature has been removed in the 1.37 release.
The <code>Cargo.lock</code> file is always included when a package is published if the
package contains a binary target. <code>cargo install</code> requires the <code>--locked</code> flag
to use the <code>Cargo.lock</code> file.
See <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a> and
<a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> for more information.</p>
<h2 id="default-run"><a class="header" href="#default-run">default-run</a></h2>
<p>The <code>default-run</code> feature has been stabilized in the 1.37 release.
See <a href="reference/manifest.html#the-default-run-field">the <code>default-run</code> field</a> for more
information about specifying the default target to run.</p>
<h2 id="cache-messages"><a class="header" href="#cache-messages">cache-messages</a></h2>
<p>Compiler message caching has been stabilized in the 1.40 release.
Compiler warnings are now cached by default and will be replayed automatically
when re-running Cargo.</p>
<h2 id="install-upgrade"><a class="header" href="#install-upgrade">install-upgrade</a></h2>
<p>The <code>install-upgrade</code> feature has been stabilized in the 1.41 release.
<a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> will now automatically upgrade packages if they appear to be
out-of-date. See the <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> documentation for more information.</p>
<h2 id="profile-overrides"><a class="header" href="#profile-overrides">Profile Overrides</a></h2>
<p>Profile overrides have been stabilized in the 1.41 release.
See <a href="reference/profiles.html#overrides">Profile Overrides</a> for more information on using
overrides.</p>
<h2 id="config-profiles"><a class="header" href="#config-profiles">Config Profiles</a></h2>
<p>Specifying profiles in Cargo config files and environment variables has been
stabilized in the 1.43 release.
See the <a href="reference/config.html#profile">config <code>[profile]</code> table</a> for more information
about specifying <a href="reference/profiles.html">profiles</a> in config files.</p>
<h2 id="crate-versions"><a class="header" href="#crate-versions">crate-versions</a></h2>
<p>The <code>-Z crate-versions</code> flag has been stabilized in the 1.47 release.
The crate version is now automatically included in the
<a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> documentation sidebar.</p>
<h2 id="features-2"><a class="header" href="#features-2">Features</a></h2>
<p>The <code>-Z features</code> flag has been stabilized in the 1.51 release.
See <a href="reference/features.html#feature-resolver-version-2">feature resolver version 2</a>
for more information on using the new feature resolver.</p>
<h2 id="package-features"><a class="header" href="#package-features">package-features</a></h2>
<p>The <code>-Z package-feature