<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A value that is known not to equal zero."><title>NonZero in core::num - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.92.0" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items1.92.0.js"></script><script defer src="../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">NonZero</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../../core/index.html">core</a><span class="version">1.92.0</span></h2></div><div class="version">(ded5c06cf	2025-12-08)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">NonZero</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#layout-1" title="Layout">Layout</a></li><li><a href="#note-on-generic-usage" title="Note on generic usage">Note on generic usage</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.BITS" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-1" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-10" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-11" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-2" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-3" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-4" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-5" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-6" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-7" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-8" title="BITS">BITS</a></li><li><a href="#associatedconstant.BITS-9" title="BITS">BITS</a></li><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-1" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-10" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-11" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-2" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-3" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-4" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-5" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-6" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-7" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-8" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX-9" title="MAX">MAX</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-1" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-10" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-11" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-2" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-3" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-4" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-5" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-6" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-7" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-8" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN-9" title="MIN">MIN</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.abs" title="abs">abs</a></li><li><a href="#method.abs-1" title="abs">abs</a></li><li><a href="#method.abs-2" title="abs">abs</a></li><li><a href="#method.abs-3" title="abs">abs</a></li><li><a href="#method.abs-4" title="abs">abs</a></li><li><a href="#method.abs-5" title="abs">abs</a></li><li><a href="#method.cast_signed" title="cast_signed">cast_signed</a></li><li><a href="#method.cast_signed-1" title="cast_signed">cast_signed</a></li><li><a href="#method.cast_signed-2" title="cast_signed">cast_signed</a></li><li><a href="#method.cast_signed-3" title="cast_signed">cast_signed</a></li><li><a href="#method.cast_signed-4" title="cast_signed">cast_signed</a></li><li><a href="#method.cast_signed-5" title="cast_signed">cast_signed</a></li><li><a href="#method.cast_unsigned" title="cast_unsigned">cast_unsigned</a></li><li><a href="#method.cast_unsigned-1" title="cast_unsigned">cast_unsigned</a></li><li><a href="#method.cast_unsigned-2" title="cast_unsigned">cast_unsigned</a></li><li><a href="#method.cast_unsigned-3" title="cast_unsigned">cast_unsigned</a></li><li><a href="#method.cast_unsigned-4" title="cast_unsigned">cast_unsigned</a></li><li><a href="#method.cast_unsigned-5" title="cast_unsigned">cast_unsigned</a></li><li><a href="#method.checked_abs" title="checked_abs">checked_abs</a></li><li><a href="#method.checked_abs-1" title="checked_abs">checked_abs</a></li><li><a href="#method.checked_abs-2" title="checked_abs">checked_abs</a></li><li><a href="#method.checked_abs-3" title="checked_abs">checked_abs</a></li><li><a href="#method.checked_abs-4" title="checked_abs">checked_abs</a></li><li><a href="#method.checked_abs-5" title="checked_abs">checked_abs</a></li><li><a href="#method.checked_add" title="checked_add">checked_add</a></li><li><a href="#method.checked_add-1" title="checked_add">checked_add</a></li><li><a href="#method.checked_add-2" title="checked_add">checked_add</a></li><li><a href="#method.checked_add-3" title="checked_add">checked_add</a></li><li><a href="#method.checked_add-4" title="checked_add">checked_add</a></li><li><a href="#method.checked_add-5" title="checked_add">checked_add</a></li><li><a href="#method.checked_mul" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-1" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-10" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-11" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-2" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-3" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-4" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-5" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-6" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-7" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-8" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_mul-9" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_neg" title="checked_neg">checked_neg</a></li><li><a href="#method.checked_neg-1" title="checked_neg">checked_neg</a></li><li><a href="#method.checked_neg-2" title="checked_neg">checked_neg</a></li><li><a href="#method.checked_neg-3" title="checked_neg">checked_neg</a></li><li><a href="#method.checked_neg-4" title="checked_neg">checked_neg</a></li><li><a href="#method.checked_neg-5" title="checked_neg">checked_neg</a></li><li><a href="#method.checked_next_power_of_two" title="checked_next_power_of_two">checked_next_power_of_two</a></li><li><a href="#method.checked_next_power_of_two-1" title="checked_next_power_of_two">checked_next_power_of_two</a></li><li><a href="#method.checked_next_power_of_two-2" title="checked_next_power_of_two">checked_next_power_of_two</a></li><li><a href="#method.checked_next_power_of_two-3" title="checked_next_power_of_two">checked_next_power_of_two</a></li><li><a href="#method.checked_next_power_of_two-4" title="checked_next_power_of_two">checked_next_power_of_two</a></li><li><a href="#method.checked_next_power_of_two-5" title="checked_next_power_of_two">checked_next_power_of_two</a></li><li><a href="#method.checked_pow" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-1" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-10" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-11" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-2" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-3" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-4" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-5" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-6" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-7" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-8" title="checked_pow">checked_pow</a></li><li><a href="#method.checked_pow-9" title="checked_pow">checked_pow</a></li><li><a href="#method.count_ones" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-1" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-10" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-11" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-2" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-3" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-4" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-5" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-6" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-7" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-8" title="count_ones">count_ones</a></li><li><a href="#method.count_ones-9" title="count_ones">count_ones</a></li><li><a href="#method.div_ceil" title="div_ceil">div_ceil</a></li><li><a href="#method.div_ceil-1" title="div_ceil">div_ceil</a></li><li><a href="#method.div_ceil-2" title="div_ceil">div_ceil</a></li><li><a href="#method.div_ceil-3" title="div_ceil">div_ceil</a></li><li><a href="#method.div_ceil-4" title="div_ceil">div_ceil</a></li><li><a href="#method.div_ceil-5" title="div_ceil">div_ceil</a></li><li><a href="#method.from_be" title="from_be">from_be</a></li><li><a href="#method.from_be-1" title="from_be">from_be</a></li><li><a href="#method.from_be-10" title="from_be">from_be</a></li><li><a href="#method.from_be-11" title="from_be">from_be</a></li><li><a href="#method.from_be-2" title="from_be">from_be</a></li><li><a href="#method.from_be-3" title="from_be">from_be</a></li><li><a href="#method.from_be-4" title="from_be">from_be</a></li><li><a href="#method.from_be-5" title="from_be">from_be</a></li><li><a href="#method.from_be-6" title="from_be">from_be</a></li><li><a href="#method.from_be-7" title="from_be">from_be</a></li><li><a href="#method.from_be-8" title="from_be">from_be</a></li><li><a href="#method.from_be-9" title="from_be">from_be</a></li><li><a href="#method.from_le" title="from_le">from_le</a></li><li><a href="#method.from_le-1" title="from_le">from_le</a></li><li><a href="#method.from_le-10" title="from_le">from_le</a></li><li><a href="#method.from_le-11" title="from_le">from_le</a></li><li><a href="#method.from_le-2" title="from_le">from_le</a></li><li><a href="#method.from_le-3" title="from_le">from_le</a></li><li><a href="#method.from_le-4" title="from_le">from_le</a></li><li><a href="#method.from_le-5" title="from_le">from_le</a></li><li><a href="#method.from_le-6" title="from_le">from_le</a></li><li><a href="#method.from_le-7" title="from_le">from_le</a></li><li><a href="#method.from_le-8" title="from_le">from_le</a></li><li><a href="#method.from_le-9" title="from_le">from_le</a></li><li><a href="#method.from_mut" title="from_mut">from_mut</a></li><li><a href="#method.from_mut_unchecked" title="from_mut_unchecked">from_mut_unchecked</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.highest_one" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-1" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-10" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-11" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-2" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-3" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-4" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-5" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-6" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-7" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-8" title="highest_one">highest_one</a></li><li><a href="#method.highest_one-9" title="highest_one">highest_one</a></li><li><a href="#method.ilog2" title="ilog2">ilog2</a></li><li><a href="#method.ilog2-1" title="ilog2">ilog2</a></li><li><a href="#method.ilog2-2" title="ilog2">ilog2</a></li><li><a href="#method.ilog2-3" title="ilog2">ilog2</a></li><li><a href="#method.ilog2-4" title="ilog2">ilog2</a></li><li><a href="#method.ilog2-5" title="ilog2">ilog2</a></li><li><a href="#method.ilog10" title="ilog10">ilog10</a></li><li><a href="#method.ilog10-1" title="ilog10">ilog10</a></li><li><a href="#method.ilog10-2" title="ilog10">ilog10</a></li><li><a href="#method.ilog10-3" title="ilog10">ilog10</a></li><li><a href="#method.ilog10-4" title="ilog10">ilog10</a></li><li><a href="#method.ilog10-5" title="ilog10">ilog10</a></li><li><a href="#method.is_negative" title="is_negative">is_negative</a></li><li><a href="#method.is_negative-1" title="is_negative">is_negative</a></li><li><a href="#method.is_negative-2" title="is_negative">is_negative</a></li><li><a href="#method.is_negative-3" title="is_negative">is_negative</a></li><li><a href="#method.is_negative-4" title="is_negative">is_negative</a></li><li><a href="#method.is_negative-5" title="is_negative">is_negative</a></li><li><a href="#method.is_positive" title="is_positive">is_positive</a></li><li><a href="#method.is_positive-1" title="is_positive">is_positive</a></li><li><a href="#method.is_positive-2" title="is_positive">is_positive</a></li><li><a href="#method.is_positive-3" title="is_positive">is_positive</a></li><li><a href="#method.is_positive-4" title="is_positive">is_positive</a></li><li><a href="#method.is_positive-5" title="is_positive">is_positive</a></li><li><a href="#method.is_power_of_two" title="is_power_of_two">is_power_of_two</a></li><li><a href="#method.is_power_of_two-1" title="is_power_of_two">is_power_of_two</a></li><li><a href="#method.is_power_of_two-2" title="is_power_of_two">is_power_of_two</a></li><li><a href="#method.is_power_of_two-3" title="is_power_of_two">is_power_of_two</a></li><li><a href="#method.is_power_of_two-4" title="is_power_of_two">is_power_of_two</a></li><li><a href="#method.is_power_of_two-5" title="is_power_of_two">is_power_of_two</a></li><li><a href="#method.isolate_highest_one" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-1" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-10" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-11" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-2" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-3" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-4" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-5" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-6" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-7" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-8" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_highest_one-9" title="isolate_highest_one">isolate_highest_one</a></li><li><a href="#method.isolate_lowest_one" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-1" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-10" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-11" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-2" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-3" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-4" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-5" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-6" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-7" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-8" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isolate_lowest_one-9" title="isolate_lowest_one">isolate_lowest_one</a></li><li><a href="#method.isqrt" title="isqrt">isqrt</a></li><li><a href="#method.isqrt-1" title="isqrt">isqrt</a></li><li><a href="#method.isqrt-2" title="isqrt">isqrt</a></li><li><a href="#method.isqrt-3" title="isqrt">isqrt</a></li><li><a href="#method.isqrt-4" title="isqrt">isqrt</a></li><li><a href="#method.isqrt-5" title="isqrt">isqrt</a></li><li><a href="#method.leading_zeros" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-1" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-10" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-11" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-2" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-3" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-4" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-5" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-6" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-7" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-8" title="leading_zeros">leading_zeros</a></li><li><a href="#method.leading_zeros-9" title="leading_zeros">leading_zeros</a></li><li><a href="#method.lowest_one" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-1" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-10" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-11" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-2" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-3" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-4" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-5" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-6" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-7" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-8" title="lowest_one">lowest_one</a></li><li><a href="#method.lowest_one-9" title="lowest_one">lowest_one</a></li><li><a href="#method.midpoint" title="midpoint">midpoint</a></li><li><a href="#method.midpoint-1" title="midpoint">midpoint</a></li><li><a href="#method.midpoint-2" title="midpoint">midpoint</a></li><li><a href="#method.midpoint-3" title="midpoint">midpoint</a></li><li><a href="#method.midpoint-4" title="midpoint">midpoint</a></li><li><a href="#method.midpoint-5" title="midpoint">midpoint</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.new_unchecked" title="new_unchecked">new_unchecked</a></li><li><a href="#method.overflowing_abs" title="overflowing_abs">overflowing_abs</a></li><li><a href="#method.overflowing_abs-1" title="overflowing_abs">overflowing_abs</a></li><li><a href="#method.overflowing_abs-2" title="overflowing_abs">overflowing_abs</a></li><li><a href="#method.overflowing_abs-3" title="overflowing_abs">overflowing_abs</a></li><li><a href="#method.overflowing_abs-4" title="overflowing_abs">overflowing_abs</a></li><li><a href="#method.overflowing_abs-5" title="overflowing_abs">overflowing_abs</a></li><li><a href="#method.overflowing_neg" title="overflowing_neg">overflowing_neg</a></li><li><a href="#method.overflowing_neg-1" title="overflowing_neg">overflowing_neg</a></li><li><a href="#method.overflowing_neg-2" title="overflowing_neg">overflowing_neg</a></li><li><a href="#method.overflowing_neg-3" title="overflowing_neg">overflowing_neg</a></li><li><a href="#method.overflowing_neg-4" title="overflowing_neg">overflowing_neg</a></li><li><a href="#method.overflowing_neg-5" title="overflowing_neg">overflowing_neg</a></li><li><a href="#method.reverse_bits" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-1" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-10" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-11" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-2" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-3" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-4" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-5" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-6" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-7" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-8" title="reverse_bits">reverse_bits</a></li><li><a href="#method.reverse_bits-9" title="reverse_bits">reverse_bits</a></li><li><a href="#method.rotate_left" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-1" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-10" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-11" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-2" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-3" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-4" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-5" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-6" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-7" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-8" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_left-9" title="rotate_left">rotate_left</a></li><li><a href="#method.rotate_right" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-1" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-10" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-11" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-2" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-3" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-4" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-5" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-6" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-7" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-8" title="rotate_right">rotate_right</a></li><li><a href="#method.rotate_right-9" title="rotate_right">rotate_right</a></li><li><a href="#method.saturating_abs" title="saturating_abs">saturating_abs</a></li><li><a href="#method.saturating_abs-1" title="saturating_abs">saturating_abs</a></li><li><a href="#method.saturating_abs-2" title="saturating_abs">saturating_abs</a></li><li><a href="#method.saturating_abs-3" title="saturating_abs">saturating_abs</a></li><li><a href="#method.saturating_abs-4" title="saturating_abs">saturating_abs</a></li><li><a href="#method.saturating_abs-5" title="saturating_abs">saturating_abs</a></li><li><a href="#method.saturating_add" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_add-1" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_add-2" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_add-3" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_add-4" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_add-5" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_mul" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-1" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-10" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-11" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-2" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-3" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-4" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-5" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-6" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-7" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-8" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_mul-9" title="saturating_mul">saturating_mul</a></li><li><a href="#method.saturating_neg" title="saturating_neg">saturating_neg</a></li><li><a href="#method.saturating_neg-1" title="saturating_neg">saturating_neg</a></li><li><a href="#method.saturating_neg-2" title="saturating_neg">saturating_neg</a></li><li><a href="#method.saturating_neg-3" title="saturating_neg">saturating_neg</a></li><li><a href="#method.saturating_neg-4" title="saturating_neg">saturating_neg</a></li><li><a href="#method.saturating_neg-5" title="saturating_neg">saturating_neg</a></li><li><a href="#method.saturating_pow" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-1" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-10" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-11" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-2" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-3" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-4" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-5" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-6" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-7" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-8" title="saturating_pow">saturating_pow</a></li><li><a href="#method.saturating_pow-9" title="saturating_pow">saturating_pow</a></li><li><a href="#method.swap_bytes" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-1" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-10" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-11" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-2" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-3" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-4" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-5" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-6" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-7" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-8" title="swap_bytes">swap_bytes</a></li><li><a href="#method.swap_bytes-9" title="swap_bytes">swap_bytes</a></li><li><a href="#method.to_be" title="to_be">to_be</a></li><li><a href="#method.to_be-1" title="to_be">to_be</a></li><li><a href="#method.to_be-10" title="to_be">to_be</a></li><li><a href="#method.to_be-11" title="to_be">to_be</a></li><li><a href="#method.to_be-2" title="to_be">to_be</a></li><li><a href="#method.to_be-3" title="to_be">to_be</a></li><li><a href="#method.to_be-4" title="to_be">to_be</a></li><li><a href="#method.to_be-5" title="to_be">to_be</a></li><li><a href="#method.to_be-6" title="to_be">to_be</a></li><li><a href="#method.to_be-7" title="to_be">to_be</a></li><li><a href="#method.to_be-8" title="to_be">to_be</a></li><li><a href="#method.to_be-9" title="to_be">to_be</a></li><li><a href="#method.to_le" title="to_le">to_le</a></li><li><a href="#method.to_le-1" title="to_le">to_le</a></li><li><a href="#method.to_le-10" title="to_le">to_le</a></li><li><a href="#method.to_le-11" title="to_le">to_le</a></li><li><a href="#method.to_le-2" title="to_le">to_le</a></li><li><a href="#method.to_le-3" title="to_le">to_le</a></li><li><a href="#method.to_le-4" title="to_le">to_le</a></li><li><a href="#method.to_le-5" title="to_le">to_le</a></li><li><a href="#method.to_le-6" title="to_le">to_le</a></li><li><a href="#method.to_le-7" title="to_le">to_le</a></li><li><a href="#method.to_le-8" title="to_le">to_le</a></li><li><a href="#method.to_le-9" title="to_le">to_le</a></li><li><a href="#method.trailing_zeros" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-1" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-10" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-11" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-2" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-3" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-4" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-5" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-6" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-7" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-8" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.trailing_zeros-9" title="trailing_zeros">trailing_zeros</a></li><li><a href="#method.unchecked_add" title="unchecked_add">unchecked_add</a></li><li><a href="#method.unchecked_add-1" title="unchecked_add">unchecked_add</a></li><li><a href="#method.unchecked_add-2" title="unchecked_add">unchecked_add</a></li><li><a href="#method.unchecked_add-3" title="unchecked_add">unchecked_add</a></li><li><a href="#method.unchecked_add-4" title="unchecked_add">unchecked_add</a></li><li><a href="#method.unchecked_add-5" title="unchecked_add">unchecked_add</a></li><li><a href="#method.unchecked_mul" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-1" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-10" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-11" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-2" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-3" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-4" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-5" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-6" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-7" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-8" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unchecked_mul-9" title="unchecked_mul">unchecked_mul</a></li><li><a href="#method.unsigned_abs" title="unsigned_abs">unsigned_abs</a></li><li><a href="#method.unsigned_abs-1" title="unsigned_abs">unsigned_abs</a></li><li><a href="#method.unsigned_abs-2" title="unsigned_abs">unsigned_abs</a></li><li><a href="#method.unsigned_abs-3" title="unsigned_abs">unsigned_abs</a></li><li><a href="#method.unsigned_abs-4" title="unsigned_abs">unsigned_abs</a></li><li><a href="#method.unsigned_abs-5" title="unsigned_abs">unsigned_abs</a></li><li><a href="#method.wrapping_abs" title="wrapping_abs">wrapping_abs</a></li><li><a href="#method.wrapping_abs-1" title="wrapping_abs">wrapping_abs</a></li><li><a href="#method.wrapping_abs-2" title="wrapping_abs">wrapping_abs</a></li><li><a href="#method.wrapping_abs-3" title="wrapping_abs">wrapping_abs</a></li><li><a href="#method.wrapping_abs-4" title="wrapping_abs">wrapping_abs</a></li><li><a href="#method.wrapping_abs-5" title="wrapping_abs">wrapping_abs</a></li><li><a href="#method.wrapping_neg" title="wrapping_neg">wrapping_neg</a></li><li><a href="#method.wrapping_neg-1" title="wrapping_neg">wrapping_neg</a></li><li><a href="#method.wrapping_neg-2" title="wrapping_neg">wrapping_neg</a></li><li><a href="#method.wrapping_neg-3" title="wrapping_neg">wrapping_neg</a></li><li><a href="#method.wrapping_neg-4" title="wrapping_neg">wrapping_neg</a></li><li><a href="#method.wrapping_neg-5" title="wrapping_neg">wrapping_neg</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Binary-for-NonZero%3CT%3E" title="Binary">Binary</a></li><li><a href="#impl-BitOr-for-NonZero%3CT%3E" title="BitOr">BitOr</a></li><li><a href="#impl-BitOr%3CT%3E-for-NonZero%3CT%3E" title="BitOr&#60;T&#62;">BitOr&#60;T&#62;</a></li><li><a href="#impl-BitOrAssign-for-NonZero%3CT%3E" title="BitOrAssign">BitOrAssign</a></li><li><a href="#impl-BitOrAssign%3CT%3E-for-NonZero%3CT%3E" title="BitOrAssign&#60;T&#62;">BitOrAssign&#60;T&#62;</a></li><li><a href="#impl-Clone-for-NonZero%3CT%3E" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-NonZero%3CT%3E" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-NonZero%3CT%3E" title="Debug">Debug</a></li><li><a href="#impl-Display-for-NonZero%3CT%3E" title="Display">Display</a></li><li><a href="#impl-Div%3CNonZero%3Cu8%3E%3E-for-u8" title="Div&#60;NonZero&#60;u8&#62;&#62;">Div&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-Div%3CNonZero%3Cu16%3E%3E-for-u16" title="Div&#60;NonZero&#60;u16&#62;&#62;">Div&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-Div%3CNonZero%3Cu32%3E%3E-for-u32" title="Div&#60;NonZero&#60;u32&#62;&#62;">Div&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-Div%3CNonZero%3Cu64%3E%3E-for-u64" title="Div&#60;NonZero&#60;u64&#62;&#62;">Div&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-Div%3CNonZero%3Cu128%3E%3E-for-u128" title="Div&#60;NonZero&#60;u128&#62;&#62;">Div&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-Div%3CNonZero%3Cusize%3E%3E-for-usize" title="Div&#60;NonZero&#60;usize&#62;&#62;">Div&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-DivAssign%3CNonZero%3Cu8%3E%3E-for-u8" title="DivAssign&#60;NonZero&#60;u8&#62;&#62;">DivAssign&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-DivAssign%3CNonZero%3Cu16%3E%3E-for-u16" title="DivAssign&#60;NonZero&#60;u16&#62;&#62;">DivAssign&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-DivAssign%3CNonZero%3Cu32%3E%3E-for-u32" title="DivAssign&#60;NonZero&#60;u32&#62;&#62;">DivAssign&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-DivAssign%3CNonZero%3Cu64%3E%3E-for-u64" title="DivAssign&#60;NonZero&#60;u64&#62;&#62;">DivAssign&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-DivAssign%3CNonZero%3Cu128%3E%3E-for-u128" title="DivAssign&#60;NonZero&#60;u128&#62;&#62;">DivAssign&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-DivAssign%3CNonZero%3Cusize%3E%3E-for-usize" title="DivAssign&#60;NonZero&#60;usize&#62;&#62;">DivAssign&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-Eq-for-NonZero%3CT%3E" title="Eq">Eq</a></li><li><a href="#impl-Freeze-for-NonZero%3CT%3E" title="Freeze">Freeze</a></li><li><a href="#impl-From%3CAlignment%3E-for-NonZero%3Cusize%3E" title="From&#60;Alignment&#62;">From&#60;Alignment&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci8%3E%3E-for-NonZero%3Ci128%3E" title="From&#60;NonZero&#60;i8&#62;&#62;">From&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci8%3E%3E-for-NonZero%3Ci16%3E" title="From&#60;NonZero&#60;i8&#62;&#62;">From&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci8%3E%3E-for-NonZero%3Ci32%3E" title="From&#60;NonZero&#60;i8&#62;&#62;">From&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci8%3E%3E-for-NonZero%3Ci64%3E" title="From&#60;NonZero&#60;i8&#62;&#62;">From&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci8%3E%3E-for-NonZero%3Cisize%3E" title="From&#60;NonZero&#60;i8&#62;&#62;">From&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci16%3E%3E-for-NonZero%3Ci128%3E" title="From&#60;NonZero&#60;i16&#62;&#62;">From&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci16%3E%3E-for-NonZero%3Ci32%3E" title="From&#60;NonZero&#60;i16&#62;&#62;">From&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci16%3E%3E-for-NonZero%3Ci64%3E" title="From&#60;NonZero&#60;i16&#62;&#62;">From&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci16%3E%3E-for-NonZero%3Cisize%3E" title="From&#60;NonZero&#60;i16&#62;&#62;">From&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci32%3E%3E-for-NonZero%3Ci128%3E" title="From&#60;NonZero&#60;i32&#62;&#62;">From&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci32%3E%3E-for-NonZero%3Ci64%3E" title="From&#60;NonZero&#60;i32&#62;&#62;">From&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Ci64%3E%3E-for-NonZero%3Ci128%3E" title="From&#60;NonZero&#60;i64&#62;&#62;">From&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Ci128%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Ci16%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Ci32%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Ci64%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Cisize%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Cu128%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Cu16%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Cu32%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Cu64%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu8%3E%3E-for-NonZero%3Cusize%3E" title="From&#60;NonZero&#60;u8&#62;&#62;">From&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu16%3E%3E-for-NonZero%3Ci128%3E" title="From&#60;NonZero&#60;u16&#62;&#62;">From&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu16%3E%3E-for-NonZero%3Ci32%3E" title="From&#60;NonZero&#60;u16&#62;&#62;">From&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu16%3E%3E-for-NonZero%3Ci64%3E" title="From&#60;NonZero&#60;u16&#62;&#62;">From&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu16%3E%3E-for-NonZero%3Cu128%3E" title="From&#60;NonZero&#60;u16&#62;&#62;">From&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu16%3E%3E-for-NonZero%3Cu32%3E" title="From&#60;NonZero&#60;u16&#62;&#62;">From&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu16%3E%3E-for-NonZero%3Cu64%3E" title="From&#60;NonZero&#60;u16&#62;&#62;">From&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu16%3E%3E-for-NonZero%3Cusize%3E" title="From&#60;NonZero&#60;u16&#62;&#62;">From&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu32%3E%3E-for-NonZero%3Ci128%3E" title="From&#60;NonZero&#60;u32&#62;&#62;">From&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu32%3E%3E-for-NonZero%3Ci64%3E" title="From&#60;NonZero&#60;u32&#62;&#62;">From&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu32%3E%3E-for-NonZero%3Cu128%3E" title="From&#60;NonZero&#60;u32&#62;&#62;">From&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu32%3E%3E-for-NonZero%3Cu64%3E" title="From&#60;NonZero&#60;u32&#62;&#62;">From&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu64%3E%3E-for-NonZero%3Ci128%3E" title="From&#60;NonZero&#60;u64&#62;&#62;">From&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-From%3CNonZero%3Cu64%3E%3E-for-NonZero%3Cu128%3E" title="From&#60;NonZero&#60;u64&#62;&#62;">From&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-FromStr-for-NonZero%3Ci128%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Ci16%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Ci32%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Ci64%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Ci8%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Cisize%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Cu128%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Cu16%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Cu32%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Cu64%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Cu8%3E" title="FromStr">FromStr</a></li><li><a href="#impl-FromStr-for-NonZero%3Cusize%3E" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-NonZero%3CT%3E" title="Hash">Hash</a></li><li><a href="#impl-LowerExp-for-NonZero%3CT%3E" title="LowerExp">LowerExp</a></li><li><a href="#impl-LowerHex-for-NonZero%3CT%3E" title="LowerHex">LowerHex</a></li><li><a href="#impl-Neg-for-%26NonZero%3Ci128%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-%26NonZero%3Ci16%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-%26NonZero%3Ci32%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-%26NonZero%3Ci64%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-%26NonZero%3Ci8%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-%26NonZero%3Cisize%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-NonZero%3Ci128%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-NonZero%3Ci16%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-NonZero%3Ci32%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-NonZero%3Ci64%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-NonZero%3Ci8%3E" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-NonZero%3Cisize%3E" title="Neg">Neg</a></li><li><a href="#impl-Octal-for-NonZero%3CT%3E" title="Octal">Octal</a></li><li><a href="#impl-Ord-for-NonZero%3CT%3E" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-NonZero%3CT%3E" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-NonZero%3CT%3E" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-RefUnwindSafe-for-NonZero%3CT%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Rem%3CNonZero%3Cu8%3E%3E-for-u8" title="Rem&#60;NonZero&#60;u8&#62;&#62;">Rem&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-Rem%3CNonZero%3Cu16%3E%3E-for-u16" title="Rem&#60;NonZero&#60;u16&#62;&#62;">Rem&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-Rem%3CNonZero%3Cu32%3E%3E-for-u32" title="Rem&#60;NonZero&#60;u32&#62;&#62;">Rem&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-Rem%3CNonZero%3Cu64%3E%3E-for-u64" title="Rem&#60;NonZero&#60;u64&#62;&#62;">Rem&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-Rem%3CNonZero%3Cu128%3E%3E-for-u128" title="Rem&#60;NonZero&#60;u128&#62;&#62;">Rem&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-Rem%3CNonZero%3Cusize%3E%3E-for-usize" title="Rem&#60;NonZero&#60;usize&#62;&#62;">Rem&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-RemAssign%3CNonZero%3Cu8%3E%3E-for-u8" title="RemAssign&#60;NonZero&#60;u8&#62;&#62;">RemAssign&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-RemAssign%3CNonZero%3Cu16%3E%3E-for-u16" title="RemAssign&#60;NonZero&#60;u16&#62;&#62;">RemAssign&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-RemAssign%3CNonZero%3Cu32%3E%3E-for-u32" title="RemAssign&#60;NonZero&#60;u32&#62;&#62;">RemAssign&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-RemAssign%3CNonZero%3Cu64%3E%3E-for-u64" title="RemAssign&#60;NonZero&#60;u64&#62;&#62;">RemAssign&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-RemAssign%3CNonZero%3Cu128%3E%3E-for-u128" title="RemAssign&#60;NonZero&#60;u128&#62;&#62;">RemAssign&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-RemAssign%3CNonZero%3Cusize%3E%3E-for-usize" title="RemAssign&#60;NonZero&#60;usize&#62;&#62;">RemAssign&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-Send-for-NonZero%3CT%3E" title="Send">Send</a></li><li><a href="#impl-StructuralPartialEq-for-NonZero%3CT%3E" title="StructuralPartialEq">StructuralPartialEq</a></li><li><a href="#impl-Sync-for-NonZero%3CT%3E" title="Sync">Sync</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci8%3E%3E-for-NonZero%3Cu128%3E" title="TryFrom&#60;NonZero&#60;i8&#62;&#62;">TryFrom&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci8%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;i8&#62;&#62;">TryFrom&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci8%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;i8&#62;&#62;">TryFrom&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci8%3E%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;NonZero&#60;i8&#62;&#62;">TryFrom&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci8%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;i8&#62;&#62;">TryFrom&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci8%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;i8&#62;&#62;">TryFrom&#60;NonZero&#60;i8&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci16%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;i16&#62;&#62;">TryFrom&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci16%3E%3E-for-NonZero%3Cu128%3E" title="TryFrom&#60;NonZero&#60;i16&#62;&#62;">TryFrom&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci16%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;i16&#62;&#62;">TryFrom&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci16%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;i16&#62;&#62;">TryFrom&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci16%3E%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;NonZero&#60;i16&#62;&#62;">TryFrom&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci16%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;i16&#62;&#62;">TryFrom&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci16%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;i16&#62;&#62;">TryFrom&#60;NonZero&#60;i16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Cu128%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci32%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;i32&#62;&#62;">TryFrom&#60;NonZero&#60;i32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Ci32%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Cu128%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci64%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;i64&#62;&#62;">TryFrom&#60;NonZero&#60;i64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Ci32%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Ci64%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Cu128%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Ci128%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;i128&#62;&#62;">TryFrom&#60;NonZero&#60;i128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Ci128%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Ci32%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Ci64%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Cu128%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cisize%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;isize&#62;&#62;">TryFrom&#60;NonZero&#60;isize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu8%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;u8&#62;&#62;">TryFrom&#60;NonZero&#60;u8&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu16%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;u16&#62;&#62;">TryFrom&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu16%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;u16&#62;&#62;">TryFrom&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu16%3E%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;NonZero&#60;u16&#62;&#62;">TryFrom&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu16%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;u16&#62;&#62;">TryFrom&#60;NonZero&#60;u16&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu32%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;u32&#62;&#62;">TryFrom&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu32%3E%3E-for-NonZero%3Ci32%3E" title="TryFrom&#60;NonZero&#60;u32&#62;&#62;">TryFrom&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu32%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;u32&#62;&#62;">TryFrom&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu32%3E%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;NonZero&#60;u32&#62;&#62;">TryFrom&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu32%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;u32&#62;&#62;">TryFrom&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu32%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;u32&#62;&#62;">TryFrom&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu32%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;u32&#62;&#62;">TryFrom&#60;NonZero&#60;u32&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Ci32%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Ci64%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu64%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;u64&#62;&#62;">TryFrom&#60;NonZero&#60;u64&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Ci128%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Ci32%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Ci64%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cu128%3E%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;NonZero&#60;u128&#62;&#62;">TryFrom&#60;NonZero&#60;u128&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-Alignment" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Ci128%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Ci32%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Ci64%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Cu128%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3CNonZero%3Cusize%3E%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;NonZero&#60;usize&#62;&#62;">TryFrom&#60;NonZero&#60;usize&#62;&#62;</a></li><li><a href="#impl-TryFrom%3Ci8%3E-for-NonZero%3Ci8%3E" title="TryFrom&#60;i8&#62;">TryFrom&#60;i8&#62;</a></li><li><a href="#impl-TryFrom%3Ci16%3E-for-NonZero%3Ci16%3E" title="TryFrom&#60;i16&#62;">TryFrom&#60;i16&#62;</a></li><li><a href="#impl-TryFrom%3Ci32%3E-for-NonZero%3Ci32%3E" title="TryFrom&#60;i32&#62;">TryFrom&#60;i32&#62;</a></li><li><a href="#impl-TryFrom%3Ci64%3E-for-NonZero%3Ci64%3E" title="TryFrom&#60;i64&#62;">TryFrom&#60;i64&#62;</a></li><li><a href="#impl-TryFrom%3Ci128%3E-for-NonZero%3Ci128%3E" title="TryFrom&#60;i128&#62;">TryFrom&#60;i128&#62;</a></li><li><a href="#impl-TryFrom%3Cisize%3E-for-NonZero%3Cisize%3E" title="TryFrom&#60;isize&#62;">TryFrom&#60;isize&#62;</a></li><li><a href="#impl-TryFrom%3Cu8%3E-for-NonZero%3Cu8%3E" title="TryFrom&#60;u8&#62;">TryFrom&#60;u8&#62;</a></li><li><a href="#impl-TryFrom%3Cu16%3E-for-NonZero%3Cu16%3E" title="TryFrom&#60;u16&#62;">TryFrom&#60;u16&#62;</a></li><li><a href="#impl-TryFrom%3Cu32%3E-for-NonZero%3Cu32%3E" title="TryFrom&#60;u32&#62;">TryFrom&#60;u32&#62;</a></li><li><a href="#impl-TryFrom%3Cu64%3E-for-NonZero%3Cu64%3E" title="TryFrom&#60;u64&#62;">TryFrom&#60;u64&#62;</a></li><li><a href="#impl-TryFrom%3Cu128%3E-for-NonZero%3Cu128%3E" title="TryFrom&#60;u128&#62;">TryFrom&#60;u128&#62;</a></li><li><a href="#impl-TryFrom%3Cusize%3E-for-NonZero%3Cusize%3E" title="TryFrom&#60;usize&#62;">TryFrom&#60;usize&#62;</a></li><li><a href="#impl-Unpin-for-NonZero%3CT%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-NonZero%3CT%3E" title="UnwindSafe">UnwindSafe</a></li><li><a href="#impl-UpperExp-for-NonZero%3CT%3E" title="UpperExp">UpperExp</a></li><li><a href="#impl-UpperHex-for-NonZero%3CT%3E" title="UpperHex">UpperHex</a></li><li><a href="#impl-UseCloned-for-NonZero%3CT%3E" title="UseCloned">UseCloned</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-BitOr%3CNonZero%3CT%3E%3E-for-T" title="BitOr&#60;NonZero&#60;T&#62;&#62;">BitOr&#60;NonZero&#60;T&#62;&#62;</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CNonZero%3CT%3E%3E-for-T" title="From&#60;NonZero&#60;T&#62;&#62;">From&#60;NonZero&#60;T&#62;&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In core::<wbr>num</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">core</a>::<wbr><a href="index.html">num</a></div><h1>Struct <span class="struct">NonZero</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.79.0">1.79.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#127">Source</a> </span></div><pre class="rust item-decl"><code>pub struct NonZero&lt;T: <a class="trait" href="trait.ZeroablePrimitive.html" title="trait core::num::ZeroablePrimitive">ZeroablePrimitive</a>&gt;(<span class="comment">/* private fields */</span>);</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A value that is known not to equal zero.</p>
<p>This enables some memory layout optimization.
For example, <code>Option&lt;NonZero&lt;u32&gt;&gt;</code> is the same size as <code>u32</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::{num::NonZero};

<span class="macro">assert_eq!</span>(size_of::&lt;<span class="prelude-ty">Option</span>&lt;NonZero&lt;u32&gt;&gt;&gt;(), size_of::&lt;u32&gt;());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Afn+main()+%7B%0A++++use+core::%7Bnum::NonZero%7D;%0A++++%0A++++assert_eq!(size_of::%3COption%3CNonZero%3Cu32%3E%3E%3E(),+size_of::%3Cu32%3E());%0A%7D&amp;edition=2024"></a></div><h2 id="layout-1"><a class="doc-anchor" href="#layout-1"></a>Layout</h2>
<p><code>NonZero&lt;T&gt;</code> is guaranteed to have the same layout and bit validity as <code>T</code>
with the exception that the all-zero bit pattern is invalid.
<code>Option&lt;NonZero&lt;T&gt;&gt;</code> is guaranteed to be compatible with <code>T</code>, including in
FFI.</p>
<p>Thanks to the <a href="../option/index.html#representation" title="mod core::option">null pointer optimization</a>, <code>NonZero&lt;T&gt;</code> and
<code>Option&lt;NonZero&lt;T&gt;&gt;</code> are guaranteed to have the same size and alignment:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::num::NonZero;

<span class="macro">assert_eq!</span>(size_of::&lt;NonZero&lt;u32&gt;&gt;(), size_of::&lt;<span class="prelude-ty">Option</span>&lt;NonZero&lt;u32&gt;&gt;&gt;());
<span class="macro">assert_eq!</span>(align_of::&lt;NonZero&lt;u32&gt;&gt;(), align_of::&lt;<span class="prelude-ty">Option</span>&lt;NonZero&lt;u32&gt;&gt;&gt;());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(size_of::%3CNonZero%3Cu32%3E%3E(),+size_of::%3COption%3CNonZero%3Cu32%3E%3E%3E());%0A++++assert_eq!(align_of::%3CNonZero%3Cu32%3E%3E(),+align_of::%3COption%3CNonZero%3Cu32%3E%3E%3E());%0A%7D&amp;edition=2024"></a></div><h2 id="note-on-generic-usage"><a class="doc-anchor" href="#note-on-generic-usage"></a>Note on generic usage</h2>
<p><code>NonZero&lt;T&gt;</code> can only be used with some standard library primitive types
(such as <code>u8</code>, <code>i32</code>, and etc.). The type parameter <code>T</code> must implement the
internal trait <a href="trait.ZeroablePrimitive.html" title="trait core::num::ZeroablePrimitive"><code>ZeroablePrimitive</code></a>, which is currently permanently unstable
and cannot be implemented by users. Therefore, you cannot use <code>NonZero&lt;T&gt;</code>
with your own types, nor can you implement traits for all <code>NonZero&lt;T&gt;</code>,
only for concrete types.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-NonZero%3CT%3E" class="impl"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#388-497">Source</a><a href="#impl-NonZero%3CT%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.ZeroablePrimitive.html" title="trait core::num::ZeroablePrimitive">ZeroablePrimitive</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0, const since 1.47.0">1.28.0 (const: 1.47.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#397-401">Source</a></span><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(n: T) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Creates a non-zero if the given value is not zero.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0, const since 1.28.0">1.28.0 (const: 1.28.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#414-429">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.new_unchecked" class="fn">new_unchecked</a>(n: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a non-zero without checking whether the value is non-zero.
This results in undefined behavior if the value is zero.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety"></a>Safety</h5>
<p>The value must not be zero.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_mut" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#436-442">Source</a><h4 class="code-header">pub fn <a href="#method.from_mut" class="fn">from_mut</a>(n: <a class="primitive" href="../primitive.reference.html">&amp;mut T</a>) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_from_mut</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/106290">#106290</a>)</span></div></span></summary><div class="docblock"><p>Converts a reference to a non-zero mutable reference
if the referenced value is not zero.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_mut_unchecked" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#455-470">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_mut_unchecked" class="fn">from_mut_unchecked</a>(n: <a class="primitive" href="../primitive.reference.html">&amp;mut T</a>) -&gt; &amp;mut Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_from_mut</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/106290">#106290</a>)</span></div></span></summary><div class="docblock"><p>Converts a mutable reference to a non-zero mutable reference
without checking whether the referenced value is non-zero.
This results in undefined behavior if the referenced value is zero.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1"></a>Safety</h5>
<p>The referenced value must not be zero.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0, const since 1.34.0">1.28.0 (const: 1.34.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#476-496">Source</a></span><h4 class="code-header">pub const fn <a href="#method.get" class="fn">get</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the contained value as a primitive type.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NonZero%3Cu8%3E" class="impl"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><a href="#impl-NonZero%3Cu8%3E" class="anchor"></a><h3 class="code-header">impl <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.BITS" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0">1.67.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.BITS" class="constant">BITS</a>: <a class="primitive" href="../primitive.u32.html">u32</a> = 8u32</h4></section></summary><div class="docblock"><p>The size of this non-zero integer type in bits.</p>
<p>This value is equal to <a href="../primitive.u8.html#associatedconstant.BITS" title="associated constant u8::BITS"><code>u8::BITS</code></a>.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::BITS, u8::BITS);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu8%3E::BITS,+u8::BITS);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: Self</h4></section></summary><div class="docblock"><p>The smallest value that can be represented by this non-zero
integer type, 1.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::MIN.get(), <span class="number">1u8</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu8%3E::MIN.get(),+1u8);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: Self</h4></section></summary><div class="docblock"><p>The largest value that can be represented by this non-zero
integer type,
equal to <a href="../primitive.u8.html#associatedconstant.MAX" title="associated constant u8::MAX"><code>u8::MAX</code></a>.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::MAX.get(), u8::MAX);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu8%3E::MAX.get(),+u8::MAX);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.leading_zeros" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0, const since 1.53.0">1.53.0 (const: 1.53.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.leading_zeros" class="fn">leading_zeros</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the number of leading zeros in the binary representation of <code>self</code>.</p>
<p>On many architectures, this function can perform better than <code>leading_zeros()</code> on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>n = NonZero::&lt;u8&gt;::new(u8::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.leading_zeros(), <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::%3Cu8%3E::new(u8::MAX)?;%0A%0Aassert_eq!(n.leading_zeros(),+0);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trailing_zeros" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0, const since 1.53.0">1.53.0 (const: 1.53.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.trailing_zeros" class="fn">trailing_zeros</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the number of trailing zeros in the binary representation
of <code>self</code>.</p>
<p>On many architectures, this function can perform better than <code>trailing_zeros()</code> on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>n = NonZero::&lt;u8&gt;::new(<span class="number">0b0101000</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.trailing_zeros(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::%3Cu8%3E::new(0b0101000)?;%0A%0Aassert_eq!(n.trailing_zeros(),+3);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isolate_highest_one" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.isolate_highest_one" class="fn">isolate_highest_one</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>isolate_most_least_significant_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136909">#136909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with only the most significant bit set.</p>
<h5 id="example"><a class="doc-anchor" href="#example"></a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(isolate_most_least_significant_one)]

</span><span class="kw">let </span>a = NonZero::&lt;u8&gt;::new(<span class="number">0b_01100100</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u8&gt;::new(<span class="number">0b_01000000</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.isolate_highest_one(), b);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(isolate_most_least_significant_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu8%3E::new(0b_01100100)?;%0Alet+b+=+NonZero::%3Cu8%3E::new(0b_01000000)?;%0A%0Aassert_eq!(a.isolate_highest_one(),+b);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isolate_lowest_one" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.isolate_lowest_one" class="fn">isolate_lowest_one</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>isolate_most_least_significant_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136909">#136909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with only the least significant bit set.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1"></a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(isolate_most_least_significant_one)]

</span><span class="kw">let </span>a = NonZero::&lt;u8&gt;::new(<span class="number">0b_01100100</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u8&gt;::new(<span class="number">0b_00000100</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.isolate_lowest_one(), b);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(isolate_most_least_significant_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu8%3E::new(0b_01100100)?;%0Alet+b+=+NonZero::%3Cu8%3E::new(0b_00000100)?;%0A%0Aassert_eq!(a.isolate_lowest_one(),+b);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.highest_one" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.highest_one" class="fn">highest_one</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>int_lowest_highest_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145203">#145203</a>)</span></div></span></summary><div class="docblock"><p>Returns the index of the highest bit set to one in <code>self</code>.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(int_lowest_highest_one)]

</span><span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::new(<span class="number">0x1</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::new(<span class="number">0x10</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::new(<span class="number">0x1f</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(int_lowest_highest_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::%3Cu8%3E::new(0x1)?.highest_one(),+0);%0Aassert_eq!(NonZero::%3Cu8%3E::new(0x10)?.highest_one(),+4);%0Aassert_eq!(NonZero::%3Cu8%3E::new(0x1f)?.highest_one(),+4);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.lowest_one" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.lowest_one" class="fn">lowest_one</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>int_lowest_highest_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145203">#145203</a>)</span></div></span></summary><div class="docblock"><p>Returns the index of the lowest bit set to one in <code>self</code>.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(int_lowest_highest_one)]

</span><span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::new(<span class="number">0x1</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::new(<span class="number">0x10</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u8&gt;::new(<span class="number">0x1f</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(int_lowest_highest_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::%3Cu8%3E::new(0x1)?.lowest_one(),+0);%0Aassert_eq!(NonZero::%3Cu8%3E::new(0x10)?.lowest_one(),+4);%0Aassert_eq!(NonZero::%3Cu8%3E::new(0x1f)?.lowest_one(),+0);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.count_ones" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.86.0, const since 1.86.0">1.86.0 (const: 1.86.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.count_ones" class="fn">count_ones</a>(self) -&gt; <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.u32.html">u32</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the number of ones in the binary representation of <code>self</code>.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = NonZero::&lt;u8&gt;::new(<span class="number">0b100_0000</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u8&gt;::new(<span class="number">0b100_0011</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.count_ones(), NonZero::new(<span class="number">1</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(b.count_ones(), NonZero::new(<span class="number">3</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu8%3E::new(0b100_0000)?;%0Alet+b+=+NonZero::%3Cu8%3E::new(0b100_0011)?;%0A%0Aassert_eq!(a.count_ones(),+NonZero::new(1)?);%0Aassert_eq!(b.count_ones(),+NonZero::new(3)?);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_left" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.rotate_left" class="fn">rotate_left</a>(self, n: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Shifts the bits to the left by a specified amount, <code>n</code>,
wrapping the truncated bits to the end of the resulting integer.</p>
<p>Please note this isnt the same operation as the <code>&lt;&lt;</code> shifting operator!</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x82u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = NonZero::new(<span class="number">0xa</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.rotate_left(<span class="number">2</span>), m);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x82u8)?;%0Alet+m+=+NonZero::new(0xa)?;%0A%0Aassert_eq!(n.rotate_left(2),+m);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_right" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.rotate_right" class="fn">rotate_right</a>(self, n: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Shifts the bits to the right by a specified amount, <code>n</code>,
wrapping the truncated bits to the beginning of the resulting
integer.</p>
<p>Please note this isnt the same operation as the <code>&gt;&gt;</code> shifting operator!</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0xau8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = NonZero::new(<span class="number">0x82</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.rotate_right(<span class="number">2</span>), m);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0xau8)?;%0Alet+m+=+NonZero::new(0x82)?;%0A%0Aassert_eq!(n.rotate_right(2),+m);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.swap_bytes" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.swap_bytes" class="fn">swap_bytes</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Reverses the byte order of the integer.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x12u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = n.swap_bytes();

<span class="macro">assert_eq!</span>(m, NonZero::new(<span class="number">0x12</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x12u8)?;%0Alet+m+=+n.swap_bytes();%0A%0Aassert_eq!(m,+NonZero::new(0x12)?);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reverse_bits" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.reverse_bits" class="fn">reverse_bits</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,
second least-significant bit becomes second most-significant bit, etc.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x12u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = n.reverse_bits();

<span class="macro">assert_eq!</span>(m, NonZero::new(<span class="number">0x48</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x12u8)?;%0Alet+m+=+n.reverse_bits();%0A%0Aassert_eq!(m,+NonZero::new(0x48)?);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_be" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.from_be" class="fn">from_be</a>(x: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts an integer from big endian to the targets endianness.</p>
<p>On big endian this is a no-op. On little endian the bytes are
swapped.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">use </span>std::num::NonZeroU8;
<span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au8</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
    <span class="macro">assert_eq!</span>(NonZeroU8::from_be(n), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(NonZeroU8::from_be(n), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0Ause+std::num::NonZeroU8;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au8)?;%0A%0Aif+cfg!(target_endian+=+%22big%22)+%7B%0A++++assert_eq!(NonZeroU8::from_be(n),+n)%0A%7D+else+%7B%0A++++assert_eq!(NonZeroU8::from_be(n),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_le" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.from_le" class="fn">from_le</a>(x: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts an integer from little endian to the targets endianness.</p>
<p>On little endian this is a no-op. On big endian the bytes are
swapped.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">use </span>std::num::NonZeroU8;
<span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au8</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"little"</span>) {
    <span class="macro">assert_eq!</span>(NonZeroU8::from_le(n), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(NonZeroU8::from_le(n), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0Ause+std::num::NonZeroU8;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au8)?;%0A%0Aif+cfg!(target_endian+=+%22little%22)+%7B%0A++++assert_eq!(NonZeroU8::from_le(n),+n)%0A%7D+else+%7B%0A++++assert_eq!(NonZeroU8::from_le(n),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_be" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.to_be" class="fn">to_be</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts <code>self</code> to big endian from the targets endianness.</p>
<p>On big endian this is a no-op. On little endian the bytes are
swapped.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au8</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
    <span class="macro">assert_eq!</span>(n.to_be(), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(n.to_be(), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au8)?;%0A%0Aif+cfg!(target_endian+=+%22big%22)+%7B%0A++++assert_eq!(n.to_be(),+n)%0A%7D+else+%7B%0A++++assert_eq!(n.to_be(),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_le" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const fn <a href="#method.to_le" class="fn">to_le</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts <code>self</code> to little endian from the targets endianness.</p>
<p>On little endian this is a no-op. On big endian the bytes are
swapped.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au8</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"little"</span>) {
    <span class="macro">assert_eq!</span>(n.to_le(), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(n.to_le(), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au8)?;%0A%0Aif+cfg!(target_endian+=+%22little%22)+%7B%0A++++assert_eq!(n.to_le(),+n)%0A%7D+else+%7B%0A++++assert_eq!(n.to_le(),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_add" class="fn">checked_add</a>(self, other: <a class="primitive" href="../primitive.u8.html">u8</a>) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u8::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(two), one.checked_add(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_add(<span class="number">1</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u8)?;%0Alet+two+=+NonZero::new(2u8)?;%0Alet+max+=+NonZero::new(u8::MAX)?;%0A%0Aassert_eq!(Some(two),+one.checked_add(1));%0Aassert_eq!(None,+max.checked_add(1));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_add" class="fn">saturating_add</a>(self, other: <a class="primitive" href="../primitive.u8.html">u8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u8&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u8::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(two, one.saturating_add(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(max, max.saturating_add(<span class="number">1</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u8)?;%0Alet+two+=+NonZero::new(2u8)?;%0Alet+max+=+NonZero::new(u8::MAX)?;%0A%0Aassert_eq!(two,+one.saturating_add(1));%0Aassert_eq!(max,+max.saturating_add(1));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unchecked_add" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.unchecked_add" class="fn">unchecked_add</a>(self, other: <a class="primitive" href="../primitive.u8.html">u8</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_ops</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/84186">#84186</a>)</span></div></span></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value,
assuming overflow cannot occur.
Overflow is unchecked, and it is undefined behavior to overflow
<em>even if the result would wrap to a non-zero value</em>.
The behavior is undefined as soon as
<code>self + rhs &gt; u8::MAX</code>.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_ops)]

</span><span class="kw">let </span>one = NonZero::new(<span class="number">1u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(two, <span class="kw">unsafe </span>{ one.unchecked_add(<span class="number">1</span>) });</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_ops)%5D%0A%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u8)?;%0Alet+two+=+NonZero::new(2u8)?;%0A%0Aassert_eq!(two,+unsafe+%7B+one.unchecked_add(1)+%7D);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_next_power_of_two" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_next_power_of_two" class="fn">checked_next_power_of_two</a>(self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Returns the smallest power of two greater than or equal to <code>self</code>.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>
if the next power of two is greater than the types maximum value.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>three = NonZero::new(<span class="number">3u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u8::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(two), two.checked_next_power_of_two() );
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(four), three.checked_next_power_of_two() );
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_next_power_of_two() );</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u8)?;%0Alet+three+=+NonZero::new(3u8)?;%0Alet+four+=+NonZero::new(4u8)?;%0Alet+max+=+NonZero::new(u8::MAX)?;%0A%0Aassert_eq!(Some(two),+two.checked_next_power_of_two()+);%0Aassert_eq!(Some(four),+three.checked_next_power_of_two()+);%0Aassert_eq!(None,+max.checked_next_power_of_two()+);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ilog2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0, const since 1.67.0">1.67.0 (const: 1.67.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.ilog2" class="fn">ilog2</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the base 2 logarithm of the number, rounded down.</p>
<p>This is the same operation as
<a href="../primitive.u8.html#method.ilog2" title="method u8::ilog2"><code>u8::ilog2</code></a>,
except that it has no failure cases to worry about
since this value can never be zero.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::new(<span class="number">7u8</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">8u8</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">9u8</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::new(7u8)?.ilog2(),+2);%0Aassert_eq!(NonZero::new(8u8)?.ilog2(),+3);%0Aassert_eq!(NonZero::new(9u8)?.ilog2(),+3);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ilog10" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0, const since 1.67.0">1.67.0 (const: 1.67.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.ilog10" class="fn">ilog10</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the base 10 logarithm of the number, rounded down.</p>
<p>This is the same operation as
<a href="../primitive.u8.html#method.ilog10" title="method u8::ilog10"><code>u8::ilog10</code></a>,
except that it has no failure cases to worry about
since this value can never be zero.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::new(<span class="number">99u8</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">100u8</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">101u8</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">2</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::new(99u8)?.ilog10(),+1);%0Aassert_eq!(NonZero::new(100u8)?.ilog10(),+2);%0Aassert_eq!(NonZero::new(101u8)?.ilog10(),+2);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.midpoint" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.85.0, const since 1.85.0">1.85.0 (const: 1.85.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.midpoint" class="fn">midpoint</a>(self, rhs: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the midpoint (average) between <code>self</code> and <code>rhs</code>.</p>
<p><code>midpoint(a, b)</code> is <code>(a + b) &gt;&gt; 1</code> as if it were performed in a
sufficiently-large signed integral type. This implies that the result is
always rounded towards negative infinity and that no overflow will ever occur.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u8</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(one.midpoint(four), two);
<span class="macro">assert_eq!</span>(four.midpoint(one), two);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u8)?;%0Alet+two+=+NonZero::new(2u8)?;%0Alet+four+=+NonZero::new(4u8)?;%0A%0Aassert_eq!(one.midpoint(four),+two);%0Aassert_eq!(four.midpoint(one),+two);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_power_of_two" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.59.0, const since 1.59.0">1.59.0 (const: 1.59.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_power_of_two" class="fn">is_power_of_two</a>(self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.</p>
<p>On many architectures, this function can perform better than <code>is_power_of_two()</code>
on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>eight = NonZero::new(<span class="number">8u8</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(eight.is_power_of_two());
<span class="kw">let </span>ten = NonZero::new(<span class="number">10u8</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!ten.is_power_of_two());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+eight+=+NonZero::new(8u8)?;%0Aassert!(eight.is_power_of_two());%0Alet+ten+=+NonZero::new(10u8)?;%0Aassert!(!ten.is_power_of_two());%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isqrt" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0, const since 1.84.0">1.84.0 (const: 1.84.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.isqrt" class="fn">isqrt</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Returns the square root of the number, rounded down.</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ten = NonZero::new(<span class="number">10u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>three = NonZero::new(<span class="number">3u8</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(ten.isqrt(), three);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+ten+=+NonZero::new(10u8)?;%0Alet+three+=+NonZero::new(3u8)?;%0A%0Aassert_eq!(ten.isqrt(),+three);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cast_signed" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.cast_signed" class="fn">cast_signed</a>(self) -&gt; <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the bit pattern of <code>self</code> reinterpreted as a signed integer of the same size.</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>n = NonZero::&lt;u8&gt;::MAX;

<span class="macro">assert_eq!</span>(n.cast_signed(), NonZero::new(-<span class="number">1i8</span>).unwrap());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++let+n+=+NonZero::%3Cu8%3E::MAX;%0A++++%0A++++assert_eq!(n.cast_signed(),+NonZero::new(-1i8).unwrap());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_mul" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_mul" class="fn">checked_mul</a>(self, other: Self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Multiplies two non-zero integers together.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u8::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(four), two.checked_mul(two));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_mul(two));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u8)?;%0Alet+four+=+NonZero::new(4u8)?;%0Alet+max+=+NonZero::new(u8::MAX)?;%0A%0Aassert_eq!(Some(four),+two.checked_mul(two));%0Aassert_eq!(None,+max.checked_mul(two));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_mul" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_mul" class="fn">saturating_mul</a>(self, other: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Multiplies two non-zero integers together.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u8&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u8::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(four, two.saturating_mul(two));
<span class="macro">assert_eq!</span>(max, four.saturating_mul(max));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u8)?;%0Alet+four+=+NonZero::new(4u8)?;%0Alet+max+=+NonZero::new(u8::MAX)?;%0A%0Aassert_eq!(four,+two.saturating_mul(two));%0Aassert_eq!(max,+four.saturating_mul(max));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unchecked_mul" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.unchecked_mul" class="fn">unchecked_mul</a>(self, other: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_ops</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/84186">#84186</a>)</span></div></span></summary><div class="docblock"><p>Multiplies two non-zero integers together,
assuming overflow cannot occur.
Overflow is unchecked, and it is undefined behavior to overflow
<em>even if the result would wrap to a non-zero value</em>.
The behavior is undefined as soon as
<code>self * rhs &gt; u8::MAX</code>.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_ops)]

</span><span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u8</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(four, <span class="kw">unsafe </span>{ two.unchecked_mul(two) });</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_ops)%5D%0A%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u8)?;%0Alet+four+=+NonZero::new(4u8)?;%0A%0Aassert_eq!(four,+unsafe+%7B+two.unchecked_mul(two)+%7D);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_pow" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_pow" class="fn">checked_pow</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Raises non-zero value to an integer power.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>three = NonZero::new(<span class="number">3u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>twenty_seven = NonZero::new(<span class="number">27u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>half_max = NonZero::new(u8::MAX / <span class="number">2</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(twenty_seven), three.checked_pow(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, half_max.checked_pow(<span class="number">3</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+three+=+NonZero::new(3u8)?;%0Alet+twenty_seven+=+NonZero::new(27u8)?;%0Alet+half_max+=+NonZero::new(u8::MAX+/+2)?;%0A%0Aassert_eq!(Some(twenty_seven),+three.checked_pow(3));%0Aassert_eq!(None,+half_max.checked_pow(3));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_pow" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_pow" class="fn">saturating_pow</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Raise non-zero value to an integer power.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u8&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>three = NonZero::new(<span class="number">3u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>twenty_seven = NonZero::new(<span class="number">27u8</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u8::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(twenty_seven, three.saturating_pow(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(max, max.saturating_pow(<span class="number">3</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+three+=+NonZero::new(3u8)?;%0Alet+twenty_seven+=+NonZero::new(27u8)?;%0Alet+max+=+NonZero::new(u8::MAX)?;%0A%0Aassert_eq!(twenty_seven,+three.saturating_pow(3));%0Aassert_eq!(max,+max.saturating_pow(3));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NonZero%3Cu8%3E-1" class="impl"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a><a href="#impl-NonZero%3Cu8%3E-1" class="anchor"></a><h3 class="code-header">impl <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.div_ceil" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.92.0, const since 1.92.0">1.92.0 (const: 1.92.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2221-2231">Source</a></span><h4 class="code-header">pub const fn <a href="#method.div_ceil" class="fn">div_ceil</a>(self, rhs: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the quotient of <code>self</code> and <code>rhs</code>, rounding the result towards positive infinity.</p>
<p>The result is guaranteed to be non-zero.</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u8</span>).unwrap();
<span class="kw">let </span>max = NonZero::new(u8::MAX).unwrap();
<span class="macro">assert_eq!</span>(one.div_ceil(max), one);

<span class="kw">let </span>two = NonZero::new(<span class="number">2u8</span>).unwrap();
<span class="kw">let </span>three = NonZero::new(<span class="number">3u8</span>).unwrap();
<span class="macro">assert_eq!</span>(three.div_ceil(two), two);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++let+one+=+NonZero::new(1u8).unwrap();%0A++++let+max+=+NonZero::new(u8::MAX).unwrap();%0A++++assert_eq!(one.div_ceil(max),+one);%0A++++%0A++++let+two+=+NonZero::new(2u8).unwrap();%0A++++let+three+=+NonZero::new(3u8).unwrap();%0A++++assert_eq!(three.div_ceil(two),+two);%0A%7D&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NonZero%3Cu16%3E" class="impl"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><a href="#impl-NonZero%3Cu16%3E" class="anchor"></a><h3 class="code-header">impl <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.u16.html">u16</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.BITS-1" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0">1.67.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.BITS-1" class="constant">BITS</a>: <a class="primitive" href="../primitive.u32.html">u32</a> = 16u32</h4></section></summary><div class="docblock"><p>The size of this non-zero integer type in bits.</p>
<p>This value is equal to <a href="../primitive.u16.html#associatedconstant.BITS" title="associated constant u16::BITS"><code>u16::BITS</code></a>.</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::BITS, u16::BITS);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu16%3E::BITS,+u16::BITS);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle" open><summary><section id="associatedconstant.MIN-1" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MIN-1" class="constant">MIN</a>: Self</h4></section></summary><div class="docblock"><p>The smallest value that can be represented by this non-zero
integer type, 1.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::MIN.get(), <span class="number">1u16</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu16%3E::MIN.get(),+1u16);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle" open><summary><section id="associatedconstant.MAX-1" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MAX-1" class="constant">MAX</a>: Self</h4></section></summary><div class="docblock"><p>The largest value that can be represented by this non-zero
integer type,
equal to <a href="../primitive.u16.html#associatedconstant.MAX" title="associated constant u16::MAX"><code>u16::MAX</code></a>.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::MAX.get(), u16::MAX);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu16%3E::MAX.get(),+u16::MAX);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.leading_zeros-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0, const since 1.53.0">1.53.0 (const: 1.53.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.leading_zeros-1" class="fn">leading_zeros</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the number of leading zeros in the binary representation of <code>self</code>.</p>
<p>On many architectures, this function can perform better than <code>leading_zeros()</code> on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>n = NonZero::&lt;u16&gt;::new(u16::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.leading_zeros(), <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::%3Cu16%3E::new(u16::MAX)?;%0A%0Aassert_eq!(n.leading_zeros(),+0);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trailing_zeros-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0, const since 1.53.0">1.53.0 (const: 1.53.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.trailing_zeros-1" class="fn">trailing_zeros</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the number of trailing zeros in the binary representation
of <code>self</code>.</p>
<p>On many architectures, this function can perform better than <code>trailing_zeros()</code> on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>n = NonZero::&lt;u16&gt;::new(<span class="number">0b0101000</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.trailing_zeros(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::%3Cu16%3E::new(0b0101000)?;%0A%0Aassert_eq!(n.trailing_zeros(),+3);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isolate_highest_one-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.isolate_highest_one-1" class="fn">isolate_highest_one</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>isolate_most_least_significant_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136909">#136909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with only the most significant bit set.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2"></a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(isolate_most_least_significant_one)]

</span><span class="kw">let </span>a = NonZero::&lt;u16&gt;::new(<span class="number">0b_01100100</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u16&gt;::new(<span class="number">0b_01000000</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.isolate_highest_one(), b);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(isolate_most_least_significant_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu16%3E::new(0b_01100100)?;%0Alet+b+=+NonZero::%3Cu16%3E::new(0b_01000000)?;%0A%0Aassert_eq!(a.isolate_highest_one(),+b);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isolate_lowest_one-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.isolate_lowest_one-1" class="fn">isolate_lowest_one</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>isolate_most_least_significant_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136909">#136909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with only the least significant bit set.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3"></a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(isolate_most_least_significant_one)]

</span><span class="kw">let </span>a = NonZero::&lt;u16&gt;::new(<span class="number">0b_01100100</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u16&gt;::new(<span class="number">0b_00000100</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.isolate_lowest_one(), b);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(isolate_most_least_significant_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu16%3E::new(0b_01100100)?;%0Alet+b+=+NonZero::%3Cu16%3E::new(0b_00000100)?;%0A%0Aassert_eq!(a.isolate_lowest_one(),+b);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.highest_one-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.highest_one-1" class="fn">highest_one</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>int_lowest_highest_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145203">#145203</a>)</span></div></span></summary><div class="docblock"><p>Returns the index of the highest bit set to one in <code>self</code>.</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(int_lowest_highest_one)]

</span><span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::new(<span class="number">0x1</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::new(<span class="number">0x10</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::new(<span class="number">0x1f</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(int_lowest_highest_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::%3Cu16%3E::new(0x1)?.highest_one(),+0);%0Aassert_eq!(NonZero::%3Cu16%3E::new(0x10)?.highest_one(),+4);%0Aassert_eq!(NonZero::%3Cu16%3E::new(0x1f)?.highest_one(),+4);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.lowest_one-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.lowest_one-1" class="fn">lowest_one</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>int_lowest_highest_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145203">#145203</a>)</span></div></span></summary><div class="docblock"><p>Returns the index of the lowest bit set to one in <code>self</code>.</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(int_lowest_highest_one)]

</span><span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::new(<span class="number">0x1</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::new(<span class="number">0x10</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u16&gt;::new(<span class="number">0x1f</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(int_lowest_highest_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::%3Cu16%3E::new(0x1)?.lowest_one(),+0);%0Aassert_eq!(NonZero::%3Cu16%3E::new(0x10)?.lowest_one(),+4);%0Aassert_eq!(NonZero::%3Cu16%3E::new(0x1f)?.lowest_one(),+0);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.count_ones-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.86.0, const since 1.86.0">1.86.0 (const: 1.86.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.count_ones-1" class="fn">count_ones</a>(self) -&gt; <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.u32.html">u32</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the number of ones in the binary representation of <code>self</code>.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = NonZero::&lt;u16&gt;::new(<span class="number">0b100_0000</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u16&gt;::new(<span class="number">0b100_0011</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.count_ones(), NonZero::new(<span class="number">1</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(b.count_ones(), NonZero::new(<span class="number">3</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu16%3E::new(0b100_0000)?;%0Alet+b+=+NonZero::%3Cu16%3E::new(0b100_0011)?;%0A%0Aassert_eq!(a.count_ones(),+NonZero::new(1)?);%0Aassert_eq!(b.count_ones(),+NonZero::new(3)?);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_left-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.rotate_left-1" class="fn">rotate_left</a>(self, n: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Shifts the bits to the left by a specified amount, <code>n</code>,
wrapping the truncated bits to the end of the resulting integer.</p>
<p>Please note this isnt the same operation as the <code>&lt;&lt;</code> shifting operator!</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0xa003u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = NonZero::new(<span class="number">0x3a</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.rotate_left(<span class="number">4</span>), m);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0xa003u16)?;%0Alet+m+=+NonZero::new(0x3a)?;%0A%0Aassert_eq!(n.rotate_left(4),+m);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_right-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.rotate_right-1" class="fn">rotate_right</a>(self, n: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Shifts the bits to the right by a specified amount, <code>n</code>,
wrapping the truncated bits to the beginning of the resulting
integer.</p>
<p>Please note this isnt the same operation as the <code>&gt;&gt;</code> shifting operator!</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x3au16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = NonZero::new(<span class="number">0xa003</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.rotate_right(<span class="number">4</span>), m);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x3au16)?;%0Alet+m+=+NonZero::new(0xa003)?;%0A%0Aassert_eq!(n.rotate_right(4),+m);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.swap_bytes-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.swap_bytes-1" class="fn">swap_bytes</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Reverses the byte order of the integer.</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x1234u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = n.swap_bytes();

<span class="macro">assert_eq!</span>(m, NonZero::new(<span class="number">0x3412</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1234u16)?;%0Alet+m+=+n.swap_bytes();%0A%0Aassert_eq!(m,+NonZero::new(0x3412)?);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reverse_bits-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.reverse_bits-1" class="fn">reverse_bits</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,
second least-significant bit becomes second most-significant bit, etc.</p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x1234u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = n.reverse_bits();

<span class="macro">assert_eq!</span>(m, NonZero::new(<span class="number">0x2c48</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1234u16)?;%0Alet+m+=+n.reverse_bits();%0A%0Aassert_eq!(m,+NonZero::new(0x2c48)?);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_be-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.from_be-1" class="fn">from_be</a>(x: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts an integer from big endian to the targets endianness.</p>
<p>On big endian this is a no-op. On little endian the bytes are
swapped.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">use </span>std::num::NonZeroU16;
<span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au16</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
    <span class="macro">assert_eq!</span>(NonZeroU16::from_be(n), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(NonZeroU16::from_be(n), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0Ause+std::num::NonZeroU16;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au16)?;%0A%0Aif+cfg!(target_endian+=+%22big%22)+%7B%0A++++assert_eq!(NonZeroU16::from_be(n),+n)%0A%7D+else+%7B%0A++++assert_eq!(NonZeroU16::from_be(n),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_le-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.from_le-1" class="fn">from_le</a>(x: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts an integer from little endian to the targets endianness.</p>
<p>On little endian this is a no-op. On big endian the bytes are
swapped.</p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">use </span>std::num::NonZeroU16;
<span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au16</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"little"</span>) {
    <span class="macro">assert_eq!</span>(NonZeroU16::from_le(n), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(NonZeroU16::from_le(n), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0Ause+std::num::NonZeroU16;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au16)?;%0A%0Aif+cfg!(target_endian+=+%22little%22)+%7B%0A++++assert_eq!(NonZeroU16::from_le(n),+n)%0A%7D+else+%7B%0A++++assert_eq!(NonZeroU16::from_le(n),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_be-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.to_be-1" class="fn">to_be</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts <code>self</code> to big endian from the targets endianness.</p>
<p>On big endian this is a no-op. On little endian the bytes are
swapped.</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au16</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
    <span class="macro">assert_eq!</span>(n.to_be(), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(n.to_be(), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au16)?;%0A%0Aif+cfg!(target_endian+=+%22big%22)+%7B%0A++++assert_eq!(n.to_be(),+n)%0A%7D+else+%7B%0A++++assert_eq!(n.to_be(),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_le-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const fn <a href="#method.to_le-1" class="fn">to_le</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts <code>self</code> to little endian from the targets endianness.</p>
<p>On little endian this is a no-op. On big endian the bytes are
swapped.</p>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au16</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"little"</span>) {
    <span class="macro">assert_eq!</span>(n.to_le(), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(n.to_le(), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au16)?;%0A%0Aif+cfg!(target_endian+=+%22little%22)+%7B%0A++++assert_eq!(n.to_le(),+n)%0A%7D+else+%7B%0A++++assert_eq!(n.to_le(),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_add-1" class="fn">checked_add</a>(self, other: <a class="primitive" href="../primitive.u16.html">u16</a>) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u16::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(two), one.checked_add(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_add(<span class="number">1</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u16)?;%0Alet+two+=+NonZero::new(2u16)?;%0Alet+max+=+NonZero::new(u16::MAX)?;%0A%0Aassert_eq!(Some(two),+one.checked_add(1));%0Aassert_eq!(None,+max.checked_add(1));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_add-1" class="fn">saturating_add</a>(self, other: <a class="primitive" href="../primitive.u16.html">u16</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u16&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u16::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(two, one.saturating_add(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(max, max.saturating_add(<span class="number">1</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u16)?;%0Alet+two+=+NonZero::new(2u16)?;%0Alet+max+=+NonZero::new(u16::MAX)?;%0A%0Aassert_eq!(two,+one.saturating_add(1));%0Aassert_eq!(max,+max.saturating_add(1));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unchecked_add-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.unchecked_add-1" class="fn">unchecked_add</a>(self, other: <a class="primitive" href="../primitive.u16.html">u16</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_ops</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/84186">#84186</a>)</span></div></span></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value,
assuming overflow cannot occur.
Overflow is unchecked, and it is undefined behavior to overflow
<em>even if the result would wrap to a non-zero value</em>.
The behavior is undefined as soon as
<code>self + rhs &gt; u16::MAX</code>.</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_ops)]

</span><span class="kw">let </span>one = NonZero::new(<span class="number">1u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(two, <span class="kw">unsafe </span>{ one.unchecked_add(<span class="number">1</span>) });</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_ops)%5D%0A%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u16)?;%0Alet+two+=+NonZero::new(2u16)?;%0A%0Aassert_eq!(two,+unsafe+%7B+one.unchecked_add(1)+%7D);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_next_power_of_two-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_next_power_of_two-1" class="fn">checked_next_power_of_two</a>(self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Returns the smallest power of two greater than or equal to <code>self</code>.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>
if the next power of two is greater than the types maximum value.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>three = NonZero::new(<span class="number">3u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u16::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(two), two.checked_next_power_of_two() );
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(four), three.checked_next_power_of_two() );
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_next_power_of_two() );</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u16)?;%0Alet+three+=+NonZero::new(3u16)?;%0Alet+four+=+NonZero::new(4u16)?;%0Alet+max+=+NonZero::new(u16::MAX)?;%0A%0Aassert_eq!(Some(two),+two.checked_next_power_of_two()+);%0Aassert_eq!(Some(four),+three.checked_next_power_of_two()+);%0Aassert_eq!(None,+max.checked_next_power_of_two()+);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ilog2-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0, const since 1.67.0">1.67.0 (const: 1.67.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.ilog2-1" class="fn">ilog2</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the base 2 logarithm of the number, rounded down.</p>
<p>This is the same operation as
<a href="../primitive.u16.html#method.ilog2" title="method u16::ilog2"><code>u16::ilog2</code></a>,
except that it has no failure cases to worry about
since this value can never be zero.</p>
<h5 id="examples-52"><a class="doc-anchor" href="#examples-52"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::new(<span class="number">7u16</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">8u16</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">9u16</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::new(7u16)?.ilog2(),+2);%0Aassert_eq!(NonZero::new(8u16)?.ilog2(),+3);%0Aassert_eq!(NonZero::new(9u16)?.ilog2(),+3);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ilog10-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0, const since 1.67.0">1.67.0 (const: 1.67.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.ilog10-1" class="fn">ilog10</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the base 10 logarithm of the number, rounded down.</p>
<p>This is the same operation as
<a href="../primitive.u16.html#method.ilog10" title="method u16::ilog10"><code>u16::ilog10</code></a>,
except that it has no failure cases to worry about
since this value can never be zero.</p>
<h5 id="examples-53"><a class="doc-anchor" href="#examples-53"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::new(<span class="number">99u16</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">100u16</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">101u16</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">2</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::new(99u16)?.ilog10(),+1);%0Aassert_eq!(NonZero::new(100u16)?.ilog10(),+2);%0Aassert_eq!(NonZero::new(101u16)?.ilog10(),+2);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.midpoint-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.85.0, const since 1.85.0">1.85.0 (const: 1.85.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.midpoint-1" class="fn">midpoint</a>(self, rhs: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the midpoint (average) between <code>self</code> and <code>rhs</code>.</p>
<p><code>midpoint(a, b)</code> is <code>(a + b) &gt;&gt; 1</code> as if it were performed in a
sufficiently-large signed integral type. This implies that the result is
always rounded towards negative infinity and that no overflow will ever occur.</p>
<h5 id="examples-54"><a class="doc-anchor" href="#examples-54"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u16</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(one.midpoint(four), two);
<span class="macro">assert_eq!</span>(four.midpoint(one), two);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u16)?;%0Alet+two+=+NonZero::new(2u16)?;%0Alet+four+=+NonZero::new(4u16)?;%0A%0Aassert_eq!(one.midpoint(four),+two);%0Aassert_eq!(four.midpoint(one),+two);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_power_of_two-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.59.0, const since 1.59.0">1.59.0 (const: 1.59.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_power_of_two-1" class="fn">is_power_of_two</a>(self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.</p>
<p>On many architectures, this function can perform better than <code>is_power_of_two()</code>
on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-55"><a class="doc-anchor" href="#examples-55"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>eight = NonZero::new(<span class="number">8u16</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(eight.is_power_of_two());
<span class="kw">let </span>ten = NonZero::new(<span class="number">10u16</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!ten.is_power_of_two());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+eight+=+NonZero::new(8u16)?;%0Aassert!(eight.is_power_of_two());%0Alet+ten+=+NonZero::new(10u16)?;%0Aassert!(!ten.is_power_of_two());%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isqrt-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0, const since 1.84.0">1.84.0 (const: 1.84.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.isqrt-1" class="fn">isqrt</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Returns the square root of the number, rounded down.</p>
<h5 id="examples-56"><a class="doc-anchor" href="#examples-56"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ten = NonZero::new(<span class="number">10u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>three = NonZero::new(<span class="number">3u16</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(ten.isqrt(), three);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+ten+=+NonZero::new(10u16)?;%0Alet+three+=+NonZero::new(3u16)?;%0A%0Aassert_eq!(ten.isqrt(),+three);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cast_signed-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.cast_signed-1" class="fn">cast_signed</a>(self) -&gt; <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the bit pattern of <code>self</code> reinterpreted as a signed integer of the same size.</p>
<h5 id="examples-57"><a class="doc-anchor" href="#examples-57"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>n = NonZero::&lt;u16&gt;::MAX;

<span class="macro">assert_eq!</span>(n.cast_signed(), NonZero::new(-<span class="number">1i16</span>).unwrap());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++let+n+=+NonZero::%3Cu16%3E::MAX;%0A++++%0A++++assert_eq!(n.cast_signed(),+NonZero::new(-1i16).unwrap());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_mul-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_mul-1" class="fn">checked_mul</a>(self, other: Self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Multiplies two non-zero integers together.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-58"><a class="doc-anchor" href="#examples-58"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u16::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(four), two.checked_mul(two));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_mul(two));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u16)?;%0Alet+four+=+NonZero::new(4u16)?;%0Alet+max+=+NonZero::new(u16::MAX)?;%0A%0Aassert_eq!(Some(four),+two.checked_mul(two));%0Aassert_eq!(None,+max.checked_mul(two));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_mul-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_mul-1" class="fn">saturating_mul</a>(self, other: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Multiplies two non-zero integers together.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u16&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-59"><a class="doc-anchor" href="#examples-59"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u16::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(four, two.saturating_mul(two));
<span class="macro">assert_eq!</span>(max, four.saturating_mul(max));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u16)?;%0Alet+four+=+NonZero::new(4u16)?;%0Alet+max+=+NonZero::new(u16::MAX)?;%0A%0Aassert_eq!(four,+two.saturating_mul(two));%0Aassert_eq!(max,+four.saturating_mul(max));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unchecked_mul-1" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.unchecked_mul-1" class="fn">unchecked_mul</a>(self, other: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_ops</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/84186">#84186</a>)</span></div></span></summary><div class="docblock"><p>Multiplies two non-zero integers together,
assuming overflow cannot occur.
Overflow is unchecked, and it is undefined behavior to overflow
<em>even if the result would wrap to a non-zero value</em>.
The behavior is undefined as soon as
<code>self * rhs &gt; u16::MAX</code>.</p>
<h5 id="examples-60"><a class="doc-anchor" href="#examples-60"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_ops)]

</span><span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u16</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(four, <span class="kw">unsafe </span>{ two.unchecked_mul(two) });</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_ops)%5D%0A%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u16)?;%0Alet+four+=+NonZero::new(4u16)?;%0A%0Aassert_eq!(four,+unsafe+%7B+two.unchecked_mul(two)+%7D);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_pow-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_pow-1" class="fn">checked_pow</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Raises non-zero value to an integer power.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-61"><a class="doc-anchor" href="#examples-61"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>three = NonZero::new(<span class="number">3u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>twenty_seven = NonZero::new(<span class="number">27u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>half_max = NonZero::new(u16::MAX / <span class="number">2</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(twenty_seven), three.checked_pow(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, half_max.checked_pow(<span class="number">3</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+three+=+NonZero::new(3u16)?;%0Alet+twenty_seven+=+NonZero::new(27u16)?;%0Alet+half_max+=+NonZero::new(u16::MAX+/+2)?;%0A%0Aassert_eq!(Some(twenty_seven),+three.checked_pow(3));%0Aassert_eq!(None,+half_max.checked_pow(3));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_pow-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_pow-1" class="fn">saturating_pow</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Raise non-zero value to an integer power.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u16&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-62"><a class="doc-anchor" href="#examples-62"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>three = NonZero::new(<span class="number">3u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>twenty_seven = NonZero::new(<span class="number">27u16</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u16::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(twenty_seven, three.saturating_pow(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(max, max.saturating_pow(<span class="number">3</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+three+=+NonZero::new(3u16)?;%0Alet+twenty_seven+=+NonZero::new(27u16)?;%0Alet+max+=+NonZero::new(u16::MAX)?;%0A%0Aassert_eq!(twenty_seven,+three.saturating_pow(3));%0Aassert_eq!(max,+max.saturating_pow(3));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NonZero%3Cu16%3E-1" class="impl"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a><a href="#impl-NonZero%3Cu16%3E-1" class="anchor"></a><h3 class="code-header">impl <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.u16.html">u16</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.div_ceil-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.92.0, const since 1.92.0">1.92.0 (const: 1.92.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2233-2243">Source</a></span><h4 class="code-header">pub const fn <a href="#method.div_ceil-1" class="fn">div_ceil</a>(self, rhs: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the quotient of <code>self</code> and <code>rhs</code>, rounding the result towards positive infinity.</p>
<p>The result is guaranteed to be non-zero.</p>
<h5 id="examples-63"><a class="doc-anchor" href="#examples-63"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u16</span>).unwrap();
<span class="kw">let </span>max = NonZero::new(u16::MAX).unwrap();
<span class="macro">assert_eq!</span>(one.div_ceil(max), one);

<span class="kw">let </span>two = NonZero::new(<span class="number">2u16</span>).unwrap();
<span class="kw">let </span>three = NonZero::new(<span class="number">3u16</span>).unwrap();
<span class="macro">assert_eq!</span>(three.div_ceil(two), two);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++let+one+=+NonZero::new(1u16).unwrap();%0A++++let+max+=+NonZero::new(u16::MAX).unwrap();%0A++++assert_eq!(one.div_ceil(max),+one);%0A++++%0A++++let+two+=+NonZero::new(2u16).unwrap();%0A++++let+three+=+NonZero::new(3u16).unwrap();%0A++++assert_eq!(three.div_ceil(two),+two);%0A%7D&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NonZero%3Cu32%3E" class="impl"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><a href="#impl-NonZero%3Cu32%3E" class="anchor"></a><h3 class="code-header">impl <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.u32.html">u32</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.BITS-2" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0">1.67.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.BITS-2" class="constant">BITS</a>: <a class="primitive" href="../primitive.u32.html">u32</a> = 32u32</h4></section></summary><div class="docblock"><p>The size of this non-zero integer type in bits.</p>
<p>This value is equal to <a href="../primitive.u32.html#associatedconstant.BITS" title="associated constant u32::BITS"><code>u32::BITS</code></a>.</p>
<h5 id="examples-64"><a class="doc-anchor" href="#examples-64"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::BITS, u32::BITS);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu32%3E::BITS,+u32::BITS);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle" open><summary><section id="associatedconstant.MIN-2" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MIN-2" class="constant">MIN</a>: Self</h4></section></summary><div class="docblock"><p>The smallest value that can be represented by this non-zero
integer type, 1.</p>
<h5 id="examples-65"><a class="doc-anchor" href="#examples-65"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::MIN.get(), <span class="number">1u32</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu32%3E::MIN.get(),+1u32);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle" open><summary><section id="associatedconstant.MAX-2" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MAX-2" class="constant">MAX</a>: Self</h4></section></summary><div class="docblock"><p>The largest value that can be represented by this non-zero
integer type,
equal to <a href="../primitive.u32.html#associatedconstant.MAX" title="associated constant u32::MAX"><code>u32::MAX</code></a>.</p>
<h5 id="examples-66"><a class="doc-anchor" href="#examples-66"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::MAX.get(), u32::MAX);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++assert_eq!(NonZero::%3Cu32%3E::MAX.get(),+u32::MAX);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.leading_zeros-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0, const since 1.53.0">1.53.0 (const: 1.53.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.leading_zeros-2" class="fn">leading_zeros</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the number of leading zeros in the binary representation of <code>self</code>.</p>
<p>On many architectures, this function can perform better than <code>leading_zeros()</code> on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-67"><a class="doc-anchor" href="#examples-67"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>n = NonZero::&lt;u32&gt;::new(u32::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.leading_zeros(), <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::%3Cu32%3E::new(u32::MAX)?;%0A%0Aassert_eq!(n.leading_zeros(),+0);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trailing_zeros-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0, const since 1.53.0">1.53.0 (const: 1.53.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.trailing_zeros-2" class="fn">trailing_zeros</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the number of trailing zeros in the binary representation
of <code>self</code>.</p>
<p>On many architectures, this function can perform better than <code>trailing_zeros()</code> on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-68"><a class="doc-anchor" href="#examples-68"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>n = NonZero::&lt;u32&gt;::new(<span class="number">0b0101000</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.trailing_zeros(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::%3Cu32%3E::new(0b0101000)?;%0A%0Aassert_eq!(n.trailing_zeros(),+3);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isolate_highest_one-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.isolate_highest_one-2" class="fn">isolate_highest_one</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>isolate_most_least_significant_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136909">#136909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with only the most significant bit set.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4"></a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(isolate_most_least_significant_one)]

</span><span class="kw">let </span>a = NonZero::&lt;u32&gt;::new(<span class="number">0b_01100100</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u32&gt;::new(<span class="number">0b_01000000</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.isolate_highest_one(), b);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(isolate_most_least_significant_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu32%3E::new(0b_01100100)?;%0Alet+b+=+NonZero::%3Cu32%3E::new(0b_01000000)?;%0A%0Aassert_eq!(a.isolate_highest_one(),+b);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isolate_lowest_one-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.isolate_lowest_one-2" class="fn">isolate_lowest_one</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>isolate_most_least_significant_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136909">#136909</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>self</code> with only the least significant bit set.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5"></a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(isolate_most_least_significant_one)]

</span><span class="kw">let </span>a = NonZero::&lt;u32&gt;::new(<span class="number">0b_01100100</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u32&gt;::new(<span class="number">0b_00000100</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.isolate_lowest_one(), b);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(isolate_most_least_significant_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu32%3E::new(0b_01100100)?;%0Alet+b+=+NonZero::%3Cu32%3E::new(0b_00000100)?;%0A%0Aassert_eq!(a.isolate_lowest_one(),+b);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.highest_one-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.highest_one-2" class="fn">highest_one</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>int_lowest_highest_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145203">#145203</a>)</span></div></span></summary><div class="docblock"><p>Returns the index of the highest bit set to one in <code>self</code>.</p>
<h5 id="examples-69"><a class="doc-anchor" href="#examples-69"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(int_lowest_highest_one)]

</span><span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::new(<span class="number">0x1</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::new(<span class="number">0x10</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::new(<span class="number">0x1f</span>)<span class="question-mark">?</span>.highest_one(), <span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(int_lowest_highest_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::%3Cu32%3E::new(0x1)?.highest_one(),+0);%0Aassert_eq!(NonZero::%3Cu32%3E::new(0x10)?.highest_one(),+4);%0Aassert_eq!(NonZero::%3Cu32%3E::new(0x1f)?.highest_one(),+4);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.lowest_one-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.lowest_one-2" class="fn">lowest_one</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>int_lowest_highest_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145203">#145203</a>)</span></div></span></summary><div class="docblock"><p>Returns the index of the lowest bit set to one in <code>self</code>.</p>
<h5 id="examples-70"><a class="doc-anchor" href="#examples-70"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(int_lowest_highest_one)]

</span><span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::new(<span class="number">0x1</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::new(<span class="number">0x10</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(NonZero::&lt;u32&gt;::new(<span class="number">0x1f</span>)<span class="question-mark">?</span>.lowest_one(), <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(int_lowest_highest_one)%5D%0A%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Ause+core::num::NonZero;%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::%3Cu32%3E::new(0x1)?.lowest_one(),+0);%0Aassert_eq!(NonZero::%3Cu32%3E::new(0x10)?.lowest_one(),+4);%0Aassert_eq!(NonZero::%3Cu32%3E::new(0x1f)?.lowest_one(),+0);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.count_ones-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.86.0, const since 1.86.0">1.86.0 (const: 1.86.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.count_ones-2" class="fn">count_ones</a>(self) -&gt; <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.u32.html">u32</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the number of ones in the binary representation of <code>self</code>.</p>
<h5 id="examples-71"><a class="doc-anchor" href="#examples-71"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = NonZero::&lt;u32&gt;::new(<span class="number">0b100_0000</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>b = NonZero::&lt;u32&gt;::new(<span class="number">0b100_0011</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a.count_ones(), NonZero::new(<span class="number">1</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(b.count_ones(), NonZero::new(<span class="number">3</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+a+=+NonZero::%3Cu32%3E::new(0b100_0000)?;%0Alet+b+=+NonZero::%3Cu32%3E::new(0b100_0011)?;%0A%0Aassert_eq!(a.count_ones(),+NonZero::new(1)?);%0Aassert_eq!(b.count_ones(),+NonZero::new(3)?);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_left-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.rotate_left-2" class="fn">rotate_left</a>(self, n: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Shifts the bits to the left by a specified amount, <code>n</code>,
wrapping the truncated bits to the end of the resulting integer.</p>
<p>Please note this isnt the same operation as the <code>&lt;&lt;</code> shifting operator!</p>
<h5 id="examples-72"><a class="doc-anchor" href="#examples-72"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x10000b3u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = NonZero::new(<span class="number">0xb301</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.rotate_left(<span class="number">8</span>), m);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x10000b3u32)?;%0Alet+m+=+NonZero::new(0xb301)?;%0A%0Aassert_eq!(n.rotate_left(8),+m);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rotate_right-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.rotate_right-2" class="fn">rotate_right</a>(self, n: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Shifts the bits to the right by a specified amount, <code>n</code>,
wrapping the truncated bits to the beginning of the resulting
integer.</p>
<p>Please note this isnt the same operation as the <code>&gt;&gt;</code> shifting operator!</p>
<h5 id="examples-73"><a class="doc-anchor" href="#examples-73"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0xb301u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = NonZero::new(<span class="number">0x10000b3</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(n.rotate_right(<span class="number">8</span>), m);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0xb301u32)?;%0Alet+m+=+NonZero::new(0x10000b3)?;%0A%0Aassert_eq!(n.rotate_right(8),+m);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.swap_bytes-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.swap_bytes-2" class="fn">swap_bytes</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Reverses the byte order of the integer.</p>
<h5 id="examples-74"><a class="doc-anchor" href="#examples-74"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x12345678u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = n.swap_bytes();

<span class="macro">assert_eq!</span>(m, NonZero::new(<span class="number">0x78563412</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x12345678u32)?;%0Alet+m+=+n.swap_bytes();%0A%0Aassert_eq!(m,+NonZero::new(0x78563412)?);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reverse_bits-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.reverse_bits-2" class="fn">reverse_bits</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,
second least-significant bit becomes second most-significant bit, etc.</p>
<h5 id="examples-75"><a class="doc-anchor" href="#examples-75"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x12345678u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>m = n.reverse_bits();

<span class="macro">assert_eq!</span>(m, NonZero::new(<span class="number">0x1e6a2c48</span>)<span class="question-mark">?</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x12345678u32)?;%0Alet+m+=+n.reverse_bits();%0A%0Aassert_eq!(m,+NonZero::new(0x1e6a2c48)?);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_be-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.from_be-2" class="fn">from_be</a>(x: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts an integer from big endian to the targets endianness.</p>
<p>On big endian this is a no-op. On little endian the bytes are
swapped.</p>
<h5 id="examples-76"><a class="doc-anchor" href="#examples-76"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">use </span>std::num::NonZeroU32;
<span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au32</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
    <span class="macro">assert_eq!</span>(NonZeroU32::from_be(n), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(NonZeroU32::from_be(n), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0Ause+std::num::NonZeroU32;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au32)?;%0A%0Aif+cfg!(target_endian+=+%22big%22)+%7B%0A++++assert_eq!(NonZeroU32::from_be(n),+n)%0A%7D+else+%7B%0A++++assert_eq!(NonZeroU32::from_be(n),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_le-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.from_le-2" class="fn">from_le</a>(x: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts an integer from little endian to the targets endianness.</p>
<p>On little endian this is a no-op. On big endian the bytes are
swapped.</p>
<h5 id="examples-77"><a class="doc-anchor" href="#examples-77"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">use </span>std::num::NonZeroU32;
<span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au32</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"little"</span>) {
    <span class="macro">assert_eq!</span>(NonZeroU32::from_le(n), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(NonZeroU32::from_le(n), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0Ause+std::num::NonZeroU32;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au32)?;%0A%0Aif+cfg!(target_endian+=+%22little%22)+%7B%0A++++assert_eq!(NonZeroU32::from_le(n),+n)%0A%7D+else+%7B%0A++++assert_eq!(NonZeroU32::from_le(n),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_be-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.to_be-2" class="fn">to_be</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts <code>self</code> to big endian from the targets endianness.</p>
<p>On big endian this is a no-op. On little endian the bytes are
swapped.</p>
<h5 id="examples-78"><a class="doc-anchor" href="#examples-78"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au32</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
    <span class="macro">assert_eq!</span>(n.to_be(), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(n.to_be(), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au32)?;%0A%0Aif+cfg!(target_endian+=+%22big%22)+%7B%0A++++assert_eq!(n.to_be(),+n)%0A%7D+else+%7B%0A++++assert_eq!(n.to_be(),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_le-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const fn <a href="#method.to_le-2" class="fn">to_le</a>(self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_bitwise</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/128281">#128281</a>)</span></div></span></summary><div class="docblock"><p>Converts <code>self</code> to little endian from the targets endianness.</p>
<p>On little endian this is a no-op. On big endian the bytes are
swapped.</p>
<h5 id="examples-79"><a class="doc-anchor" href="#examples-79"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_bitwise)]
</span><span class="kw">let </span>n = NonZero::new(<span class="number">0x1Au32</span>)<span class="question-mark">?</span>;

<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"little"</span>) {
    <span class="macro">assert_eq!</span>(n.to_le(), n)
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(n.to_le(), n.swap_bytes())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_bitwise)%5D%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+n+=+NonZero::new(0x1Au32)?;%0A%0Aif+cfg!(target_endian+=+%22little%22)+%7B%0A++++assert_eq!(n.to_le(),+n)%0A%7D+else+%7B%0A++++assert_eq!(n.to_le(),+n.swap_bytes())%0A%7D%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_add-2" class="fn">checked_add</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-80"><a class="doc-anchor" href="#examples-80"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u32::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(two), one.checked_add(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_add(<span class="number">1</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u32)?;%0Alet+two+=+NonZero::new(2u32)?;%0Alet+max+=+NonZero::new(u32::MAX)?;%0A%0Aassert_eq!(Some(two),+one.checked_add(1));%0Aassert_eq!(None,+max.checked_add(1));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_add-2" class="fn">saturating_add</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u32&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-81"><a class="doc-anchor" href="#examples-81"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u32::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(two, one.saturating_add(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(max, max.saturating_add(<span class="number">1</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u32)?;%0Alet+two+=+NonZero::new(2u32)?;%0Alet+max+=+NonZero::new(u32::MAX)?;%0A%0Aassert_eq!(two,+one.saturating_add(1));%0Aassert_eq!(max,+max.saturating_add(1));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unchecked_add-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.unchecked_add-2" class="fn">unchecked_add</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_ops</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/84186">#84186</a>)</span></div></span></summary><div class="docblock"><p>Adds an unsigned integer to a non-zero value,
assuming overflow cannot occur.
Overflow is unchecked, and it is undefined behavior to overflow
<em>even if the result would wrap to a non-zero value</em>.
The behavior is undefined as soon as
<code>self + rhs &gt; u32::MAX</code>.</p>
<h5 id="examples-82"><a class="doc-anchor" href="#examples-82"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_ops)]

</span><span class="kw">let </span>one = NonZero::new(<span class="number">1u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u32</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(two, <span class="kw">unsafe </span>{ one.unchecked_add(<span class="number">1</span>) });</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_ops)%5D%0A%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u32)?;%0Alet+two+=+NonZero::new(2u32)?;%0A%0Aassert_eq!(two,+unsafe+%7B+one.unchecked_add(1)+%7D);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_next_power_of_two-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_next_power_of_two-2" class="fn">checked_next_power_of_two</a>(self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Returns the smallest power of two greater than or equal to <code>self</code>.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>
if the next power of two is greater than the types maximum value.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-83"><a class="doc-anchor" href="#examples-83"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>three = NonZero::new(<span class="number">3u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u32::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(two), two.checked_next_power_of_two() );
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(four), three.checked_next_power_of_two() );
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_next_power_of_two() );</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u32)?;%0Alet+three+=+NonZero::new(3u32)?;%0Alet+four+=+NonZero::new(4u32)?;%0Alet+max+=+NonZero::new(u32::MAX)?;%0A%0Aassert_eq!(Some(two),+two.checked_next_power_of_two()+);%0Aassert_eq!(Some(four),+three.checked_next_power_of_two()+);%0Aassert_eq!(None,+max.checked_next_power_of_two()+);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ilog2-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0, const since 1.67.0">1.67.0 (const: 1.67.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.ilog2-2" class="fn">ilog2</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the base 2 logarithm of the number, rounded down.</p>
<p>This is the same operation as
<a href="../primitive.u32.html#method.ilog2" title="method u32::ilog2"><code>u32::ilog2</code></a>,
except that it has no failure cases to worry about
since this value can never be zero.</p>
<h5 id="examples-84"><a class="doc-anchor" href="#examples-84"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::new(<span class="number">7u32</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">8u32</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">9u32</span>)<span class="question-mark">?</span>.ilog2(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::new(7u32)?.ilog2(),+2);%0Aassert_eq!(NonZero::new(8u32)?.ilog2(),+3);%0Aassert_eq!(NonZero::new(9u32)?.ilog2(),+3);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ilog10-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.67.0, const since 1.67.0">1.67.0 (const: 1.67.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.ilog10-2" class="fn">ilog10</a>(self) -&gt; <a class="primitive" href="../primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the base 10 logarithm of the number, rounded down.</p>
<p>This is the same operation as
<a href="../primitive.u32.html#method.ilog10" title="method u32::ilog10"><code>u32::ilog10</code></a>,
except that it has no failure cases to worry about
since this value can never be zero.</p>
<h5 id="examples-85"><a class="doc-anchor" href="#examples-85"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(NonZero::new(<span class="number">99u32</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">100u32</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(NonZero::new(<span class="number">101u32</span>)<span class="question-mark">?</span>.ilog10(), <span class="number">2</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Aassert_eq!(NonZero::new(99u32)?.ilog10(),+1);%0Aassert_eq!(NonZero::new(100u32)?.ilog10(),+2);%0Aassert_eq!(NonZero::new(101u32)?.ilog10(),+2);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.midpoint-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.85.0, const since 1.85.0">1.85.0 (const: 1.85.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.midpoint-2" class="fn">midpoint</a>(self, rhs: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the midpoint (average) between <code>self</code> and <code>rhs</code>.</p>
<p><code>midpoint(a, b)</code> is <code>(a + b) &gt;&gt; 1</code> as if it were performed in a
sufficiently-large signed integral type. This implies that the result is
always rounded towards negative infinity and that no overflow will ever occur.</p>
<h5 id="examples-86"><a class="doc-anchor" href="#examples-86"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = NonZero::new(<span class="number">1u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>two = NonZero::new(<span class="number">2u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u32</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(one.midpoint(four), two);
<span class="macro">assert_eq!</span>(four.midpoint(one), two);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+one+=+NonZero::new(1u32)?;%0Alet+two+=+NonZero::new(2u32)?;%0Alet+four+=+NonZero::new(4u32)?;%0A%0Aassert_eq!(one.midpoint(four),+two);%0Aassert_eq!(four.midpoint(one),+two);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_power_of_two-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.59.0, const since 1.59.0">1.59.0 (const: 1.59.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_power_of_two-2" class="fn">is_power_of_two</a>(self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.</p>
<p>On many architectures, this function can perform better than <code>is_power_of_two()</code>
on the underlying integer type, as special handling of zero can be avoided.</p>
<h5 id="examples-87"><a class="doc-anchor" href="#examples-87"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>eight = NonZero::new(<span class="number">8u32</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(eight.is_power_of_two());
<span class="kw">let </span>ten = NonZero::new(<span class="number">10u32</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!ten.is_power_of_two());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+eight+=+NonZero::new(8u32)?;%0Aassert!(eight.is_power_of_two());%0Alet+ten+=+NonZero::new(10u32)?;%0Aassert!(!ten.is_power_of_two());%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isqrt-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0, const since 1.84.0">1.84.0 (const: 1.84.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.isqrt-2" class="fn">isqrt</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Returns the square root of the number, rounded down.</p>
<h5 id="examples-88"><a class="doc-anchor" href="#examples-88"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ten = NonZero::new(<span class="number">10u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>three = NonZero::new(<span class="number">3u32</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(ten.isqrt(), three);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+ten+=+NonZero::new(10u32)?;%0Alet+three+=+NonZero::new(3u32)?;%0A%0Aassert_eq!(ten.isqrt(),+three);%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cast_signed-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.cast_signed-2" class="fn">cast_signed</a>(self) -&gt; <a class="struct" href="struct.NonZero.html" title="struct core::num::NonZero">NonZero</a>&lt;<a class="primitive" href="../primitive.i32.html">i32</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the bit pattern of <code>self</code> reinterpreted as a signed integer of the same size.</p>
<h5 id="examples-89"><a class="doc-anchor" href="#examples-89"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>n = NonZero::&lt;u32&gt;::MAX;

<span class="macro">assert_eq!</span>(n.cast_signed(), NonZero::new(-<span class="number">1i32</span>).unwrap());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::NonZero;%0A++++%0A++++let+n+=+NonZero::%3Cu32%3E::MAX;%0A++++%0A++++assert_eq!(n.cast_signed(),+NonZero::new(-1i32).unwrap());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_mul-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_mul-2" class="fn">checked_mul</a>(self, other: Self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Multiplies two non-zero integers together.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-90"><a class="doc-anchor" href="#examples-90"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u32::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(four), two.checked_mul(two));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, max.checked_mul(two));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u32)?;%0Alet+four+=+NonZero::new(4u32)?;%0Alet+max+=+NonZero::new(u32::MAX)?;%0A%0Aassert_eq!(Some(four),+two.checked_mul(two));%0Aassert_eq!(None,+max.checked_mul(two));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_mul-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_mul-2" class="fn">saturating_mul</a>(self, other: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Multiplies two non-zero integers together.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u32&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-91"><a class="doc-anchor" href="#examples-91"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = NonZero::new(<span class="number">2u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u32::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(four, two.saturating_mul(two));
<span class="macro">assert_eq!</span>(max, four.saturating_mul(max));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u32)?;%0Alet+four+=+NonZero::new(4u32)?;%0Alet+max+=+NonZero::new(u32::MAX)?;%0A%0Aassert_eq!(four,+two.saturating_mul(two));%0Aassert_eq!(max,+four.saturating_mul(max));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unchecked_mul-2" class="method"><a class="src rightside" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.unchecked_mul-2" class="fn">unchecked_mul</a>(self, other: Self) -&gt; Self</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji"></span><span>This is a nightly-only experimental API. (<code>nonzero_ops</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/84186">#84186</a>)</span></div></span></summary><div class="docblock"><p>Multiplies two non-zero integers together,
assuming overflow cannot occur.
Overflow is unchecked, and it is undefined behavior to overflow
<em>even if the result would wrap to a non-zero value</em>.
The behavior is undefined as soon as
<code>self * rhs &gt; u32::MAX</code>.</p>
<h5 id="examples-92"><a class="doc-anchor" href="#examples-92"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonzero_ops)]

</span><span class="kw">let </span>two = NonZero::new(<span class="number">2u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>four = NonZero::new(<span class="number">4u32</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(four, <span class="kw">unsafe </span>{ two.unchecked_mul(two) });</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonzero_ops)%5D%0A%0A%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+two+=+NonZero::new(2u32)?;%0Alet+four+=+NonZero::new(4u32)?;%0A%0Aassert_eq!(four,+unsafe+%7B+two.unchecked_mul(two)+%7D);%0ASome(())%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_pow-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.checked_pow-2" class="fn">checked_pow</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Raises non-zero value to an integer power.
Checks for overflow and returns <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on overflow.
As a consequence, the result cannot wrap to zero.</p>
<h5 id="examples-93"><a class="doc-anchor" href="#examples-93"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>three = NonZero::new(<span class="number">3u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>twenty_seven = NonZero::new(<span class="number">27u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>half_max = NonZero::new(u32::MAX / <span class="number">2</span>)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(twenty_seven), three.checked_pow(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, half_max.checked_pow(<span class="number">3</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+three+=+NonZero::new(3u32)?;%0Alet+twenty_seven+=+NonZero::new(27u32)?;%0Alet+half_max+=+NonZero::new(u32::MAX+/+2)?;%0A%0Aassert_eq!(Some(twenty_seven),+three.checked_pow(3));%0Aassert_eq!(None,+half_max.checked_pow(3));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_pow-2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.64.0, const since 1.64.0">1.64.0 (const: 1.64.0)</span>  <a class="src" href="../../src/core/num/nonzero.rs.html#2245-2255">Source</a></span><h4 class="code-header">pub const fn <a href="#method.saturating_pow-2" class="fn">saturating_pow</a>(self, other: <a class="primitive" href="../primitive.u32.html">u32</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Raise non-zero value to an integer power.
Return <a href="struct.NonZero.html#associatedconstant.MAX" title="associated constant core::num::NonZero::MAX"><code>NonZero::&lt;u32&gt;::MAX</code></a> on overflow.</p>
<h5 id="examples-94"><a class="doc-anchor" href="#examples-94"></a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>three = NonZero::new(<span class="number">3u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>twenty_seven = NonZero::new(<span class="number">27u32</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>max = NonZero::new(u32::MAX)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(twenty_seven, three.saturating_pow(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(max, max.saturating_pow(<span class="number">3</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::num::NonZero;%0A%0Afn+main()+%7B+test().unwrap();+%7D%0Afn+test()+-%3E+Option%3C()%3E+%7B%0Alet+three+=+NonZero::new(3u32)?;%0Alet+twenty_seven+=+NonZero::new(27u32)?;%0Alet+max+=+NonZero::new(u32::MAX)?;%0A%0Aassert_eq!(twenty_seven,+three.saturating_pow(3));%0Aassert_eq!(max,+max.saturating_pow(3));%0ASome(())%0A%7D&amp;edition=2024"></a></div></div></de