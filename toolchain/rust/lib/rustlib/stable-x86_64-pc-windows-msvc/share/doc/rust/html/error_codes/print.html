<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Error codes index</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Book listing all Rust error codes">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="error-index.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Error codes index</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-error-codes-index"><a class="header" href="#rust-error-codes-index">Rust error codes index</a></h1>
<p>This page lists all the error codes emitted by the Rust compiler.</p>
<ul>
<li><a href="./E0001.html">E0001</a></li>
<li><a href="./E0002.html">E0002</a></li>
<li><a href="./E0004.html">E0004</a></li>
<li><a href="./E0005.html">E0005</a></li>
<li><a href="./E0007.html">E0007</a></li>
<li><a href="./E0009.html">E0009</a></li>
<li><a href="./E0010.html">E0010</a></li>
<li><a href="./E0013.html">E0013</a></li>
<li><a href="./E0014.html">E0014</a></li>
<li><a href="./E0015.html">E0015</a></li>
<li><a href="./E0023.html">E0023</a></li>
<li><a href="./E0025.html">E0025</a></li>
<li><a href="./E0026.html">E0026</a></li>
<li><a href="./E0027.html">E0027</a></li>
<li><a href="./E0029.html">E0029</a></li>
<li><a href="./E0030.html">E0030</a></li>
<li><a href="./E0033.html">E0033</a></li>
<li><a href="./E0034.html">E0034</a></li>
<li><a href="./E0038.html">E0038</a></li>
<li><a href="./E0040.html">E0040</a></li>
<li><a href="./E0044.html">E0044</a></li>
<li><a href="./E0045.html">E0045</a></li>
<li><a href="./E0046.html">E0046</a></li>
<li><a href="./E0049.html">E0049</a></li>
<li><a href="./E0050.html">E0050</a></li>
<li><a href="./E0053.html">E0053</a></li>
<li><a href="./E0054.html">E0054</a></li>
<li><a href="./E0055.html">E0055</a></li>
<li><a href="./E0057.html">E0057</a></li>
<li><a href="./E0059.html">E0059</a></li>
<li><a href="./E0060.html">E0060</a></li>
<li><a href="./E0061.html">E0061</a></li>
<li><a href="./E0062.html">E0062</a></li>
<li><a href="./E0063.html">E0063</a></li>
<li><a href="./E0067.html">E0067</a></li>
<li><a href="./E0069.html">E0069</a></li>
<li><a href="./E0070.html">E0070</a></li>
<li><a href="./E0071.html">E0071</a></li>
<li><a href="./E0072.html">E0072</a></li>
<li><a href="./E0073.html">E0073</a></li>
<li><a href="./E0074.html">E0074</a></li>
<li><a href="./E0075.html">E0075</a></li>
<li><a href="./E0076.html">E0076</a></li>
<li><a href="./E0077.html">E0077</a></li>
<li><a href="./E0080.html">E0080</a></li>
<li><a href="./E0081.html">E0081</a></li>
<li><a href="./E0084.html">E0084</a></li>
<li><a href="./E0087.html">E0087</a></li>
<li><a href="./E0088.html">E0088</a></li>
<li><a href="./E0089.html">E0089</a></li>
<li><a href="./E0090.html">E0090</a></li>
<li><a href="./E0091.html">E0091</a></li>
<li><a href="./E0092.html">E0092</a></li>
<li><a href="./E0093.html">E0093</a></li>
<li><a href="./E0094.html">E0094</a></li>
<li><a href="./E0106.html">E0106</a></li>
<li><a href="./E0107.html">E0107</a></li>
<li><a href="./E0109.html">E0109</a></li>
<li><a href="./E0110.html">E0110</a></li>
<li><a href="./E0116.html">E0116</a></li>
<li><a href="./E0117.html">E0117</a></li>
<li><a href="./E0118.html">E0118</a></li>
<li><a href="./E0119.html">E0119</a></li>
<li><a href="./E0120.html">E0120</a></li>
<li><a href="./E0121.html">E0121</a></li>
<li><a href="./E0124.html">E0124</a></li>
<li><a href="./E0128.html">E0128</a></li>
<li><a href="./E0130.html">E0130</a></li>
<li><a href="./E0131.html">E0131</a></li>
<li><a href="./E0132.html">E0132</a></li>
<li><a href="./E0133.html">E0133</a></li>
<li><a href="./E0136.html">E0136</a></li>
<li><a href="./E0137.html">E0137</a></li>
<li><a href="./E0138.html">E0138</a></li>
<li><a href="./E0139.html">E0139</a></li>
<li><a href="./E0152.html">E0152</a></li>
<li><a href="./E0154.html">E0154</a></li>
<li><a href="./E0158.html">E0158</a></li>
<li><a href="./E0161.html">E0161</a></li>
<li><a href="./E0162.html">E0162</a></li>
<li><a href="./E0164.html">E0164</a></li>
<li><a href="./E0165.html">E0165</a></li>
<li><a href="./E0170.html">E0170</a></li>
<li><a href="./E0178.html">E0178</a></li>
<li><a href="./E0183.html">E0183</a></li>
<li><a href="./E0184.html">E0184</a></li>
<li><a href="./E0185.html">E0185</a></li>
<li><a href="./E0186.html">E0186</a></li>
<li><a href="./E0191.html">E0191</a></li>
<li><a href="./E0192.html">E0192</a></li>
<li><a href="./E0193.html">E0193</a></li>
<li><a href="./E0195.html">E0195</a></li>
<li><a href="./E0197.html">E0197</a></li>
<li><a href="./E0198.html">E0198</a></li>
<li><a href="./E0199.html">E0199</a></li>
<li><a href="./E0200.html">E0200</a></li>
<li><a href="./E0201.html">E0201</a></li>
<li><a href="./E0203.html">E0203</a></li>
<li><a href="./E0204.html">E0204</a></li>
<li><a href="./E0205.html">E0205</a></li>
<li><a href="./E0206.html">E0206</a></li>
<li><a href="./E0207.html">E0207</a></li>
<li><a href="./E0208.html">E0208</a></li>
<li><a href="./E0210.html">E0210</a></li>
<li><a href="./E0211.html">E0211</a></li>
<li><a href="./E0212.html">E0212</a></li>
<li><a href="./E0214.html">E0214</a></li>
<li><a href="./E0220.html">E0220</a></li>
<li><a href="./E0221.html">E0221</a></li>
<li><a href="./E0222.html">E0222</a></li>
<li><a href="./E0223.html">E0223</a></li>
<li><a href="./E0224.html">E0224</a></li>
<li><a href="./E0225.html">E0225</a></li>
<li><a href="./E0226.html">E0226</a></li>
<li><a href="./E0227.html">E0227</a></li>
<li><a href="./E0228.html">E0228</a></li>
<li><a href="./E0229.html">E0229</a></li>
<li><a href="./E0230.html">E0230</a></li>
<li><a href="./E0231.html">E0231</a></li>
<li><a href="./E0232.html">E0232</a></li>
<li><a href="./E0243.html">E0243</a></li>
<li><a href="./E0244.html">E0244</a></li>
<li><a href="./E0251.html">E0251</a></li>
<li><a href="./E0252.html">E0252</a></li>
<li><a href="./E0253.html">E0253</a></li>
<li><a href="./E0254.html">E0254</a></li>
<li><a href="./E0255.html">E0255</a></li>
<li><a href="./E0256.html">E0256</a></li>
<li><a href="./E0259.html">E0259</a></li>
<li><a href="./E0260.html">E0260</a></li>
<li><a href="./E0261.html">E0261</a></li>
<li><a href="./E0262.html">E0262</a></li>
<li><a href="./E0263.html">E0263</a></li>
<li><a href="./E0264.html">E0264</a></li>
<li><a href="./E0267.html">E0267</a></li>
<li><a href="./E0268.html">E0268</a></li>
<li><a href="./E0271.html">E0271</a></li>
<li><a href="./E0275.html">E0275</a></li>
<li><a href="./E0276.html">E0276</a></li>
<li><a href="./E0277.html">E0277</a></li>
<li><a href="./E0281.html">E0281</a></li>
<li><a href="./E0282.html">E0282</a></li>
<li><a href="./E0283.html">E0283</a></li>
<li><a href="./E0284.html">E0284</a></li>
<li><a href="./E0297.html">E0297</a></li>
<li><a href="./E0301.html">E0301</a></li>
<li><a href="./E0302.html">E0302</a></li>
<li><a href="./E0303.html">E0303</a></li>
<li><a href="./E0307.html">E0307</a></li>
<li><a href="./E0308.html">E0308</a></li>
<li><a href="./E0309.html">E0309</a></li>
<li><a href="./E0310.html">E0310</a></li>
<li><a href="./E0311.html">E0311</a></li>
<li><a href="./E0312.html">E0312</a></li>
<li><a href="./E0316.html">E0316</a></li>
<li><a href="./E0317.html">E0317</a></li>
<li><a href="./E0320.html">E0320</a></li>
<li><a href="./E0321.html">E0321</a></li>
<li><a href="./E0322.html">E0322</a></li>
<li><a href="./E0323.html">E0323</a></li>
<li><a href="./E0324.html">E0324</a></li>
<li><a href="./E0325.html">E0325</a></li>
<li><a href="./E0326.html">E0326</a></li>
<li><a href="./E0328.html">E0328</a></li>
<li><a href="./E0329.html">E0329</a></li>
<li><a href="./E0364.html">E0364</a></li>
<li><a href="./E0365.html">E0365</a></li>
<li><a href="./E0366.html">E0366</a></li>
<li><a href="./E0367.html">E0367</a></li>
<li><a href="./E0368.html">E0368</a></li>
<li><a href="./E0369.html">E0369</a></li>
<li><a href="./E0370.html">E0370</a></li>
<li><a href="./E0371.html">E0371</a></li>
<li><a href="./E0373.html">E0373</a></li>
<li><a href="./E0374.html">E0374</a></li>
<li><a href="./E0375.html">E0375</a></li>
<li><a href="./E0376.html">E0376</a></li>
<li><a href="./E0377.html">E0377</a></li>
<li><a href="./E0378.html">E0378</a></li>
<li><a href="./E0379.html">E0379</a></li>
<li><a href="./E0380.html">E0380</a></li>
<li><a href="./E0381.html">E0381</a></li>
<li><a href="./E0382.html">E0382</a></li>
<li><a href="./E0383.html">E0383</a></li>
<li><a href="./E0384.html">E0384</a></li>
<li><a href="./E0386.html">E0386</a></li>
<li><a href="./E0387.html">E0387</a></li>
<li><a href="./E0388.html">E0388</a></li>
<li><a href="./E0389.html">E0389</a></li>
<li><a href="./E0390.html">E0390</a></li>
<li><a href="./E0391.html">E0391</a></li>
<li><a href="./E0392.html">E0392</a></li>
<li><a href="./E0393.html">E0393</a></li>
<li><a href="./E0398.html">E0398</a></li>
<li><a href="./E0399.html">E0399</a></li>
<li><a href="./E0401.html">E0401</a></li>
<li><a href="./E0403.html">E0403</a></li>
<li><a href="./E0404.html">E0404</a></li>
<li><a href="./E0405.html">E0405</a></li>
<li><a href="./E0407.html">E0407</a></li>
<li><a href="./E0408.html">E0408</a></li>
<li><a href="./E0409.html">E0409</a></li>
<li><a href="./E0411.html">E0411</a></li>
<li><a href="./E0412.html">E0412</a></li>
<li><a href="./E0415.html">E0415</a></li>
<li><a href="./E0416.html">E0416</a></li>
<li><a href="./E0422.html">E0422</a></li>
<li><a href="./E0423.html">E0423</a></li>
<li><a href="./E0424.html">E0424</a></li>
<li><a href="./E0425.html">E0425</a></li>
<li><a href="./E0426.html">E0426</a></li>
<li><a href="./E0428.html">E0428</a></li>
<li><a href="./E0429.html">E0429</a></li>
<li><a href="./E0430.html">E0430</a></li>
<li><a href="./E0431.html">E0431</a></li>
<li><a href="./E0432.html">E0432</a></li>
<li><a href="./E0433.html">E0433</a></li>
<li><a href="./E0434.html">E0434</a></li>
<li><a href="./E0435.html">E0435</a></li>
<li><a href="./E0436.html">E0436</a></li>
<li><a href="./E0437.html">E0437</a></li>
<li><a href="./E0438.html">E0438</a></li>
<li><a href="./E0439.html">E0439</a></li>
<li><a href="./E0445.html">E0445</a></li>
<li><a href="./E0446.html">E0446</a></li>
<li><a href="./E0447.html">E0447</a></li>
<li><a href="./E0448.html">E0448</a></li>
<li><a href="./E0449.html">E0449</a></li>
<li><a href="./E0451.html">E0451</a></li>
<li><a href="./E0452.html">E0452</a></li>
<li><a href="./E0453.html">E0453</a></li>
<li><a href="./E0454.html">E0454</a></li>
<li><a href="./E0455.html">E0455</a></li>
<li><a href="./E0457.html">E0457</a></li>
<li><a href="./E0458.html">E0458</a></li>
<li><a href="./E0459.html">E0459</a></li>
<li><a href="./E0460.html">E0460</a></li>
<li><a href="./E0461.html">E0461</a></li>
<li><a href="./E0462.html">E0462</a></li>
<li><a href="./E0463.html">E0463</a></li>
<li><a href="./E0464.html">E0464</a></li>
<li><a href="./E0466.html">E0466</a></li>
<li><a href="./E0468.html">E0468</a></li>
<li><a href="./E0469.html">E0469</a></li>
<li><a href="./E0472.html">E0472</a></li>
<li><a href="./E0476.html">E0476</a></li>
<li><a href="./E0477.html">E0477</a></li>
<li><a href="./E0478.html">E0478</a></li>
<li><a href="./E0482.html">E0482</a></li>
<li><a href="./E0491.html">E0491</a></li>
<li><a href="./E0492.html">E0492</a></li>
<li><a href="./E0493.html">E0493</a></li>
<li><a href="./E0495.html">E0495</a></li>
<li><a href="./E0496.html">E0496</a></li>
<li><a href="./E0497.html">E0497</a></li>
<li><a href="./E0498.html">E0498</a></li>
<li><a href="./E0499.html">E0499</a></li>
<li><a href="./E0500.html">E0500</a></li>
<li><a href="./E0501.html">E0501</a></li>
<li><a href="./E0502.html">E0502</a></li>
<li><a href="./E0503.html">E0503</a></li>
<li><a href="./E0504.html">E0504</a></li>
<li><a href="./E0505.html">E0505</a></li>
<li><a href="./E0506.html">E0506</a></li>
<li><a href="./E0507.html">E0507</a></li>
<li><a href="./E0508.html">E0508</a></li>
<li><a href="./E0509.html">E0509</a></li>
<li><a href="./E0510.html">E0510</a></li>
<li><a href="./E0511.html">E0511</a></li>
<li><a href="./E0512.html">E0512</a></li>
<li><a href="./E0514.html">E0514</a></li>
<li><a href="./E0515.html">E0515</a></li>
<li><a href="./E0516.html">E0516</a></li>
<li><a href="./E0517.html">E0517</a></li>
<li><a href="./E0518.html">E0518</a></li>
<li><a href="./E0519.html">E0519</a></li>
<li><a href="./E0520.html">E0520</a></li>
<li><a href="./E0521.html">E0521</a></li>
<li><a href="./E0522.html">E0522</a></li>
<li><a href="./E0523.html">E0523</a></li>
<li><a href="./E0524.html">E0524</a></li>
<li><a href="./E0525.html">E0525</a></li>
<li><a href="./E0527.html">E0527</a></li>
<li><a href="./E0528.html">E0528</a></li>
<li><a href="./E0529.html">E0529</a></li>
<li><a href="./E0530.html">E0530</a></li>
<li><a href="./E0531.html">E0531</a></li>
<li><a href="./E0532.html">E0532</a></li>
<li><a href="./E0533.html">E0533</a></li>
<li><a href="./E0534.html">E0534</a></li>
<li><a href="./E0535.html">E0535</a></li>
<li><a href="./E0536.html">E0536</a></li>
<li><a href="./E0537.html">E0537</a></li>
<li><a href="./E0538.html">E0538</a></li>
<li><a href="./E0539.html">E0539</a></li>
<li><a href="./E0541.html">E0541</a></li>
<li><a href="./E0542.html">E0542</a></li>
<li><a href="./E0543.html">E0543</a></li>
<li><a href="./E0544.html">E0544</a></li>
<li><a href="./E0545.html">E0545</a></li>
<li><a href="./E0546.html">E0546</a></li>
<li><a href="./E0547.html">E0547</a></li>
<li><a href="./E0549.html">E0549</a></li>
<li><a href="./E0550.html">E0550</a></li>
<li><a href="./E0551.html">E0551</a></li>
<li><a href="./E0552.html">E0552</a></li>
<li><a href="./E0554.html">E0554</a></li>
<li><a href="./E0556.html">E0556</a></li>
<li><a href="./E0557.html">E0557</a></li>
<li><a href="./E0559.html">E0559</a></li>
<li><a href="./E0560.html">E0560</a></li>
<li><a href="./E0561.html">E0561</a></li>
<li><a href="./E0562.html">E0562</a></li>
<li><a href="./E0565.html">E0565</a></li>
<li><a href="./E0566.html">E0566</a></li>
<li><a href="./E0567.html">E0567</a></li>
<li><a href="./E0568.html">E0568</a></li>
<li><a href="./E0569.html">E0569</a></li>
<li><a href="./E0570.html">E0570</a></li>
<li><a href="./E0571.html">E0571</a></li>
<li><a href="./E0572.html">E0572</a></li>
<li><a href="./E0573.html">E0573</a></li>
<li><a href="./E0574.html">E0574</a></li>
<li><a href="./E0575.html">E0575</a></li>
<li><a href="./E0576.html">E0576</a></li>
<li><a href="./E0577.html">E0577</a></li>
<li><a href="./E0578.html">E0578</a></li>
<li><a href="./E0579.html">E0579</a></li>
<li><a href="./E0580.html">E0580</a></li>
<li><a href="./E0581.html">E0581</a></li>
<li><a href="./E0582.html">E0582</a></li>
<li><a href="./E0583.html">E0583</a></li>
<li><a href="./E0584.html">E0584</a></li>
<li><a href="./E0585.html">E0585</a></li>
<li><a href="./E0586.html">E0586</a></li>
<li><a href="./E0587.html">E0587</a></li>
<li><a href="./E0588.html">E0588</a></li>
<li><a href="./E0589.html">E0589</a></li>
<li><a href="./E0590.html">E0590</a></li>
<li><a href="./E0591.html">E0591</a></li>
<li><a href="./E0592.html">E0592</a></li>
<li><a href="./E0593.html">E0593</a></li>
<li><a href="./E0594.html">E0594</a></li>
<li><a href="./E0595.html">E0595</a></li>
<li><a href="./E0596.html">E0596</a></li>
<li><a href="./E0597.html">E0597</a></li>
<li><a href="./E0599.html">E0599</a></li>
<li><a href="./E0600.html">E0600</a></li>
<li><a href="./E0601.html">E0601</a></li>
<li><a href="./E0602.html">E0602</a></li>
<li><a href="./E0603.html">E0603</a></li>
<li><a href="./E0604.html">E0604</a></li>
<li><a href="./E0605.html">E0605</a></li>
<li><a href="./E0606.html">E0606</a></li>
<li><a href="./E0607.html">E0607</a></li>
<li><a href="./E0608.html">E0608</a></li>
<li><a href="./E0609.html">E0609</a></li>
<li><a href="./E0610.html">E0610</a></li>
<li><a href="./E0614.html">E0614</a></li>
<li><a href="./E0615.html">E0615</a></li>
<li><a href="./E0616.html">E0616</a></li>
<li><a href="./E0617.html">E0617</a></li>
<li><a href="./E0618.html">E0618</a></li>
<li><a href="./E0619.html">E0619</a></li>
<li><a href="./E0620.html">E0620</a></li>
<li><a href="./E0621.html">E0621</a></li>
<li><a href="./E0622.html">E0622</a></li>
<li><a href="./E0623.html">E0623</a></li>
<li><a href="./E0624.html">E0624</a></li>
<li><a href="./E0625.html">E0625</a></li>
<li><a href="./E0626.html">E0626</a></li>
<li><a href="./E0627.html">E0627</a></li>
<li><a href="./E0628.html">E0628</a></li>
<li><a href="./E0631.html">E0631</a></li>
<li><a href="./E0632.html">E0632</a></li>
<li><a href="./E0633.html">E0633</a></li>
<li><a href="./E0634.html">E0634</a></li>
<li><a href="./E0635.html">E0635</a></li>
<li><a href="./E0636.html">E0636</a></li>
<li><a href="./E0637.html">E0637</a></li>
<li><a href="./E0638.html">E0638</a></li>
<li><a href="./E0639.html">E0639</a></li>
<li><a href="./E0640.html">E0640</a></li>
<li><a href="./E0641.html">E0641</a></li>
<li><a href="./E0642.html">E0642</a></li>
<li><a href="./E0643.html">E0643</a></li>
<li><a href="./E0644.html">E0644</a></li>
<li><a href="./E0646.html">E0646</a></li>
<li><a href="./E0647.html">E0647</a></li>
<li><a href="./E0648.html">E0648</a></li>
<li><a href="./E0657.html">E0657</a></li>
<li><a href="./E0658.html">E0658</a></li>
<li><a href="./E0659.html">E0659</a></li>
<li><a href="./E0660.html">E0660</a></li>
<li><a href="./E0661.html">E0661</a></li>
<li><a href="./E0662.html">E0662</a></li>
<li><a href="./E0663.html">E0663</a></li>
<li><a href="./E0664.html">E0664</a></li>
<li><a href="./E0665.html">E0665</a></li>
<li><a href="./E0666.html">E0666</a></li>
<li><a href="./E0667.html">E0667</a></li>
<li><a href="./E0668.html">E0668</a></li>
<li><a href="./E0669.html">E0669</a></li>
<li><a href="./E0670.html">E0670</a></li>
<li><a href="./E0671.html">E0671</a></li>
<li><a href="./E0687.html">E0687</a></li>
<li><a href="./E0688.html">E0688</a></li>
<li><a href="./E0689.html">E0689</a></li>
<li><a href="./E0690.html">E0690</a></li>
<li><a href="./E0691.html">E0691</a></li>
<li><a href="./E0692.html">E0692</a></li>
<li><a href="./E0693.html">E0693</a></li>
<li><a href="./E0695.html">E0695</a></li>
<li><a href="./E0696.html">E0696</a></li>
<li><a href="./E0697.html">E0697</a></li>
<li><a href="./E0698.html">E0698</a></li>
<li><a href="./E0699.html">E0699</a></li>
<li><a href="./E0700.html">E0700</a></li>
<li><a href="./E0701.html">E0701</a></li>
<li><a href="./E0703.html">E0703</a></li>
<li><a href="./E0704.html">E0704</a></li>
<li><a href="./E0705.html">E0705</a></li>
<li><a href="./E0706.html">E0706</a></li>
<li><a href="./E0708.html">E0708</a></li>
<li><a href="./E0710.html">E0710</a></li>
<li><a href="./E0712.html">E0712</a></li>
<li><a href="./E0713.html">E0713</a></li>
<li><a href="./E0714.html">E0714</a></li>
<li><a href="./E0715.html">E0715</a></li>
<li><a href="./E0716.html">E0716</a></li>
<li><a href="./E0711.html">E0711</a></li>
<li><a href="./E0717.html">E0717</a></li>
<li><a href="./E0718.html">E0718</a></li>
<li><a href="./E0719.html">E0719</a></li>
<li><a href="./E0720.html">E0720</a></li>
<li><a href="./E0722.html">E0722</a></li>
<li><a href="./E0724.html">E0724</a></li>
<li><a href="./E0725.html">E0725</a></li>
<li><a href="./E0726.html">E0726</a></li>
<li><a href="./E0727.html">E0727</a></li>
<li><a href="./E0728.html">E0728</a></li>
<li><a href="./E0729.html">E0729</a></li>
<li><a href="./E0730.html">E0730</a></li>
<li><a href="./E0731.html">E0731</a></li>
<li><a href="./E0732.html">E0732</a></li>
<li><a href="./E0733.html">E0733</a></li>
<li><a href="./E0734.html">E0734</a></li>
<li><a href="./E0735.html">E0735</a></li>
<li><a href="./E0736.html">E0736</a></li>
<li><a href="./E0737.html">E0737</a></li>
<li><a href="./E0739.html">E0739</a></li>
<li><a href="./E0740.html">E0740</a></li>
<li><a href="./E0741.html">E0741</a></li>
<li><a href="./E0742.html">E0742</a></li>
<li><a href="./E0743.html">E0743</a></li>
<li><a href="./E0744.html">E0744</a></li>
<li><a href="./E0745.html">E0745</a></li>
<li><a href="./E0746.html">E0746</a></li>
<li><a href="./E0747.html">E0747</a></li>
<li><a href="./E0748.html">E0748</a></li>
<li><a href="./E0749.html">E0749</a></li>
<li><a href="./E0750.html">E0750</a></li>
<li><a href="./E0751.html">E0751</a></li>
<li><a href="./E0752.html">E0752</a></li>
<li><a href="./E0753.html">E0753</a></li>
<li><a href="./E0754.html">E0754</a></li>
<li><a href="./E0755.html">E0755</a></li>
<li><a href="./E0756.html">E0756</a></li>
<li><a href="./E0757.html">E0757</a></li>
<li><a href="./E0758.html">E0758</a></li>
<li><a href="./E0759.html">E0759</a></li>
<li><a href="./E0760.html">E0760</a></li>
<li><a href="./E0761.html">E0761</a></li>
<li><a href="./E0762.html">E0762</a></li>
<li><a href="./E0763.html">E0763</a></li>
<li><a href="./E0764.html">E0764</a></li>
<li><a href="./E0765.html">E0765</a></li>
<li><a href="./E0766.html">E0766</a></li>
<li><a href="./E0767.html">E0767</a></li>
<li><a href="./E0768.html">E0768</a></li>
<li><a href="./E0769.html">E0769</a></li>
<li><a href="./E0770.html">E0770</a></li>
<li><a href="./E0771.html">E0771</a></li>
<li><a href="./E0772.html">E0772</a></li>
<li><a href="./E0773.html">E0773</a></li>
<li><a href="./E0774.html">E0774</a></li>
<li><a href="./E0775.html">E0775</a></li>
<li><a href="./E0776.html">E0776</a></li>
<li><a href="./E0777.html">E0777</a></li>
<li><a href="./E0778.html">E0778</a></li>
<li><a href="./E0779.html">E0779</a></li>
<li><a href="./E0780.html">E0780</a></li>
<li><a href="./E0781.html">E0781</a></li>
<li><a href="./E0782.html">E0782</a></li>
<li><a href="./E0783.html">E0783</a></li>
<li><a href="./E0784.html">E0784</a></li>
<li><a href="./E0785.html">E0785</a></li>
<li><a href="./E0786.html">E0786</a></li>
<li><a href="./E0787.html">E0787</a></li>
<li><a href="./E0788.html">E0788</a></li>
<li><a href="./E0789.html">E0789</a></li>
<li><a href="./E0790.html">E0790</a></li>
<li><a href="./E0791.html">E0791</a></li>
<li><a href="./E0792.html">E0792</a></li>
<li><a href="./E0793.html">E0793</a></li>
<li><a href="./E0794.html">E0794</a></li>
<li><a href="./E0795.html">E0795</a></li>
<li><a href="./E0796.html">E0796</a></li>
<li><a href="./E0797.html">E0797</a></li>
<li><a href="./E0798.html">E0798</a></li>
<li><a href="./E0799.html">E0799</a></li>
<li><a href="./E0800.html">E0800</a></li>
<li><a href="./E0801.html">E0801</a></li>
<li><a href="./E0802.html">E0802</a></li>
<li><a href="./E0803.html">E0803</a></li>
<li><a href="./E0804.html">E0804</a></li>
<li><a href="./E0805.html">E0805</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0001"><a class="header" href="#error-code-e0001">Error code E0001</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error suggests that the expression arm corresponding to the noted pattern
will never be reached as for all possible values of the expression being
matched, one of the preceding patterns will match.</p>
<p>This means that perhaps some of the preceding patterns are too general, this
one is too specific or the ordering is incorrect.</p>
<p>For example, the following <code>match</code> block has too many arms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(0) {
    Some(bar) =&gt; {/* ... */}
    x =&gt; {/* ... */} // This handles the `None` case
    _ =&gt; {/* ... */} // All possible cases have already been handled
}
<span class="boring">}</span></code></pre></pre>
<p><code>match</code> blocks have their patterns matched in order, so, for example, putting
a wildcard arm above a more specific arm will make the latter arm irrelevant.</p>
<p>Ensure the ordering of the match arm is correct and remove any superfluous
arms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0002"><a class="header" href="#error-code-e0002">Error code E0002</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-1"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-1">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error indicates that an empty match expression is invalid because the type
it is matching on is non-empty (there exist values of this type). In safe code
it is impossible to create an instance of an empty type, so empty match
expressions are almost never desired. This error is typically fixed by adding
one or more cases to the match expression.</p>
<p>An example of an empty type is <code>enum Empty { }</code>. So, the following will work:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Empty {}

fn foo(x: Empty) {
    match x {
        // empty
    }
}
<span class="boring">}</span></code></pre></pre>
<p>However, this won't:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: Option&lt;String&gt;) {
    match x {
        // empty
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0004"><a class="header" href="#error-code-e0004">Error code E0004</a></h1>
<p>This error indicates that the compiler cannot guarantee a matching pattern for
one or more possible inputs to a match expression. Guaranteed matches are
required in order to assign values to match expressions, or alternatively,
determine the flow of execution.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0004"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered
    Terminator::TalkToMyHand =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>If you encounter this error you must alter your patterns so that every possible
value of the input type is matched. For types with a small number of variants
(like enums) you should probably cover all cases explicitly. Alternatively, the
underscore <code>_</code> wildcard pattern can be added after all other patterns to match
"anything else". Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x {
    Terminator::TalkToMyHand =&gt; {}
    Terminator::HastaLaVistaBaby =&gt; {}
}

// or:

match x {
    Terminator::TalkToMyHand =&gt; {}
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0005"><a class="header" href="#error-code-e0005">Error code E0005</a></h1>
<p>Patterns used to bind names must be irrefutable, that is, they must guarantee
that a name will be extracted in all cases.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0005"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(1);
let Some(y) = x;
// error: refutable pattern in local binding: `None` not covered
<span class="boring">}</span></code></pre></pre>
<p>If you encounter this error you probably need to use a <code>match</code> or <code>if let</code> to
deal with the possibility of failure. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(1);

match x {
    Some(y) =&gt; {
        // do something
    },
    None =&gt; {}
}

// or:

if let Some(y) = x {
    // do something
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0007"><a class="header" href="#error-code-e0007">Error code E0007</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-2"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-2">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error indicates that the bindings in a match arm would require a value to
be moved into more than one location, thus violating unique ownership. Code
like the following is invalid as it requires the entire <code>Option&lt;String&gt;</code> to be
moved into a variable called <code>op_string</code> while simultaneously requiring the
inner <code>String</code> to be moved into a variable called <code>s</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382"><span class="boring">#![allow(unused)]
</span>#![feature(bindings_after_at)]

<span class="boring">fn main() {
</span>let x = Some("s".to_string());

match x {
    op_string @ Some(s) =&gt; {}, // error: use of moved value
    None =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>See also the error E0303.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0009"><a class="header" href="#error-code-e0009">Error code E0009</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-3"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-3">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>In a pattern, all values that don't implement the <code>Copy</code> trait have to be bound
the same way. The goal here is to avoid binding simultaneously by-move and
by-ref.</p>
<p>This limitation may be removed in a future version of Rust.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(move_ref_pattern)]

<span class="boring">fn main() {
</span>struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {}, // error: cannot bind by-move and by-ref in the
                            //        same pattern
    None =&gt; panic!()
}
<span class="boring">}</span></code></pre></pre>
<p>You have two solutions:</p>
<p>Solution #1: Bind the pattern's values the same way.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((ref y, ref z)) =&gt; {},
    // or Some((y, z)) =&gt; {}
    None =&gt; panic!()
}
<span class="boring">}</span></code></pre></pre>
<p>Solution #2: Implement the <code>Copy</code> trait for the <code>X</code> structure.</p>
<p>However, please keep in mind that the first solution should be preferred.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {},
    None =&gt; panic!()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0010"><a class="header" href="#error-code-e0010">Error code E0010</a></h1>
<p>The value of statics and constants must be known at compile time, and they live
for the entire lifetime of a program. Creating a boxed value allocates memory on
the heap at runtime, and therefore cannot be done at compile time.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0010"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const CON : Vec&lt;i32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0013"><a class="header" href="#error-code-e0013">Error code E0013</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-4"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-4">Note: this error code is no longer emitted by the compiler</a></h4>
<p>Static and const variables can refer to other const variables. But a const
variable cannot refer to a static variable.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static X: i32 = 42;
const Y: i32 = X;
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>Y</code> cannot refer to <code>X</code>. To fix this, the value can be
extracted as a const and then used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const A: i32 = 42;
static X: i32 = A;
const Y: i32 = A;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0014"><a class="header" href="#error-code-e0014">Error code E0014</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-5"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-5">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Constants can only be initialized by a constant value or, in a future
version of Rust, a call to a const function. This error indicates the use
of a path (like a::b, or x) denoting something other than one of these
allowed items.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!
<span class="boring">}</span></code></pre></pre>
<p>To avoid it, you have to replace the non-constant value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: i32 = { const X : i32 = 0; X };
// or even:
const FOO2: i32 = { 0 }; // but brackets are useless here
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0015"><a class="header" href="#error-code-e0015">Error code E0015</a></h1>
<p>A non-<code>const</code> function was called in a <code>const</code> context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0015"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_some() -&gt; Option&lt;u8&gt; {
    Some(1)
}

// error: cannot call non-const function `create_some` in constants
const FOO: Option&lt;u8&gt; = create_some();
<span class="boring">}</span></code></pre></pre>
<p>All functions used in a <code>const</code> context (constant or static expression) must
be marked <code>const</code>.</p>
<p>To fix this error, you can declare <code>create_some</code> as a constant function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// declared as a `const` function:
const fn create_some() -&gt; Option&lt;u8&gt; {
    Some(1)
}

const FOO: Option&lt;u8&gt; = create_some(); // no error!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0023"><a class="header" href="#error-code-e0023">Error code E0023</a></h1>
<p>A pattern attempted to extract an incorrect number of fields from a variant.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0023"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

match x {
    Fruit::Apple(a) =&gt; {}, // error!
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>A pattern used to match against an enum variant must provide a sub-pattern for
each field of the enum variant.</p>
<p>Here the <code>Apple</code> variant has two fields, and should be matched against like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Correct.
match x {
    Fruit::Apple(a, b) =&gt; {},
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>Matching with the wrong number of fields has no sensible interpretation:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0023"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Incorrect.
match x {
    Fruit::Apple(a) =&gt; {},
    Fruit::Apple(a, b, c) =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>Check how many fields the enum was declared with and ensure that your pattern
uses the same number.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0025"><a class="header" href="#error-code-e0025">Error code E0025</a></h1>
<p>Each field of a struct can only be bound once in a pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0025">struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, a: y } = x;
    // error: field `a` bound multiple times in the pattern
}</code></pre></pre>
<p>Each occurrence of a field name binds the value of that field, so to fix this
error you will have to remove or alter the duplicate uses of the field name.
Perhaps you misspelled another field name? Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, b: y } = x; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0026"><a class="header" href="#error-code-e0026">Error code E0026</a></h1>
<p>A struct pattern attempted to extract a nonexistent field from a struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0026"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thing {
    x: u32,
    y: u32,
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, z } =&gt; {} // error: `Thing::z` field doesn't exist
}
<span class="boring">}</span></code></pre></pre>
<p>If you are using shorthand field patterns but want to refer to the struct field
by a different name, you should rename it explicitly. Struct fields are
identified by the name used before the colon <code>:</code> so struct patterns should
resemble the declaration of the struct type being matched.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thing {
    x: u32,
    y: u32,
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, y: z } =&gt; {} // we renamed `y` to `z`
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0027"><a class="header" href="#error-code-e0027">Error code E0027</a></h1>
<p>A pattern for a struct fails to specify a sub-pattern for every one of the
struct's fields.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0027"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: "Rusty".to_string(), age: 8 };

// This is incorrect.
match d {
    Dog { age: x } =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, ensure that each field from the struct's definition is
mentioned in the pattern, or use <code>..</code> to ignore unwanted fields. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: "Rusty".to_string(), age: 8 };

match d {
    Dog { name: ref n, age: x } =&gt; {}
}

// This is also correct (ignore unused fields).
match d {
    Dog { age: x, .. } =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0029"><a class="header" href="#error-code-e0029">Error code E0029</a></h1>
<p>Something other than numbers and characters has been used for a range.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0029"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let string = "salutations !";

// The ordering relation for strings cannot be evaluated at compile time,
// so this doesn't work:
match string {
    "hello" ..= "world" =&gt; {}
    _ =&gt; {}
}

// This is a more general version, using a guard:
match string {
    s if s &gt;= "hello" &amp;&amp; s &lt;= "world" =&gt; {}
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>In a match expression, only numbers and characters can be matched against a
range. This is because the compiler checks that the range is non-empty at
compile-time, and is unable to evaluate arbitrary comparison functions. If you
want to capture values of an orderable type between two end-points, you can use
a guard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0030"><a class="header" href="#error-code-e0030">Error code E0030</a></h1>
<p>When matching against a range, the compiler verifies that the range is
non-empty. Range patterns include both end-points, so this is equivalent to
requiring the start of the range to be less than or equal to the end of the
range.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0030"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match 5u32 {
    // This range is ok, albeit pointless.
    1 ..= 1 =&gt; {}
    // This range is empty, and the compiler can tell.
    1000 ..= 5 =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0033"><a class="header" href="#error-code-e0033">Error code E0033</a></h1>
<p>A trait type has been dereferenced.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0033"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait SomeTrait { fn method_one(&amp;self){} fn method_two(&amp;self){} }
</span><span class="boring">impl&lt;T&gt; SomeTrait for T {}
</span>let trait_obj: &amp;SomeTrait = &amp;"some_value";

// This tries to implicitly dereference to create an unsized local variable.
let &amp;invalid = trait_obj;

// You can call methods without binding to the value being pointed at.
trait_obj.method_one();
trait_obj.method_two();
<span class="boring">}</span></code></pre></pre>
<p>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every
trait defines a type, but because the size of trait implementers isn't fixed,
this type has no compile-time size. Therefore, all accesses to trait types must
be through pointers. If you encounter this error you should try to avoid
dereferencing the pointer.</p>
<p>You can read more about trait objects in the <a href="https://doc.rust-lang.org/reference/types.html#trait-objects">Trait Objects</a> section of the
Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0034"><a class="header" href="#error-code-e0034">Error code E0034</a></h1>
<p>The compiler doesn't know what method to call because more than one method
has the same prototype.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0034">struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    Test::foo() // error, which foo() to call?
}</code></pre></pre>
<p>To avoid this error, you have to keep only one of them and remove the others.
So let's take our example and fix it:</p>
<pre><pre class="playground"><code class="language-rust">struct Test;

trait Trait1 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }

fn main() {
    Test::foo() // and now that's good!
}</code></pre></pre>
<p>However, a better solution would be using fully explicit naming of type and
trait:</p>
<pre><pre class="playground"><code class="language-rust">struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    &lt;Test as Trait1&gt;::foo()
}</code></pre></pre>
<p>One last example:</p>
<pre><pre class="playground"><code class="language-rust">trait F {
    fn m(&amp;self);
}

trait G {
    fn m(&amp;self);
}

struct X;

impl F for X { fn m(&amp;self) { println!("I am F"); } }
impl G for X { fn m(&amp;self) { println!("I am G"); } }

fn main() {
    let f = X;

    F::m(&amp;f); // it displays "I am F"
    G::m(&amp;f); // it displays "I am G"
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0038"><a class="header" href="#error-code-e0038">Error code E0038</a></h1>
<p>For any given trait <code>Trait</code> there may be a related <em>type</em> called the <em>trait
object type</em> which is typically written as <code>dyn Trait</code>. In earlier editions of
Rust, trait object types were written as plain <code>Trait</code> (just the name of the
trait, written in type positions) but this was a bit too confusing, so we now
write <code>dyn Trait</code>.</p>
<p>Some traits are not allowed to be used as trait object types. The traits that
are allowed to be used as trait object types are called "dyn-compatible"<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>
traits. Attempting to use a trait object type for a trait that is not
dyn-compatible will trigger error E0038.</p>
<p>Two general aspects of trait object types give rise to the restrictions:</p>
<ol>
<li>
<p>Trait object types are dynamically sized types (DSTs), and trait objects of
these types can only be accessed through pointers, such as <code>&amp;dyn Trait</code> or
<code>Box&lt;dyn Trait&gt;</code>. The size of such a pointer is known, but the size of the
<code>dyn Trait</code> object pointed-to by the pointer is <em>opaque</em> to code working
with it, and different trait objects with the same trait object type may
have different sizes.</p>
</li>
<li>
<p>The pointer used to access a trait object is paired with an extra pointer
to a "virtual method table" or "vtable", which is used to implement dynamic
dispatch to the object's implementations of the trait's methods. There is a
single such vtable for each trait implementation, but different trait
objects with the same trait object type may point to vtables from different
implementations.</p>
</li>
</ol>
<p>The specific conditions that violate dyn-compatibility follow, most of which
relate to missing size information and vtable polymorphism arising from these
aspects.</p>
<h3 id="the-trait-requires-self-sized"><a class="header" href="#the-trait-requires-self-sized">The trait requires <code>Self: Sized</code></a></h3>
<p>Traits that are declared as <code>Trait: Sized</code> or which otherwise inherit a
constraint of <code>Self:Sized</code> are not dyn-compatible.</p>
<p>The reasoning behind this is somewhat subtle. It derives from the fact that Rust
requires (and defines) that every trait object type <code>dyn Trait</code> automatically
implements <code>Trait</code>. Rust does this to simplify error reporting and ease
interoperation between static and dynamic polymorphism. For example, this code
works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
}

fn static_foo&lt;T:Trait + ?Sized&gt;(b: &amp;T) {
}

fn dynamic_bar(a: &amp;dyn Trait) {
    static_foo(a)
}
<span class="boring">}</span></code></pre></pre>
<p>This code works because <code>dyn Trait</code>, if it exists, always implements <code>Trait</code>.</p>
<p>However as we know, any <code>dyn Trait</code> is also unsized, and so it can never
implement a sized trait like <code>Trait:Sized</code>. So, rather than allow an exception
to the rule that <code>dyn Trait</code> always implements <code>Trait</code>, Rust chooses to prohibit
such a <code>dyn Trait</code> from existing at all.</p>
<p>Only unsized traits are considered dyn-compatible.</p>
<p>Generally, <code>Self: Sized</code> is used to indicate that the trait should not be used
as a trait object. If the trait comes from your own crate, consider removing
this restriction.</p>
<h3 id="method-references-the-self-type-in-its-parameters-or-return-type"><a class="header" href="#method-references-the-self-type-in-its-parameters-or-return-type">Method references the <code>Self</code> type in its parameters or return type</a></h3>
<p>This happens when a trait has a method like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

impl Trait for String {
    fn foo(&amp;self) -&gt; Self {
        "hi".to_owned()
    }
}

impl Trait for u8 {
    fn foo(&amp;self) -&gt; Self {
        1
    }
}
<span class="boring">}</span></code></pre></pre>
<p>(Note that <code>&amp;self</code> and <code>&amp;mut self</code> are okay, it's additional <code>Self</code> types which
cause this problem.)</p>
<p>In such a case, the compiler cannot predict the return type of <code>foo()</code> in a
situation like the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

fn call_foo(x: Box&lt;dyn Trait&gt;) {
    let y = x.foo(); // What type is y?
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>If only some methods aren't dyn-compatible, you can add a <code>where Self: Sized</code>
bound on them to mark them as explicitly unavailable to trait objects. The
functionality will still be available to all other implementers, including
<code>Box&lt;dyn Trait&gt;</code> which is itself sized (assuming you <code>impl Trait for Box&lt;dyn Trait&gt;</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self where Self: Sized;
    // more functions
}
<span class="boring">}</span></code></pre></pre>
<p>Now, <code>foo()</code> can no longer be called on a trait object, but you will now be
allowed to make a trait object, and that will be able to call any dyn-compatible
methods. With such a bound, one can still call <code>foo()</code> on types implementing
that trait that aren't behind trait objects.</p>
<h3 id="method-has-generic-type-parameters"><a class="header" href="#method-has-generic-type-parameters">Method has generic type parameters</a></h3>
<p>As mentioned before, trait objects contain pointers to method tables. So, if we
have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self);
}

impl Trait for String {
    fn foo(&amp;self) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo(&amp;self) {
        // implementation 2
    }
}
// ...
<span class="boring">}</span></code></pre></pre>
<p>At compile time each implementation of <code>Trait</code> will produce a table containing
the various methods (and other items) related to the implementation, which will
be used as the virtual method table for a <code>dyn Trait</code> object derived from that
implementation.</p>
<p>This works fine, but when the method gains generic parameters, we can have a
problem.</p>
<p>Usually, generic parameters get <em>monomorphized</em>. For example, if I have</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The machine code for <code>foo::&lt;u8&gt;()</code>, <code>foo::&lt;bool&gt;()</code>, <code>foo::&lt;String&gt;()</code>, or any
other instantiation is different. Hence the compiler generates the
implementation on-demand. If you call <code>foo()</code> with a <code>bool</code> parameter, the
compiler will only generate code for <code>foo::&lt;bool&gt;()</code>. When we have additional
type parameters, the number of monomorphized implementations the compiler
generates does not grow drastically, since the compiler will only generate an
implementation if the function is called with fully concrete arguments
(i.e., arguments which do not contain any generic parameters).</p>
<p>However, with trait objects we have to make a table containing <em>every</em> object
that implements the trait. Now, if it has type parameters, we need to add
implementations for every type that implements the trait, and there could
theoretically be an infinite number of types.</p>
<p>For example, with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T);
    // more methods
}

impl Trait for String {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 2
    }
}

// 8 more implementations
<span class="boring">}</span></code></pre></pre>
<p>Now, if we have the following code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait { fn foo&lt;T&gt;(&amp;self, on: T); }
</span><span class="boring">impl Trait for String { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">impl Trait for u8 { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">impl Trait for bool { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">// etc.
</span>fn call_foo(thing: Box&lt;dyn Trait&gt;) {
    thing.foo(true); // this could be any one of the 8 types above
    thing.foo(1);
    thing.foo("hello");
}
<span class="boring">}</span></code></pre></pre>
<p>We don't just need to create a table of all implementations of all methods of
<code>Trait</code>, we need to create such a table, for each different type fed to
<code>foo()</code>. In this case this turns out to be (10 types implementing <code>Trait</code>)*(3
types being fed to <code>foo()</code>) = 30 implementations!</p>
<p>With real world traits these numbers can grow drastically.</p>
<p>To fix this, it is suggested to use a <code>where Self: Sized</code> bound similar to the
fix for the sub-error above if you do not intend to call the method with type
parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T) where Self: Sized;
    // more methods
}
<span class="boring">}</span></code></pre></pre>
<p>If this is not an option, consider replacing the type parameter with another
trait object (e.g., if <code>T: OtherTrait</code>, use <code>on: Box&lt;dyn OtherTrait&gt;</code>). If the
number of types you intend to feed to this method is limited, consider manually
listing out the methods of different types.</p>
<h3 id="method-has-no-receiver"><a class="header" href="#method-has-no-receiver">Method has no receiver</a></h3>
<p>Methods that do not take a <code>self</code> parameter can't be called since there won't be
a way to get a pointer to the method table for them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo() -&gt; u8;
}
<span class="boring">}</span></code></pre></pre>
<p>This could be called as <code>&lt;Foo as Foo&gt;::foo()</code>, which would not be able to pick
an implementation.</p>
<p>Adding a <code>Self: Sized</code> bound to these methods will generally make this compile.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo() -&gt; u8 where Self: Sized;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-contains-associated-constants"><a class="header" href="#trait-contains-associated-constants">Trait contains associated constants</a></h3>
<p>Just like static functions, associated constants aren't stored on the method
table. If the trait or any subtrait contain an associated constant, they are not
dyn compatible.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const X: i32;
}

impl dyn Foo {}
<span class="boring">}</span></code></pre></pre>
<p>A simple workaround is to use a helper method instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn x(&amp;self) -&gt; i32;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-uses-self-as-a-type-parameter-in-the-supertrait-listing"><a class="header" href="#trait-uses-self-as-a-type-parameter-in-the-supertrait-listing">Trait uses <code>Self</code> as a type parameter in the supertrait listing</a></h3>
<p>This is similar to the second sub-error, but subtler. It happens in situations
like the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038">trait Super&lt;A: ?Sized&gt; {}

trait Trait: Super&lt;Self&gt; {
}

struct Foo;

impl Super&lt;Foo&gt; for Foo{}

impl Trait for Foo {}

fn main() {
    let x: Box&lt;dyn Trait&gt;;
}</code></pre></pre>
<p>Here, the supertrait might have methods as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Super&lt;A: ?Sized&gt; {
    fn get_a(&amp;self) -&gt; &amp;A; // note that this is dyn-compatible!
}
<span class="boring">}</span></code></pre></pre>
<p>If the trait <code>Trait</code> was deriving from something like <code>Super&lt;String&gt;</code> or
<code>Super&lt;T&gt;</code> (where <code>Foo</code> itself is <code>Foo&lt;T&gt;</code>), this is okay, because given a type
<code>get_a()</code> will definitely return an object of that type.</p>
<p>However, if it derives from <code>Super&lt;Self&gt;</code>, even though <code>Super</code> is
dyn-compatible, the method <code>get_a()</code> would return an object of unknown type when
called on the function. <code>Self</code> type parameters let us make dyn-compatible traits
no longer compatible, so they are forbidden when specifying supertraits.</p>
<p>There's no easy fix for this. Generally, code will need to be refactored so that
you no longer need to derive from <code>Super&lt;Self&gt;</code>.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Formerly known as "object-safe". <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0040"><a class="header" href="#error-code-e0040">Error code E0040</a></h1>
<p>It is not allowed to manually call destructors in Rust.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0040">struct Foo {
    x: i32,
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("kaboom");
    }
}

fn main() {
    let mut x = Foo { x: -7 };
    x.drop(); // error: explicit use of destructor method
}</code></pre></pre>
<p>It is unnecessary to do this since <code>drop</code> is called automatically whenever a
value goes out of scope. However, if you really need to drop a value by hand,
you can use the <code>std::mem::drop</code> function:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("kaboom");
    }
}
fn main() {
    let mut x = Foo { x: -7 };
    drop(x); // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0044"><a class="header" href="#error-code-e0044">Error code E0044</a></h1>
<p>You cannot use type or const parameters on foreign items.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0044"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" { fn some_func&lt;T&gt;(x: T); }
<span class="boring">}</span></code></pre></pre>
<p>To fix this, replace the generic parameter with the specializations that you
need:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" { fn some_func_i32(x: i32); }
extern "C" { fn some_func_i64(x: i64); }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0045"><a class="header" href="#error-code-e0045">Error code E0045</a></h1>
<p>Variadic parameters have been used on a non-C ABI function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0045"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "Rust" {
    fn foo(x: u8, ...); // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Rust only supports variadic parameters for interoperability with C code in its
FFI. As such, variadic parameters can only be used with functions which are
using the C ABI. To fix such code, put them in an extern "C" block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    fn foo (x: u8, ...);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0046"><a class="header" href="#error-code-e0046">Error code E0046</a></h1>
<p>Items are missing in a trait implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0046"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {}
// error: not all trait items implemented, missing: `foo`
<span class="boring">}</span></code></pre></pre>
<p>When trying to make some type implement a trait <code>Foo</code>, you must, at minimum,
provide implementations for all of <code>Foo</code>'s required methods (meaning the
methods that do not have default implementations), as well as any required
trait items like associated types or constants. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    fn foo() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0049"><a class="header" href="#error-code-e0049">Error code E0049</a></h1>
<p>An attempted implementation of a trait method has the wrong number of type or
const parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0049"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;
}

struct Bar;

// error: method `foo` has 0 type parameters but its trait declaration has 1
// type parameter
impl Foo for Bar {
    fn foo(x: bool) -&gt; Self { Bar }
}
<span class="boring">}</span></code></pre></pre>
<p>For example, the <code>Foo</code> trait has a method <code>foo</code> with a type parameter <code>T</code>,
but the implementation of <code>foo</code> for the type <code>Bar</code> is missing this parameter.
To fix this error, they must have the same type parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;
}

struct Bar;

impl Foo for Bar {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self { // ok!
        Bar
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0050"><a class="header" href="#error-code-e0050">Error code E0050</a></h1>
<p>An attempted implementation of a trait method has the wrong number of function
parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0050"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, x: u8) -&gt; bool;
}

struct Bar;

// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`
// has 2
impl Foo for Bar {
    fn foo(&amp;self) -&gt; bool { true }
}
<span class="boring">}</span></code></pre></pre>
<p>For example, the <code>Foo</code> trait has a method <code>foo</code> with two function parameters
(<code>&amp;self</code> and <code>u8</code>), but the implementation of <code>foo</code> for the type <code>Bar</code> omits
the <code>u8</code> parameter. To fix this error, they must have the same parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, x: u8) -&gt; bool;
}

struct Bar;

impl Foo for Bar {
    fn foo(&amp;self, x: u8) -&gt; bool { // ok!
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0053"><a class="header" href="#error-code-e0053">Error code E0053</a></h1>
<p>The parameters of any trait method must match between a trait implementation
and the trait definition.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0053"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(x: u16);
    fn bar(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, expected u16, found i16
    fn foo(x: i16) { }

    // error, types differ in mutability
    fn bar(&amp;mut self) { }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0054"><a class="header" href="#error-code-e0054">Error code E0054</a></h1>
<p>It is not allowed to cast to a bool.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0054"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

// Not allowed, won't compile
let x_is_nonzero = x as bool;
<span class="boring">}</span></code></pre></pre>
<p>If you are trying to cast a numeric type to a bool, you can compare it with
zero instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

// Ok
let x_is_nonzero = x != 0;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0055"><a class="header" href="#error-code-e0055">Error code E0055</a></h1>
<p>During a method call, a value is automatically dereferenced as many times as
needed to make the value's type match the method's receiver. The catch is that
the compiler will only attempt to dereference a number of times up to the
recursion limit (which can be set via the <code>recursion_limit</code> attribute).</p>
<p>For a somewhat artificial example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0055">#![recursion_limit="4"]

struct Foo;

impl Foo {
    fn foo(&amp;self) {}
}

fn main() {
    let foo = Foo;
    let ref_foo = &amp;&amp;&amp;&amp;&amp;Foo;

    // error, reached the recursion limit while auto-dereferencing `&amp;&amp;&amp;&amp;&amp;Foo`
    ref_foo.foo();
}</code></pre></pre>
<p>One fix may be to increase the recursion limit. Note that it is possible to
create an infinite recursion of dereferencing, in which case the only fix is to
somehow break the recursion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0057"><a class="header" href="#error-code-e0057">Error code E0057</a></h1>
<p>An invalid number of arguments was given when calling a closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0057"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = |x| x * 3;
let a = f();        // invalid, too few parameters
let b = f(4);       // this works!
let c = f(2, 3);    // invalid, too many parameters
<span class="boring">}</span></code></pre></pre>
<p>When invoking closures or other implementations of the function traits <code>Fn</code>,
<code>FnMut</code> or <code>FnOnce</code> using call notation, the number of parameters passed to the
function must match its definition.</p>
<p>A generic function must be treated similarly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;F: Fn()&gt;(f: F) {
    f(); // this is valid, but f(3) would not work
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0059"><a class="header" href="#error-code-e0059">Error code E0059</a></h1>
<p>The built-in function traits are generic over a tuple of the function arguments.
If one uses angle-bracket notation (<code>Fn&lt;(T,), Output=U&gt;</code>) instead of parentheses
(<code>Fn(T) -&gt; U</code>) to denote the function trait, the type parameter should be a
tuple. Otherwise function call notation cannot be used and the trait will not be
implemented by closures.</p>
<p>The most likely source of this error is using angle-bracket notation without
wrapping the function argument type into a tuple, for example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0059"><span class="boring">#![allow(unused)]
</span>#![feature(unboxed_closures)]

<span class="boring">fn main() {
</span>fn foo&lt;F: Fn&lt;i32&gt;&gt;(f: F) -&gt; F::Output { f(3) }
<span class="boring">}</span></code></pre></pre>
<p>It can be fixed by adjusting the trait bound like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(unboxed_closures)]

<span class="boring">fn main() {
</span>fn foo&lt;F: Fn&lt;(i32,)&gt;&gt;(f: F) -&gt; F::Output { f(3) }
<span class="boring">}</span></code></pre></pre>
<p>Note that <code>(T,)</code> always denotes the type of a 1-tuple containing an element of
type <code>T</code>. The comma is necessary for syntactic disambiguation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0060"><a class="header" href="#error-code-e0060">Error code E0060</a></h1>
<p>External C functions are allowed to be variadic. However, a variadic function
takes a minimum number of arguments. For example, consider C's variadic <code>printf</code>
function:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0060"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::os::raw::{c_char, c_int};

extern "C" {
    fn printf(_: *const c_char, ...) -&gt; c_int;
}

unsafe { printf(); } // error!
<span class="boring">}</span></code></pre></pre>
<p>Using this declaration, it must be called with at least one argument, so
simply calling <code>printf()</code> is invalid. But the following uses are allowed:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::os::raw::{c_char, c_int};
</span><span class="boring">#[cfg_attr(all(windows, target_env = "msvc"),
</span><span class="boring">           link(name = "legacy_stdio_definitions",
</span><span class="boring">                kind = "static", modifiers = "-bundle"))]
</span><span class="boring">extern "C" { fn printf(_: *const c_char, ...) -&gt; c_int; }
</span><span class="boring">fn main() {
</span>unsafe {
    printf(c"test\n".as_ptr());

    printf(c"number = %d\n".as_ptr(), 3);

    printf(c"%d, %d\n".as_ptr(), 10, 5);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0061"><a class="header" href="#error-code-e0061">Error code E0061</a></h1>
<p>An invalid number of arguments was passed when calling a function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0061"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(u: i32) {}

f(); // error!
<span class="boring">}</span></code></pre></pre>
<p>The number of arguments passed to a function must match the number of arguments
specified in the function signature.</p>
<p>For example, a function like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(a: u16, b: &amp;str) {}
<span class="boring">}</span></code></pre></pre>
<p>Must always be called with exactly two arguments, e.g., <code>f(2, "test")</code>.</p>
<p>Note that Rust does not have a notion of optional function arguments or
variadic functions (except for its C-FFI).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0062"><a class="header" href="#error-code-e0062">Error code E0062</a></h1>
<p>A struct's or struct-like enum variant's field was specified more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0062">struct Foo {
    x: i32,
}

fn main() {
    let x = Foo {
                x: 0,
                x: 0, // error: field `x` specified more than once
            };
}</code></pre></pre>
<p>This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was specified more than once. Each field should
be specified exactly one time. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
}

fn main() {
    let x = Foo { x: 0 }; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0063"><a class="header" href="#error-code-e0063">Error code E0063</a></h1>
<p>A struct's or struct-like enum variant's field was not provided.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0063">struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0 }; // error: missing field: `y`
}</code></pre></pre>
<p>Each field should be specified exactly once. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0, y: 0 }; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0067"><a class="header" href="#error-code-e0067">Error code E0067</a></h1>
<p>An invalid left-hand side expression was used on an assignment operation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0067"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>12 += 1; // error!
<span class="boring">}</span></code></pre></pre>
<p>You need to have a place expression to be able to assign it something. For
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x: i8 = 12;
x += 1; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0069"><a class="header" href="#error-code-e0069">Error code E0069</a></h1>
<p>The compiler found a function whose body contains a <code>return;</code> statement but
whose return type is not <code>()</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0069"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error
fn foo() -&gt; u8 {
    return;
}
<span class="boring">}</span></code></pre></pre>
<p>Since <code>return;</code> is just like <code>return ();</code>, there is a mismatch between the
function's return type and the value being returned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0070"><a class="header" href="#error-code-e0070">Error code E0070</a></h1>
<p>An assignment operator was used on a non-place expression.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0070"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    x: i32,
    y: i32,
}

const SOME_CONST: i32 = 12;

fn some_other_func() {}

fn some_function() {
    SOME_CONST = 14; // error: a constant value cannot be changed!
    1 = 3; // error: 1 isn't a valid place!
    some_other_func() = 4; // error: we cannot assign value to a function!
    SomeStruct::x = 12; // error: SomeStruct a structure name but it is used
                        //        like a variable!
}
<span class="boring">}</span></code></pre></pre>
<p>The left-hand side of an assignment operator must be a place expression. A
place expression represents a memory location and can be a variable (with
optional namespacing), a dereference, an indexing expression or a field
reference.</p>
<p>More details can be found in the <a href="https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries">Expressions</a> section of the Reference.</p>
<p>And now let's give working examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    x: i32,
    y: i32,
}
let mut s = SomeStruct { x: 0, y: 0 };

s.x = 3; // that's good !

// ...

fn some_func(x: &amp;mut i32) {
    *x = 12; // that's good !
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0071"><a class="header" href="#error-code-e0071">Error code E0071</a></h1>
<p>A structure-literal syntax was used to create an item that is not a structure
or enum variant.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0071"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type U32 = u32;
let t = U32 { value: 4 }; // error: expected struct, variant or union type,
                          // found builtin type `u32`
<span class="boring">}</span></code></pre></pre>
<p>To fix this, ensure that the name was correctly spelled, and that the correct
form of initializer was used.</p>
<p>For example, the code above can be fixed to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type U32 = u32;
let t: U32 = 4;
<span class="boring">}</span></code></pre></pre>
<p>or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct U32 { value: u32 }
let t = U32 { value: 4 };
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0072"><a class="header" href="#error-code-e0072">Error code E0072</a></h1>
<p>A recursive type has infinite size because it doesn't have an indirection.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0072"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ListNode {
    head: u8,
    tail: Option&lt;ListNode&gt;, // error: no indirection here so impossible to
                            //        compute the type's size
}
<span class="boring">}</span></code></pre></pre>
<p>When defining a recursive struct or enum, any use of the type being defined
from inside the definition must occur behind a pointer (like <code>Box</code>, <code>&amp;</code> or
<code>Rc</code>). This is because structs and enums must have a well-defined size, and
without the pointer, the size of the type would need to be unbounded.</p>
<p>In the example, the type cannot have a well-defined size, because it needs to be
arbitrarily large (since we would be able to nest <code>ListNode</code>s to any depth).
Specifically,</p>
<pre><code class="language-plain">size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
</code></pre>
<p>One way to fix this is by wrapping <code>ListNode</code> in a <code>Box</code>, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ListNode {
    head: u8,
    tail: Option&lt;Box&lt;ListNode&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This works because <code>Box</code> is a pointer, so its size is well-known.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0073"><a class="header" href="#error-code-e0073">Error code E0073</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-6"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-6">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You cannot define a struct (or enum) <code>Foo</code> that requires an instance of <code>Foo</code>
in order to make a new <code>Foo</code> value. This is because there would be no way a
first instance of <code>Foo</code> could be made to initialize another instance!</p>
<p>Here's an example of a struct that has this problem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { x: Box&lt;Foo&gt; } // error
<span class="boring">}</span></code></pre></pre>
<p>One fix is to use <code>Option</code>, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { x: Option&lt;Box&lt;Foo&gt;&gt; }
<span class="boring">}</span></code></pre></pre>
<p>Now it's possible to create at least one instance of <code>Foo</code>: <code>Foo { x: None }</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0074"><a class="header" href="#error-code-e0074">Error code E0074</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-7"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-7">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>When using the <code>#[simd]</code> attribute on a tuple struct, the components of the
tuple struct must all be of a concrete, nongeneric type so the compiler can
reason about how to use SIMD with them. This error will occur if the types
are generic.</p>
<p>This will cause an error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad&lt;T&gt;([T; 4]);
<span class="boring">}</span></code></pre></pre>
<p>This will not:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Good([u32; 4]);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0075"><a class="header" href="#error-code-e0075">Error code E0075</a></h1>
<p>A <code>#[simd]</code> attribute was applied to an empty or multi-field struct.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0075"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad; // error!
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0075"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad([u32; 1], [u32; 1]); // error!
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[simd]</code> attribute can only be applied to a single-field struct, because
the one field must be the array of values in the vector.</p>
<p>Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Good([u32; 2]); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0076"><a class="header" href="#error-code-e0076">Error code E0076</a></h1>
<p>The type of the field in a tuple struct isn't an array when using the <code>#[simd]</code>
attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0076"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad(u16); // error!
<span class="boring">}</span></code></pre></pre>
<p>When using the <code>#[simd]</code> attribute to automatically use SIMD operations in tuple
structs, if you want a single-lane vector then the field must be a 1-element
array, or the compiler will trigger this error.</p>
<p>Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Good([u16; 1]); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0077"><a class="header" href="#error-code-e0077">Error code E0077</a></h1>
<p>A tuple struct's element isn't a machine type when using the <code>#[simd]</code>
attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0077"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad([String; 2]); // error!
<span class="boring">}</span></code></pre></pre>
<p>When using the <code>#[simd]</code> attribute on a tuple struct, the elements in the tuple
must be machine types so SIMD operations can be applied to them.</p>
<p>Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Good([u32; 4]); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0080"><a class="header" href="#error-code-e0080">Error code E0080</a></h1>
<p>A constant value failed to get evaluated.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0080"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    X = (1 &lt;&lt; 500),
    Y = (1 / 0),
}
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that the compiler was unable to sensibly evaluate a
constant expression that had to be evaluated. Attempting to divide by 0
or causing an integer overflow are two ways to induce this error.</p>
<p>Ensure that the expressions given can be evaluated as the desired integer type.</p>
<p>See the <a href="https://doc.rust-lang.org/reference/items/enumerations.html#discriminants">Discriminants</a> section of the Reference for more information about
setting custom integer types on enums using the
<a href="https://doc.rust-lang.org/reference/type-layout.html#representations"><code>repr</code> attribute</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0081"><a class="header" href="#error-code-e0081">Error code E0081</a></h1>
<p>A discriminant value is present more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0081"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    P = 3,
    X = 3, // error!
    Y = 5,
}
<span class="boring">}</span></code></pre></pre>
<p>Enum discriminants are used to differentiate enum variants stored in memory.
This error indicates that the same value was used for two or more variants,
making it impossible to distinguish them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    P,
    X = 3, // ok!
    Y = 5,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that variants without a manually specified discriminant are numbered from
top to bottom starting from 0, so clashes can occur with seemingly unrelated
variants.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0081"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Bad {
    X,
    Y = 0, // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Here <code>X</code> will have already been specified the discriminant 0 by the time <code>Y</code> is
encountered, so a conflict occurs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0084"><a class="header" href="#error-code-e0084">Error code E0084</a></h1>
<p>An unsupported representation was attempted on a zero-variant enum.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0084"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i32)]
enum NightsWatch {} // error: unsupported representation for zero-variant enum
<span class="boring">}</span></code></pre></pre>
<p>It is impossible to define an integer type to be used to represent zero-variant
enum values because there are no zero-variant enum values. There is no way to
construct an instance of the following type using only safe code. So you have
two solutions. Either you add variants in your enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i32)]
enum NightsWatch {
    JonSnow,
    Commander,
}
<span class="boring">}</span></code></pre></pre>
<p>or you remove the integer representation of your enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum NightsWatch {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0087"><a class="header" href="#error-code-e0087">Error code E0087</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-8"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-8">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Too many type arguments were supplied for a function. For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn foo&lt;T&gt;() {}

fn main() {
    foo::&lt;f64, bool&gt;(); // error: wrong number of type arguments:
                        //        expected 1, found 2
}</code></pre></pre>
<p>The number of supplied arguments must exactly match the number of defined type
parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0088"><a class="header" href="#error-code-e0088">Error code E0088</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-9"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-9">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You gave too many lifetime arguments. Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn f() {}

fn main() {
    f::&lt;'static&gt;() // error: wrong number of lifetime arguments:
                   //        expected 0, found 1
}</code></pre></pre>
<p>Please check you give the right number of lifetime arguments. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn f() {}

fn main() {
    f() // ok!
}</code></pre></pre>
<p>It's also important to note that the Rust compiler can generally
determine the lifetime by itself. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    value: String
}

impl Foo {
    // it can be written like this
    fn get_value&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str { &amp;self.value }
    // but the compiler works fine with this too:
    fn without_lifetime(&amp;self) -&gt; &amp;str { &amp;self.value }
}

fn main() {
    let f = Foo { value: "hello".to_owned() };

    println!("{}", f.get_value());
    println!("{}", f.without_lifetime());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0089"><a class="header" href="#error-code-e0089">Error code E0089</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-10"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-10">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Too few type arguments were supplied for a function. For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn foo&lt;T, U&gt;() {}

fn main() {
    foo::&lt;f64&gt;(); // error: wrong number of type arguments: expected 2, found 1
}</code></pre></pre>
<p>Note that if a function takes multiple type arguments but you want the compiler
to infer some of them, you can use type placeholders:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn foo&lt;T, U&gt;(x: T) {}

fn main() {
    let x: bool = true;
    foo::&lt;f64&gt;(x);    // error: wrong number of type arguments:
                      //        expected 2, found 1
    foo::&lt;_, f64&gt;(x); // same as `foo::&lt;bool, f64&gt;(x)`
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0090"><a class="header" href="#error-code-e0090">Error code E0090</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-11"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-11">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You gave too few lifetime arguments. Example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn foo&lt;'a: 'b, 'b: 'a&gt;() {}

fn main() {
    foo::&lt;'static&gt;(); // error: wrong number of lifetime arguments:
                      //        expected 2, found 1
}</code></pre></pre>
<p>Please check you give the right number of lifetime arguments. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;'a: 'b, 'b: 'a&gt;() {}

fn main() {
    foo::&lt;'static, 'static&gt;();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0091"><a class="header" href="#error-code-e0091">Error code E0091</a></h1>
<p>An unnecessary type parameter was given in a type alias.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0091"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;T&gt; = u32; // error: type parameter `T` is never used
// or:
type Foo&lt;A, B&gt; = Box&lt;A&gt;; // error: type parameter `B` is never used
<span class="boring">}</span></code></pre></pre>
<p>Please check you didn't write too many parameters. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = u32; // ok!
type Foo2&lt;A&gt; = Box&lt;A&gt;; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0092"><a class="header" href="#error-code-e0092">Error code E0092</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-12"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-12">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An undefined atomic operation function was declared.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">#![feature(intrinsics)]
#![allow(internal_features)]

#[rustc_intrinsic]
unsafe fn atomic_foo(); // error: unrecognized atomic operation
                        //        function</code></pre>
<p>Please check you didn't make a mistake in the function's name. All intrinsic
functions are defined in <code>library/core/src/intrinsics</code> in the Rust source code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0093"><a class="header" href="#error-code-e0093">Error code E0093</a></h1>
<p>An unknown intrinsic function was declared.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0093">#![feature(intrinsics)]
#![allow(internal_features)]

#[rustc_intrinsic]
unsafe fn foo(); // error: unrecognized intrinsic function: `foo`

fn main() {
    unsafe {
        foo();
    }
}</code></pre></pre>
<p>Please check you didn't make a mistake in the function's name. All intrinsic
functions are defined in <code>library/core/src/intrinsics</code> in the Rust source code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0094"><a class="header" href="#error-code-e0094">Error code E0094</a></h1>
<p>An invalid number of generic parameters was passed to an intrinsic function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0094"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_intrinsic]
fn size_of&lt;T, U&gt;() -&gt; usize; // error: intrinsic has wrong number
                             //        of type parameters
<span class="boring">}</span></code></pre></pre>
<p>Please check that you provided the right number of type parameters
and verify with the function declaration in the Rust source code.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_intrinsic]
fn size_of&lt;T&gt;() -&gt; usize; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0106"><a class="header" href="#error-code-e0106">Error code E0106</a></h1>
<p>This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0106"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo1 { x: &amp;bool }
              // ^ expected lifetime parameter
struct Foo2&lt;'a&gt; { x: &amp;'a bool } // correct

struct Bar1 { x: Foo2 }
              // ^^^^ expected lifetime parameter
struct Bar2&lt;'a&gt; { x: Foo2&lt;'a&gt; } // correct

enum Baz1 { A(u8), B(&amp;bool), }
                  // ^ expected lifetime parameter
enum Baz2&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr1 = &amp;str;
           // ^ expected lifetime parameter
type MyStr2&lt;'a&gt; = &amp;'a str; // correct
<span class="boring">}</span></code></pre></pre>
<p>Lifetime elision is a special, limited kind of inference for lifetimes in
function signatures which allows you to leave out lifetimes in certain cases.
For more background on lifetime elision see <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">the book</a>.</p>
<p>The lifetime elision rules require that any function signature with an elided
output lifetime must either have:</p>
<ul>
<li>exactly one input lifetime</li>
<li>or, multiple input lifetimes, but the function must also be a method with a
<code>&amp;self</code> or <code>&amp;mut self</code> receiver</li>
</ul>
<p>In the first case, the output lifetime is inferred to be the same as the unique
input lifetime. In the second case, the lifetime is instead inferred to be the
same as the lifetime on <code>&amp;self</code> or <code>&amp;mut self</code>.</p>
<p>Here are some examples of elision errors:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0106"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error, no input lifetimes
fn foo() -&gt; &amp;str { }

// error, `x` and `y` have distinct lifetimes inferred
fn bar(x: &amp;str, y: &amp;str) -&gt; &amp;str { }

// error, `y`'s lifetime is inferred to be distinct from `x`'s
fn baz&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;str { }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0107"><a class="header" href="#error-code-e0107">Error code E0107</a></h1>
<p>An incorrect number of generic arguments was provided.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }             // error: wrong number of type arguments:
                                  //        expected 1, found 0
struct Baz&lt;S, T&gt; { x: Foo&lt;S, T&gt; } // error: wrong number of type arguments:
                                  //        expected 1, found 2

fn foo&lt;T, U&gt;(x: T, y: U) {}
fn f() {}

fn main() {
    let x: bool = true;
    foo::&lt;bool&gt;(x);                 // error: wrong number of type arguments:
                                    //        expected 2, found 1
    foo::&lt;bool, i32, i32&gt;(x, 2, 4); // error: wrong number of type arguments:
                                    //        expected 2, found 3
    f::&lt;'static&gt;();                 // error: wrong number of lifetime arguments
                                    //        expected 0, found 1
}</code></pre></pre>
<p>When using/declaring an item with generic arguments, you must provide the exact
same number:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo&lt;T&gt; { x: T }

struct Bar&lt;T&gt; { x: Foo&lt;T&gt; }               // ok!
struct Baz&lt;S, T&gt; { x: Foo&lt;S&gt;, y: Foo&lt;T&gt; } // ok!

fn foo&lt;T, U&gt;(x: T, y: U) {}
fn f() {}

fn main() {
    let x: bool = true;
    foo::&lt;bool, u32&gt;(x, 12);              // ok!
    f();                                  // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0109"><a class="header" href="#error-code-e0109">Error code E0109</a></h1>
<p>You tried to provide a generic argument to a type which doesn't need it.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0109"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type X = u32&lt;i32&gt;; // error: type arguments are not allowed for this type
type Y = bool&lt;'static&gt;; // error: lifetime parameters are not allowed on
                        //        this type
<span class="boring">}</span></code></pre></pre>
<p>Check that you used the correct argument and that the definition is correct.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type X = u32; // ok!
type Y = bool; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Note that generic arguments for enum variant constructors go after the variant,
not after the enum. For example, you would write <code>Option::None::&lt;u32&gt;</code>,
rather than <code>Option::&lt;u32&gt;::None</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0110"><a class="header" href="#error-code-e0110">Error code E0110</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-13"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-13">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You tried to provide a lifetime to a type which doesn't need it.
See <code>E0109</code> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0116"><a class="header" href="#error-code-e0116">Error code E0116</a></h1>
<p>An inherent implementation was defined for a type outside the current crate.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0116"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Vec&lt;u8&gt; { } // error
<span class="boring">}</span></code></pre></pre>
<p>You can only define an inherent implementation for a type in the same crate
where the type was defined. For example, an <code>impl</code> block as above is not allowed
since <code>Vec</code> is defined in the standard library.</p>
<p>To fix this problem, you can either:</p>
<ul>
<li>define a trait that has the desired associated functions/types/constants and
implement the trait for the type in question</li>
<li>define a new type wrapping the type and define an implementation on the new
type</li>
</ul>
<p>Note that using the <code>type</code> keyword does not work here because <code>type</code> only
introduces a type alias:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0116"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Bytes = Vec&lt;u8&gt;;

impl Bytes { } // error, same as above
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0117"><a class="header" href="#error-code-e0117">Error code E0117</a></h1>
<p>Only traits defined in the current crate can be implemented for arbitrary types.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0117"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for u32 {}
<span class="boring">}</span></code></pre></pre>
<p>This error indicates a violation of one of Rust's orphan rules for trait
implementations. The rule prohibits any implementation of a foreign trait (a
trait defined in another crate) where</p>
<ul>
<li>the type that is implementing the trait is foreign</li>
<li>all of the parameters being passed to the trait (if there are any) are also
foreign.</li>
</ul>
<p>To avoid this kind of error, ensure that at least one local type is referenced
by the <code>impl</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo; // you define your type in your crate

impl Drop for Foo { // and you can implement the trait on it!
    // code of trait implementation here
<span class="boring">  fn drop(&amp;mut self) { }
</span>}

impl From&lt;Foo&gt; for i32 { // or you use a type from your crate as
                         // a type parameter
    fn from(i: Foo) -&gt; i32 {
        0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, define a trait locally and implement that instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Bar {
    fn get(&amp;self) -&gt; usize;
}

impl Bar for u32 {
    fn get(&amp;self) -&gt; usize { 0 }
}
<span class="boring">}</span></code></pre></pre>
<p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md">RFC 1023</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0118"><a class="header" href="#error-code-e0118">Error code E0118</a></h1>
<p>An inherent implementation was defined for something which isn't a struct,
enum, union, or trait object.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0118"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; T { // error: no nominal type found for inherent implementation
    fn get_state(&amp;self) -&gt; String {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please implement a trait on the type or wrap it in a struct.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// we create a trait here
trait LiveLongAndProsper {
    fn get_state(&amp;self) -&gt; String;
}

// and now you can implement it on T
impl&lt;T&gt; LiveLongAndProsper for T {
    fn get_state(&amp;self) -&gt; String {
        "He's dead, Jim!".to_owned()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct.
For example, <code>NewType</code> is a newtype over <code>Foo</code> in <code>struct NewType(Foo)</code>.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TypeWrapper&lt;T&gt;(T);

impl&lt;T&gt; TypeWrapper&lt;T&gt; {
    fn get_state(&amp;self) -&gt; String {
        "Fascinating!".to_owned()
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0119"><a class="header" href="#error-code-e0119">Error code E0119</a></h1>
<p>There are conflicting trait implementations for the same type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0119"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo {
    value: usize
}

impl MyTrait for Foo { // error: conflicting implementations of trait
                       //        `MyTrait` for type `Foo`
    fn get(&amp;self) -&gt; usize { self.value }
}
<span class="boring">}</span></code></pre></pre>
<p>When looking for the implementation for the trait, the compiler finds
both the <code>impl&lt;T&gt; MyTrait for T</code> where T is all types and the <code>impl MyTrait for Foo</code>. Since a trait cannot be implemented multiple times,
this is an error. So, when you write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}
<span class="boring">}</span></code></pre></pre>
<p>This makes the trait implemented on all types in the scope. So if you
try to implement it on another one after that, the implementations will
conflict. Example:</p>
<pre><pre class="playground"><code class="language-rust">trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo;

fn main() {
    let f = Foo;

    f.get(); // the trait is implemented so we can use it
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0120"><a class="header" href="#error-code-e0120">Error code E0120</a></h1>
<p><code>Drop</code> was implemented on a trait object or reference, which is not allowed;
only structs, enums, and unions can implement Drop.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0120"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {}

impl Drop for MyTrait {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0120"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Concrete {}

impl Drop for &amp;'_ mut Concrete  {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>A workaround for traits is to create a wrapper struct with a generic type,
add a trait bound to the type, and implement <code>Drop</code> on the wrapper:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {}
struct MyWrapper&lt;T: MyTrait&gt; { foo: T }

impl &lt;T: MyTrait&gt; Drop for MyWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}

<span class="boring">}</span></code></pre></pre>
<p>Alternatively, the <code>Drop</code> wrapper can contain the trait object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {}

// or Box&lt;dyn MyTrait&gt;, if you wanted an owned trait object
struct MyWrapper&lt;'a&gt; { foo: &amp;'a dyn MyTrait }

impl &lt;'a&gt; Drop for MyWrapper&lt;'a&gt; {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0121"><a class="header" href="#error-code-e0121">Error code E0121</a></h1>
<p>The type placeholder <code>_</code> was used within a type on an item's signature.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0121"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; _ { 5 } // error

static BAR: _ = "test"; // error
<span class="boring">}</span></code></pre></pre>
<p>In those cases, you need to provide the type explicitly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; i32 { 5 } // ok!

static BAR: &amp;str = "test"; // ok!
<span class="boring">}</span></code></pre></pre>
<p>The type placeholder <code>_</code> can be used outside item's signature as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "a4a".split('4')
    .collect::&lt;Vec&lt;_&gt;&gt;(); // No need to precise the Vec's generic type.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0124"><a class="header" href="#error-code-e0124">Error code E0124</a></h1>
<p>A struct was declared with two fields having the same name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0124"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    field1: i32,
    field1: i32, // error: field is already declared
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the field names have been correctly spelled. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    field1: i32,
    field2: i32, // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0128"><a class="header" href="#error-code-e0128">Error code E0128</a></h1>
<p>A type parameter with default value is using forward declared identifier.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0128"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T = U, U = ()&gt; {
    field1: T,
    field2: U,
}
// error: generic parameters with a default cannot use forward declared
//        identifiers
<span class="boring">}</span></code></pre></pre>
<p>Type parameter defaults can only use parameters that occur before them. Since
type parameters are evaluated in-order, this issue could be fixed by doing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;U = (), T = U&gt; {
    field1: T,
    field2: U,
}
<span class="boring">}</span></code></pre></pre>
<p>Please also verify that this wasn't because of a name-clash and rename the type
parameter if so.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0130"><a class="header" href="#error-code-e0130">Error code E0130</a></h1>
<p>A pattern was declared as an argument in a foreign function declaration.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0130"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign
                                //        function declarations
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, replace the pattern argument with a regular one. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    a: u32,
    b: u32,
}

extern "C" {
    fn foo(s: SomeStruct); // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    fn foo(a: (u32, u32)); // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0131"><a class="header" href="#error-code-e0131">Error code E0131</a></h1>
<p>The <code>main</code> function was defined with generic parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0131">fn main&lt;T&gt;() { // error: main function is not allowed to have generic parameters
}</code></pre></pre>
<p>It is not possible to define the <code>main</code> function with generic parameters.
It must not take any arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0132"><a class="header" href="#error-code-e0132">Error code E0132</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-14"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-14">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A function with the <code>start</code> attribute was declared with type parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0133"><a class="header" href="#error-code-e0133">Error code E0133</a></h1>
<p>Unsafe code was used outside of an unsafe block.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0133">unsafe fn f() { return; } // This is the unsafe code

fn main() {
    f(); // error: call to unsafe function requires unsafe function or block
}</code></pre></pre>
<p>Using unsafe functionality is potentially dangerous and disallowed by safety
checks. Examples:</p>
<ul>
<li>Dereferencing raw pointers</li>
<li>Calling functions via FFI</li>
<li>Calling functions marked unsafe</li>
</ul>
<p>These safety checks can be relaxed for a section of the code by wrapping the
unsafe instructions with an <code>unsafe</code> block. For instance:</p>
<pre><pre class="playground"><code class="language-rust">unsafe fn f() { return; }

fn main() {
    unsafe { f(); } // ok!
}</code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">unsafe section</a> of the Book for more details.</p>
<h4 id="unsafe-code-in-functions"><a class="header" href="#unsafe-code-in-functions">Unsafe code in functions</a></h4>
<p>Unsafe code is currently accepted in unsafe functions, but that is being phased
out in favor of requiring unsafe blocks here too.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn f() { return; }

unsafe fn g() {
    f(); // Is accepted, but no longer recommended
    unsafe { f(); } // Recommended way to write this
}
<span class="boring">}</span></code></pre></pre>
<p>Linting against this is controlled via the <code>unsafe_op_in_unsafe_fn</code> lint, which
is <code>warn</code> by default in the 2024 edition and <code>allow</code> by default in earlier
editions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0136"><a class="header" href="#error-code-e0136">Error code E0136</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-15"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-15">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>More than one <code>main</code> function was found.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
    // ...
}

// ...

fn main() { // error!
    // ...
}</code></pre></pre>
<p>A binary can only have one entry point, and by default that entry point is the
<code>main()</code> function. If there are multiple instances of this function, please
rename one of them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0137"><a class="header" href="#error-code-e0137">Error code E0137</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-16"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-16">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>More than one function was declared with the <code>#[main]</code> attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![feature(main)]

<span class="boring">fn main() {
</span>#[main]
fn foo() {}

#[main]
fn f() {} // error: multiple functions with a `#[main]` attribute
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that the compiler found multiple functions with the
<code>#[main]</code> attribute. This is an error because there must be a unique entry
point into a Rust program. Example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![feature(main)]

<span class="boring">fn main() {
</span>#[main]
fn f() {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0138"><a class="header" href="#error-code-e0138">Error code E0138</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-17"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-17">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>More than one function was declared with the <code>#[start]</code> attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0139"><a class="header" href="#error-code-e0139">Error code E0139</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-18"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-18">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>There are various restrictions on transmuting between types in Rust; for example
types being transmuted must have the same size. To apply all these restrictions,
the compiler must know the exact types that may be transmuted. When type
parameters are involved, this cannot always be done.</p>
<p>So, for example, the following is not allowed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

fn foo&lt;T&gt;(x: Vec&lt;T&gt;) {
    // we are transmuting between Vec&lt;T&gt; and Foo&lt;F&gt; here
    let y: Foo&lt;T&gt; = unsafe { transmute(x) };
    // do something with y
}
<span class="boring">}</span></code></pre></pre>
<p>In this specific case there's a good chance that the transmute is harmless (but
this is not guaranteed by Rust). However, when alignment and enum optimizations
come into the picture, it's quite likely that the sizes may or may not match
with different type parameter instantiations. It's not possible to check this
for <em>all</em> possible types, so <code>transmute()</code> simply only accepts types without any
uninstantiated type parameters.</p>
<p>If you need this, there's a good chance you're doing something wrong. Keep in
mind that Rust doesn't guarantee much about the layout of different structs
(even two structs with identical declarations may have different layouts). If
there is a solution that avoids the transmute entirely, try it instead.</p>
<p>If it's possible, hand-monomorphize the code by writing the function for each
possible type instantiation. It's possible to use traits to do this cleanly,
for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

trait MyTransmutableType: Sized {
    fn transmute(_: Vec&lt;Self&gt;) -&gt; Foo&lt;Self&gt;;
}

impl MyTransmutableType for u8 {
    fn transmute(x: Vec&lt;u8&gt;) -&gt; Foo&lt;u8&gt; {
        unsafe { transmute(x) }
    }
}

impl MyTransmutableType for String {
    fn transmute(x: Vec&lt;String&gt;) -&gt; Foo&lt;String&gt; {
        unsafe { transmute(x) }
    }
}

// ... more impls for the types you intend to transmute

fn foo&lt;T: MyTransmutableType&gt;(x: Vec&lt;T&gt;) {
    let y: Foo&lt;T&gt; = &lt;T as MyTransmutableType&gt;::transmute(x);
    // do something with y
}
<span class="boring">}</span></code></pre></pre>
<p>Each impl will be checked for a size match in the transmute as usual, and since
there are no unbound type parameters involved, this should compile unless there
is a size mismatch in one of the impls.</p>
<p>It is also possible to manually transmute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ptr;
</span><span class="boring">let v = Some("value");
</span><span class="boring">type SomeType = &amp;'static [u8];
</span>unsafe {
    ptr::read(&amp;v as *const _ as *const SomeType) // `v` transmuted to `SomeType`
}
<span class="boring">;
</span><span class="boring">}</span></code></pre></pre>
<p>Note that this does not move <code>v</code> (unlike <code>transmute</code>), and may need a
call to <code>mem::forget(v)</code> in case you want to avoid destructors being called.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0152"><a class="header" href="#error-code-e0152">Error code E0152</a></h1>
<p>A lang item was redefined.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0152"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]

<span class="boring">fn main() {
</span>#[lang = "owned_box"]
struct Foo&lt;T&gt;(T); // error: duplicate lang item found: `owned_box`
<span class="boring">}</span></code></pre></pre>
<p>Lang items are already implemented in the standard library. Unless you are
writing a free-standing application (e.g., a kernel), you do not need to provide
them yourself.</p>
<p>You can build a free-standing crate by adding <code>#![no_std]</code> to the crate
attributes:</p>
<pre><code class="language-rust ignore (only-for-syntax-highlight)">#![no_std]</code></pre>
<p>See also <a href="https://doc.rust-lang.org/nomicon/beneath-std.html">this section of the Rustonomicon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0154"><a class="header" href="#error-code-e0154">Error code E0154</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-19"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-19">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Imports (<code>use</code> statements) are not allowed after non-item statements, such as
variable declarations and expression statements.</p>
<p>Here is an example that demonstrates the error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() {
    // Variable declaration before import
    let x = 0;
    use std::io::Read;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The solution is to declare the imports at the top of the block, function, or
file.</p>
<p>Here is the previous example again, with the correct order:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() {
    use std::io::Read;
    let x = 0;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/reference/statements.html#declaration-statements">Declaration Statements</a> section of the
reference for more information about what constitutes an item declaration
and what does not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0158"><a class="header" href="#error-code-e0158">Error code E0158</a></h1>
<p>A generic parameter or <code>static</code> has been referenced in a pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0158"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    One,
    Two
}

trait Bar {
    const X: Foo;
}

fn test&lt;A: Bar&gt;(arg: Foo) {
    match arg {
        A::X =&gt; println!("A::X"), // error: E0158: constant pattern depends
                                  //        on a generic parameter
        Foo::Two =&gt; println!("Two")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Generic parameters cannot be referenced in patterns because it is impossible
for the compiler to prove exhaustiveness (that some pattern will always match).
Take the above example, because Rust does type checking in the <em>generic</em>
method, not the <em>monomorphized</em> specific instance. So because <code>Bar</code> could have
theoretically arbitrary implementations, there's no way to always be sure that
<code>A::X</code> is <code>Foo::One</code>. So this code must be rejected. Even if code can be
proven exhaustive by a programmer, the compiler cannot currently prove this.</p>
<p>The same holds true of <code>static</code>s.</p>
<p>If you want to match against a <code>const</code> that depends on a generic parameter or a
<code>static</code>, consider using a guard instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    const X: char;
}

static FOO: char = 'j';

fn test&lt;A: Trait, const Y: char&gt;(arg: char) {
    match arg {
        c if c == A::X =&gt; println!("A::X"),
        c if c == Y =&gt; println!("Y"),
        c if c == FOO =&gt; println!("FOO"),
        _ =&gt; ()
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0161"><a class="header" href="#error-code-e0161">Error code E0161</a></h1>
<p>A value was moved whose size was not known at compile time.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0161">trait Bar {
    fn f(self);
}

impl Bar for i32 {
    fn f(self) {}
}

fn main() {
    let b: Box&lt;dyn Bar&gt; = Box::new(0i32);
    b.f();
    // error: cannot move a value of type dyn Bar: the size of dyn Bar cannot
    //        be statically determined
}</code></pre></pre>
<p>In Rust, you can only move a value when its size is known at compile time.</p>
<p>To work around this restriction, consider "hiding" the value behind a reference:
either <code>&amp;x</code> or <code>&amp;mut x</code>. Since a reference has a fixed size, this lets you move
it around as usual. Example:</p>
<pre><pre class="playground"><code class="language-rust">trait Bar {
    fn f(&amp;self);
}

impl Bar for i32 {
    fn f(&amp;self) {}
}

fn main() {
    let b: Box&lt;dyn Bar&gt; = Box::new(0i32);
    b.f();
    // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0162"><a class="header" href="#error-code-e0162">Error code E0162</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-20"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-20">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An <code>if let</code> pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular <code>let</code>-binding instead. For instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
if let Irrefutable(x) = irr {
    // This body will always be executed.
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Try this instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Irrefutable(i32);
let irr = Irrefutable(0);

let Irrefutable(x) = irr;
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0164"><a class="header" href="#error-code-e0164">Error code E0164</a></h1>
<p>Something which is neither a tuple struct nor a tuple variant was used as a
pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0164"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum A {
    B,
    C,
}

impl A {
    fn new() {}
}

fn bar(foo: A) {
    match foo {
        A::new() =&gt; (), // error!
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This error means that an attempt was made to match something which is neither a
tuple struct nor a tuple variant. Only these two elements are allowed as a
pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum A {
    B,
    C,
}

impl A {
    fn new() {}
}

fn bar(foo: A) {
    match foo {
        A::B =&gt; (), // ok!
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0165"><a class="header" href="#error-code-e0165">Error code E0165</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-21"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-21">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A <code>while let</code> pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular <code>let</code>-binding inside a <code>loop</code> instead. For instance:</p>
<pre><code class="language-no_run">struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
while let Irrefutable(x) = irr {
    // ...
}
</code></pre>
<p>Try this instead:</p>
<pre><code class="language-no_run">struct Irrefutable(i32);
let irr = Irrefutable(0);

loop {
    let Irrefutable(x) = irr;
    // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0170"><a class="header" href="#error-code-e0170">Error code E0170</a></h1>
<p>A pattern binding is using the same name as one of the variants of a type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0170"><span class="boring">#![deny(warnings)]
</span>enum Method {
    GET,
    POST,
}

fn is_empty(s: Method) -&gt; bool {
    match s {
        GET =&gt; true,
        _ =&gt; false
    }
}

fn main() {}</code></pre></pre>
<p>Enum variants are qualified by default. For example, given this type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Method {
    GET,
    POST,
}
<span class="boring">}</span></code></pre></pre>
<p>You would match it using:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Method {
    GET,
    POST,
}

let m = Method::GET;

match m {
    Method::GET =&gt; {},
    Method::POST =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>If you don't qualify the names, the code will bind new variables named "GET" and
"POST" instead. This behavior is likely not what you want, so <code>rustc</code> warns when
that happens.</p>
<p>Qualified names are good practice, and most code works well with them. But if
you prefer them unqualified, you can import the variants into scope:</p>
<pre><pre class="playground"><code class="language-rust">use Method::*;
enum Method { GET, POST }
<span class="boring">fn main() {}</span></code></pre></pre>
<p>If you want others to be able to import variants from your module directly, use
<code>pub use</code>:</p>
<pre><pre class="playground"><code class="language-rust">pub use Method::*;
pub enum Method { GET, POST }
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0178"><a class="header" href="#error-code-e0178">Error code E0178</a></h1>
<p>The <code>+</code> type operator was used in an ambiguous context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0178"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

struct Bar&lt;'a&gt; {
    x: &amp;'a Foo + 'a,     // error!
    y: &amp;'a mut Foo + 'a, // error!
    z: fn() -&gt; Foo + 'a, // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In types, the <code>+</code> type operator has low precedence, so it is often necessary
to use parentheses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

struct Bar&lt;'a&gt; {
    x: &amp;'a (Foo + 'a),     // ok!
    y: &amp;'a mut (Foo + 'a), // ok!
    z: fn() -&gt; (Foo + 'a), // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>More details can be found in <a href="https://github.com/rust-lang/rfcs/pull/438">RFC 438</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0183"><a class="header" href="#error-code-e0183">Error code E0183</a></h1>
<p>Manual implementation of a <code>Fn*</code> trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0183"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyClosure {
    foo: i32
}

impl FnOnce&lt;()&gt; for MyClosure {  // error
    type Output = ();
    extern "rust-call" fn call_once(self, args: ()) -&gt; Self::Output {
        println!("{}", self.foo);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Manually implementing <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> is unstable
and requires <code>#![feature(fn_traits, unboxed_closures)]</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(fn_traits, unboxed_closures)]

<span class="boring">fn main() {
</span>struct MyClosure {
    foo: i32
}

impl FnOnce&lt;()&gt; for MyClosure {  // ok!
    type Output = ();
    extern "rust-call" fn call_once(self, args: ()) -&gt; Self::Output {
        println!("{}", self.foo);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The arguments must be a tuple representing the argument list.
For more info, see the <a href="https://github.com/rust-lang/rust/issues/29625">tracking issue</a>:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0184"><a class="header" href="#error-code-e0184">Error code E0184</a></h1>
<p>The <code>Copy</code> trait was implemented on a type with a <code>Drop</code> implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0184"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct Foo; // error!

impl Drop for Foo {
    fn drop(&amp;mut self) {
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Explicitly implementing both <code>Drop</code> and <code>Copy</code> trait on a type is currently
disallowed. This feature can make some sense in theory, but the current
implementation is incorrect and can lead to memory unsafety (see
<a href="https://github.com/rust-lang/rust/issues/20126">issue #20126</a>), so it has been disabled for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0185"><a class="header" href="#error-code-e0185">Error code E0185</a></h1>
<p>An associated function for a trait was defined to be static, but an
implementation of the trait declared the same function to be a method (i.e., to
take a <code>self</code> parameter).</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0185"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the impl, but not in
    // the trait
    fn foo(&amp;self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>When a type implements a trait's associated function, it has to use the same
signature. So in this case, since <code>Foo::foo</code> does not take any argument and
does not return anything, its implementation on <code>Bar</code> should be the same:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    fn foo() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0186"><a class="header" href="#error-code-e0186">Error code E0186</a></h1>
<p>An associated function for a trait was defined to be a method (i.e., to take a
<code>self</code> parameter), but an implementation of the trait declared the same function
to be static.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0186"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the trait, but not in
    // the impl
    fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<p>When a type implements a trait's associated function, it has to use the same
signature. So in this case, since <code>Foo::foo</code> takes <code>self</code> as argument and
does not return anything, its implementation on <code>Bar</code> should be the same:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self);
}

struct Bar;

impl Foo for Bar {
    fn foo(&amp;self) {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0191"><a class="header" href="#error-code-e0191">Error code E0191</a></h1>
<p>An associated type wasn't specified for a trait object.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0191"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    type Bar;
}

type Foo = dyn Trait; // error: the value of the associated type `Bar` (from
                      //        the trait `Trait`) must be specified
<span class="boring">}</span></code></pre></pre>
<p>Trait objects need to have all associated types specified. Please verify that
all associated types of the trait were specified and the correct trait was used.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    type Bar;
}

type Foo = dyn Trait&lt;Bar=i32&gt;; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0192"><a class="header" href="#error-code-e0192">Error code E0192</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-22"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-22">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A negative impl was added on a trait implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">trait Trait {
    type Bar;
}

struct Foo;

impl !Trait for Foo { } //~ ERROR

fn main() {}</code></pre></pre>
<p>Negative impls are only allowed for auto traits. For more
information see the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0193"><a class="header" href="#error-code-e0193">Error code E0193</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-23"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-23">Note: this error code is no longer emitted by the compiler.</a></h4>
<p><code>where</code> clauses must use generic type parameters: it does not make sense to use
them otherwise. An example causing this error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}

impl Foo for Wrapper&lt;u32&gt; where Wrapper&lt;u32&gt;: Clone {
    fn bar(&amp;self) { }
}
<span class="boring">}</span></code></pre></pre>
<p>This use of a <code>where</code> clause is strange - a more common usage would look
something like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}
impl &lt;T&gt; Foo for Wrapper&lt;T&gt; where Wrapper&lt;T&gt;: Clone {
    fn bar(&amp;self) { }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, we're saying that the implementation exists on Wrapper only when the
wrapped type <code>T</code> implements <code>Clone</code>. The <code>where</code> clause is important because
some types will not implement <code>Clone</code>, and thus will not get this method.</p>
<p>In our erroneous example, however, we're referencing a single concrete type.
Since we know for certain that <code>Wrapper&lt;u32&gt;</code> implements <code>Clone</code>, there's no
reason to also specify it in a <code>where</code> clause.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0195"><a class="header" href="#error-code-e0195">Error code E0195</a></h1>
<p>The lifetime parameters of the method do not match the trait declaration.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0195"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn bar&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn bar&lt;'a,'b&gt;(x: &amp;'a str, y: &amp;'b str) {
    // error: lifetime parameters or bounds on method `bar`
    // do not match the trait declaration
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The lifetime constraint <code>'b</code> for <code>bar()</code> implementation does not match the
trait declaration. Ensure lifetime declarations match exactly in both trait
declaration and implementation. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str) { // ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0197"><a class="header" href="#error-code-e0197">Error code E0197</a></h1>
<p>An inherent implementation was marked unsafe.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0197"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

unsafe impl Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>Inherent implementations (one that do not implement a trait but provide
methods associated with a type) are always safe because they are not
implementing an unsafe trait. Removing the <code>unsafe</code> keyword from the inherent
implementation will resolve this error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo { } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0198"><a class="header" href="#error-code-e0198">Error code E0198</a></h1>
<p>A negative implementation was marked as unsafe.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0198"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

unsafe impl !Clone for Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>A negative implementation is one that excludes a type from implementing a
particular trait. Not being able to use a trait is always a safe operation,
so negative implementations are always safe and never need to be marked as
unsafe.</p>
<p>This will compile:</p>
<pre><code class="language-rust ignore (ignore auto_trait future compatibility warning)">#![feature(auto_traits)]

struct Foo;

auto trait Enterprise {}

impl !Enterprise for Foo { }</code></pre>
<p>Please note that negative impls are only allowed for auto traits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0199"><a class="header" href="#error-code-e0199">Error code E0199</a></h1>
<p>A trait implementation was marked as unsafe while the trait is safe.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0199"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

trait Bar { }

unsafe impl Bar for Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>Safe traits should not have unsafe implementations, therefore marking an
implementation for a safe trait unsafe will cause a compiler error. Removing
the unsafe marker on the trait noted in the error will resolve this problem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

trait Bar { }

impl Bar for Foo { } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0200"><a class="header" href="#error-code-e0200">Error code E0200</a></h1>
<p>An unsafe trait was implemented without an unsafe implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0200"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

unsafe trait Bar { }

impl Bar for Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>Unsafe traits must have unsafe implementations. This error occurs when an
implementation for an unsafe trait isn't marked as unsafe. This may be resolved
by marking the unsafe implementation as unsafe.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

unsafe trait Bar { }

unsafe impl Bar for Foo { } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0201"><a class="header" href="#error-code-e0201">Error code E0201</a></h1>
<p>Two associated items (like methods, associated types, associated functions,
etc.) were defined with the same identifier.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0201"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo(u8);

impl Foo {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
    fn bar() {} // error: duplicate associated function
}

trait Baz {
    type Quux;
    fn baz(&amp;self) -&gt; bool;
}

impl Baz for Foo {
    type Quux = u32;

    fn baz(&amp;self) -&gt; bool { true }

    // error: duplicate method
    fn baz(&amp;self) -&gt; bool { self.0 &gt; 5 }

    // error: duplicate associated type
    type Quux = u32;
}
<span class="boring">}</span></code></pre></pre>
<p>Note, however, that items with the same name are allowed for inherent <code>impl</code>
blocks that don't overlap:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt;(T);

impl Foo&lt;u8&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
}

impl Foo&lt;bool&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0203"><a class="header" href="#error-code-e0203">Error code E0203</a></h1>
<p>Having duplicate relaxed default bounds is unsupported.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0203"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bad&lt;T: ?Sized + ?Sized&gt;{
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>Here the type parameter <code>T</code> cannot have duplicate relaxed bounds for default
trait <code>Sized</code>. This can be fixed by only using one relaxed bound:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Good&lt;T: ?Sized&gt;{
    inner: T
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0204"><a class="header" href="#error-code-e0204">Error code E0204</a></h1>
<p>The <code>Copy</code> trait was implemented on a type which contains a field that doesn't
implement the <code>Copy</code> trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0204"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    foo: Vec&lt;u32&gt;,
}

impl Copy for Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>The <code>Copy</code> trait is implemented by default only on primitive types. If your
type only contains primitive types, you'll be able to implement <code>Copy</code> on it.
Otherwise, it won't be possible.</p>
<p>Here's another example that will fail:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0204"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)] // error!
struct Foo&lt;'a&gt; {
    ty: &amp;'a mut bool,
}
<span class="boring">}</span></code></pre></pre>
<p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this
differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0205"><a class="header" href="#error-code-e0205">Error code E0205</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-24"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-24">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An attempt to implement the <code>Copy</code> trait for an enum failed because one of the
variants does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for
the mentioned variant. Note that this may not be possible, as in the example of</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0204"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar(Vec&lt;u32&gt;),
    Baz,
}

impl Copy for Foo { }
<span class="boring">}</span></code></pre></pre>
<p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p>
<p>Here's another example that will fail:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0204"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
enum Foo&lt;'a&gt; {
    Bar(&amp;'a mut bool),
    Baz,
}
<span class="boring">}</span></code></pre></pre>
<p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this
differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0206"><a class="header" href="#error-code-e0206">Error code E0206</a></h1>
<p>The <code>Copy</code> trait was implemented on a type which is neither a struct, an
enum, nor a union.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0206"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct Bar;

impl Copy for &amp;'static mut Bar { } // error!
<span class="boring">}</span></code></pre></pre>
<p>You can only implement <code>Copy</code> for a struct, an enum, or a union.
The previous example will fail because <code>&amp;'static mut Bar</code>
is not a struct, an enum, or a union.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0207"><a class="header" href="#error-code-e0207">Error code E0207</a></h1>
<p>A type, const or lifetime parameter that is specified for <code>impl</code> is not
constrained.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0207"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl&lt;T: Default&gt; Foo {
    // error: the type parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Any type or const parameter of an <code>impl</code> must meet at least one of the
following criteria:</p>
<ul>
<li>it appears in the <em>implementing type</em> of the impl, e.g. <code>impl&lt;T&gt; Foo&lt;T&gt;</code></li>
<li>for a trait impl, it appears in the <em>implemented trait</em>, e.g.
<code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code></li>
<li>it is bound as an associated type, e.g. <code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code></li>
</ul>
<p>Any unconstrained lifetime parameter of an <code>impl</code> is not supported if the
lifetime parameter is used by an associated type.</p>
<h3 id="error-example-1"><a class="header" href="#error-example-1">Error example 1</a></h3>
<p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it.
The previous code example has a definition which leads to a compiler error:</p>
<p>The problem is that the parameter <code>T</code> does not appear in the implementing type
(<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type
parameter from the <code>impl</code> to the method <code>get</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-example-2"><a class="header" href="#error-example-2">Error example 2</a></h3>
<p>As another example, suppose we have a <code>Maker</code> trait and want to establish a
type <code>FooMaker</code> that makes <code>Foo</code>s:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0207"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This fails to compile because <code>T</code> does not appear in the trait or in the
implementing type.</p>
<p>One way to work around this is to introduce a phantom type parameter into
<code>FooMaker</code>, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Another way is to do away with the associated type in <code>Maker</code> and use an input
type parameter instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use a type parameter instead of an associated type here
trait Maker&lt;Item&gt; {
    fn make(&amp;mut self) -&gt; Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker&lt;Foo&lt;T&gt;&gt; for FooMaker {
    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-example-3"><a class="header" href="#error-example-3">Error example 3</a></h3>
<p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it.
The following code example has a definition which leads to a compiler error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0207"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl&lt;const T: i32&gt; Foo {
    // error: the const parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; i32 {
        i32::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The problem is that the const parameter <code>T</code> does not appear in the implementing
type (<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type
parameter from the <code>impl</code> to the method <code>get</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

// Move the const parameter from the impl to the method
impl Foo {
    fn get&lt;const T: i32&gt;(&amp;self) -&gt; i32 {
        i32::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-example-4"><a class="header" href="#error-example-4">Error example 4</a></h3>
<p>Suppose we have a struct <code>Foo</code> and a struct <code>Bar</code> that uses lifetime <code>'a</code>. We
would like to implement trait <code>Contains</code> for <code>Foo</code>. The trait <code>Contains</code> have
the associated type <code>B</code>. The following code example has a definition which
leads to a compiler error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0207"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
struct Bar&lt;'a&gt;;

trait Contains {
    type B;

    fn get(&amp;self) -&gt; i32;
}

impl&lt;'a&gt; Contains for Foo {
    type B = Bar&lt;'a&gt;;

    // error: the lifetime parameter `'a` is not constrained by the impl trait,
    // self type, or predicates [E0207]
    fn get(&amp;self) -&gt; i32 {
        i32::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Please note that unconstrained lifetime parameters are not supported if they are
being used by an associated type.</p>
<p>In cases where the associated type's lifetime is meant to be tied to the
self type, and none of the methods on the trait need ownership or different
mutability, then an option is to implement the trait on a borrowed type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo(i32);

trait Contents {
    type Item;

    fn get(&amp;self) -&gt; Self::Item;
}

// Note the lifetime `'a` is used both for the self type...
impl&lt;'a&gt; Contents for &amp;'a Foo {
    // ...and the associated type.
    type Item = &amp;'a i32;

    fn get(&amp;self) -&gt; Self::Item {
        &amp;self.0
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="additional-information"><a class="header" href="#additional-information">Additional information</a></h3>
<p>For more information, please see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md">RFC 447</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0208"><a class="header" href="#error-code-e0208">Error code E0208</a></h1>
<h4 id="this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code"><a class="header" href="#this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code">This error code is internal to the compiler and will not be emitted with normal Rust code.</a></h4>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-25"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-25">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error code shows the variance of a type's generic parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOTE: this feature is perma-unstable and should *only* be used for
//       testing purposes.
#![allow(internal_features)]
#![feature(rustc_attrs)]

#[rustc_variance]
struct Foo&lt;'a, T&gt; { // error: deliberate error to display type's variance
    t: &amp;'a mut T,
}
<span class="boring">}</span></code></pre></pre>
<p>which produces the following error:</p>
<pre><code class="language-text">error: [-, o]
 --&gt; &lt;anon&gt;:4:1
  |
4 | struct Foo&lt;'a, T&gt; {
  | ^^^^^^^^^^^^^^^^^
</code></pre>
<p><em>Note that while <code>#[rustc_variance]</code> still exists and is used within the</em>
<em>compiler, it no longer is marked as <code>E0208</code> and instead has no error code.</em></p>
<p>This error is deliberately triggered with the <code>#[rustc_variance]</code> attribute
(<code>#![feature(rustc_attrs)]</code> must be enabled) and helps to show you the variance
of the type's generic parameters. You can read more about variance and
subtyping in <a href="https://doc.rust-lang.org/nomicon/subtyping.html">this section of the Rustonomicon</a>. For a more in depth look at
variance (including a more complete list of common variances) see
<a href="https://doc.rust-lang.org/reference/subtyping.html#variance">this section of the Reference</a>. For information on how variance is implemented
in the compiler, see <a href="https://rustc-dev-guide.rust-lang.org/variance.html">this section of <code>rustc-dev-guide</code></a>.</p>
<p>This error can be easily fixed by removing the <code>#[rustc_variance]</code> attribute,
the compiler's suggestion to comment it out can be applied automatically with
<code>rustfix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0210"><a class="header" href="#error-code-e0210">Error code E0210</a></h1>
<p>This error indicates a violation of one of Rust's orphan rules for trait
implementations. The rule concerns the use of type parameters in an
implementation of a foreign trait (a trait defined in another crate), and
states that type parameters must be "covered" by a local type.</p>
<p>When implementing a foreign trait for a foreign type,
the trait must have one or more type parameters.
A type local to your crate must appear before any use of any type parameters.</p>
<p>To understand what this means, it is perhaps easier to consider a few examples.</p>
<p>If <code>ForeignTrait</code> is a trait defined in some external crate <code>foo</code>, then the
following trait <code>impl</code> is an error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0210"><span class="boring">#[cfg(for_demonstration_only)]
</span>extern crate foo;
<span class="boring">#[cfg(for_demonstration_only)]
</span>use foo::ForeignTrait;
<span class="boring">use std::panic::UnwindSafe as ForeignTrait;
</span>
impl&lt;T&gt; ForeignTrait for T { } // error
<span class="boring">fn main() {}</span></code></pre></pre>
<p>To work around this, it can be covered with a local type, <code>MyType</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::panic::UnwindSafe as ForeignTrait;
</span>struct MyType&lt;T&gt;(T);
impl&lt;T&gt; ForeignTrait for MyType&lt;T&gt; { } // Ok
<span class="boring">}</span></code></pre></pre>
<p>Please note that a type alias is not sufficient.</p>
<p>For another example of an error, suppose there's another trait defined in <code>foo</code>
named <code>ForeignTrait2</code> that takes two type parameters. Then this <code>impl</code> results
in the same rule violation:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">struct MyType2;
impl&lt;T&gt; ForeignTrait2&lt;T, MyType&lt;T&gt;&gt; for MyType2 { } // error</code></pre>
<p>The reason for this is that there are two appearances of type parameter <code>T</code> in
the <code>impl</code> header, both as parameters for <code>ForeignTrait2</code>. The first appearance
is uncovered, and so runs afoul of the orphan rule.</p>
<p>Consider one more example:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">impl&lt;T&gt; ForeignTrait2&lt;MyType&lt;T&gt;, T&gt; for MyType2 { } // Ok</code></pre>
<p>This only differs from the previous <code>impl</code> in that the parameters <code>T</code> and
<code>MyType&lt;T&gt;</code> for <code>ForeignTrait2</code> have been swapped. This example does <em>not</em>
violate the orphan rule; it is permitted.</p>
<p>To see why that last example was allowed, you need to understand the general
rule. Unfortunately this rule is a bit tricky to state. Consider an <code>impl</code>:</p>
<pre><code class="language-rust ignore (only-for-syntax-highlight)">impl&lt;P1, ..., Pm&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0 { ... }</code></pre>
<p>where <code>P1, ..., Pm</code> are the type parameters of the <code>impl</code> and <code>T0, ..., Tn</code>
are types. One of the types <code>T0, ..., Tn</code> must be a local type (this is another
orphan rule, see the explanation for E0117).</p>
<p>Both of the following must be true:</p>
<ol>
<li>At least one of the types <code>T0..=Tn</code> must be a local type.
Let <code>Ti</code> be the first such type.</li>
<li>No uncovered type parameters <code>P1..=Pm</code> may appear in <code>T0..Ti</code>
(excluding <code>Ti</code>).</li>
</ol>
<p>For information on the design of the orphan rules,
see <a href="https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html">RFC 2451</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md">RFC 1023</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0211"><a class="header" href="#error-code-e0211">Error code E0211</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-26"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-26">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You used a function or type which doesn't fit the requirements for where it was
used. Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![feature(intrinsics)]
#![allow(internal_features)]

#[rustc_intrinsic]
unsafe fn unreachable(); // error: intrinsic has wrong type

// or:

fn main() -&gt; i32 { 0 }
// error: main function expects type: `fn() {main}`: expected (), found i32

// or:

let x = 1u8;
match x {
    0u8..=3i8 =&gt; (),
    // error: mismatched types in range: expected u8, found i8
    _ =&gt; ()
}

// or:

use std::rc::Rc;
struct Foo;

impl Foo {
    fn x(self: Rc&lt;Foo&gt;) {}
    // error: mismatched self type: expected `Foo`: expected struct
    //        `Foo`, found struct `alloc::rc::Rc`
}</code></pre></pre>
<p>For the first code example, please check the function definition. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_intrinsic]
unsafe fn unreachable() -&gt; !; // ok!
<span class="boring">}</span></code></pre></pre>
<p>The second case example is a bit particular: the main function must always
have this definition:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main();</code></pre></pre>
<p>They never take parameters and never return types.</p>
<p>For the third example, when you match, all patterns must have the same type
as the type you're matching on. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1u8;

match x {
    0u8..=3u8 =&gt; (), // ok!
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<p>And finally, for the last example, only <code>Box&lt;Self&gt;</code>, <code>&amp;Self</code>, <code>Self</code>,
or <code>&amp;mut Self</code> work as explicit self parameters. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    fn x(self: Box&lt;Foo&gt;) {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0212"><a class="header" href="#error-code-e0212">Error code E0212</a></h1>
<p>Cannot use the associated type of
a trait with uninferred generic parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0212"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Foo&lt;T&gt; {
    type A;

    fn get(&amp;self, t: T) -&gt; Self::A;
}

fn foo2&lt;I : for&lt;'x&gt; Foo&lt;&amp;'x isize&gt;&gt;(
    field: I::A) {} // error!
<span class="boring">}</span></code></pre></pre>
<p>In this example, we have to instantiate <code>'x</code>, and
we don't know what lifetime to instantiate it with.
To fix this, spell out the precise lifetimes involved.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Foo&lt;T&gt; {
    type A;

    fn get(&amp;self, t: T) -&gt; Self::A;
}

fn foo3&lt;I : for&lt;'x&gt; Foo&lt;&amp;'x isize&gt;&gt;(
    x: &lt;I as Foo&lt;&amp;isize&gt;&gt;::A) {} // ok!


fn foo4&lt;'a, I : for&lt;'x&gt; Foo&lt;&amp;'x isize&gt;&gt;(
    x: &lt;I as Foo&lt;&amp;'a isize&gt;&gt;::A) {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0214"><a class="header" href="#error-code-e0214">Error code E0214</a></h1>
<p>A generic type was described using parentheses rather than angle brackets.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0214"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec(&amp;str) = vec!["foo"];
<span class="boring">}</span></code></pre></pre>
<p>This is not currently supported: <code>v</code> should be defined as <code>Vec&lt;&amp;str&gt;</code>.
Parentheses are currently only used with generic types when defining parameters
for <code>Fn</code>-family traits.</p>
<p>The previous code example fixed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;&amp;str&gt; = vec!["foo"];
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0220"><a class="header" href="#error-code-e0220">Error code E0220</a></h1>
<p>The associated type used was not defined in the trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0220"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T1 {
    type Bar;
}

type Foo = T1&lt;F=i32&gt;; // error: associated type `F` not found for `T1`

// or:

trait T2 {
    type Bar;

    // error: Baz is used but not declared
    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<p>Make sure that you have defined the associated type in the trait body.
Also, verify that you used the right trait or you didn't misspell the
associated type name. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T1 {
    type Bar;
}

type Foo = T1&lt;Bar=i32&gt;; // ok!

// or:

trait T2 {
    type Bar;
    type Baz; // we declare `Baz` in our trait.

    // and now we can use it here:
    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0221"><a class="header" href="#error-code-e0221">Error code E0221</a></h1>
<p>An attempt was made to retrieve an associated type, but the type was ambiguous.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0221"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: Self::A;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>Foo</code> defines an associated type <code>A</code>. <code>Bar</code> inherits that type
from <code>Foo</code>, and defines another associated type of the same name. As a result,
when we attempt to use <code>Self::A</code>, it's ambiguous whether we mean the <code>A</code> defined
by <code>Foo</code> or the one defined by <code>Bar</code>.</p>
<p>There are two options to work around this issue. The first is simply to rename
one of the types. Alternatively, one can specify the intended type using the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: &lt;Self as Bar&gt;::A;
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0222"><a class="header" href="#error-code-e0222">Error code E0222</a></h1>
<p>An attempt was made to constrain an associated type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0222"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Vehicle {
    type Color;
}

pub trait Box {
    type Color;
}

pub trait BoxCar : Box + Vehicle {}

fn dent_object&lt;COLOR&gt;(c: dyn BoxCar&lt;Color=COLOR&gt;) {} // Invalid constraint
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>BoxCar</code> has two supertraits: <code>Vehicle</code> and <code>Box</code>. Both of
these traits define an associated type <code>Color</code>. <code>BoxCar</code> inherits two types
with that name from both supertraits. Because of this, we need to use the
fully qualified path syntax to refer to the appropriate <code>Color</code> associated
type, either <code>&lt;BoxCar as Vehicle&gt;::Color</code> or <code>&lt;BoxCar as Box&gt;::Color</code>, but this
syntax is not allowed to be used in a function signature.</p>
<p>In order to encode this kind of constraint, a <code>where</code> clause and a new type
parameter are needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Vehicle {
    type Color;
}

pub trait Box {
    type Color;
}

pub trait BoxCar : Box + Vehicle {}

// Introduce a new `CAR` type parameter
fn foo&lt;CAR, COLOR&gt;(
    c: CAR,
) where
    // Bind the type parameter `CAR` to the trait `BoxCar`
    CAR: BoxCar,
    // Further restrict `&lt;BoxCar as Vehicle&gt;::Color` to be the same as the
    // type parameter `COLOR`
    CAR: Vehicle&lt;Color = COLOR&gt;,
    // We can also simultaneously restrict the other trait's associated type
    CAR: Box&lt;Color = COLOR&gt;
{}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0223"><a class="header" href="#error-code-e0223">Error code E0223</a></h1>
<p>An attempt was made to retrieve an associated type, but the type was ambiguous.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0223">trait Trait { type X; }

fn main() {
    let foo: Trait::X;
}</code></pre></pre>
<p>The problem here is that we're attempting to take the associated type of <code>X</code>
from <code>Trait</code>. Unfortunately, the type of <code>X</code> is not defined, because it's only
made concrete in implementations of the trait. A working version of this code
might look like:</p>
<pre><pre class="playground"><code class="language-rust">trait Trait { type X; }

struct Struct;
impl Trait for Struct {
    type X = u32;
}

fn main() {
    let foo: &lt;Struct as Trait&gt;::X;
}</code></pre></pre>
<p>This syntax specifies that we want the associated type <code>X</code> from <code>Struct</code>'s
implementation of <code>Trait</code>.</p>
<p>Due to internal limitations of the current compiler implementation we cannot
simply use <code>Struct::X</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0224"><a class="header" href="#error-code-e0224">Error code E0224</a></h1>
<p>A trait object was declared with no traits.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0224"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = dyn 'static +;
<span class="boring">}</span></code></pre></pre>
<p>Rust does not currently support this.</p>
<p>To solve, ensure that the trait object has at least one trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = dyn 'static + Copy;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0225"><a class="header" href="#error-code-e0225">Error code E0225</a></h1>
<p>Multiple types were used as bounds for a closure or trait object.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0225">fn main() {
    let _: Box&lt;dyn std::io::Read + std::io::Write&gt;;
}</code></pre></pre>
<p>Rust does not currently support this.</p>
<p>Auto traits such as Send and Sync are an exception to this rule:
It's possible to have bounds of one non-builtin trait, plus any number of
auto traits. For example, the following compiles correctly:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _: Box&lt;dyn std::io::Read + Send + Sync&gt;;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0226"><a class="header" href="#error-code-e0226">Error code E0226</a></h1>
<p>More than one explicit lifetime bound was used on a trait object.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0226"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

type T&lt;'a, 'b&gt; = dyn Foo + 'a + 'b; // error: Trait object `arg` has two
                                    //        lifetime bound, 'a and 'b.
<span class="boring">}</span></code></pre></pre>
<p>Here <code>T</code> is a trait object with two explicit lifetime bounds, 'a and 'b.</p>
<p>Only a single explicit lifetime bound is permitted on trait objects.
To fix this error, consider removing one of the lifetime bounds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

type T&lt;'a&gt; = dyn Foo + 'a;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0227"><a class="header" href="#error-code-e0227">Error code E0227</a></h1>
<p>This error indicates that the compiler is unable to determine whether there is
exactly one unique region in the set of derived region bounds.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0227"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;'foo&gt;: 'foo {}
trait Bar&lt;'bar&gt;: 'bar {}

trait FooBar&lt;'foo, 'bar&gt;: Foo&lt;'foo&gt; + Bar&lt;'bar&gt; {}

struct Baz&lt;'foo, 'bar&gt; {
    baz: dyn FooBar&lt;'foo, 'bar&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>baz</code> can have either <code>'foo</code> or <code>'bar</code> lifetimes.</p>
<p>To resolve this error, provide an explicit lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;'foo&gt;: 'foo {}
trait Bar&lt;'bar&gt;: 'bar {}

trait FooBar&lt;'foo, 'bar&gt;: Foo&lt;'foo&gt; + Bar&lt;'bar&gt; {}

struct Baz&lt;'foo, 'bar, 'baz&gt;
where
    'baz: 'foo + 'bar,
{
    obj: dyn FooBar&lt;'foo, 'bar&gt; + 'baz,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0228"><a class="header" href="#error-code-e0228">Error code E0228</a></h1>
<p>The lifetime bound for this object type cannot be deduced from context and must
be specified.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0228"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { }

struct TwoBounds&lt;'a, 'b, T: Sized + 'a + 'b&gt; {
    x: &amp;'a i32,
    y: &amp;'b i32,
    z: T,
}

type Foo&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Trait&gt;;
<span class="boring">}</span></code></pre></pre>
<p>When a trait object is used as a type argument of a generic type, Rust will try
to infer its lifetime if unspecified. However, this isn't possible when the
containing type has more than one lifetime bound.</p>
<p>The above example can be resolved by either reducing the number of lifetime
bounds to one or by making the trait object lifetime explicit, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { }

struct TwoBounds&lt;'a, 'b, T: Sized + 'a + 'b&gt; {
    x: &amp;'a i32,
    y: &amp;'b i32,
    z: T,
}

type Foo&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Trait + 'b&gt;;
<span class="boring">}</span></code></pre></pre>
<p>For more information, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a> and its amendment <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0229"><a class="header" href="#error-code-e0229">Error code E0229</a></h1>
<p>An associated item constraint was written in an unexpected context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0229"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Foo {
    type A;
    fn boo(&amp;self) -&gt; &lt;Self as Foo&gt;::A;
}

struct Bar;

impl Foo for isize {
    type A = usize;
    fn boo(&amp;self) -&gt; usize { 42 }
}

fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&lt;A = Bar&gt;&gt;::A) {}
// error: associated item constraint are not allowed here
<span class="boring">}</span></code></pre></pre>
<p>To solve this error, please move the associated item constraints to the type
parameter declaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Bar;
</span><span class="boring">trait Foo { type A; }
</span>fn baz&lt;I: Foo&lt;A=Bar&gt;&gt;(x: &amp;&lt;I as Foo&gt;::A) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>Or into the where-clause:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Bar;
</span><span class="boring">trait Foo { type A; }
</span>fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&gt;::A) where I: Foo&lt;A=Bar&gt; {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0230"><a class="header" href="#error-code-e0230">Error code E0230</a></h1>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0230"><span class="boring">#![allow(unused)]
</span>#![feature(rustc_attrs)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_on_unimplemented = "error on `{Self}` with params `&lt;{A},{B}&gt;`"] // error
trait BadAnnotation&lt;A&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>There will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p>
<p>As you can see, you can specify type parameters in curly braces for
instantiation with the actual types (using the regular format string syntax) in
a given situation. Furthermore, <code>{Self}</code> will be instantiated to the type (in
this case, <code>bool</code>) that we tried to use.</p>
<p>This error appears when the curly braces contain an identifier which doesn't
match with any of the type parameters or the string <code>Self</code>. This might happen
if you misspelled a type parameter, or if you intended to use literal curly
braces. If it is the latter, escape the curly braces with a second curly brace
of the same type; e.g., a literal <code>{</code> is <code>{{</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0231"><a class="header" href="#error-code-e0231">Error code E0231</a></h1>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0231"><span class="boring">#![allow(unused)]
</span>#![feature(rustc_attrs)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_on_unimplemented = "error on `{Self}` with params `&lt;{A},{}&gt;`"] // error!
trait BadAnnotation&lt;A&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p>
<p>As you can see, you can specify type parameters in curly braces for
instantiation with the actual types (using the regular format string syntax) in
a given situation. Furthermore, <code>{Self}</code> will be instantiated to the type (in
this case, <code>bool</code>) that we tried to use.</p>
<p>This error appears when the curly braces do not contain an identifier. Please
add one of the same name as a type parameter. If you intended to use literal
braces, use <code>{{</code> and <code>}}</code> to escape them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0232"><a class="header" href="#error-code-e0232">Error code E0232</a></h1>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0232"><span class="boring">#![allow(unused)]
</span>#![feature(rustc_attrs)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_on_unimplemented(lorem="")] // error!
trait BadAnnotation {}
<span class="boring">}</span></code></pre></pre>
<p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p>
<p>For this to work, some note must be specified. An empty attribute will not do
anything, please remove the attribute or add some helpful note for users of the
trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0243"><a class="header" href="#error-code-e0243">Error code E0243</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-27"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-27">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error indicates that not enough type parameters were found in a type or
trait.</p>
<p>For example, the <code>Foo</code> struct below is defined to be generic in <code>T</code>, but the
type parameter is missing in the definition of <code>Bar</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0244"><a class="header" href="#error-code-e0244">Error code E0244</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-28"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-28">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error indicates that too many type parameters were found in a type or
trait.</p>
<p>For example, the <code>Foo</code> struct below has no type parameters, but is supplied
with two in the definition of <code>Bar</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { x: bool }

struct Bar&lt;S, T&gt; { x: Foo&lt;S, T&gt; }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0251"><a class="header" href="#error-code-e0251">Error code E0251</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-29"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-29">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Two items of the same name cannot be imported without rebinding one of the
items under a new local name.</p>
<p>An example of this error:</p>
<pre><pre class="playground"><code class="language-rust">use foo::baz;
use bar::*; // error, do `use foo::baz as quux` instead on the previous line

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0252"><a class="header" href="#error-code-e0252">Error code E0252</a></h1>
<p>Two items of the same name cannot be imported without rebinding one of the
items under a new local name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0252">use foo::baz;
use bar::baz; // error, do `use bar::baz as quux` instead

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</code></pre></pre>
<p>You can use aliases in order to fix this error. Example:</p>
<pre><pre class="playground"><code class="language-rust">use foo::baz as foo_baz;
use bar::baz; // ok!

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</code></pre></pre>
<p>Or you can reference the item with its parent:</p>
<pre><pre class="playground"><code class="language-rust">use bar::baz;

fn main() {
    let x = foo::baz; // ok!
}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0253"><a class="header" href="#error-code-e0253">Error code E0253</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-30"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-30">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Attempt was made to import an unimportable type. This can happen when trying
to import a type from a trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(import_trait_associated_functions)]

mod foo {
    pub trait MyTrait {
        type SomeType;
    }
}

use foo::MyTrait::SomeType;
// error: `SomeType` is not directly importable

fn main() {}</code></pre></pre>
<p>It's invalid to directly import types belonging to a trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0254"><a class="header" href="#error-code-e0254">Error code E0254</a></h1>
<p>Attempt was made to import an item whereas an extern crate with this name has
already been imported.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0254">extern crate core;

mod foo {
    pub trait core {
        fn do_something();
    }
}

use foo::core;  // error: an extern crate named `core` has already
                //        been imported in this module

fn main() {}</code></pre></pre>
<p>To fix this issue, you have to rename at least one of the two imports.
Example:</p>
<pre><pre class="playground"><code class="language-rust">extern crate core as libcore; // ok!

mod foo {
    pub trait core {
        fn do_something();
    }
}

use foo::core;

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0255"><a class="header" href="#error-code-e0255">Error code E0255</a></h1>
<p>You can't import a value whose name is the same as another value defined in the
module.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0255">use bar::foo; // error: an item named `foo` is already in scope

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</code></pre></pre>
<p>You can use aliases in order to fix this error. Example:</p>
<pre><pre class="playground"><code class="language-rust">use bar::foo as bar_foo; // ok!

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</code></pre></pre>
<p>Or you can reference the item with its parent:</p>
<pre><pre class="playground"><code class="language-rust">fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {
    bar::foo(); // we get the item by referring to its parent
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0256"><a class="header" href="#error-code-e0256">Error code E0256</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-31"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-31">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You can't import a type or module when the name of the item being imported is
the same as another type or submodule defined in the module.</p>
<p>An example of this error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use foo::Bar; // error

type Bar = u32;

mod foo {
    pub mod Bar { }
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0259"><a class="header" href="#error-code-e0259">Error code E0259</a></h1>
<p>The name chosen for an external crate conflicts with another external crate
that has been imported into the current module.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0259">extern crate core;
extern crate std as core;

fn main() {}</code></pre></pre>
<p>The solution is to choose a different name that doesn't conflict with any
external crate imported into the current module.</p>
<p>Correct example:</p>
<pre><pre class="playground"><code class="language-rust">extern crate core;
extern crate std as other_name;

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0260"><a class="header" href="#error-code-e0260">Error code E0260</a></h1>
<p>The name for an item declaration conflicts with an external crate's name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0260">extern crate core;

struct core;

fn main() {}</code></pre></pre>
<p>There are two possible solutions:</p>
<p>Solution #1: Rename the item.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate core;

struct xyz;
<span class="boring">}</span></code></pre></pre>
<p>Solution #2: Import the crate with a different name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate core as xyz;

struct abc;
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/reference/statements.html#declaration-statements">Declaration Statements</a> section of the
reference for more information about what constitutes an item declaration
and what does not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0261"><a class="header" href="#error-code-e0261">Error code E0261</a></h1>
<p>An undeclared lifetime was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0261"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error, use of undeclared lifetime name `'a`
fn foo(x: &amp;'a str) { }

struct Foo {
    // error, use of undeclared lifetime name `'a`
    x: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
<p>These can be fixed by declaring lifetime parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

fn foo&lt;'a&gt;(x: &amp;'a str) {}
<span class="boring">}</span></code></pre></pre>
<p>Impl blocks declare lifetime parameters separately. You need to add lifetime
parameters to an impl block if you're implementing a type that has a lifetime
parameter of its own.
For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0261"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

// error,  use of undeclared lifetime name `'a`
impl Foo&lt;'a&gt; {
    fn foo&lt;'a&gt;(x: &amp;'a str) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This is fixed by declaring the impl block like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

// correct
impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn foo(x: &amp;'a str) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0262"><a class="header" href="#error-code-e0262">Error code E0262</a></h1>
<p>An invalid name was used for a lifetime parameter.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0262"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error, invalid lifetime parameter name `'static`
fn foo&lt;'static&gt;(x: &amp;'static str) { }
<span class="boring">}</span></code></pre></pre>
<p>Declaring certain lifetime names in parameters is disallowed. For example,
because the <code>'static</code> lifetime is a special built-in lifetime name denoting
the lifetime of the entire program, this is an error:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0263"><a class="header" href="#error-code-e0263">Error code E0263</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-32"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-32">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A lifetime was declared more than once in the same scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0403"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, 'b, 'a&gt;(x: &amp;'a str, y: &amp;'b str, z: &amp;'a str) { // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Two lifetimes cannot have the same name. To fix this example, change
the second <code>'a</code> lifetime into something else (<code>'c</code> for example):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, 'b, 'c&gt;(x: &amp;'a str, y: &amp;'b str, z: &amp;'c str) { // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0264"><a class="header" href="#error-code-e0264">Error code E0264</a></h1>
<p>An unknown external lang item was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0264"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>extern "C" {
    #[lang = "cake"] // error: unknown external lang item: `cake`
    fn cake();
}
<span class="boring">}</span></code></pre></pre>
<p>A list of available external lang items is available in
<code>compiler/rustc_hir/src/weak_lang_items.rs</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>extern "C" {
    #[lang = "panic_impl"] // ok!
    fn cake();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0267"><a class="header" href="#error-code-e0267">Error code E0267</a></h1>
<p>A loop keyword (<code>break</code> or <code>continue</code>) was used inside a closure but outside of
any loop.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0267"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let w = || { break; }; // error: `break` inside of a closure
<span class="boring">}</span></code></pre></pre>
<p><code>break</code> and <code>continue</code> keywords can be used as normal inside closures as long as
they are also contained within a loop. To halt the execution of a closure you
should instead use a return statement. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let w = || {
    for _ in 0..10 {
        break;
    }
};

w();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0268"><a class="header" href="#error-code-e0268">Error code E0268</a></h1>
<p>A loop keyword (<code>break</code> or <code>continue</code>) was used outside of a loop.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0268"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_func() {
    break; // error: `break` outside of a loop
}
<span class="boring">}</span></code></pre></pre>
<p>Without a loop to break out of or continue in, no sensible action can be taken.
Please verify that you are using <code>break</code> and <code>continue</code> only in loops. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_func() {
    for _ in 0..10 {
        break; // ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0271"><a class="header" href="#error-code-e0271">Error code E0271</a></h1>
<p>A type mismatched an associated type of a trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0271"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {
//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~
//                        |            |
//         This says `foo` can         |
//           only be used with         |
//              some type that         |
//         implements `Trait`.         |
//                                     |
//                             This says not only must
//                             `T` be an impl of `Trait`
//                             but also that the impl
//                             must assign the type `u32`
//                             to the associated type.
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }
//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//      |                             |
// `i8` does have                     |
// implementation                     |
// of `Trait`...                      |
//                     ... but it is an implementation
//                     that assigns `&amp;'static str` to
//                     the associated type.

foo(3_i8);
// Here, we invoke `foo` with an `i8`, which does not satisfy
// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and
// therefore the type-checker complains with this error code.
<span class="boring">}</span></code></pre></pre>
<p>The issue can be resolved by changing the associated type:</p>
<ol>
<li>in the <code>foo</code> implementation:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = &amp;'static str&gt; {
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }

foo(3_i8);
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>in the <code>Trait</code> implementation for <code>i8</code>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = u32&gt; {
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = u32; }

foo(3_i8);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0275"><a class="header" href="#error-code-e0275">Error code E0275</a></h1>
<p>An evaluation of a trait requirement overflowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0275"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

struct Bar&lt;T&gt;(T);

impl&lt;T&gt; Foo for T where Bar&lt;T&gt;: Foo {}
<span class="boring">}</span></code></pre></pre>
<p>This error occurs when there was a recursive trait requirement that overflowed
before it could be evaluated. This often means that there is an unbounded
recursion in resolving some type bounds.</p>
<p>To determine if a <code>T</code> is <code>Foo</code>, we need to check if <code>Bar&lt;T&gt;</code> is <code>Foo</code>. However,
to do this check, we need to determine that <code>Bar&lt;Bar&lt;T&gt;&gt;</code> is <code>Foo</code>. To
determine this, we check if <code>Bar&lt;Bar&lt;Bar&lt;T&gt;&gt;&gt;</code> is <code>Foo</code>, and so on. This is
clearly a recursive requirement that can't be resolved directly.</p>
<p>Consider changing your trait bounds so that they're less self-referential.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0276"><a class="header" href="#error-code-e0276">Error code E0276</a></h1>
<p>A trait implementation has stricter requirements than the trait definition.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0276"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo&lt;T&gt;(x: T);
}

impl Foo for bool {
    fn foo&lt;T&gt;(x: T) where T: Copy {}
}
<span class="boring">}</span></code></pre></pre>
<p>Here, all types implementing <code>Foo</code> must have a method <code>foo&lt;T&gt;(x: T)</code> which can
take any type <code>T</code>. However, in the <code>impl</code> for <code>bool</code>, we have added an extra
bound that <code>T</code> is <code>Copy</code>, which isn't compatible with the original trait.</p>
<p>Consider removing the bound from the method or adding the bound to the original
method definition in the trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0277"><a class="header" href="#error-code-e0277">Error code E0277</a></h1>
<p>You tried to use a type which doesn't implement some trait in a place which
expected that trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277">// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&amp;self);
}

// we now declare a function which takes an object implementing the Foo trait
fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar();
}

fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
}</code></pre></pre>
<p>In order to fix this error, verify that the type you're using does implement
the trait. Example:</p>
<pre><pre class="playground"><code class="language-rust">trait Foo {
    fn bar(&amp;self);
}

// we implement the trait on the i32 type
impl Foo for i32 {
    fn bar(&amp;self) {}
}

fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar(); // we can now use this method since i32 implements the
               // Foo trait
}

fn main() {
    some_func(5i32); // ok!
}</code></pre></pre>
<p>Or in a generic context, an erroneous code example would look like:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277">fn some_func&lt;T&gt;(foo: T) {
    println!("{:?}", foo); // error: the trait `core::fmt::Debug` is not
                           //        implemented for the type `T`
}

fn main() {
    // We now call the method with the i32 type,
    // which *does* implement the Debug trait.
    some_func(5i32);
}</code></pre></pre>
<p>Note that the error here is in the definition of the generic function. Although
we only call it with a parameter that does implement <code>Debug</code>, the compiler
still rejects the function. It must work with all possible input types. In
order to make this example compile, we need to restrict the generic type we're
accepting:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

// Restrict the input type to types that implement Debug.
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!("{:?}", foo);
}

fn main() {
    // Calling the method is still fine, as i32 implements Debug.
    some_func(5i32);

    // This would fail to compile now:
    // struct WithoutDebug;
    // some_func(WithoutDebug);
}</code></pre></pre>
<p>Rust only looks at the signature of the called function, as such it must
already specify all requirements that will be used for every type parameter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0281"><a class="header" href="#error-code-e0281">Error code E0281</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-33"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-33">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You tried to supply a type which doesn't implement some trait in a location
which expected that trait. This error typically occurs when working with
<code>Fn</code>-based types. Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn foo&lt;F: Fn(usize)&gt;(x: F) { }

fn main() {
    // type mismatch: ... implements the trait `core::ops::Fn&lt;(String,)&gt;`,
    // but the trait `core::ops::Fn&lt;(usize,)&gt;` is required
    // [E0281]
    foo(|y: String| { });
}</code></pre></pre>
<p>The issue in this case is that <code>foo</code> is defined as accepting a <code>Fn</code> with one
argument of type <code>String</code>, but the closure we attempted to pass to it requires
one arguments of type <code>usize</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0282"><a class="header" href="#error-code-e0282">Error code E0282</a></h1>
<p>The compiler could not infer a type and asked for a type annotation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0282"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that type inference did not result in one unique possible
type, and extra information is required. In most cases this can be provided
by adding a type annotation. Sometimes you need to specify a generic type
parameter manually.</p>
<p>In the example above, type <code>Vec</code> has a type parameter <code>T</code>. When calling
<code>Vec::new</code>, barring any other later usage of the variable <code>x</code> that allows the
compiler to infer what type <code>T</code> is, the compiler needs to be told what it is.</p>
<p>The type can be specified on the variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>The type can also be specified in the path of the expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Vec::&lt;i32&gt;::new();
<span class="boring">}</span></code></pre></pre>
<p>In cases with more complex types, it is not necessary to annotate the full
type. Once the ambiguity is resolved, the compiler can infer the rest:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;_&gt; = "hello".chars().rev().collect();
<span class="boring">}</span></code></pre></pre>
<p>Another way to provide the compiler with enough information, is to specify the
generic type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "hello".chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>Again, you need not specify the full type if the compiler can infer it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "hello".chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>Apart from a method or function with a generic type parameter, this error can
occur when a type parameter of a struct or trait cannot be inferred. In that
case it is not always possible to use a type annotation, because all candidates
have the same return type. For instance:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0282"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; {
    num: T,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    fn bar() -&gt; i32 {
        0
    }

    fn baz() {
        let number = Foo::bar();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This will fail because the compiler does not know which instance of <code>Foo</code> to
call <code>bar</code> on. Change <code>Foo::bar()</code> to <code>Foo::&lt;T&gt;::bar()</code> to resolve the error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0283"><a class="header" href="#error-code-e0283">Error code E0283</a></h1>
<p>The compiler could not infer a type and asked for a type annotation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0283"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "hello".chars().rev().collect();
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that type inference did not result in one unique possible
type, and extra information is required. In most cases this can be provided
by adding a type annotation. Sometimes you need to specify a generic type
parameter manually.</p>
<p>A common example is the <code>collect</code> method on <code>Iterator</code>. It has a generic type
parameter with a <code>FromIterator</code> bound, which for a <code>char</code> iterator is
implemented by <code>Vec</code> and <code>String</code> among others. Consider the following snippet
that reverses the characters of a string:</p>
<p>In the first code example, the compiler cannot infer what the type of <code>x</code> should
be: <code>Vec&lt;char&gt;</code> and <code>String</code> are both suitable candidates. To specify which type
to use, you can use a type annotation on <code>x</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;char&gt; = "hello".chars().rev().collect();
<span class="boring">}</span></code></pre></pre>
<p>It is not necessary to annotate the full type. Once the ambiguity is resolved,
the compiler can infer the rest:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;_&gt; = "hello".chars().rev().collect();
<span class="boring">}</span></code></pre></pre>
<p>Another way to provide the compiler with enough information, is to specify the
generic type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "hello".chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>Again, you need not specify the full type if the compiler can infer it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "hello".chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>We can see a self-contained example below:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0283"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Into&lt;u32&gt; for Foo {
    fn into(self) -&gt; u32 { 1 }
}

let foo = Foo;
let bar: u32 = foo.into() * 1u32;
<span class="boring">}</span></code></pre></pre>
<p>This error can be solved by adding type annotations that provide the missing
information to the compiler. In this case, the solution is to specify the
trait's type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Into&lt;u32&gt; for Foo {
    fn into(self) -&gt; u32 { 1 }
}

let foo = Foo;
let bar: u32 = Into::&lt;u32&gt;::into(foo) * 1u32;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0284"><a class="header" href="#error-code-e0284">Error code E0284</a></h1>
<p>This error occurs when the compiler is unable to unambiguously infer the
return type of a function or method which is generic on return type, such
as the <code>collect</code> method for <code>Iterator</code>s.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0284">fn main() {
    let n: u32 = 1;
    let mut d: u64 = 2;
    d = d + n.into();
}</code></pre></pre>
<p>Here we have an addition of <code>d</code> and <code>n.into()</code>. Hence, <code>n.into()</code> can return
any type <code>T</code> where <code>u64: Add&lt;T&gt;</code>. On the other hand, the <code>into</code> method can
return any type where <code>u32: Into&lt;T&gt;</code>.</p>
<p>The author of this code probably wants <code>into()</code> to return a <code>u64</code>, but the
compiler can't be sure that there isn't another type <code>T</code> where both
<code>u32: Into&lt;T&gt;</code> and <code>u64: Add&lt;T&gt;</code>.</p>
<p>To resolve this error, use a concrete type for the intermediate expression:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let n: u32 = 1;
    let mut d: u64 = 2;
    let m: u64 = n.into();
    d = d + m;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0297"><a class="header" href="#error-code-e0297">Error code E0297</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-34"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-34">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Patterns used to bind names must be irrefutable. That is, they must guarantee
that a name will be extracted in all cases. Instead of pattern matching the
loop variable, consider using a <code>match</code> or <code>if let</code> inside the loop body. For
instance:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0005"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

// This fails because `None` is not covered.
for Some(x) in xs {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Match inside the loop instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    match item {
        Some(x) =&gt; {},
        None =&gt; {},
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Or use <code>if let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    if let Some(x) = item {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0301"><a class="header" href="#error-code-e0301">Error code E0301</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-35"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-35">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Mutable borrows are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if mutable
borrows were allowed:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0596"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(()) {
    None =&gt; { },
    option if option.take().is_none() =&gt; {
        /* impossible, option is `Some` */
    },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0302"><a class="header" href="#error-code-e0302">Error code E0302</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-36"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-36">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Assignments are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if assignments
were allowed:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0594"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(()) {
    None =&gt; { },
    option if { option = None; false } =&gt; { },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0303"><a class="header" href="#error-code-e0303">Error code E0303</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-37"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-37">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Sub-bindings, e.g. <code>ref x @ Some(ref y)</code> are now allowed under
<code>#![feature(bindings_after_at)]</code> and checked to make sure that
memory safety is upheld.</p>
<hr />
<p>In certain cases it is possible for sub-bindings to violate memory safety.
Updates to the borrow checker in a future version of Rust may remove this
restriction, but for now patterns must be rewritten without sub-bindings.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some("hi".to_string()) {
    ref op_string_ref @ Some(s) =&gt; {},
    None =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some("hi".to_string()) {
    Some(ref s) =&gt; {
        let op_string_ref = &amp;Some(s);
        // ...
    },
    None =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>op_string_ref</code> binding has type <code>&amp;Option&lt;&amp;String&gt;</code> in both cases.</p>
<p>See also <a href="https://github.com/rust-lang/rust/issues/14587">Issue 14587</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0307"><a class="header" href="#error-code-e0307">Error code E0307</a></h1>
<p>The <code>self</code> parameter in a method has an invalid "receiver type".</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0307"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
struct Bar;

trait Trait {
    fn foo(&amp;self);
}

impl Trait for Foo {
    fn foo(self: &amp;Bar) {}
}
<span class="boring">}</span></code></pre></pre>
<p>Methods take a special first parameter, of which there are three variants:
<code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>. These are syntactic sugar for
<code>self: Self</code>, <code>self: &amp;Self</code>, and <code>self: &amp;mut Self</code> respectively.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span>trait Trait {
    fn foo(&amp;self);
//         ^^^^^ `self` here is a reference to the receiver object
}

impl Trait for Foo {
    fn foo(&amp;self) {}
//         ^^^^^ the receiver type is `&amp;Foo`
}
<span class="boring">}</span></code></pre></pre>
<p>The type <code>Self</code> acts as an alias to the type of the current trait
implementer, or "receiver type". Besides the already mentioned <code>Self</code>,
<code>&amp;Self</code> and <code>&amp;mut Self</code> valid receiver types, the following are also valid:
<code>self: Box&lt;Self&gt;</code>, <code>self: Rc&lt;Self&gt;</code>, <code>self: Arc&lt;Self&gt;</code>, and <code>self: Pin&lt;P&gt;</code>
(where P is one of the previous types except <code>Self</code>). Note that <code>Self</code> can
also be the underlying implementing type, like <code>Foo</code> in the following
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">trait Trait {
</span><span class="boring">    fn foo(&amp;self);
</span><span class="boring">}
</span>impl Trait for Foo {
    fn foo(self: &amp;Foo) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This error will be emitted by the compiler when using an invalid receiver type,
like in the following example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0307"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">trait Trait {
</span><span class="boring">    fn foo(&amp;self);
</span><span class="boring">}
</span>impl Trait for Foo {
    fn foo(self: &amp;Bar) {}
}
<span class="boring">}</span></code></pre></pre>
<p>The nightly feature <a href="https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html">Arbitrary self types</a> extends the accepted
set of receiver types to also include any type that implements the
<code>Receiver</code> trait and can follow its chain of <code>Target</code> types to <code>Self</code>.
There's a blanket implementation of <code>Receiver</code> for <code>T: Deref</code>, so any
type which dereferences to <code>Self</code> can be used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(arbitrary_self_types)]

<span class="boring">fn main() {
</span>struct Foo;
struct Bar;

// Because you can dereference `Bar` into `Foo`...
impl std::ops::Deref for Bar {
    type Target = Foo;

    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;Foo
    }
}

impl Foo {
    fn foo(self: Bar) {}
//         ^^^^^^^^^ ...it can be used as the receiver type
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0308"><a class="header" href="#error-code-e0308">Error code E0308</a></h1>
<p>Expected type did not match the received type.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0308"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: i32) -&gt; i32 {
    x + 1
}

plus_one("Not a number");
//       ^^^^^^^^^^^^^^ expected `i32`, found `&amp;str`

if "Not a bool" {
// ^^^^^^^^^^^^ expected `bool`, found `&amp;str`
}

let x: f32 = "Not a float";
//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&amp;str`
//     |
//     expected due to this
<span class="boring">}</span></code></pre></pre>
<p>This error occurs when an expression was used in a place where the compiler
expected an expression of a different type. It can occur in several cases, the
most common being when calling a function and passing an argument which has a
different type than the matching type in the function declaration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0309"><a class="header" href="#error-code-e0309">Error code E0309</a></h1>
<p>A parameter type is missing an explicit lifetime bound and may not live long
enough.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0309"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't compile because the applicable impl of
// `SomeTrait` (below) requires that `T: 'a`, but the struct does
// not have a matching where-clause.
struct Foo&lt;'a, T&gt; {
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output,
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}
<span class="boring">}</span></code></pre></pre>
<p>The type definition contains some field whose type requires an outlives
annotation. Outlives annotations (e.g., <code>T: 'a</code>) are used to guarantee that all
the data in <code>T</code> is valid for at least the lifetime <code>'a</code>. This scenario most
commonly arises when the type contains an associated type reference like
<code>&lt;T as SomeTrait&lt;'a&gt;&gt;::Output</code>, as shown in the previous code.</p>
<p>There, the where clause <code>T: 'a</code> that appears on the impl is not known to be
satisfied on the struct. To make this example compile, you have to add a
where-clause like <code>T: 'a</code> to the struct definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, T&gt;
where
    T: 'a,
{
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0310"><a class="header" href="#error-code-e0310">Error code E0310</a></h1>
<p>A parameter type is missing a lifetime constraint or has a lifetime that
does not live long enough.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0310"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't compile because T is not constrained to the static lifetime
// the reference needs
struct Foo&lt;T&gt; {
    foo: &amp;'static T
}
<span class="boring">}</span></code></pre></pre>
<p>Type parameters in type definitions have lifetimes associated with them that
represent how long the data stored within them is guaranteed to live. This
lifetime must be as long as the data needs to be alive, and missing the
constraint that denotes this will cause this error.</p>
<p>This will compile, because it has the constraint on the type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T: 'static&gt; {
    foo: &amp;'static T
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0311"><a class="header" href="#error-code-e0311">Error code E0311</a></h1>
<p>This error occurs when there is an unsatisfied outlives bound involving an
elided region and a generic type parameter or associated type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0311"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_restriction&lt;T&gt;(x: &amp;()) -&gt; &amp;() {
    with_restriction::&lt;T&gt;(x)
}

fn with_restriction&lt;'a, T: 'a&gt;(x: &amp;'a ()) -&gt; &amp;'a () {
    x
}
<span class="boring">}</span></code></pre></pre>
<p>Why doesn't this code compile? It helps to look at the lifetime bounds that are
automatically added by the compiler. For more details see the documentation for
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision</a>.</p>
<p>The compiler elides the lifetime of <code>x</code> and the return type to some arbitrary
lifetime <code>'anon</code> in <code>no_restriction()</code>. The only information available to the
compiler is that <code>'anon</code> is valid for the duration of the function. When
calling <code>with_restriction()</code>, the compiler requires the completely unrelated
type parameter <code>T</code> to outlive <code>'anon</code> because of the <code>T: 'a</code> bound in
<code>with_restriction()</code>. This causes an error because <code>T</code> is not required to
outlive <code>'anon</code> in <code>no_restriction()</code>.</p>
<p>If <code>no_restriction()</code> were to use <code>&amp;T</code> instead of <code>&amp;()</code> as an argument, the
compiler would have added an implied bound, causing this to compile.</p>
<p>This error can be resolved by explicitly naming the elided lifetime for <code>x</code> and
then explicitly requiring that the generic parameter <code>T</code> outlives that lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_restriction&lt;'a, T: 'a&gt;(x: &amp;'a ()) -&gt; &amp;'a () {
    with_restriction::&lt;T&gt;(x)
}

fn with_restriction&lt;'a, T: 'a&gt;(x: &amp;'a ()) -&gt; &amp;'a () {
    x
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0312"><a class="header" href="#error-code-e0312">Error code E0312</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-38"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-38">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Reference's lifetime of borrowed content doesn't match the expected lifetime.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn opt_str&lt;'a&gt;(maybestr: &amp;'a Option&lt;String&gt;) -&gt; &amp;'static str {
    if maybestr.is_none() {
        "(none)"
    } else {
        let s: &amp;'a str = maybestr.as_ref().unwrap();
        s  // Invalid lifetime!
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, either lessen the expected lifetime or find a way to not have
to use this reference outside of its current scope (by running the code directly
in the same block for example?):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In this case, we can fix the issue by switching from "static" lifetime to 'a
pub fn opt_str&lt;'a&gt;(maybestr: &amp;'a Option&lt;String&gt;) -&gt; &amp;'a str {
    if maybestr.is_none() {
        "(none)"
    } else {
        let s: &amp;'a str = maybestr.as_ref().unwrap();
        s  // Ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0316"><a class="header" href="#error-code-e0316">Error code E0316</a></h1>
<p>A <code>where</code> clause contains a nested quantification over lifetimes.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0316"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr&lt;'a, 'b&gt; {}

fn foo&lt;T&gt;(t: T)
where
    for&lt;'a&gt; &amp;'a T: for&lt;'b&gt; Tr&lt;'a, 'b&gt;, // error: nested quantification
{
}
<span class="boring">}</span></code></pre></pre>
<p>Rust syntax allows lifetime quantifications in two places within
<code>where</code> clauses: Quantifying over the trait bound only (as in
<code>Ty: for&lt;'l&gt; Trait&lt;'l&gt;</code>) and quantifying over the whole clause
(as in <code>for&lt;'l&gt; &amp;'l Ty: Trait&lt;'l&gt;</code>). Using both in the same clause
leads to a nested lifetime quantification, which is not supported.</p>
<p>The following example compiles, because the clause with the nested
quantification has been rewritten to use only one <code>for&lt;&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr&lt;'a, 'b&gt; {}

fn foo&lt;T&gt;(t: T)
where
    for&lt;'a, 'b&gt; &amp;'a T: Tr&lt;'a, 'b&gt;, // ok
{
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0317"><a class="header" href="#error-code-e0317">Error code E0317</a></h1>
<p>An <code>if</code> expression is missing an <code>else</code> block.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0317"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let a = if x == 5 {
    1
};
<span class="boring">}</span></code></pre></pre>
<p>This error occurs when an <code>if</code> expression without an <code>else</code> block is used in a
context where a type other than <code>()</code> is expected. In the previous code example,
the <code>let</code> expression was expecting a value but since there was no <code>else</code>, no
value was returned.</p>
<p>An <code>if</code> expression without an <code>else</code> block has the type <code>()</code>, so this is a type
error. To resolve it, add an <code>else</code> block having the same type as the <code>if</code>
block.</p>
<p>So to fix the previous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let a = if x == 5 {
    1
} else {
    2
};
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0320"><a class="header" href="#error-code-e0320">Error code E0320</a></h1>
<p>Recursion limit reached while creating drop-check rules.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0320"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum A&lt;T&gt; {
    B,
    C(T, Box&lt;A&lt;(T, T)&gt;&gt;)
}

fn foo&lt;T&gt;() {
    A::&lt;T&gt;::B; // error: overflow while adding drop-check rules for A&lt;T&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>The Rust compiler must be able to reason about how a type is <a href="../std/ops/trait.Drop.html"><code>Drop</code></a>ped, and
by extension the types of its fields, to be able to generate the glue to
properly drop a value. The code example above shows a type where this inference
is impossible because it is recursive. Note that this is <em>not</em> the same as
<a href="E0072.html">E0072</a>, where a type has an infinite size; the type here has a
finite size but any attempt to <code>Drop</code> it would recurse infinitely. For more
information, read <a href="../std/ops/trait.Drop.html">the <code>Drop</code> docs</a>.</p>
<p>It is not possible to define a type with recursive drop-check rules. All such
recursion must be removed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0321"><a class="header" href="#error-code-e0321">Error code E0321</a></h1>
<p>A cross-crate opt-out trait was implemented on something which wasn't a struct
or enum type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0321"><span class="boring">#![allow(unused)]
</span>#![feature(auto_traits)]

<span class="boring">fn main() {
</span>struct Foo;

impl !Sync for Foo {}

unsafe impl Send for &amp;'static Foo {}
// error: cross-crate traits with a default impl, like `core::marker::Send`,
//        can only be implemented for a struct/enum type, not
//        `&amp;'static Foo`
<span class="boring">}</span></code></pre></pre>
<p>Only structs and enums are permitted to impl Send, Sync, and other opt-out
trait, and the struct or enum must be local to the current crate. So, for
example, <code>unsafe impl Send for Rc&lt;Foo&gt;</code> is not allowed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0322"><a class="header" href="#error-code-e0322">Error code E0322</a></h1>
<p>A built-in trait was implemented explicitly. All implementations of the trait
are provided automatically by the compiler.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0322"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Sized for Foo {} // error!
<span class="boring">}</span></code></pre></pre>
<p>The <code>Sized</code> trait is a special trait built-in to the compiler for types with a
constant size known at compile-time. This trait is automatically implemented
for types as needed by the compiler, and it is currently disallowed to
explicitly implement it for a type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0323"><a class="header" href="#error-code-e0323">Error code E0323</a></h1>
<p>An associated const was implemented when another trait item was expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0323"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type N;
}

struct Bar;

impl Foo for Bar {
    const N : u32 = 0;
    // error: item `N` is an associated const, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the associated const wasn't misspelled and the correct trait
was implemented. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0324"><a class="header" href="#error-code-e0324">Error code E0324</a></h1>
<p>A method was implemented when another trait item was expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0324"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    fn N() {}
    // error: item `N` is an associated method, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please verify that the method name wasn't misspelled and
verify that you are indeed implementing the correct trait items. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    const N : u32 = 0;

    fn M() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0325"><a class="header" href="#error-code-e0325">Error code E0325</a></h1>
<p>An associated type was implemented when another trait item was expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0325"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    type N = u32;
    // error: item `N` is an associated type, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the associated type name wasn't misspelled and your
implementation corresponds to the trait definition. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0326"><a class="header" href="#error-code-e0326">Error code E0326</a></h1>
<p>An implementation of a trait doesn't match the type constraint.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0326"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const BAR: bool;
}

struct Bar;

impl Foo for Bar {
    const BAR: u32 = 5; // error, expected bool, found u32
}
<span class="boring">}</span></code></pre></pre>
<p>The types of any associated constants in a trait implementation must match the
types in the trait definition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0328"><a class="header" href="#error-code-e0328">Error code E0328</a></h1>
<p>The Unsize trait should not be implemented directly. All implementations of
Unsize are provided automatically by the compiler.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0328"><span class="boring">#![allow(unused)]
</span>#![feature(unsize)]

<span class="boring">fn main() {
</span>use std::marker::Unsize;

pub struct MyType;

impl&lt;T&gt; Unsize&lt;T&gt; for MyType {}
<span class="boring">}</span></code></pre></pre>
<p>If you are defining your own smart pointer type and would like to enable
conversion from a sized to an unsized type with the
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md">DST coercion system</a>, use <a href="https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html"><code>CoerceUnsized</code></a> instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]

<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

pub struct MyType&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

impl&lt;T, U&gt; CoerceUnsized&lt;MyType&lt;U&gt;&gt; for MyType&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0329"><a class="header" href="#error-code-e0329">Error code E0329</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-39"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-39">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An attempt was made to access an associated constant through either a generic
type parameter or <code>Self</code>. This is not supported yet. An example causing this
error is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const BAR: f64;
}

struct MyStruct;

impl Foo for MyStruct {
    const BAR: f64 = 0f64;
}

fn get_bar_bad&lt;F: Foo&gt;(t: F) -&gt; f64 {
    F::BAR
}
<span class="boring">}</span></code></pre></pre>
<p>Currently, the value of <code>BAR</code> for a particular type can only be accessed
through a concrete type, as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const BAR: f64;
}

struct MyStruct;

impl Foo for MyStruct {
    const BAR: f64 = 0f64;
}

fn get_bar_good() -&gt; f64 {
    &lt;MyStruct as Foo&gt;::BAR
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0364"><a class="header" href="#error-code-e0364">Error code E0364</a></h1>
<p>Private items cannot be publicly re-exported. This error indicates that you
attempted to <code>pub use</code> a type or value that was not itself public.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0364"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    fn foo() {}

    mod a {
        pub use super::foo; // error!
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The solution to this problem is to ensure that the items that you are
re-exporting are themselves marked with <code>pub</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    pub fn foo() {} // ok!

    mod a {
        pub use super::foo;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/reference/items/use-declarations.html">Use Declarations</a> section of the reference for
more information on this topic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0365"><a class="header" href="#error-code-e0365">Error code E0365</a></h1>
<p>Private modules cannot be publicly re-exported. This error indicates that you
attempted to <code>pub use</code> a module that was not itself public.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0365">mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</code></pre></pre>
<p>The solution to this problem is to ensure that the module that you are
re-exporting is itself marked with <code>pub</code>:</p>
<pre><pre class="playground"><code class="language-rust">pub mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/reference/items/use-declarations.html">Use Declarations</a> section of the reference for
more information on this topic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0366"><a class="header" href="#error-code-e0366">Error code E0366</a></h1>
<p>An attempt was made to implement <code>Drop</code> on a concrete specialization of a
generic type. An example is shown below:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0366"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; {
    t: T
}

impl Drop for Foo&lt;u32&gt; {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of
implementations of a generic type. One workaround for this is to wrap the
generic type, as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; {
    t: T
}

struct Bar {
    t: Foo&lt;u32&gt;
}

impl Drop for Bar {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0367"><a class="header" href="#error-code-e0367">Error code E0367</a></h1>
<p>An attempt was made to implement <code>Drop</code> on a specialization of a generic type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0367"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

struct MyStruct&lt;T&gt; {
    t: T
}

impl&lt;T: Foo&gt; Drop for MyStruct&lt;T&gt; {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of
implementations of a generic type. In order for this code to work, <code>MyStruct</code>
must also require that <code>T</code> implements <code>Foo</code>. Alternatively, another option is
to wrap the generic type in another that specializes appropriately:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo{}

struct MyStruct&lt;T&gt; {
    t: T
}

struct MyStructWrapper&lt;T: Foo&gt; {
    t: MyStruct&lt;T&gt;
}

impl &lt;T: Foo&gt; Drop for MyStructWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0368"><a class="header" href="#error-code-e0368">Error code E0368</a></h1>
<p>A binary assignment operator like <code>+=</code> or <code>^=</code> was applied to a type that
doesn't support it.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0368"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
                   //        type `f32`

x &lt;&lt;= 2;
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please check that this type implements this binary
operation. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait

x &lt;&lt;= 2; // ok!
<span class="boring">}</span></code></pre></pre>
<p>It is also possible to overload most operators for your own type by
implementing the <code>[OP]Assign</code> traits from <code>std::ops</code>.</p>
<p>Another problem you might be facing is this: suppose you've overloaded the <code>+</code>
operator for some type <code>Foo</code> by implementing the <code>std::ops::Add</code> trait for
<code>Foo</code>, but you find that using <code>+=</code> does not work, as in this example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0368">use std::ops::Add;

struct Foo(u32);

impl Add for Foo {
    type Output = Foo;

    fn add(self, rhs: Foo) -&gt; Foo {
        Foo(self.0 + rhs.0)
    }
}

fn main() {
    let mut x: Foo = Foo(5);
    x += Foo(7); // error, `+=` cannot be applied to the type `Foo`
}</code></pre></pre>
<p>This is because <code>AddAssign</code> is not automatically implemented, so you need to
manually implement it for your type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0369"><a class="header" href="#error-code-e0369">Error code E0369</a></h1>
<p>A binary operation was attempted on a type which doesn't support it.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0369"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
               //        type `f32`

x &lt;&lt; 2;
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please check that this type implements this binary
operation. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 12u32; // the `u32` type does implement it:
               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html

x &lt;&lt; 2; // ok!
<span class="boring">}</span></code></pre></pre>
<p>It is also possible to overload most operators for your own type by
implementing traits from <code>std::ops</code>.</p>
<p>String concatenation appends the string on the right to the string on the
left and may require reallocation. This requires ownership of the string
on the left. If something should be added to a string literal, move the
literal to the heap by allocating it with <code>to_owned()</code> like in
<code>"Your text".to_owned()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0370"><a class="header" href="#error-code-e0370">Error code E0370</a></h1>
<p>The maximum value of an enum was reached, so it cannot be automatically
set in the next enum value.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0370"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i64)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y, // error: enum discriminant overflowed on value after
       //        9223372036854775807: i64; set explicitly via
       //        Y = -9223372036854775808 if that is desired outcome
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this, please set manually the next enum value or put the enum variant
with the maximum value at the end of the enum. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i64)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y = 0, // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i64)]
enum Foo {
    Y = 0, // ok!
    X = 0x7fffffffffffffff,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0371"><a class="header" href="#error-code-e0371">Error code E0371</a></h1>
<p>A trait was implemented on another which already automatically implemented it.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0371"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo { fn foo(&amp;self) { } }
trait Bar: Foo { }
trait Baz: Bar { }

impl Bar for Baz { } // error, `Baz` implements `Bar` by definition
impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`
impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`
impl Baz for Bar { } // Note: This is OK
<span class="boring">}</span></code></pre></pre>
<p>When <code>Trait2</code> is a subtrait of <code>Trait1</code> (for example, when <code>Trait2</code> has a
definition like <code>trait Trait2: Trait1 { ... }</code>), it is not allowed to implement
<code>Trait1</code> for <code>Trait2</code>. This is because <code>Trait2</code> already implements <code>Trait1</code> by
definition, so it is not useful to do this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0373"><a class="header" href="#error-code-e0373">Error code E0373</a></h1>
<p>A captured variable in a closure may not live long enough.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0373"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Box&lt;dyn Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(|y| x + y)
}
<span class="boring">}</span></code></pre></pre>
<p>This error occurs when an attempt is made to use data captured by a closure,
when that data may no longer exist. It's most commonly seen when attempting to
return a closure as shown in the previous code example.</p>
<p>Notice that <code>x</code> is stack-allocated by <code>foo()</code>. By default, Rust captures
closed-over data by reference. This means that once <code>foo()</code> returns, <code>x</code> no
longer exists. An attempt to access <code>x</code> within the closure would thus be
unsafe.</p>
<p>Another situation where this might be encountered is when spawning threads:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0373"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 0u32;
    let y = 1u32;

    let thr = std::thread::spawn(|| {
        x + y
    });
}
<span class="boring">}</span></code></pre></pre>
<p>Since our new thread runs in parallel, the stack frame containing <code>x</code> and <code>y</code>
may well have disappeared by the time we try to use them. Even if we call
<code>thr.join()</code> within foo (which blocks until <code>thr</code> has completed, ensuring the
stack frame won't disappear), we will not succeed: the compiler cannot prove
that this behavior is safe, and so won't let us do it.</p>
<p>The solution to this problem is usually to switch to using a <code>move</code> closure.
This approach moves (or copies, where possible) data into the closure, rather
than taking references to it. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Box&lt;dyn Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(move |y| x + y)
}
<span class="boring">}</span></code></pre></pre>
<p>Now that the closure has its own copy of the data, there's no need to worry
about safety.</p>
<p>This error may also be encountered while using <code>async</code> blocks:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0373 edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

async fn f() {
    let v = vec![1, 2, 3i32];
    spawn(async { //~ ERROR E0373
        println!("{:?}", v)
    });
}

fn spawn&lt;F: Future + Send + 'static&gt;(future: F) {
    unimplemented!()
}
<span class="boring">}</span></code></pre></pre>
<p>Similarly to closures, <code>async</code> blocks are not executed immediately and may
capture closed-over data by reference. For more information, see
<a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html">https://rust-lang.github.io/async-book/03_async_await/01_chapter.html</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0374"><a class="header" href="#error-code-e0374">Error code E0374</a></h1>
<p><code>CoerceUnsized</code> or <code>DispatchFromDyn</code> was implemented on a struct which does not
contain a field that is being unsized.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0374"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
}

// error: Struct `Foo` has no unsized fields that need to be coerced.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}
<span class="boring">}</span></code></pre></pre>
<p><code>CoerceUnsized</code> is used to coerce structs that have a field that can be unsized,
like a custom <code>MyBox&lt;T&gt;</code> being unsized to <code>MyBox&lt;dyn Trait&gt;</code>. <code>DispatchFromDyn</code>
is used to dispatch from <code>MyBox&lt;dyn Trait&gt;</code> to <code>MyBox&lt;Self&gt;</code> in a dyn-compatible
trait.</p>
<p>If the struct doesn't have any fields of unsized types then there is no
meaningful way to implement <code>CoerceUnsized</code> or <code>DispatchFromDyn</code>, since
there is no coercion taking place.</p>
<p>Note that <code>CoerceUnsized</code> and <code>DispatchFromDyn</code> is mainly used by smart pointers
like <code>Box</code>, <code>Rc</code> and <code>Arc</code> to be able to mark that they can coerce unsized types
that they are pointing at.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0375"><a class="header" href="#error-code-e0375">Error code E0375</a></h1>
<p><code>CoerceUnsized</code> or <code>DispatchFromDyn</code> was implemented on a struct which contains
more than one field that is being unsized.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0375"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized, U: ?Sized&gt; {
    a: i32,
    b: T,
    c: U,
}

// error: Struct `Foo` has more than one unsized field.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U, T&gt;&gt; for Foo&lt;T, U&gt; {}
<span class="boring">}</span></code></pre></pre>
<p><code>CoerceUnsized</code> is used to coerce structs that have a field that can be unsized,
like a custom <code>MyBox&lt;T&gt;</code> being unsized to <code>MyBox&lt;dyn Trait&gt;</code>. <code>DispatchFromDyn</code>
is used to dispatch from <code>MyBox&lt;dyn Trait&gt;</code> to <code>MyBox&lt;Self&gt;</code> in a dyn-compatible
trait.</p>
<p>If the struct has multiple fields that must be unsized, then the compiler has no
way to generate a valid implementation of <code>CoerceUnsized</code> or <code>DispatchFromDyn</code>.</p>
<p>Note that <code>CoerceUnsized</code> and <code>DispatchFromDyn</code> is mainly used by smart pointers
like <code>Box</code>, <code>Rc</code> and <code>Arc</code> to be able to mark that they can coerce unsized types
that they are pointing at.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0376"><a class="header" href="#error-code-e0376">Error code E0376</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-40"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-40">Note: this error code is no longer emitted by the compiler.</a></h4>
<p><code>CoerceUnsized</code> or <code>DispatchFromDyn</code> was implemented between two types that
are not structs.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0377"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: T,
}

// error: The type `U` is not a struct
impl&lt;T, U&gt; CoerceUnsized&lt;U&gt; for Foo&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p><code>CoerceUnsized</code> or <code>DispatchFromDyn</code> can only be implemented between structs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0377"><a class="header" href="#error-code-e0377">Error code E0377</a></h1>
<p><code>CoerceUnsized</code> or <code>DispatchFromDyn</code> may only be implemented between structs
of the same type.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0377"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

pub struct Foo&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

pub struct Bar&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

// error: the trait `CoerceUnsized` may only be implemented for a coercion
//        between structures with the same definition
impl&lt;T, U&gt; CoerceUnsized&lt;Bar&lt;U&gt;&gt; for Foo&lt;T&gt; where T: CoerceUnsized&lt;U&gt; {}
<span class="boring">}</span></code></pre></pre>
<p><code>CoerceUnsized</code> is used to coerce structs that have a field that can be unsized,
like a custom <code>MyBox&lt;T&gt;</code> being unsized to <code>MyBox&lt;dyn Trait&gt;</code>. <code>DispatchFromDyn</code>
is used to dispatch from <code>MyBox&lt;dyn Trait&gt;</code> to <code>MyBox&lt;Self&gt;</code> in a dyn-compatible
trait.</p>
<p>The compiler cannot support coercions between structs of different types, so
a valid implementation of <code>CoerceUnsized</code> or <code>DispatchFromDyn</code> should be
implemented between the same struct with different generic parameters.</p>
<p>Note that <code>CoerceUnsized</code> and <code>DispatchFromDyn</code> is mainly used by smart pointers
like <code>Box</code>, <code>Rc</code> and <code>Arc</code> to be able to mark that they can coerce unsized types
that they are pointing at.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0378"><a class="header" href="#error-code-e0378">Error code E0378</a></h1>
<p>The <code>DispatchFromDyn</code> trait was implemented on something which is not a pointer
or a newtype wrapper around a pointer.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0378"><span class="boring">#![allow(unused)]
</span>#![feature(dispatch_from_dyn)]
<span class="boring">fn main() {
</span>use std::ops::DispatchFromDyn;

struct WrapperExtraField&lt;T&gt; {
    ptr: T,
    extra_stuff: i32,
}

impl&lt;T, U&gt; DispatchFromDyn&lt;WrapperExtraField&lt;U&gt;&gt; for WrapperExtraField&lt;T&gt;
where
    T: DispatchFromDyn&lt;U&gt;,
{}
<span class="boring">}</span></code></pre></pre>
<p>The <code>DispatchFromDyn</code> trait currently can only be implemented for
builtin pointer types and structs that are newtype wrappers around them
— that is, the struct must have only one field (except for <code>PhantomData</code>),
and that field must itself implement <code>DispatchFromDyn</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(dispatch_from_dyn, unsize)]
<span class="boring">fn main() {
</span>use std::{
    marker::Unsize,
    ops::DispatchFromDyn,
};

struct Ptr&lt;T: ?Sized&gt;(*const T);

impl&lt;T: ?Sized, U: ?Sized&gt; DispatchFromDyn&lt;Ptr&lt;U&gt;&gt; for Ptr&lt;T&gt;
where
    T: Unsize&lt;U&gt;,
{}
<span class="boring">}</span></code></pre></pre>
<p>Another example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(dispatch_from_dyn)]
<span class="boring">fn main() {
</span>use std::{
    ops::DispatchFromDyn,
    marker::PhantomData,
};

struct Wrapper&lt;T&gt; {
    ptr: T,
    _phantom: PhantomData&lt;()&gt;,
}

impl&lt;T, U&gt; DispatchFromDyn&lt;Wrapper&lt;U&gt;&gt; for Wrapper&lt;T&gt;
where
    T: DispatchFromDyn&lt;U&gt;,
{}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0379"><a class="header" href="#error-code-e0379">Error code E0379</a></h1>
<p>A trait method was declared const.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0379"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const fn bar() -&gt; u32; // error!
}

impl Foo for () {
    const fn bar() -&gt; u32 { 0 } // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Trait methods cannot be declared <code>const</code> by design. For more information, see
<a href="https://github.com/rust-lang/rfcs/pull/911">RFC 911</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0380"><a class="header" href="#error-code-e0380">Error code E0380</a></h1>
<p>An auto trait was declared with a method or an associated item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0380"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe auto trait Trait {
    type Output; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Auto traits cannot have methods or associated items. For more information see
the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0381"><a class="header" href="#error-code-e0381">Error code E0381</a></h1>
<p>It is not allowed to use or capture an uninitialized variable.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0381">fn main() {
    let x: i32;
    let y = x; // error, use of possibly-uninitialized variable
}</code></pre></pre>
<p>To fix this, ensure that any declared variables are initialized before being
used. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 0;
    let y = x; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0382"><a class="header" href="#error-code-e0382">Error code E0382</a></h1>
<p>A variable was used after its contents have been moved elsewhere.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382">struct MyStruct { s: u32 }

fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
}</code></pre></pre>
<p>Since <code>MyStruct</code> is a type that is not marked <code>Copy</code>, the data gets moved out
of <code>x</code> when we set <code>y</code>. This is fundamental to Rust's ownership system: outside
of workarounds like <code>Rc</code>, a value cannot be owned by more than one variable.</p>
<p>Sometimes we don't need to move the value. Using a reference, we can let another
function borrow the value without changing its ownership. In the example below,
we don't actually have to move our string to <code>calculate_length</code>, we can give it
a reference to it with <code>&amp;</code> instead.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>A mutable reference can be created with <code>&amp;mut</code>.</p>
<p>Sometimes we don't want a reference, but a duplicate. All types marked <code>Clone</code>
can be duplicated by calling <code>.clone()</code>. Subsequent changes to a clone do not
affect the original variable.</p>
<p>Most types in the standard library are marked <code>Clone</code>. The example below
demonstrates using <code>clone()</code> on a string. <code>s1</code> is first set to "many", and then
copied to <code>s2</code>. Then the first character of <code>s1</code> is removed, without affecting
<code>s2</code>. "any many" is printed to the console.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s1 = String::from("many");
    let s2 = s1.clone();
    s1.remove(0);
    println!("{} {}", s1, s2);
}</code></pre></pre>
<p>If we control the definition of a type, we can implement <code>Clone</code> on it ourselves
with <code>#[derive(Clone)]</code>.</p>
<p>Some types have no ownership semantics at all and are trivial to duplicate. An
example is <code>i32</code> and the other number types. We don't have to call <code>.clone()</code> to
clone them, because they are marked <code>Copy</code> in addition to <code>Clone</code>. Implicit
cloning is more convenient in this case. We can mark our own types <code>Copy</code> if
all their members also are marked <code>Copy</code>.</p>
<p>In the example below, we implement a <code>Point</code> type. Because it only stores two
integers, we opt-out of ownership semantics with <code>Copy</code>. Then we can
<code>let p2 = p1</code> without <code>p1</code> being moved.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Copy, Clone)]
struct Point { x: i32, y: i32 }

fn main() {
    let mut p1 = Point{ x: -1, y: 2 };
    let p2 = p1;
    p1.x = 1;
    println!("p1: {}, {}", p1.x, p1.y);
    println!("p2: {}, {}", p2.x, p2.y);
}</code></pre></pre>
<p>Alternatively, if we don't control the struct's definition, or mutable shared
ownership is truly required, we can use <code>Rc</code> and <code>RefCell</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

struct MyStruct { s: u32 }

fn main() {
    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));
    let y = x.clone();
    x.borrow_mut().s = 6;
    println!("{}", x.borrow().s);
}</code></pre></pre>
<p>With this approach, x and y share ownership of the data via the <code>Rc</code> (reference
count type). <code>RefCell</code> essentially performs runtime borrow checking: ensuring
that at most one writer or multiple readers can access the data at any one time.</p>
<p>If you wish to learn more about ownership in Rust, start with the
<a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Understanding Ownership</a> chapter in the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0383"><a class="header" href="#error-code-e0383">Error code E0383</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-41"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-41">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error occurs when an attempt is made to partially reinitialize a
structure that is currently uninitialized.</p>
<p>For example, this can happen when a drop has taken place:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: u32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) { /* ... */ }
}

let mut x = Foo { a: 1 };
drop(x); // `x` is now uninitialized
x.a = 2; // error, partial reinitialization of uninitialized structure `t`
<span class="boring">}</span></code></pre></pre>
<p>This error can be fixed by fully reinitializing the structure in question:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: u32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) { /* ... */ }
}

let mut x = Foo { a: 1 };
drop(x);
x = Foo { a: 2 };
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0384"><a class="header" href="#error-code-e0384">Error code E0384</a></h1>
<p>An immutable variable was reassigned.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0384">fn main() {
    let x = 3;
    x = 5; // error, reassignment of immutable variable
}</code></pre></pre>
<p>By default, variables in Rust are immutable. To fix this error, add the keyword
<code>mut</code> after the keyword <code>let</code> when declaring the variable. For example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 3;
    x = 5;
}</code></pre></pre>
<p>Alternatively, you might consider initializing a new variable: either with a new
bound name or (by <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing">shadowing</a>) with the bound name of your existing variable.
For example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3;
    let x = 5;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0386"><a class="header" href="#error-code-e0386">Error code E0386</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-42"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-42">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error occurs when an attempt is made to mutate the target of a mutable
reference stored inside an immutable container.</p>
<p>For example, this can happen when storing a <code>&amp;mut</code> inside an immutable <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x: i64 = 1;
let y: Box&lt;_&gt; = Box::new(&amp;mut x);
**y = 2; // error, cannot assign to data in an immutable container
<span class="boring">}</span></code></pre></pre>
<p>This error can be fixed by making the container mutable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x: i64 = 1;
let mut y: Box&lt;_&gt; = Box::new(&amp;mut x);
**y = 2;
<span class="boring">}</span></code></pre></pre>
<p>It can also be fixed by using a type with interior mutability, such as <code>Cell</code>
or <code>RefCell</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

let x: i64 = 1;
let y: Box&lt;Cell&lt;_&gt;&gt; = Box::new(Cell::new(x));
y.set(2);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0387"><a class="header" href="#error-code-e0387">Error code E0387</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-43"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-43">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error occurs when an attempt is made to mutate or mutably reference data
that a closure has captured immutably.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Accepts a function or a closure that captures its environment immutably.
// Closures passed to foo will not be able to mutate their closed-over state.
fn foo&lt;F: Fn()&gt;(f: F) { }

// Attempts to mutate closed-over data. Error message reads:
// `cannot assign to data in a captured outer variable...`
fn mutable() {
    let mut x = 0u32;
    foo(|| x = 2);
}

// Attempts to take a mutable reference to closed-over data. Error message
// reads: `cannot borrow data mutably in a captured outer variable...`
fn mut_addr() {
    let mut x = 0u32;
    foo(|| { let y = &amp;mut x; });
}
<span class="boring">}</span></code></pre></pre>
<p>The problem here is that foo is defined as accepting a parameter of type <code>Fn</code>.
Closures passed into foo will thus be inferred to be of type <code>Fn</code>, meaning that
they capture their context immutably.</p>
<p>If the definition of <code>foo</code> is under your control, the simplest solution is to
capture the data mutably. This can be done by defining <code>foo</code> to take FnMut
rather than Fn:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;F: FnMut()&gt;(f: F) { }
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, we can consider using the <code>Cell</code> and <code>RefCell</code> types to achieve
interior mutability through a shared reference. Our example's <code>mutable</code>
function could be redefined as below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

fn foo&lt;F: Fn()&gt;(f: F) { }

fn mutable() {
    let x = Cell::new(0u32);
    foo(|| x.set(2));
}
<span class="boring">}</span></code></pre></pre>
<p>You can read more in the API documentation for <a href="https://doc.rust-lang.org/std/cell/">Cell</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0388"><a class="header" href="#error-code-e0388">Error code E0388</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-44"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-44">Note: this error code is no longer emitted by the compiler.</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0389"><a class="header" href="#error-code-e0389">Error code E0389</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-45"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-45">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An attempt was made to mutate data using a non-mutable reference. This
commonly occurs when attempting to assign to a non-mutable reference of a
mutable reference (<code>&amp;(&amp;mut T)</code>).</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &amp;(&amp;mut fancy);
    fancy_ref.num = 6; // error: cannot assign to data in a `&amp;` reference
    println!("{}", fancy_ref.num);
}</code></pre></pre>
<p>Here, <code>&amp;mut fancy</code> is mutable, but <code>&amp;(&amp;mut fancy)</code> is not. Creating an
immutable reference to a value borrows it immutably. There can be multiple
references of type <code>&amp;(&amp;mut T)</code> that point to the same value, so they must be
immutable to prevent multiple mutable references to the same value.</p>
<p>To fix this, either remove the outer reference:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut fancy;
    // `fancy_ref` is now &amp;mut FancyNum, rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!("{}", fancy_ref.num);
}</code></pre></pre>
<p>Or make the outer reference mutable:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: u8
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut (&amp;mut fancy);
    // `fancy_ref` is now &amp;mut(&amp;mut FancyNum), rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!("{}", fancy_ref.num);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0390"><a class="header" href="#error-code-e0390">Error code E0390</a></h1>
<p>A method or constant was implemented on a primitive type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0390"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: i32
}

impl *mut Foo {}
// error: cannot define inherent `impl` for primitive types
<span class="boring">}</span></code></pre></pre>
<p>This isn't allowed, but using a trait to implement a method or constant
is a good solution.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: i32
}

trait Bar {
    fn bar();
}

impl Bar for *mut Foo {
    fn bar() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of defining an inherent implementation on a reference, you could also
move the reference inside the implementation:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0390"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl &amp;Foo { // error: no nominal type found for inherent implementation
    fn bar(self, other: Self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>becomes</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    fn bar(&amp;self, other: &amp;Self) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0391"><a class="header" href="#error-code-e0391">Error code E0391</a></h1>
<p>A type dependency cycle has been encountered.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0391"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FirstTrait : SecondTrait {

}

trait SecondTrait : FirstTrait {

}
<span class="boring">}</span></code></pre></pre>
<p>The previous example contains a circular dependency between two traits:
<code>FirstTrait</code> depends on <code>SecondTrait</code> which itself depends on <code>FirstTrait</code>.</p>
<p>See https://rustc-dev-guide.rust-lang.org/overview.html#queries and
https://rustc-dev-guide.rust-lang.org/query.html for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0392"><a class="header" href="#error-code-e0392">Error code E0392</a></h1>
<p>A type or lifetime parameter has been declared but is not actually used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0392"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo&lt;T&gt; {
    Bar,
}
<span class="boring">}</span></code></pre></pre>
<p>If the type parameter was included by mistake, this error can be fixed
by simply removing the type parameter, as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, if the type parameter was intentionally inserted, it must be
used. A simple fix is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo&lt;T&gt; {
    Bar(T),
}
<span class="boring">}</span></code></pre></pre>
<p>This error may also commonly be found when working with unsafe code. For
example, when using raw pointers one may wish to specify the lifetime for
which the pointed-at data is valid. An initial attempt (below) causes this
error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0392"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, T&gt; {
    x: *const T,
}
<span class="boring">}</span></code></pre></pre>
<p>We want to express the constraint that Foo should not outlive <code>'a</code>, because
the data pointed to by <code>T</code> is only valid for that lifetime. The problem is
that there are no actual uses of <code>'a</code>. It's possible to work around this
by adding a PhantomData type to the struct, using it to tell the compiler
to act as if the struct contained a borrowed reference <code>&amp;'a T</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

struct Foo&lt;'a, T: 'a&gt; {
    x: *const T,
    phantom: PhantomData&lt;&amp;'a T&gt;
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData</a> can also be used to express information about unused type
parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0393"><a class="header" href="#error-code-e0393">Error code E0393</a></h1>
<p>A type parameter which references <code>Self</code> in its default value was not specified.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0393"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A&lt;T = Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;dyn A) {}
// error: the type parameter `T` must be explicitly specified
<span class="boring">}</span></code></pre></pre>
<p>A trait object is defined over a single, fully-defined trait. With a regular
default parameter, this parameter can just be instantiated in. However, if the
default parameter is <code>Self</code>, the trait changes for each concrete type; i.e.
<code>i32</code> will be expected to implement <code>A&lt;i32&gt;</code>, <code>bool</code> will be expected to
implement <code>A&lt;bool&gt;</code>, etc... These types will not share an implementation of a
fully-defined trait; instead they share implementations of a trait with
different parameters instantiated in for each implementation. This is
irreconcilable with what we need to make a trait object work, and is thus
disallowed. Making the trait concrete by explicitly specifying the value of the
defaulted parameter will fix this issue. Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A&lt;T = Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;dyn A&lt;i32&gt;) {} // Ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0398"><a class="header" href="#error-code-e0398">Error code E0398</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-46"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-46">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>In Rust 1.3, the default object lifetime bounds are expected to change, as
described in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>. You are getting a warning because the compiler
thinks it is possible that this change will cause a compilation error in your
code. It is possible, though unlikely, that this is a false alarm.</p>
<p>The heart of the change is that where <code>&amp;'a Box&lt;SomeTrait&gt;</code> used to default to
<code>&amp;'a Box&lt;SomeTrait+'a&gt;</code>, it now defaults to <code>&amp;'a Box&lt;SomeTrait+'static&gt;</code> (here,
<code>SomeTrait</code> is the name of some trait type). Note that the only types which are
affected are references to boxes, like <code>&amp;Box&lt;SomeTrait&gt;</code> or
<code>&amp;[Box&lt;SomeTrait&gt;]</code>. More common types like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code>
are unaffected.</p>
<p>To silence this warning, edit your code to use an explicit bound. Most of the
time, this means that you will want to change the signature of a function that
you are calling. For example, if the error is reported on a call like <code>foo(x)</code>,
and <code>foo</code> is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait SomeTrait {}
</span>fn foo(arg: &amp;Box&lt;SomeTrait&gt;) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>You might change it to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait SomeTrait {}
</span>fn foo&lt;'a&gt;(arg: &amp;'a Box&lt;SomeTrait+'a&gt;) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>This explicitly states that you expect the trait object <code>SomeTrait</code> to contain
references (with a maximum lifetime of <code>'a</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0399"><a class="header" href="#error-code-e0399">Error code E0399</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-47"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-47">Note: this error code is no longer emitted by the compiler</a></h4>
<p>You implemented a trait, overriding one or more of its associated types but did
not reimplement its default methods.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(associated_type_defaults)]

<span class="boring">fn main() {
</span>pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    // error - the following trait items need to be reimplemented as
    //         `Assoc` was overridden: `bar`
    type Assoc = i32;
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this, add an implementation for each default method from the trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(associated_type_defaults)]

<span class="boring">fn main() {
</span>pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    type Assoc = i32;
    fn bar(&amp;self) {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0401"><a class="header" href="#error-code-e0401">Error code E0401</a></h1>
<p>Inner items do not inherit the generic parameters from the items
they are embedded in.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0401"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    fn bar(y: T) { // T is defined in the "outer" function
        // ..
    }
    bar(x);
}
<span class="boring">}</span></code></pre></pre>
<p>Nor will this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0401"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    type MaybeT = Option&lt;T&gt;;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Or this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0401"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    struct Foo {
        x: T,
    }
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Items nested inside other items are basically just like top-level items, except
that they can only be used from the item they are in.</p>
<p>There are a couple of solutions for this.</p>
<p>If the item is a function, you may use a closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    let bar = |y: T| { // explicit type annotation may not be necessary
        // ..
    };
    bar(x);
}
<span class="boring">}</span></code></pre></pre>
<p>For a generic item, you can copy over the parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    fn bar&lt;T&gt;(y: T) {
        // ..
    }
    bar(x);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    type MaybeT&lt;T&gt; = Option&lt;T&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Be sure to copy over any bounds as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Copy&gt;(x: T) {
    fn bar&lt;T: Copy&gt;(y: T) {
        // ..
    }
    bar(x);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Copy&gt;(x: T) {
    struct Foo&lt;T: Copy&gt; {
        x: T,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This may require additional type hints in the function body.</p>
<p>In case the item is a function inside an <code>impl</code>, defining a private helper
function might be easier:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo&lt;T&gt;(T);
</span>impl&lt;T&gt; Foo&lt;T&gt; {
    pub fn foo(&amp;self, x: T) {
        self.bar(x);
    }

    fn bar(&amp;self, y: T) {
        // ..
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For default impls in traits, the private helper solution won't work, however
closures or copying the parameters should still work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0403"><a class="header" href="#error-code-e0403">Error code E0403</a></h1>
<p>Some type parameters have the same name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0403"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;T, T&gt;(s: T, u: T) {} // error: the name `T` is already used for a generic
                          //        parameter in this item's generic parameters
<span class="boring">}</span></code></pre></pre>
<p>Please verify that none of the type parameters are misspelled, and rename any
clashing parameters. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;T, Y&gt;(s: T, u: Y) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>Type parameters in an associated item also cannot shadow parameters from the
containing item:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0403"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;T&gt; {
    fn do_something(&amp;self) -&gt; T;
    fn do_something_else&lt;T: Clone&gt;(&amp;self, bar: T);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0404"><a class="header" href="#error-code-e0404">Error code E0404</a></h1>
<p>A type that is not a trait was used in a trait position, such as a bound
or <code>impl</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0404"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
struct Bar;

impl Foo for Bar {} // error: `Foo` is not a trait
fn baz&lt;T: Foo&gt;(t: T) {} // error: `Foo` is not a trait
<span class="boring">}</span></code></pre></pre>
<p>Another erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0404"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = Iterator&lt;Item=String&gt;;

fn bar&lt;T: Foo&gt;(t: T) {} // error: `Foo` is a type alias
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the trait's name was not misspelled or that the right
identifier was used. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    // some functions
}
struct Bar;

impl Foo for Bar { // ok!
    // functions implementation
}

fn baz&lt;T: Foo&gt;(t: T) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, you could introduce a new trait with your desired restrictions
as a super trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Foo {}
</span><span class="boring">struct Bar;
</span><span class="boring">impl Foo for Bar {}
</span>trait Qux: Foo {} // Anything that implements Qux also needs to implement Foo
fn baz&lt;T: Qux&gt;(t: T) {} // also ok!
<span class="boring">}</span></code></pre></pre>
<p>Finally, if you are on nightly and want to use a trait alias
instead of a type alias, you should use <code>#![feature(trait_alias)]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(trait_alias)]
<span class="boring">fn main() {
</span>trait Foo = Iterator&lt;Item=String&gt;;

fn bar&lt;T: Foo&gt;(t: T) {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0405"><a class="header" href="#error-code-e0405">Error code E0405</a></h1>
<p>The code refers to a trait that is not in scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0405"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the name of the trait wasn't misspelled and ensure that it
was imported. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(for_demonstration_only)]
</span>// solution 1:
use some_file::SomeTrait;

// solution 2:
trait SomeTrait {
    // some functions
}

struct Foo;

impl SomeTrait for Foo { // ok!
    // implements functions
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0407"><a class="header" href="#error-code-e0407">Error code E0407</a></h1>
<p>A definition of a method not in the implemented trait was given in a trait
implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0407"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // error: method `b` is not a member of trait `Foo`
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the method name and you used the correct
trait. First example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn a();
    fn b();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Second example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
}

impl Bar {
    fn b() {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0408"><a class="header" href="#error-code-e0408">Error code E0408</a></h1>
<p>An "or" pattern was used where the variable bindings are not consistently bound
across patterns.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0408"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match x {
    Some(y) | None =&gt; { /* use y */ } // error: variable `y` from pattern #1 is
                                      //        not bound in pattern #2
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>y</code> is bound to the contents of the <code>Some</code> and can be used within the
block corresponding to the match arm. However, in case <code>x</code> is <code>None</code>, we have
not specified what <code>y</code> is, and the block will use a nonexistent variable.</p>
<p>To fix this error, either split into multiple match arms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(1);
match x {
    Some(y) =&gt; { /* use y */ }
    None =&gt; { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<p>or, bind the variable to a field of the same type in all sub-patterns of the
or pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (0, 2);
match x {
    (0, y) | (y, 0) =&gt; { /* use y */}
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, if <code>x</code> matches the pattern <code>(0, _)</code>, the second field is set
to <code>y</code>. If it matches <code>(_, 0)</code>, the first field is set to <code>y</code>; so in all
cases <code>y</code> is set to some value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0409"><a class="header" href="#error-code-e0409">Error code E0409</a></h1>
<p>An "or" pattern was used where the variable bindings are not consistently bound
across patterns.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0409"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (0, 2);
match x {
    (0, ref y) | (y, 0) =&gt; { /* use y */} // error: variable `y` is bound with
                                          //        different mode in pattern #2
                                          //        than in pattern #1
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>y</code> is bound by-value in one case and by-reference in the other.</p>
<p>To fix this error, just use the same mode in both cases.
Generally using <code>ref</code> or <code>ref mut</code> where not already used will fix this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (0, 2);
match x {
    (0, ref y) | (ref y, 0) =&gt; { /* use y */}
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, split the pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (0, 2);
match x {
    (y, 0) =&gt; { /* use y */ }
    (0, ref y) =&gt; { /* use y */}
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0411"><a class="header" href="#error-code-e0411">Error code E0411</a></h1>
<p>The <code>Self</code> keyword was used outside an impl, trait, or type definition.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0411"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;Self&gt;::foo; // error: use of `Self` outside of an impl, trait, or type
             // definition
<span class="boring">}</span></code></pre></pre>
<p>The <code>Self</code> keyword represents the current type, which explains why it can only
be used inside an impl, trait, or type definition. It gives access to the
associated items of a type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar;
}

trait Baz : Foo {
    fn bar() -&gt; Self::Bar; // like this
}
<span class="boring">}</span></code></pre></pre>
<p>However, be careful when two types have a common associated type:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; Self::Bar;
    // error: ambiguous associated type `Bar` in bounds of `Self`
}
<span class="boring">}</span></code></pre></pre>
<p>This problem can be solved by specifying from which trait we want to use the
<code>Bar</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; &lt;Self as Foo&gt;::Bar; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0412"><a class="header" href="#error-code-e0412">Error code E0412</a></h1>
<p>A used type name is not in scope.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0412"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Something {} // error: type name `Something` is not in scope

// or:

trait Foo {
    fn bar(N); // error: type name `N` is not in scope
}

// or:

fn foo(x: T) {} // type name `T` is not in scope
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please verify you didn't misspell the type name, you did
declare it or imported it into the scope. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Something;

impl Something {} // ok!

// or:

trait Foo {
    type N;

    fn bar(_: Self::N); // ok!
}

// or:

fn foo&lt;T&gt;(x: T) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>Another case that causes this error is when a type is imported into a parent
module. To fix this, you can follow the suggestion and use File directly or
<code>use super::File;</code> which will import the types from the parent namespace. An
example that causes this error is below:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0412"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

mod foo {
    fn some_function(f: File) {}
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

mod foo {
    // either
    use super::File;
    // or
    // use std::fs::File;
    fn foo(f: File) {}
}
<span class="boring">fn main() {} // don't insert it for us; that'll break imports</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0415"><a class="header" href="#error-code-e0415">Error code E0415</a></h1>
<p>More than one function parameter have the same name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0415"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than
                          //        once in this parameter list
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell parameters' name. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(f: i32, g: i32) {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0416"><a class="header" href="#error-code-e0416">Error code E0416</a></h1>
<p>An identifier is bound more than once in a pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0416"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match (1, 2) {
    (x, x) =&gt; {} // error: identifier `x` is bound more than once in the
                 //        same pattern
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell identifiers' name. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match (1, 2) {
    (x, y) =&gt; {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or maybe did you mean to unify? Consider using a guard:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let (A, B, C) = (1, 2, 3);
</span>match (A, B, C) {
    (x, x2, see) if x == x2 =&gt; { /* A and B are equal, do one thing */ }
    (y, z, see) =&gt; { /* A and B not equal; do another thing */ }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0422"><a class="header" href="#error-code-e0422">Error code E0422</a></h1>
<p>An identifier that is neither defined nor a struct was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0422">fn main () {
    let x = Foo { x: 1, y: 2 };
}</code></pre></pre>
<p>In this case, <code>Foo</code> is undefined, so it inherently isn't anything, and
definitely not a struct.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main () {
    let foo = 1;
    let x = foo { x: 1, y: 2 };
}</code></pre></pre>
<p>In this case, <code>foo</code> is defined, but is not a struct, so Rust can't use it as
one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0423"><a class="header" href="#error-code-e0423">Error code E0423</a></h1>
<p>An identifier was used like a function name or a value was expected and the
identifier exists but it belongs to a different namespace.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0423"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { a: bool };

let f = Foo();
// error: expected function, tuple struct or tuple variant, found `Foo`
// `Foo` is a struct name, but this expression uses it like a function name
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the name of what you actually wanted to use
here. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Foo() -&gt; u32 { 0 }

let f = Foo(); // ok!
<span class="boring">}</span></code></pre></pre>
<p>It is common to forget the trailing <code>!</code> on macro invocations, which would also
yield this error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0423"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println("");
// error: expected function, tuple struct or tuple variant,
// found macro `println`
// did you mean `println!(...)`? (notice the trailing `!`)
<span class="boring">}</span></code></pre></pre>
<p>Another case where this error is emitted is when a value is expected, but
something else is found:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0423"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod a {
    pub const I: i32 = 1;
}

fn h1() -&gt; i32 {
    a.I
    //~^ ERROR expected value, found module `a`
    // did you mean `a::I`?
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0424"><a class="header" href="#error-code-e0424">Error code E0424</a></h1>
<p>The <code>self</code> keyword was used inside of an associated function without a "<code>self</code>
receiver" parameter.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0424"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    // `bar` is a method, because it has a receiver parameter.
    fn bar(&amp;self) {}

    // `foo` is not a method, because it has no receiver parameter.
    fn foo() {
        self.bar(); // error: `self` value is a keyword only available in
                    //        methods with a `self` parameter
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>self</code> keyword can only be used inside methods, which are associated
functions (functions defined inside of a <code>trait</code> or <code>impl</code> block) that have a
<code>self</code> receiver as its first parameter, like <code>self</code>, <code>&amp;self</code>, <code>&amp;mut self</code> or
<code>self: &amp;mut Pin&lt;Self&gt;</code> (this last one is an example of an <a href="https://github.com/rust-lang/rust/issues/44874">"arbitrary <code>self</code>
type"</a>).</p>
<p>Check if the associated function's parameter list should have contained a <code>self</code>
receiver for it to be a method, and add it if so. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    fn bar(&amp;self) {}

    fn foo(self) { // `foo` is now a method.
        self.bar(); // ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0425"><a class="header" href="#error-code-e0425">Error code E0425</a></h1>
<p>An unresolved name was used.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0425"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>something_that_doesnt_exist::foo;
// error: unresolved name `something_that_doesnt_exist::foo`

// or:

trait Foo {
    fn bar() {
        Self; // error: unresolved name `Self`
    }
}

// or:

let x = unknown_variable;  // error: unresolved name `unknown_variable`
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the name wasn't misspelled and ensure that the
identifier being referred to is valid for the given situation. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum something_that_does_exist {
    Foo,
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod something_that_does_exist {
    pub static foo : i32 = 0i32;
}

something_that_does_exist::foo; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unknown_variable = 12u32;
let x = unknown_variable; // ok!
<span class="boring">}</span></code></pre></pre>
<p>If the item is not defined in the current module, it must be imported using a
<code>use</code> statement, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod foo { pub fn bar() {} }
</span><span class="boring">fn main() {
</span>use foo::bar;
bar();
<span class="boring">}</span></code></pre></pre>
<p>If the item you are importing is not defined in some super-module of the
current module, then it must also be declared as public (e.g., <code>pub fn</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0426"><a class="header" href="#error-code-e0426">Error code E0426</a></h1>
<p>An undeclared label was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0426"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    break 'a; // error: use of undeclared label `'a`
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify you spelled or declared the label correctly. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: loop {
    break 'a; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0428"><a class="header" href="#error-code-e0428">Error code E0428</a></h1>
<p>A type or module has been defined more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0428"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;
struct Bar; // error: duplicate definition of value `Bar`
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the type/module's name or remove/rename the
duplicated one. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;
struct Bar2; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0429"><a class="header" href="#error-code-e0429">Error code E0429</a></h1>
<p>The <code>self</code> keyword cannot appear alone as the last segment in a <code>use</code>
declaration.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0429"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::self; // error: `self` imports are only allowed within a { } list
<span class="boring">}</span></code></pre></pre>
<p>To use a namespace itself in addition to some of its members, <code>self</code> may appear
as part of a brace-enclosed list of imports:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::{self, Debug};
<span class="boring">}</span></code></pre></pre>
<p>If you only want to import the namespace, do so directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0430"><a class="header" href="#error-code-e0430">Error code E0430</a></h1>
<p>The <code>self</code> import appears more than once in the list.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0430"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use something::{self, self}; // error: `self` import can only appear once in
                             //        the list
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the import name or remove the duplicated
<code>self</code> import. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod something {}
</span><span class="boring">fn main() {
</span>use something::{self}; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0431"><a class="header" href="#error-code-e0431">Error code E0431</a></h1>
<p>An invalid <code>self</code> import was made.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0431"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use {self}; // error: `self` import can only appear in an import list with a
            //        non-empty prefix
<span class="boring">}</span></code></pre></pre>
<p>You cannot import the current module into itself, please remove this import
or verify you didn't misspell it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0432"><a class="header" href="#error-code-e0432">Error code E0432</a></h1>
<p>An import was unresolved.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0432"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use something::Foo; // error: unresolved import `something::Foo`.
<span class="boring">}</span></code></pre></pre>
<p>In Rust 2015, paths in <code>use</code> statements are relative to the crate root. To
import items relative to the current and parent modules, use the <code>self::</code> and
<code>super::</code> prefixes, respectively.</p>
<p>In Rust 2018 or later, paths in <code>use</code> statements are relative to the current
module unless they begin with the name of a crate or a literal <code>crate::</code>, in
which case they start from the crate root. As in Rust 2015 code, the <code>self::</code>
and <code>super::</code> prefixes refer to the current and parent modules respectively.</p>
<p>Also verify that you didn't misspell the import name and that the import exists
in the module from where you tried to import it. Example:</p>
<pre><pre class="playground"><code class="language-rust">use self::something::Foo; // Ok.

mod something {
    pub struct Foo;
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>If you tried to use a module from an external crate and are using Rust 2015,
you may have missed the <code>extern crate</code> declaration (which is usually placed in
the crate root):</p>
<pre><pre class="playground"><code class="language-rust edition2015">extern crate core; // Required to use the `core` crate in Rust 2015.

use core::any;
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Since Rust 2018 the <code>extern crate</code> declaration is not required and
you can instead just <code>use</code> it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use core::any; // No extern crate required in Rust 2018.
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0433"><a class="header" href="#error-code-e0433">Error code E0433</a></h1>
<p>An undeclared crate, module, or type was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0433"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map = HashMap::new();
// error: failed to resolve: use of undeclared type `HashMap`
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the type/module's name or that you didn't
forget to import it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap; // HashMap has been imported.
let map: HashMap&lt;u32, u32&gt; = HashMap::new(); // So it can be used!
<span class="boring">}</span></code></pre></pre>
<p>If you've expected to use a crate name:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ferris_wheel::BigO;
// error: failed to resolve: use of undeclared module or unlinked crate
<span class="boring">}</span></code></pre></pre>
<p>Make sure the crate has been added as a dependency in <code>Cargo.toml</code>.</p>
<p>To use a module from your current crate, add the <code>crate::</code> prefix to the path.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0434"><a class="header" href="#error-code-e0434">Error code E0434</a></h1>
<p>A variable used inside an inner function comes from a dynamic environment.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0434"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let y = 5;
    fn bar() -&gt; u32 {
        y // error: can't capture dynamic environment in a fn item; use the
          //        || { ... } closure form instead.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Inner functions do not have access to their containing environment. To fix this
error, you can replace the function with a closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let y = 5;
    let bar = || {
        y
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Or replace the captured variable with a constant or a static item:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    static mut X: u32 = 4;
    const Y: u32 = 5;
    fn bar() -&gt; u32 {
        unsafe {
            X = 3;
        }
        Y
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0435"><a class="header" href="#error-code-e0435">Error code E0435</a></h1>
<p>A non-constant value was used in a constant expression.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0435"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = 42;
let a: [u8; foo]; // error: attempt to use a non-constant value in a constant
<span class="boring">}</span></code></pre></pre>
<p>'constant' means 'a compile-time value'.</p>
<p>More details can be found in the <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants">Variables and Mutability</a> section of the book.</p>
<p>To fix this error, please replace the value with a constant. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [u8; 42]; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: usize = 42;
let a: [u8; FOO]; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0436"><a class="header" href="#error-code-e0436">Error code E0436</a></h1>
<p>The functional record update syntax was used on something other than a struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0436"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
}

fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -&gt; PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        c @ PublicationFrequency::SemiMonthly{ .. } =&gt;
            PublicationFrequency::SemiMonthly {
                annual_special: true, ..c // error: functional record update
                                          //        syntax requires a struct
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The functional record update syntax is only allowed for structs (struct-like
enum variants don't qualify, for example). To fix the previous code, rewrite the
expression without functional record update syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
}

fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -&gt; PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        PublicationFrequency::SemiMonthly{ days, .. } =&gt;
            PublicationFrequency::SemiMonthly {
                days, annual_special: true // ok!
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0437"><a class="header" href="#error-code-e0437">Error code E0437</a></h1>
<p>An associated type whose name does not match any of the associated types
in the trait was used when implementing the trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0437"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

impl Foo for i32 {
    type Bar = bool;
}
<span class="boring">}</span></code></pre></pre>
<p>Trait implementations can only implement associated types that are members of
the trait in question.</p>
<p>The solution to this problem is to remove the extraneous associated type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

impl Foo for i32 {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0438"><a class="header" href="#error-code-e0438">Error code E0438</a></h1>
<p>An associated constant whose name does not match any of the associated constants
in the trait was used when implementing the trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0438"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

impl Foo for i32 {
    const BAR: bool = true;
}
<span class="boring">}</span></code></pre></pre>
<p>Trait implementations can only implement associated constants that are
members of the trait in question.</p>
<p>The solution to this problem is to remove the extraneous associated constant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

impl Foo for i32 {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0439"><a class="header" href="#error-code-e0439">Error code E0439</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-48"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-48">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The length of the platform-intrinsic function <code>simd_shuffle</code> wasn't specified.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_shuffle&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`
}</code></pre>
<p>The <code>simd_shuffle</code> function needs the length of the array passed as
last parameter in its name. Example:</p>
<pre><code class="language-rust ignore (no longer compiles)">#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_shuffle8&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0445"><a class="header" href="#error-code-e0445">Error code E0445</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-49"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-49">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A private trait was used on a public type parameter bound.</p>
<p>Previously erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust">trait Foo {
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // error: private trait in public interface
pub struct Bar2&lt;T: Foo&gt;(pub T); // same error
pub fn foo&lt;T: Foo&gt; (t: T) {} // same error

fn main() {}</code></pre></pre>
<p>To solve this error, please ensure that the trait is also public. The trait
can be made inaccessible if necessary by placing it into a private inner
module, but it still has to be marked with <code>pub</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust">pub trait Foo { // we set the Foo trait public
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // ok!
pub struct Bar2&lt;T: Foo&gt;(pub T); // ok!
pub fn foo&lt;T: Foo&gt; (t: T) {} // ok!

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0446"><a class="header" href="#error-code-e0446">Error code E0446</a></h1>
<p>A private type or trait was used in a public associated type signature.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0446">struct Bar;

pub trait PubTr {
    type Alias;
}

impl PubTr for u8 {
    type Alias = Bar; // error private type in public interface
}

fn main() {}</code></pre></pre>
<p>There are two ways to solve this error. The first is to make the public type
signature only public to a module that also has access to the private type.
This is done by using pub(crate) or pub(in crate::my_mod::etc)
Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Bar;

pub(crate) trait PubTr { // only public to crate root
    type Alias;
}

impl PubTr for u8 {
    type Alias = Bar;
}

fn main() {}</code></pre></pre>
<p>The other way to solve this error is to make the private type public.
Example:</p>
<pre><pre class="playground"><code class="language-rust">
pub struct Bar; // we set the Bar trait public

pub trait PubTr {
    type Alias;
}

impl PubTr for u8 {
    type Alias = Bar;
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0447"><a class="header" href="#error-code-e0447">Error code E0447</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-50"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-50">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The <code>pub</code> keyword was used inside a function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    pub struct Bar; // error: visibility has no effect inside functions
}
<span class="boring">}</span></code></pre></pre>
<p>Since we cannot access items defined inside a function, the visibility of its
items does not impact outer code. So using the <code>pub</code> keyword in this context
is invalid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0448"><a class="header" href="#error-code-e0448">Error code E0448</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-51"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-51">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The <code>pub</code> keyword was used inside a public enum.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Foo {
    pub Bar, // error: unnecessary `pub` visibility
}
<span class="boring">}</span></code></pre></pre>
<p>Since the enum is already public, adding <code>pub</code> on one its elements is
unnecessary. Example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    pub Bar, // not ok!
}
<span class="boring">}</span></code></pre></pre>
<p>This is the correct syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Foo {
    Bar, // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0449"><a class="header" href="#error-code-e0449">Error code E0449</a></h1>
<p>A visibility qualifier was used where one is not permitted. Visibility
qualifiers are not permitted on enum variants, trait items, impl blocks, and
extern blocks, as they already share the visibility of the parent item.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0449"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    fn foo();
}

enum Baz {
    pub Qux, // error: visibility qualifiers are not permitted here
}

pub impl Bar {} // error: visibility qualifiers are not permitted here

pub impl Foo for Bar { // error: visibility qualifiers are not permitted here
    pub fn foo() {} // error: visibility qualifiers are not permitted here
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, simply remove the visibility qualifier. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    fn foo();
}

enum Baz {
    // Enum variants share the visibility of the enum they are in, so
    // `pub` is not allowed here
    Qux,
}

// Directly implemented methods share the visibility of the type itself,
// so `pub` is not allowed here
impl Bar {}

// Trait methods share the visibility of the trait, so `pub` is not
// allowed in either case
impl Foo for Bar {
    fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0451"><a class="header" href="#error-code-e0451">Error code E0451</a></h1>
<p>A struct constructor with private fields was invoked.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0451"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod bar {
    pub struct Foo {
        pub a: isize,
        b: isize,
    }
}

let f = bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `bar::Foo`
                                //        is private
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please ensure that all the fields of the struct are public,
or implement a function for easy instantiation. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod bar {
    pub struct Foo {
        pub a: isize,
        pub b: isize, // we set `b` field public
    }
}

let f = bar::Foo{ a: 0, b: 0 }; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod bar {
    pub struct Foo {
        pub a: isize,
        b: isize, // still private
    }

    impl Foo {
        pub fn new() -&gt; Foo { // we create a method to instantiate `Foo`
            Foo { a: 0, b: 0 }
        }
    }
}

let f = bar::Foo::new(); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0452"><a class="header" href="#error-code-e0452">Error code E0452</a></h1>
<p>An invalid lint attribute has been given.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0452"><span class="boring">#![allow(unused)]
</span>#![allow(foo = "")] // error: malformed lint attribute
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>Lint attributes only accept a list of identifiers (where each identifier is a
lint name). Ensure the attribute is of this form:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(foo)] // ok!
<span class="boring">fn main() {
</span>// or:
#![allow(foo, foo2)] // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0453"><a class="header" href="#error-code-e0453">Error code E0453</a></h1>
<p>A lint check attribute was overruled by a <code>forbid</code> directive set as an
attribute on an enclosing scope, or on the command line with the <code>-F</code> option.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0453">#![forbid(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    // error: allow(non_snake_case) incompatible with previous forbid
    let MyNumber = 2;
}</code></pre></pre>
<p>The <code>forbid</code> lint setting, like <code>deny</code>, turns the corresponding compiler
warning into a hard error. Unlike <code>deny</code>, <code>forbid</code> prevents itself from being
overridden by inner attributes.</p>
<p>If you're sure you want to override the lint check, you can change <code>forbid</code> to
<code>deny</code> (or use <code>-D</code> instead of <code>-F</code> if the <code>forbid</code> setting was given as a
command-line option) to allow the inner lint check attribute:</p>
<pre><pre class="playground"><code class="language-rust">#![deny(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // ok!
}</code></pre></pre>
<p>Otherwise, edit the code to pass the lint check, and remove the overruled
attribute:</p>
<pre><pre class="playground"><code class="language-rust">#![forbid(non_snake_case)]

fn main() {
    let my_number = 2;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0454"><a class="header" href="#error-code-e0454">Error code E0454</a></h1>
<p>A link name was given with an empty name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0454"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = "")] extern "C" {}
// error: `#[link(name = "")]` given with empty name
<span class="boring">}</span></code></pre></pre>
<p>The rust compiler cannot link to an external library if you don't give it its
name. Example:</p>
<pre><code class="language-no_run">#[link(name = "some_lib")] extern "C" {} // ok!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0455"><a class="header" href="#error-code-e0455">Error code E0455</a></h1>
<p>Some linking kinds are target-specific and not supported on all platforms.</p>
<p>Linking with <code>kind=framework</code> is only supported when targeting macOS,
as frameworks are specific to that operating system.</p>
<p>Similarly, <code>kind=raw-dylib</code> is only supported when targeting Windows-like
platforms.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (should-compile_fail-but-cannot-doctest-conditionally-without-macos)">#[link(name = "FooCoreServices", kind = "framework")] extern "C" {}
// OS used to compile is Linux for example</code></pre>
<p>To solve this error you can use conditional compilation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(target="macos", link(name = "FooCoreServices", kind = "framework"))]
extern "C" {}
<span class="boring">}</span></code></pre></pre>
<p>Learn more in the <a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">Conditional Compilation</a> section
of the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0457"><a class="header" href="#error-code-e0457">Error code E0457</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-52"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-52">Note: this error code is no longer emitted by the compiler</a></h4>
<p>Plugin <code>..</code> only found in rlib format, but must be available in dylib format.</p>
<p>Erroneous code example:</p>
<p><code>rlib-plugin.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![crate_type = "rlib"]
#![feature(rustc_private)]

extern crate rustc_middle;
extern crate rustc_driver;

use rustc_driver::plugin::Registry;

#[no_mangle]
fn __rustc_plugin_registrar(_: &amp;mut Registry) {}</code></pre>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![feature(plugin)]
#![plugin(rlib_plugin)] // error: plugin `rlib_plugin` only found in rlib
                        //        format, but must be available in dylib

fn main() {}</code></pre>
<p>The compiler exposes a plugin interface to allow altering the compile process
(adding lints, etc). Plugins must be defined in their own crates (similar to
<a href="../reference/procedural-macros.html">proc-macro</a> isolation) and then compiled
and linked to another crate. Plugin crates <em>must</em> be compiled to the
dynamically-linked dylib format, and not the statically-linked rlib format.
Learn more about different output types in
<a href="../reference/linkage.html">this section</a> of the Rust reference.</p>
<p>This error is easily fixed by recompiling the plugin crate in the dylib format.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0458"><a class="header" href="#error-code-e0458">Error code E0458</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-53"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-53">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An unknown "kind" was specified for a link attribute.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">#[link(kind = "wonderful_unicorn")] extern "C" {}
// error: unknown kind: `wonderful_unicorn`</code></pre>
<p>Please specify a valid "kind" value, from one of the following:</p>
<ul>
<li>static</li>
<li>dylib</li>
<li>framework</li>
<li>raw-dylib</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0459"><a class="header" href="#error-code-e0459">Error code E0459</a></h1>
<p>A link was used without a name parameter.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0459"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(kind = "dylib")] extern "C" {}
// error: `#[link(...)]` specified without `name = "foo"`
<span class="boring">}</span></code></pre></pre>
<p>Please add the name parameter to allow the rust compiler to find the library
you want. Example:</p>
<pre><code class="language-no_run">#[link(kind = "dylib", name = "some_lib")] extern "C" {} // ok!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0460"><a class="header" href="#error-code-e0460">Error code E0460</a></h1>
<p>Found possibly newer version of crate <code>..</code> which <code>..</code> depends on.</p>
<p>Consider these erroneous files:</p>
<p><code>a1.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![crate_name = "a"]

pub fn foo&lt;T&gt;() {}</code></pre>
<p><code>a2.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![crate_name = "a"]

pub fn foo&lt;T&gt;() {
    println!("foo&lt;T&gt;()");
}</code></pre>
<p><code>b.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![crate_name = "b"]

extern crate a; // linked with `a1.rs`

pub fn foo() {
    a::foo::&lt;isize&gt;();
}</code></pre>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">extern crate a; // linked with `a2.rs`
extern crate b; // error: found possibly newer version of crate `a` which `b`
                //        depends on

fn main() {}</code></pre>
<p>The dependency graph of this program can be represented as follows:</p>
<pre><code class="language-text">    crate `main`
         |
         +-------------+
         |             |
         |             v
depends: |         crate `b`
 `a` v1  |             |
         |             | depends:
         |             |  `a` v2
         v             |
      crate `a` &lt;------+
</code></pre>
<p>Crate <code>main</code> depends on crate <code>a</code> (version 1) and crate <code>b</code> which in turn
depends on crate <code>a</code> (version 2); this discrepancy in versions cannot be
reconciled. This difference in versions typically occurs when one crate is
compiled and linked, then updated and linked to another crate. The crate
"version" is a SVH (Strict Version Hash) of the crate in an
implementation-specific way. Note that this error can <em>only</em> occur when
directly compiling and linking with <code>rustc</code>; <a href="../cargo/index.html">Cargo</a> automatically resolves
dependencies, without using the compiler's own dependency management that
causes this issue.</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager, automatically fixing this issue.</li>
<li>Recompiling crate <code>a</code> so that both crate <code>b</code> and <code>main</code> have a uniform
version to depend on.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0461"><a class="header" href="#error-code-e0461">Error code E0461</a></h1>
<p>Couldn't find crate <code>..</code> with expected target triple <code>..</code>.</p>
<p>Example of erroneous code:</p>
<p><code>a.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">#![crate_type = "lib"]

fn foo() {}</code></pre>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">extern crate a;

fn main() {
    a::foo();
}</code></pre>
<p><code>a.rs</code> is then compiled with <code>--target powerpc-unknown-linux-gnu</code> and <code>b.rs</code>
with <code>--target x86_64-unknown-linux-gnu</code>. <code>a.rs</code> is compiled into a binary
format incompatible with <code>b.rs</code>; PowerPC and x86 are totally different
architectures. This issue also extends to any difference in target triples, as
<code>std</code> is operating-system specific.</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager, automatically
fixing this issue.</li>
<li>Recompiling either crate so that they target a consistent target triple.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0462"><a class="header" href="#error-code-e0462">Error code E0462</a></h1>
<p>Found <code>staticlib</code> <code>..</code> instead of <code>rlib</code> or <code>dylib</code>.</p>
<p>Consider the following two files:</p>
<p><code>a.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">#![crate_type = "staticlib"]

fn foo() {}</code></pre>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">extern crate a;

fn main() {
    a::foo();
}</code></pre>
<p>Crate <code>a</code> is compiled as a <code>staticlib</code>. A <code>staticlib</code> is a system-dependant
library only intended for linking with non-Rust applications (C programs). Note
that <code>staticlib</code>s include all upstream dependencies (<code>core</code>, <code>std</code>, other user
dependencies, etc) which makes them significantly larger than <code>dylib</code>s:
prefer <code>staticlib</code> for linking with C programs. Learn more about different
<code>crate_type</code>s in <a href="../reference/linkage.html">this section of the Reference</a>.</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager, automatically
fixing this issue.</li>
<li>Recompiling the crate as a <code>rlib</code> or <code>dylib</code>; formats suitable for Rust
linking.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0463"><a class="header" href="#error-code-e0463">Error code E0463</a></h1>
<p>A crate was declared but cannot be found.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0463"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate foo; // error: can't find crate
<span class="boring">}</span></code></pre></pre>
<p>You need to link your code to the relevant crate in order to be able to use it
(through Cargo or the <code>-L</code> option of rustc, for example).</p>
<h2 id="common-causes"><a class="header" href="#common-causes">Common causes</a></h2>
<ul>
<li>The crate is not present at all. If using Cargo, add it to <code>[dependencies]</code>
in Cargo.toml.</li>
<li>The crate is present, but under a different name. If using Cargo, look for
<code>package = </code> under <code>[dependencies]</code> in Cargo.toml.</li>
</ul>
<h2 id="common-causes-for-missing-std-or-core"><a class="header" href="#common-causes-for-missing-std-or-core">Common causes for missing <code>std</code> or <code>core</code></a></h2>
<ul>
<li>You are cross-compiling for a target which doesn't have <code>std</code> prepackaged.
Consider one of the following:
<ul>
<li>Adding a pre-compiled version of std with <code>rustup target add</code></li>
<li>Building std from source with <code>cargo build -Z build-std</code></li>
<li>Using <code>#![no_std]</code> at the crate root, so you won't need <code>std</code> in the first
place.</li>
</ul>
</li>
<li>You are developing the compiler itself and haven't built libstd from source.
You can usually build it with <code>x.py build library/std</code>. More information
about x.py is available in the <a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler">rustc-dev-guide</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0464"><a class="header" href="#error-code-e0464">Error code E0464</a></h1>
<p>The compiler found multiple library files with the requested crate name.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">// aux-build:crateresolve-1.rs
// aux-build:crateresolve-2.rs
// aux-build:crateresolve-3.rs

extern crate crateresolve;
//~^ ERROR multiple candidates for `rlib` dependency `crateresolve` found

fn main() {}</code></pre></pre>
<p>This error can occur in several different cases -- for example, when using
<code>extern crate</code> or passing <code>--extern</code> options without crate paths. It can also be
caused by caching issues with the build directory, in which case <code>cargo clean</code>
may help.</p>
<p>In the above example, there are three different library files, all of which
define the same crate name. Without providing a full path, there is no way for
the compiler to know which crate it should use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0466"><a class="header" href="#error-code-e0466">Error code E0466</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-54"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-54">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Macro import declaration was malformed.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use(a_macro(another_macro))] // error: invalid import declaration
extern crate core as some_crate;

#[macro_use(i_want = "some_macros")] // error: invalid import declaration
extern crate core as another_crate;
<span class="boring">}</span></code></pre></pre>
<p>This is a syntax error at the level of attribute declarations. The proper
syntax for macro imports is the following:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">// In some_crate:
#[macro_export]
macro_rules! get_tacos {
    ...
}

#[macro_export]
macro_rules! get_pimientos {
    ...
}

// In your crate:
#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and
extern crate some_crate;               // `get_pimientos` macros from some_crate</code></pre>
<p>If you would like to import all exported macros, write <code>macro_use</code> with no
arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0468"><a class="header" href="#error-code-e0468">Error code E0468</a></h1>
<p>A non-root module tried to import macros from another crate.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0468"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    #[macro_use(debug_assert)]  // error: must be at crate root to import
    extern crate core;          //        macros from another crate
    fn run_macro() { debug_assert!(true); }
}
<span class="boring">}</span></code></pre></pre>
<p>Only <code>extern crate</code> imports at the crate root level are allowed to import
macros.</p>
<p>Either move the macro import to crate root or do without the foreign macros.
This will work:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use(debug_assert)] // ok!
extern crate core;

mod foo {
    fn run_macro() { debug_assert!(true); }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0469"><a class="header" href="#error-code-e0469">Error code E0469</a></h1>
<p>A macro listed for import was not found.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0469">#[macro_use(drink, be_merry)] // error: imported macro not found
extern crate alloc;

fn main() {
    // ...
}</code></pre></pre>
<p>Either the listed macro is not contained in the imported crate, or it is not
exported from the given crate.</p>
<p>This could be caused by a typo. Did you misspell the macro's name?</p>
<p>Double-check the names of the macros listed for import, and that the crate
in question exports them.</p>
<p>A working version would be:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">// In some_crate crate:
#[macro_export]
macro_rules! eat {
    ...
}

#[macro_export]
macro_rules! drink {
    ...
}

// In your crate:
#[macro_use(eat, drink)]
extern crate some_crate; //ok!</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0472"><a class="header" href="#error-code-e0472">Error code E0472</a></h1>
<p>Inline assembly (<code>asm!</code>) is not supported on this target.</p>
<p>Example of erroneous code:</p>
<pre><code class="language-rust ignore (cannot-change-target)">// compile-flags: --target sparc64-unknown-linux-gnu
#![no_std]

use core::arch::asm;

fn main() {
    unsafe {
        asm!(""); // error: inline assembly is not supported on this target
    }
}</code></pre>
<p>The Rust compiler does not support inline assembly, with the <code>asm!</code> macro
(previously <code>llvm_asm!</code>), for all targets. All Tier 1 targets do support this
macro but support among Tier 2 and 3 targets is not guaranteed (even when they
have <code>std</code> support). Note that this error is related to
<code>error[E0658]: inline assembly is not stable yet on this architecture</code>, but
distinct in that with <code>E0472</code> support is not planned or in progress.</p>
<p>There is no way to easily fix this issue, however:</p>
<ul>
<li>Consider if you really need inline assembly, is there some other way to
achieve your goal (intrinsics, etc)?</li>
<li>Consider writing your assembly externally, linking with it and calling it
from Rust.</li>
<li>Consider contributing to <a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a> and help
integrate support for your target!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0476"><a class="header" href="#error-code-e0476">Error code E0476</a></h1>
<p>The coerced type does not outlive the value being coerced to.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0476"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
#![feature(unsize)]

<span class="boring">fn main() {
</span>use std::marker::Unsize;
use std::ops::CoerceUnsized;

// error: lifetime of the source pointer does not outlive lifetime bound of the
//        object type
impl&lt;'a, 'b, T, S&gt; CoerceUnsized&lt;&amp;'a T&gt; for &amp;'b S where S: Unsize&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>During a coercion, the "source pointer" (the coerced type) did not outlive the
"object type" (value being coerced to). In the above example, <code>'b</code> is not a
subtype of <code>'a</code>. This error can currently only be encountered with the unstable
<code>CoerceUnsized</code> trait which allows custom coercions of unsized types behind a
smart pointer to be implemented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0477"><a class="header" href="#error-code-e0477">Error code E0477</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-55"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-55">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The type does not fulfill the required lifetime.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct MyString&lt;'a&gt; {
    data: &amp;'a str,
}

fn i_want_static_closure&lt;F&gt;(a: F)
    where F: Fn() + 'static {}

fn print_string&lt;'a&gt;(s: Mutex&lt;MyString&lt;'a&gt;&gt;) {

    i_want_static_closure(move || {     // error: this closure has lifetime 'a
                                        //        rather than 'static
        println!("{}", s.lock().unwrap().data);
    });
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the closure does not satisfy the <code>'static</code> lifetime constraint.
To fix this error, you need to double check the lifetime of the type. Here, we
can fix this problem by giving <code>s</code> a static lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct MyString&lt;'a&gt; {
    data: &amp;'a str,
}

fn i_want_static_closure&lt;F&gt;(a: F)
    where F: Fn() + 'static {}

fn print_string(s: Mutex&lt;MyString&lt;'static&gt;&gt;) {

    i_want_static_closure(move || {     // ok!
        println!("{}", s.lock().unwrap().data);
    });
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0478"><a class="header" href="#error-code-e0478">Error code E0478</a></h1>
<p>A lifetime bound was not satisfied.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0478"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must
// outlive all the superbounds from the trait (`'kiss`, in this example).

trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite&gt; {
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;,
    // error: lifetime bound not satisfied
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the <code>'SnowWhite</code> lifetime is supposed to outlive the <code>'kiss</code>
lifetime but the declaration of the <code>Prince</code> struct doesn't enforce it. To fix
this issue, you need to specify it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite: 'kiss&gt; { // You say here that 'SnowWhite
                                          // must live longer than 'kiss.
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;, // And now it's all good!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0482"><a class="header" href="#error-code-e0482">Error code E0482</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-56"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-56">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A lifetime of a returned value does not outlive the function call.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0700"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prefix&lt;'a&gt;(
    words: impl Iterator&lt;Item = &amp;'a str&gt;
) -&gt; impl Iterator&lt;Item = String&gt; { // error!
    words.map(|v| format!("foo-{}", v))
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, make the lifetime of the returned value explicit:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prefix&lt;'a&gt;(
    words: impl Iterator&lt;Item = &amp;'a str&gt; + 'a
) -&gt; impl Iterator&lt;Item = String&gt; + 'a { // ok!
    words.map(|v| format!("foo-{}", v))
}
<span class="boring">}</span></code></pre></pre>
<p>The <a href="https://doc.rust-lang.org/reference/types/impl-trait.html"><code>impl Trait</code></a> feature in this example uses an implicit <code>'static</code> lifetime
restriction in the returned type. However the type implementing the <code>Iterator</code>
passed to the function lives just as long as <code>'a</code>, which is not long enough.</p>
<p>The solution involves adding lifetime bound to both function argument and
the return value to make sure that the values inside the iterator
are not dropped when the function goes out of the scope.</p>
<p>An alternative solution would be to guarantee that the <code>Item</code> references
in the iterator are alive for the whole lifetime of the program.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prefix(
    words: impl Iterator&lt;Item = &amp;'static str&gt;
) -&gt; impl Iterator&lt;Item = String&gt; {  // ok!
    words.map(|v| format!("foo-{}", v))
}
<span class="boring">}</span></code></pre></pre>
<p>A similar lifetime problem might arise when returning closures:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0700"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(
    x: &amp;mut Vec&lt;i32&gt;
) -&gt; impl FnMut(&amp;mut Vec&lt;i32&gt;) -&gt; &amp;[i32] { // error!
    |y| {
        y.append(x);
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Analogically, a solution here is to use explicit return lifetime
and move the ownership of the variable to the closure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(
    x: &amp;'a mut Vec&lt;i32&gt;
) -&gt; impl FnMut(&amp;mut Vec&lt;i32&gt;) -&gt; &amp;[i32] + 'a { // ok!
    move |y| {
        y.append(x);
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To better understand the lifetime treatment in the <a href="https://doc.rust-lang.org/reference/types/impl-trait.html"><code>impl Trait</code></a>,
please see the <a href="https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html">RFC 1951</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0491"><a class="header" href="#error-code-e0491">Error code E0491</a></h1>
<p>A reference has a longer lifetime than the data it references.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0491"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: fn(&amp;'a i32),
}

trait Trait&lt;'a, 'b&gt; {
    type Out;
}

impl&lt;'a, 'b&gt; Trait&lt;'a, 'b&gt; for usize {
    type Out = &amp;'a Foo&lt;'b&gt;; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the problem is that the compiler cannot be sure that the <code>'b</code> lifetime
will live longer than <code>'a</code>, which should be mandatory in order to be sure that
<code>Trait::Out</code> will always have a reference pointing to an existing type. So in
this case, we just need to tell the compiler than <code>'b</code> must outlive <code>'a</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: fn(&amp;'a i32),
}

trait Trait&lt;'a, 'b&gt; {
    type Out;
}

impl&lt;'a, 'b: 'a&gt; Trait&lt;'a, 'b&gt; for usize { // we added the lifetime enforcement
    type Out = &amp;'a Foo&lt;'b&gt;; // it now works!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0492"><a class="header" href="#error-code-e0492">Error code E0492</a></h1>
<p>A borrow of a constant containing interior mutability was attempted.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0492"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::AtomicUsize;

const A: AtomicUsize = AtomicUsize::new(0);
const B: &amp;'static AtomicUsize = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead
<span class="boring">}</span></code></pre></pre>
<p>A <code>const</code> represents a constant value that should never change. If one takes
a <code>&amp;</code> reference to the constant, then one is taking a pointer to some memory
location containing the value. Normally this is perfectly fine: most values
can't be changed via a shared <code>&amp;</code> pointer, but interior mutability would allow
it. That is, a constant value could be mutated. On the other hand, a <code>static</code> is
explicitly a single memory location, which can be mutated at will.</p>
<p>So, in order to solve this error, use statics which are <code>Sync</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::AtomicUsize;

static A: AtomicUsize = AtomicUsize::new(0);
static B: &amp;'static AtomicUsize = &amp;A; // ok!
<span class="boring">}</span></code></pre></pre>
<p>You can also have this error while using a cell type:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0492"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

const A: Cell&lt;usize&gt; = Cell::new(1);
const B: &amp;Cell&lt;usize&gt; = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead

// or:
struct C { a: Cell&lt;usize&gt; }

const D: C = C { a: Cell::new(1) };
const E: &amp;Cell&lt;usize&gt; = &amp;D.a; // error

// or:
const F: &amp;C = &amp;D; // error
<span class="boring">}</span></code></pre></pre>
<p>This is because cell types do operations that are not thread-safe. Due to this,
they don't implement Sync and thus can't be placed in statics.</p>
<p>However, if you still wish to use these types, you can achieve this by an unsafe
wrapper:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

struct NotThreadSafe&lt;T&gt; {
    value: Cell&lt;T&gt;,
}

unsafe impl&lt;T&gt; Sync for NotThreadSafe&lt;T&gt; {}

static A: NotThreadSafe&lt;usize&gt; = NotThreadSafe { value : Cell::new(1) };
static B: &amp;'static NotThreadSafe&lt;usize&gt; = &amp;A; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Remember this solution is unsafe! You will have to ensure that accesses to the
cell are synchronized.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0493"><a class="header" href="#error-code-e0493">Error code E0493</a></h1>
<p>A value with a custom <code>Drop</code> implementation may be dropped during const-eval.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0493"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DropType {
    A,
}

impl Drop for DropType {
    fn drop(&amp;mut self) {}
}

struct Foo {
    field1: DropType,
}

static FOO: Foo = Foo { field1: (DropType::A, DropType::A).1 }; // error!
<span class="boring">}</span></code></pre></pre>
<p>The problem here is that if the given type or one of its fields implements the
<code>Drop</code> trait, this <code>Drop</code> implementation cannot be called within a const
context since it may run arbitrary, non-const-checked code. To prevent this
issue, ensure all values with a custom <code>Drop</code> implementation escape the
initializer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DropType {
    A,
}

impl Drop for DropType {
    fn drop(&amp;mut self) {}
}

struct Foo {
    field1: DropType,
}

static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields
                                               // by hand.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0495"><a class="header" href="#error-code-e0495">Error code E0495</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-57"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-57">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A lifetime cannot be determined in the given situation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transmute_lifetime&lt;'a, 'b, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'b T {
    match (&amp;t,) { // error!
        ((u,),) =&gt; u,
    }
}

let y = Box::new((42,));
let x = transmute_lifetime(&amp;y);
<span class="boring">}</span></code></pre></pre>
<p>In this code, you have two ways to solve this issue:</p>
<ol>
<li>Enforce that <code>'a</code> lives at least as long as <code>'b</code>.</li>
<li>Use the same lifetime requirement for both input and output values.</li>
</ol>
<p>So for the first solution, you can do it by replacing <code>'a</code> with <code>'a: 'b</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transmute_lifetime&lt;'a: 'b, 'b, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'b T {
    match (&amp;t,) { // ok!
        ((u,),) =&gt; u,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the second you can do it by simply removing <code>'b</code> so they both use <code>'a</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transmute_lifetime&lt;'a, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'a T {
    match (&amp;t,) { // ok!
        ((u,),) =&gt; u,
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0496"><a class="header" href="#error-code-e0496">Error code E0496</a></h1>
<p>A lifetime name is shadowing another lifetime name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0496"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'a&gt;(x: &amp;'a i32) { // error: lifetime name `'a` shadows a lifetime
                           //        name that is already in scope
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Please change the name of one of the lifetimes to remove this error. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'b&gt;(x: &amp;'b i32) { // ok!
    }
}

fn main() {
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0497"><a class="header" href="#error-code-e0497">Error code E0497</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-58"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-58">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A stability attribute was used outside of the standard library.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable] // error: stability attributes may not be used outside of the
          //        standard library
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>It is not possible to use stability attributes outside of the standard library.
Also, for now, it is not possible to write deprecation messages either.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0498"><a class="header" href="#error-code-e0498">Error code E0498</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-59"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-59">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The <code>plugin</code> attribute was malformed.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (E0498 is no longer emitted)">#![feature(plugin)]
#![plugin(foo(args))] // error: invalid argument
#![plugin(bar="test")] // error: invalid argument</code></pre>
<p>The <code>#[plugin]</code> attribute should take a single argument: the name of the plugin.</p>
<p>For example, for the plugin <code>foo</code>:</p>
<pre><code class="language-rust ignore (requires external plugin crate)">#![feature(plugin)]
#![plugin(foo)] // ok!</code></pre>
<p>See the <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/plugin.html"><code>plugin</code> feature</a> section of the Unstable book for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0499"><a class="header" href="#error-code-e0499">Error code E0499</a></h1>
<p>A variable was borrowed as mutable more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0499"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;
let mut x = &amp;mut i;
let mut a = &amp;mut i;
x;
// error: cannot borrow `i` as mutable more than once at a time
<span class="boring">}</span></code></pre></pre>
<p>Please note that in Rust, you can either have many immutable references, or one
mutable reference. For more details you may want to read the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;
let mut x = &amp;mut i; // ok!

// or:
let mut i = 0;
let a = &amp;i; // ok!
let b = &amp;i; // still ok!
let c = &amp;i; // still ok!
b;
a;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0500"><a class="header" href="#error-code-e0500">Error code E0500</a></h1>
<p>A borrowed variable was used by a closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0500"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    let starks = || {
        *jon_snow = 3; // error: closure requires unique access to `jon_snow`
                       //        but it is already borrowed
    };
    println!("{}", nights_watch);
}
<span class="boring">}</span></code></pre></pre>
<p>In here, <code>jon_snow</code> is already borrowed by the <code>nights_watch</code> reference, so it
cannot be borrowed by the <code>starks</code> closure at the same time. To fix this issue,
you can create the closure after the borrow has ended:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    println!("{}", nights_watch);
    let starks = || {
        *jon_snow = 3;
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Or, if the type implements the <code>Clone</code> trait, you can clone it between
closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn you_know_nothing(jon_snow: &amp;mut i32) {
    let mut jon_copy = jon_snow.clone();
    let starks = || {
        *jon_snow = 3;
    };
    println!("{}", jon_copy);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0501"><a class="header" href="#error-code-e0501">Error code E0501</a></h1>
<p>A mutable variable is used but it is already captured by a closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0501"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn outside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn foo(a: &amp;mut i32) {
    let mut bar = || {
        inside_closure(a)
    };
    outside_closure(a); // error: cannot borrow `*a` as mutable because previous
                        //        closure requires unique access.
    bar();
}
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that a mutable variable is used while it is still captured
by a closure. Because the closure has borrowed the variable, it is not available
until the closure goes out of scope.</p>
<p>Note that a capture will either move or borrow a variable, but in this
situation, the closure is borrowing the variable. Take a look at the chapter
on <a href="https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html">Capturing</a> in Rust By Example for more information.</p>
<p>To fix this error, you can finish using the closure before using the captured
variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let mut bar = || {
        inside_closure(a)
    };
    bar();
    // borrow on `a` ends.
    outside_closure(a); // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or you can pass the variable as a parameter to the closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let mut bar = |s: &amp;mut i32| {
        inside_closure(s)
    };
    outside_closure(a);
    bar(a);
}
<span class="boring">}</span></code></pre></pre>
<p>It may be possible to define the closure later:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    outside_closure(a);
    let mut bar = || {
        inside_closure(a)
    };
    bar();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0502"><a class="header" href="#error-code-e0502">Error code E0502</a></h1>
<p>A variable already borrowed with a certain mutability (either mutable or
immutable) was borrowed again with a different mutability.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    let y = &amp;a; // a is borrowed as immutable.
    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed
            //        as immutable
    println!("{}", y);
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, ensure that you don't have any other references to the
variable before trying to access it with a different mutability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    bar(a);
    let y = &amp;a; // ok!
    println!("{}", y);
}
<span class="boring">}</span></code></pre></pre>
<p>For more information on Rust's ownership system, take a look at the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0503"><a class="header" href="#error-code-e0503">Error code E0503</a></h1>
<p>A value was used after it was mutably borrowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0503">fn main() {
    let mut value = 3;
    // Create a mutable borrow of `value`.
    let borrow = &amp;mut value;
    let _sum = value + 1; // error: cannot use `value` because
                          //        it was mutably borrowed
    println!("{}", borrow);
}</code></pre></pre>
<p>In this example, <code>value</code> is mutably borrowed by <code>borrow</code> and cannot be
used to calculate <code>sum</code>. This is not possible because this would violate
Rust's mutability rules.</p>
<p>You can fix this error by finishing using the borrow before the next use of
the value:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut value = 3;
    let borrow = &amp;mut value;
    println!("{}", borrow);
    // The block has ended and with it the borrow.
    // You can now use `value` again.
    let _sum = value + 1;
}</code></pre></pre>
<p>Or by cloning <code>value</code> before borrowing it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut value = 3;
    // We clone `value`, creating a copy.
    let value_cloned = value.clone();
    // The mutable borrow is a reference to `value` and
    // not to `value_cloned`...
    let borrow = &amp;mut value;
    // ... which means we can still use `value_cloned`,
    let _sum = value_cloned + 1;
    // even though the borrow only ends here.
    println!("{}", borrow);
}</code></pre></pre>
<p>For more information on Rust's ownership system, take a look at the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0504"><a class="header" href="#error-code-e0504">Error code E0504</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-60"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-60">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error occurs when an attempt is made to move a borrowed variable into a
closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        println!("child function: {}", fancy_num.num);
        // error: cannot move `fancy_num` into closure because it is borrowed
    };

    x();
    println!("main function: {}", fancy_ref.num);
}</code></pre></pre>
<p>Here, <code>fancy_num</code> is borrowed by <code>fancy_ref</code> and so cannot be moved into
the closure <code>x</code>. There is no way to move a value into a closure while it is
borrowed, as that would invalidate the borrow.</p>
<p>If the closure can't outlive the value being moved, try using a reference
rather than moving:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        // fancy_ref is usable here because it doesn't move `fancy_num`
        println!("child function: {}", fancy_ref.num);
    };

    x();

    println!("main function: {}", fancy_num.num);
}</code></pre></pre>
<p>If the value has to be borrowed and then moved, try limiting the lifetime of
the borrow using a scoped block:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };

    {
        let fancy_ref = &amp;fancy_num;
        println!("main function: {}", fancy_ref.num);
        // `fancy_ref` goes out of scope here
    }

    let x = move || {
        // `fancy_num` can be moved now (no more references exist)
        println!("child function: {}", fancy_num.num);
    };

    x();
}</code></pre></pre>
<p>If the lifetime of a reference isn't enough, such as in the case of threading,
consider using an <code>Arc</code> to create a reference-counted value:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::thread;

struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_ref1 = Arc::new(FancyNum { num: 5 });
    let fancy_ref2 = fancy_ref1.clone();

    let x = thread::spawn(move || {
        // `fancy_ref1` can be moved and has a `'static` lifetime
        println!("child thread: {}", fancy_ref1.num);
    });

    x.join().expect("child thread should finish");
    println!("main thread: {}", fancy_ref2.num);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0505"><a class="header" href="#error-code-e0505">Error code E0505</a></h1>
<p>A value was moved out while it was still borrowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0505">struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    let _ref_to_val: &amp;Value = &amp;x;
    eat(x);
    borrow(_ref_to_val);
}</code></pre></pre>
<p>Here, the function <code>eat</code> takes ownership of <code>x</code>. However,
<code>x</code> cannot be moved because the borrow to <code>_ref_to_val</code>
needs to last till the function <code>borrow</code>.
To fix that you can do a few different things:</p>
<ul>
<li>Try to avoid moving the variable.</li>
<li>Release borrow before move.</li>
<li>Implement the <code>Copy</code> trait on the type.</li>
</ul>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust">struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: &amp;Value) {}

fn main() {
    let x = Value{};

    let ref_to_val: &amp;Value = &amp;x;
    eat(&amp;x); // pass by reference, if it's possible
    borrow(ref_to_val);
}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust">struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};

    let ref_to_val: &amp;Value = &amp;x;
    borrow(ref_to_val);
    // ref_to_val is no longer used.
    eat(x);
}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)] // implement Copy trait
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    let ref_to_val: &amp;Value = &amp;x;
    eat(x); // it will be copied here.
    borrow(ref_to_val);
}</code></pre></pre>
<p>For more information on Rust's ownership system, take a look at the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0506"><a class="header" href="#error-code-e0506">Error code E0506</a></h1>
<p>An attempt was made to assign to a borrowed value.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0506"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };
let fancy_ref = &amp;fancy_num;
fancy_num = FancyNum { num: 6 };
// error: cannot assign to `fancy_num` because it is borrowed

println!("Num: {}, Ref: {}", fancy_num.num, fancy_ref.num);
<span class="boring">}</span></code></pre></pre>
<p>Because <code>fancy_ref</code> still holds a reference to <code>fancy_num</code>, <code>fancy_num</code> can't
be assigned to a new value as it would invalidate the reference.</p>
<p>Alternatively, we can move out of <code>fancy_num</code> into a second <code>fancy_num</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };
let moved_num = fancy_num;
fancy_num = FancyNum { num: 6 };

println!("Num: {}, Moved num: {}", fancy_num.num, moved_num.num);
<span class="boring">}</span></code></pre></pre>
<p>If the value has to be borrowed, try limiting the lifetime of the borrow using
a scoped block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };

{
    let fancy_ref = &amp;fancy_num;
    println!("Ref: {}", fancy_ref.num);
}

// Works because `fancy_ref` is no longer in scope
fancy_num = FancyNum { num: 6 };
println!("Num: {}", fancy_num.num);
<span class="boring">}</span></code></pre></pre>
<p>Or by moving the reference into a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FancyNum {
    num: u8,
}

fn print_fancy_ref(fancy_ref: &amp;FancyNum){
    println!("Ref: {}", fancy_ref.num);
}

let mut fancy_num = FancyNum { num: 5 };

print_fancy_ref(&amp;fancy_num);

// Works because function borrow has ended
fancy_num = FancyNum { num: 6 };
println!("Num: {}", fancy_num.num);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0507"><a class="header" href="#error-code-e0507">Error code E0507</a></h1>
<p>A borrowed value was moved out.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0507">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content
}</code></pre></pre>
<p>Here, the <code>nothing_is_true</code> method takes the ownership of <code>self</code>. However,
<code>self</code> cannot be moved because <code>.borrow()</code> only provides an <code>&amp;TheDarkKnight</code>,
which is a borrow of the content owned by the <code>RefCell</code>. To fix this error,
you have three choices:</p>
<ul>
<li>Try to avoid moving the variable.</li>
<li>Somehow reclaim the ownership.</li>
<li>Implement the <code>Copy</code> trait on the type.</li>
</ul>
<p>This can also happen when using a type implementing <code>Fn</code> or <code>FnMut</code>, as neither
allows moving out of them (they usually represent closures which can be called
more than once). Much of the text following applies equally well to non-<code>FnOnce</code>
closure bodies.</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(&amp;self) {} // First case, we don't take ownership
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);
    let x = x.into_inner(); // we get back ownership

    x.nothing_is_true(); // ok!
}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

#[derive(Clone, Copy)] // we implement the Copy trait
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</code></pre></pre>
<p>Moving a member out of a mutably borrowed struct will also cause E0507 error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0507">struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

struct Batcave {
    knight: TheDarkKnight
}

fn main() {
    let mut cave = Batcave {
        knight: TheDarkKnight
    };
    let borrowed = &amp;mut cave;

    borrowed.knight.nothing_is_true(); // E0507
}</code></pre></pre>
<p>It is fine only if you put something back. <code>mem::replace</code> can be used for that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct TheDarkKnight;
</span><span class="boring">impl TheDarkKnight { fn nothing_is_true(self) {} }
</span><span class="boring">struct Batcave { knight: TheDarkKnight }
</span>use std::mem;

let mut cave = Batcave {
    knight: TheDarkKnight
};
let borrowed = &amp;mut cave;

mem::replace(&amp;mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!
<span class="boring">}</span></code></pre></pre>
<p>For more information on Rust's ownership system, take a look at the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0508"><a class="header" href="#error-code-e0508">Error code E0508</a></h1>
<p>A value was moved out of a non-copy fixed-size array.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0508">struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,
                           //        a non-copy fixed-size array
}</code></pre></pre>
<p>The first element was moved out of the array, but this is not
possible because <code>NonCopy</code> does not implement the <code>Copy</code> trait.</p>
<p>Consider borrowing the element instead of moving it:</p>
<pre><pre class="playground"><code class="language-rust">struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = &amp;array[0]; // Borrowing is allowed, unlike moving.
}</code></pre></pre>
<p>Alternatively, if your type implements <code>Clone</code> and you need to own the value,
consider borrowing and then cloning:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone)]
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    // Now you can clone the array element.
    let _value = array[0].clone();
}</code></pre></pre>
<p>If you really want to move the value out, you can use a destructuring array
pattern to move it:</p>
<pre><pre class="playground"><code class="language-rust">struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    // Destructuring the array
    let [_value] = array;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0509"><a class="header" href="#error-code-e0509">Error code E0509</a></h1>
<p>This error occurs when an attempt is made to move out of a value whose type
implements the <code>Drop</code> trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0509">struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let fancy_field = drop_struct.fancy; // Error E0509
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</code></pre></pre>
<p>Here, we tried to move a field out of a struct of type <code>DropStruct</code> which
implements the <code>Drop</code> trait. However, a struct cannot be dropped if one or
more of its fields have been moved.</p>
<p>Structs implementing the <code>Drop</code> trait have an implicit destructor that gets
called when they go out of scope. This destructor may use the fields of the
struct, so moving out of the struct could make it impossible to run the
destructor. Therefore, we must think of all values whose type implements the
<code>Drop</code> trait as single units whose fields cannot be moved.</p>
<p>This error can be fixed by creating a reference to the fields of a struct,
enum, or tuple using the <code>ref</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let ref fancy_field = drop_struct.fancy; // No more errors!
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</code></pre></pre>
<p>Note that this technique can also be used in the arms of a match expression:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: usize
}

enum DropEnum {
    Fancy(FancyNum)
}

impl Drop for DropEnum {
    fn drop(&amp;mut self) {
        // Destruct DropEnum, possibly using FancyNum
    }
}

fn main() {
    // Creates and enum of type `DropEnum`, which implements `Drop`
    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});
    match drop_enum {
        // Creates a reference to the inside of `DropEnum::Fancy`
        DropEnum::Fancy(ref fancy_field) =&gt; // No error!
            println!("It was fancy-- {}!", fancy_field.num),
    }
    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0510"><a class="header" href="#error-code-e0510">Error code E0510</a></h1>
<p>The matched value was assigned in a match guard.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0510"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Some(0);
match x {
    None =&gt; {}
    Some(_) if { x = None; false } =&gt; {} // error!
    Some(_) =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>When matching on a variable it cannot be mutated in the match guards, as this
could cause the match to be non-exhaustive.</p>
<p>Here executing <code>x = None</code> would modify the value being matched and require us
to go "back in time" to the <code>None</code> arm. To fix it, change the value in the match
arm:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Some(0);
match x {
    None =&gt; {}
    Some(_) =&gt; {
        x = None; // ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0511"><a class="header" href="#error-code-e0511">Error code E0511</a></h1>
<p>Invalid monomorphization of an intrinsic function was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0511">#![feature(intrinsics)]

#[rustc_intrinsic]
unsafe fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;

fn main() {
    unsafe { simd_add(0, 1); }
    // error: invalid monomorphization of `simd_add` intrinsic
}</code></pre></pre>
<p>The generic type has to be a SIMD type. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]
#![feature(intrinsics)]

<span class="boring">fn main() {
</span>#[repr(simd)]
#[derive(Copy, Clone)]
struct i32x2([i32; 2]);

#[rustc_intrinsic]
unsafe fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;

unsafe { simd_add(i32x2([0, 0]), i32x2([1, 2])); } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0512"><a class="header" href="#error-code-e0512">Error code E0512</a></h1>
<p>Transmute with two differently sized types was attempted.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0512">fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0u16)); }
    // error: cannot transmute between types of different sizes,
    //        or dependently-sized types
}</code></pre></pre>
<p>Please use types with same size or use the expected type directly. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!
    // or:
    unsafe { takes_u8(0u8); } // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0514"><a class="header" href="#error-code-e0514">Error code E0514</a></h1>
<p>Dependency compiled with different version of <code>rustc</code>.</p>
<p>Example of erroneous code:</p>
<p><code>a.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">// compiled with stable `rustc`

#[crate_type = "lib"]</code></pre>
<p><code>b.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">// compiled with nightly `rustc`

#[crate_type = "lib"]

extern crate a; // error: found crate `a` compiled by an incompatible version
                //        of rustc</code></pre>
<p>This error is caused when the version of <code>rustc</code> used to compile a crate, as
stored in the binary's metadata, differs from the version of one of its
dependencies. Many parts of Rust binaries are considered unstable. For
instance, the Rust ABI is not stable between compiler versions. This means that
the compiler cannot be sure about <em>how</em> to call a function between compiler
versions, and therefore this error occurs.</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager and
<a href="https://rust-lang.github.io/rustup/">Rustup</a>, the Rust toolchain installer,
automatically fixing this issue.</li>
<li>Recompiling the crates with a uniform <code>rustc</code> version.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0515"><a class="header" href="#error-code-e0515">Error code E0515</a></h1>
<p>A reference to a local variable was returned.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0515"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_dangling_reference() -&gt; &amp;'static i32 {
    let x = 0;
    &amp;x
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0515"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice::Iter;
fn get_dangling_iterator&lt;'a&gt;() -&gt; Iter&lt;'a, i32&gt; {
    let v = vec![1, 2, 3];
    v.iter()
}
<span class="boring">}</span></code></pre></pre>
<p>Local variables, function parameters and temporaries are all dropped before
the end of the function body. A returned reference (or struct containing a
reference) to such a dropped value would immediately be invalid. Therefore
it is not allowed to return such a reference.</p>
<p>Consider returning a value that takes ownership of local data instead of
referencing it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::vec::IntoIter;

fn get_integer() -&gt; i32 {
    let x = 0;
    x
}

fn get_owned_iterator() -&gt; IntoIter&lt;i32&gt; {
    let v = vec![1, 2, 3];
    v.into_iter()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0516"><a class="header" href="#error-code-e0516">Error code E0516</a></h1>
<p>The <code>typeof</code> keyword is currently reserved but unimplemented.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0516">fn main() {
    let x: typeof(92) = 92;
}</code></pre></pre>
<p>Try using type inference instead. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 92;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0517"><a class="header" href="#error-code-e0517">Error code E0517</a></h1>
<p>A <code>#[repr(..)]</code> attribute was placed on an unsupported item.</p>
<p>Examples of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0517"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
type Foo = u8;

#[repr(packed)]
enum Foo {Bar, Baz}

#[repr(u8)]
struct Foo {bar: bool, baz: bool}

#[repr(C)]
impl Foo {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>#[repr(C)]</code> attribute can only be placed on structs and enums.</li>
<li>The <code>#[repr(packed)]</code> and <code>#[repr(simd)]</code> attributes only work on structs.</li>
<li>The <code>#[repr(u8)]</code>, <code>#[repr(i16)]</code>, etc attributes only work on enums.</li>
</ul>
<p>These attributes do not work on typedefs, since typedefs are just aliases.</p>
<p>Representations like <code>#[repr(u8)]</code>, <code>#[repr(i64)]</code> are for selecting the
discriminant size for enums. For enums with no data fields on any of the
variants, e.g. <code>enum Color {Red, Blue, Green}</code>, this effectively sets the size
of the enum to the size of the provided type. Such an enum can be cast to a
value of the same type as well. In short, <code>#[repr(u8)]</code> makes a field-less enum
behave like an integer with a constrained set of allowed values.</p>
<p>For a description of how <code>#[repr(C)]</code> and representations like <code>#[repr(u8)]</code>
affect the layout of enums with data fields, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">RFC 2195</a>.</p>
<p>Only field-less enums can be cast to numerical primitives. Representations like
<code>#[repr(u8)]</code> will not apply to structs.</p>
<p><code>#[repr(packed)]</code> reduces padding to make the struct size smaller. The
representation of enums isn't strictly defined in Rust, and this attribute
won't work on enums.</p>
<p><code>#[repr(simd)]</code> will give a struct consisting of a homogeneous series of machine
types (i.e., <code>u8</code>, <code>i32</code>, etc) a representation that permits vectorization via
SIMD. This doesn't make much sense for enums since they don't consist of a
single list of data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0518"><a class="header" href="#error-code-e0518">Error code E0518</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-61"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-61">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An <code>#[inline(..)]</code> attribute was incorrectly placed on something other than a
function or method.</p>
<p>Example of erroneous code:</p>
<pre><code class="language-rust ignore (no longer emitted)">#[inline(always)]
struct Foo;

#[inline(never)]
impl Foo {
    // ...
}</code></pre>
<p><code>#[inline]</code> hints the compiler whether or not to attempt to inline a method or
function. By default, the compiler does a pretty good job of figuring this out
itself, but if you feel the need for annotations, <code>#[inline(always)]</code> and
<code>#[inline(never)]</code> can override or force the compiler's decision.</p>
<p>If you wish to apply this attribute to all methods in an impl, manually annotate
each method; it is not possible to annotate the entire impl with an <code>#[inline]</code>
attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0519"><a class="header" href="#error-code-e0519">Error code E0519</a></h1>
<p>The current crate is indistinguishable from one of its dependencies, in terms
of metadata.</p>
<p>Example of erroneous code:</p>
<p><code>a.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">#![crate_name = "a"]
#![crate_type = "lib"]

pub fn foo() {}</code></pre>
<p><code>b.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">#![crate_name = "a"]
#![crate_type = "lib"]

// error: the current crate is indistinguishable from one of its dependencies:
//        it has the same crate-name `a` and was compiled with the same
//        `-C metadata` arguments. This will result in symbol conflicts between
//        the two.
extern crate a;

pub fn foo() {}

fn bar() {
    a::foo(); // is this calling the local crate or the dependency?
}</code></pre>
<p>The above example compiles two crates with exactly the same name and
<code>crate_type</code> (plus any other metadata). This causes an error because it becomes
impossible for the compiler to distinguish between symbols (<code>pub</code> item names).</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager, automatically
fixing this issue.</li>
<li>Recompiling the crate with different metadata (different name/
<code>crate_type</code>).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0520"><a class="header" href="#error-code-e0520">Error code E0520</a></h1>
<p>A non-default implementation was already made on this type so it cannot be
specialized further.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0520"><span class="boring">#![allow(unused)]
</span>#![feature(specialization)]

<span class="boring">fn main() {
</span>trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {}
}

// non-default impl
// applies to all `Clone` T and overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    fn fly(&amp;self) {}
}

// since `i32` is clone, this conflicts with the previous implementation
impl SpaceLlama for i32 {
    default fn fly(&amp;self) {}
    // error: item `fly` is provided by an `impl` that specializes
    //        another, but the item in the parent `impl` is not marked
    //        `default` and so it cannot be specialized.
}
<span class="boring">}</span></code></pre></pre>
<p>Specialization only allows you to override <code>default</code> functions in
implementations.</p>
<p>To fix this error, you need to mark all the parent implementations as default.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(specialization)]

<span class="boring">fn main() {
</span>trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation.
}

// applies to all `Clone` T; overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation but was
                             // previously not a default one, causing the error
}

// applies to i32, overrides the previous two impls
impl SpaceLlama for i32 {
    fn fly(&amp;self) {} // And now that's ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0521"><a class="header" href="#error-code-e0521">Error code E0521</a></h1>
<p>Borrowed data escapes outside of closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0521"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut list: Vec&lt;&amp;str&gt; = Vec::new();

let _add = |el: &amp;str| {
    list.push(el); // error: `el` escapes the closure body here
};
<span class="boring">}</span></code></pre></pre>
<p>A type annotation of a closure parameter implies a new lifetime declaration.
Consider to drop it, the compiler is reliably able to infer them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut list: Vec&lt;&amp;str&gt; = Vec::new();

let _add = |el| {
    list.push(el);
};
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/ch13-01-closures.html#closure-type-inference-and-annotation">Closure type inference and annotation</a> and
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html">Lifetime elision</a> sections of the Book for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0522"><a class="header" href="#error-code-e0522">Error code E0522</a></h1>
<p>The lang attribute was used in an invalid context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0522"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]

<span class="boring">fn main() {
</span>#[lang = "cookie"]
fn cookie() -&gt; ! { // error: definition of an unknown lang item: `cookie`
    loop {}
}
<span class="boring">}</span></code></pre></pre>
<p>The lang attribute is intended for marking special items that are built-in to
Rust itself. This includes special traits (like <code>Copy</code> and <code>Sized</code>) that affect
how the compiler behaves, as well as special functions that may be automatically
invoked (such as the handler for out-of-bounds accesses when indexing a slice).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0523"><a class="header" href="#error-code-e0523">Error code E0523</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-62"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-62">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The compiler found multiple library files with the requested crate name.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">// aux-build:crateresolve-1.rs
// aux-build:crateresolve-2.rs
// aux-build:crateresolve-3.rs

extern crate crateresolve;
//~^ ERROR multiple candidates for `rlib` dependency `crateresolve` found

fn main() {}</code></pre></pre>
<p>This error can occur in several different cases -- for example, when using
<code>extern crate</code> or passing <code>--extern</code> options without crate paths. It can also be
caused by caching issues with the build directory, in which case <code>cargo clean</code>
may help.</p>
<p>In the above example, there are three different library files, all of which
define the same crate name. Without providing a full path, there is no way for
the compiler to know which crate it should use.</p>
<p><em>Note that E0523 has been merged into E0464.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0524"><a class="header" href="#error-code-e0524">Error code E0524</a></h1>
<p>A variable which requires unique access is being used in more than one closure
at the same time.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0524"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    let mut c1 = || set(x);
    let mut c2 = || set(x); // error!

    c2();
    c1();
}
<span class="boring">}</span></code></pre></pre>
<p>To solve this issue, multiple solutions are available. First, is it required
for this variable to be used in more than one closure at a time? If it is the
case, use reference counted types such as <code>Rc</code> (or <code>Arc</code> if it runs
concurrently):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    let x = Rc::new(RefCell::new(x));
    let y = Rc::clone(&amp;x);
    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&amp;mut x2); };
    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&amp;mut x2); }; // ok!

    c2();
    c1();
}
<span class="boring">}</span></code></pre></pre>
<p>If not, just run closures one at a time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    { // This block isn't necessary since non-lexical lifetimes, it's just to
      // make it more clear.
        let mut c1 = || set(&amp;mut *x);
        c1();
    } // `c1` has been dropped here so we're free to use `x` again!
    let mut c2 = || set(&amp;mut *x);
    c2();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0525"><a class="header" href="#error-code-e0525">Error code E0525</a></h1>
<p>A closure was used but didn't implement the expected trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0525">struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x); // error: expected a closure that implements
                              //        the `Fn` trait, but this closure only
                              //        implements `FnOnce`
    bar(closure);
}</code></pre></pre>
<p>In the example above, <code>closure</code> is an <code>FnOnce</code> closure whereas the <code>bar</code>
function expected an <code>Fn</code> closure. In this case, it's simple to fix the issue,
you just have to implement <code>Copy</code> and <code>Clone</code> traits on <code>struct X</code> and it'll
be ok:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.
struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x);
    bar(closure); // ok!
}</code></pre></pre>
<p>To better understand how these work in Rust, read the <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closures</a>
chapter of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0527"><a class="header" href="#error-code-e0527">Error code E0527</a></h1>
<p>The number of elements in an array or slice pattern differed from the number of
elements in the array being matched.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0527"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b] =&gt; { // error: pattern requires 2 elements but array
                 //        has 4
        println!("a={}, b={}", a, b);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ensure that the pattern is consistent with the size of the matched
array. Additional elements can be matched with <code>..</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b, ..] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0528"><a class="header" href="#error-code-e0528">Error code E0528</a></h1>
<p>An array or slice pattern required more elements than were present in the
matched array.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0528"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = &amp;[1, 2];
match r {
    &amp;[a, b, c, rest @ ..] =&gt; { // error: pattern requires at least 3
                               //        elements but array has 2
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ensure that the matched array has at least as many elements as the pattern
requires. You can match an arbitrary number of remaining elements with <code>..</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = &amp;[1, 2, 3, 4, 5];
match r {
    &amp;[a, b, c, rest @ ..] =&gt; { // ok!
        // prints `a=1, b=2, c=3 rest=[4, 5]`
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0529"><a class="header" href="#error-code-e0529">Error code E0529</a></h1>
<p>An array or slice pattern was matched against some other type.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0529"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: f32 = 1.0;
match r {
    [a, b] =&gt; { // error: expected an array or slice, found `f32`
        println!("a={}, b={}", a, b);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ensure that the pattern and the expression being matched on are of consistent
types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = [1.0, 2.0];
match r {
    [a, b] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0530"><a class="header" href="#error-code-e0530">Error code E0530</a></h1>
<p>A binding shadowed something it shouldn't.</p>
<p>A match arm or a variable has a name that is already used by
something else, e.g.</p>
<ul>
<li>struct name</li>
<li>enum variant</li>
<li>static</li>
<li>associated constant</li>
</ul>
<p>This error may also happen when an enum variant <em>with fields</em> is used
in a pattern, but without its fields.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    WithField(i32)
}

use Enum::*;
match WithField(1) {
    WithField =&gt; {} // error: missing (_)
}
<span class="boring">}</span></code></pre></pre>
<p>Match bindings cannot shadow statics:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0530"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static TEST: i32 = 0;

let r = 123;
match r {
    TEST =&gt; {} // error: name of a static
}
<span class="boring">}</span></code></pre></pre>
<p>Fixed examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static TEST: i32 = 0;

let r = 123;
match r {
    some_value =&gt; {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>or</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TEST: i32 = 0; // const, not static

let r = 123;
match r {
    TEST =&gt; {} // const is ok!
    other_values =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0531"><a class="header" href="#error-code-e0531">Error code E0531</a></h1>
<p>An unknown tuple struct/variant has been used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0531"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Type(x) = Type(12); // error!
match Bar(12) {
    Bar(x) =&gt; {} // error!
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>In most cases, it's either a forgotten import or a typo. However, let's look at
how you can have such a type:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type(u32); // this is a tuple struct

enum Foo {
    Bar(u32), // this is a tuple variant
}

use Foo::*; // To use Foo's variant directly, we need to import them in
            // the scope.
<span class="boring">}</span></code></pre></pre>
<p>Either way, it should work fine with our previous code:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type(u32);

enum Foo {
    Bar(u32),
}
use Foo::*;

let Type(x) = Type(12); // ok!
match Type(12) {
    Type(x) =&gt; {} // ok!
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0532"><a class="header" href="#error-code-e0532">Error code E0532</a></h1>
<p>Pattern arm did not match expected kind.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0532"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        // error: expected unit struct, unit variant or constant, found tuple
        //        variant `State::Failed`
        State::Failed =&gt; println!("Failed"),
        _ =&gt; ()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, ensure the match arm kind is the same as the expression
matched.</p>
<p>Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        State::Failed(ref msg) =&gt; println!("Failed with {}", msg),
        _ =&gt; ()
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0533"><a class="header" href="#error-code-e0533">Error code E0533</a></h1>
<p>An item which isn't a unit struct, a variant, nor a constant has been used as a
match pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0533"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Tortoise;

impl Tortoise {
    fn turtle(&amp;self) -&gt; u32 { 0 }
}

match 0u32 {
    Tortoise::turtle =&gt; {} // Error!
    _ =&gt; {}
}
if let Tortoise::turtle = 0u32 {} // Same error!
<span class="boring">}</span></code></pre></pre>
<p>If you want to match against a value returned by a method, you need to bind the
value first:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Tortoise;

impl Tortoise {
    fn turtle(&amp;self) -&gt; u32 { 0 }
}

match 0u32 {
    x if x == Tortoise.turtle() =&gt; {} // Bound into `x` then we compare it!
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0534"><a class="header" href="#error-code-e0534">Error code E0534</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-63"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-63">Note: this error code is no longer emitted by the compiler</a></h4>
<p>This is because it was too specific to the <code>inline</code> attribute.
Similar diagnostics occur for other attributes too.
The example here will now emit <code>E0805</code></p>
<p>The <code>inline</code> attribute was malformed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0805">#[inline()] // error: expected one argument
pub fn something() {}

fn main() {}</code></pre></pre>
<p>The parenthesized <code>inline</code> attribute requires the parameter to be specified:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(always)]
fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, a paren-less version of the attribute may be used to hint the
compiler about inlining opportunity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>For more information see the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>inline</code> attribute</a> section
of the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0535"><a class="header" href="#error-code-e0535">Error code E0535</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-64"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-64">Note: this error code is no longer emitted by the compiler</a></h4>
<p>This is because it was too specific to the <code>inline</code> attribute.
Similar diagnostics occur for other attributes too.
The example here will now emit <code>E0539</code></p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0539">#[inline(unknown)] // error: invalid argument
pub fn something() {}

fn main() {}</code></pre></pre>
<p>The <code>inline</code> attribute only supports two arguments:</p>
<ul>
<li>always</li>
<li>never</li>
</ul>
<p>All other arguments given to the <code>inline</code> attribute will return this error.
Example:</p>
<pre><pre class="playground"><code class="language-rust">#[inline(never)] // ok!
pub fn something() {}

fn main() {}</code></pre></pre>
<p>For more information see the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>inline</code> Attribute</a> section
of the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0536"><a class="header" href="#error-code-e0536">Error code E0536</a></h1>
<p>The <code>not</code> cfg-predicate was malformed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0536">pub fn main() {
    if cfg!(not()) { }
}</code></pre></pre>
<p>The <code>not</code> predicate expects one cfg-pattern. Example:</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
    if cfg!(not(target_os = "linux")) { } // ok!
}</code></pre></pre>
<p>For more information about the <code>cfg</code> macro, read the section on
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">Conditional Compilation</a> in the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0537"><a class="header" href="#error-code-e0537">Error code E0537</a></h1>
<p>An unknown predicate was used inside the <code>cfg</code> attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0537">#[cfg(unknown())] // error: invalid predicate `unknown`
pub fn something() {}

pub fn main() {}</code></pre></pre>
<p>The <code>cfg</code> attribute supports only three kinds of predicates:</p>
<ul>
<li>any</li>
<li>all</li>
<li>not</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(not(target_os = "linux"))] // ok!
pub fn something() {}

pub fn main() {}</code></pre></pre>
<p>For more information about the <code>cfg</code> attribute, read the section on
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">Conditional Compilation</a> in the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0538"><a class="header" href="#error-code-e0538">Error code E0538</a></h1>
<p>Attribute contains same meta item more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0538"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since="1.0.0",
    note="First deprecation note.",
    note="Second deprecation note." // error: multiple same meta item
)]
fn deprecated_function() {}
<span class="boring">}</span></code></pre></pre>
<p>Meta items are the key-value pairs inside of an attribute. Each key may only be
used once in each attribute.</p>
<p>To fix the problem, remove all but one of the meta items with the same key.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since="1.0.0",
    note="First deprecation note."
)]
fn deprecated_function() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0539"><a class="header" href="#error-code-e0539">Error code E0539</a></h1>
<p>An invalid meta-item was used inside an attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0539"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[deprecated(note)] // error!
#[unstable(feature = "deprecated_fn", issue = "123")]
fn deprecated() {}

#[unstable(feature = "unstable_struct", issue)] // error!
struct Unstable;

#[rustc_const_unstable(feature)] // error!
const fn unstable_fn() {}

#[stable(feature = "stable_struct", since)] // error!
struct Stable;

#[rustc_const_stable(feature)] // error!
const fn stable_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix the above example, you can write the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[deprecated(since = "1.39.0", note = "reason")] // ok!
#[unstable(feature = "deprecated_fn", issue = "123")]
fn deprecated() {}

#[unstable(feature = "unstable_struct", issue = "123")] // ok!
struct Unstable;

#[rustc_const_unstable(feature = "unstable_fn", issue = "124")] // ok!
const fn unstable_fn() {}

#[stable(feature = "stable_struct", since = "1.39.0")] // ok!
struct Stable;

#[stable(feature = "stable_fn", since = "1.39.0")]
#[rustc_const_stable(feature = "stable_fn", since = "1.39.0")] // ok!
const fn stable_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>Several causes of this are,
an attribute may have expected you to give a list but you gave a
<code>name = value</code> pair:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0539"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// wrong, should be `#[repr(C)]`
#[repr = "C"]
struct Foo {}
<span class="boring">}</span></code></pre></pre>
<p>Or a <code>name = value</code> pair, but you gave a list:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0539"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// wrong, should be `note = "reason"`
#[deprecated(since = "1.0.0", note("reason"))]
struct Foo {}
<span class="boring">}</span></code></pre></pre>
<p>Or it expected some specific word but you gave an unexpected one:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0539"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// should be `always` or `never`
#[inline(maybe_if_you_feel_like_it)]
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0541"><a class="header" href="#error-code-e0541">Error code E0541</a></h1>
<p>An unknown meta item was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0541"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since="1.0.0",
    // error: unknown meta item
    reason="Example invalid meta item. Should be 'note'")
]
fn deprecated_function() {}
<span class="boring">}</span></code></pre></pre>
<p>Meta items are the key-value pairs inside of an attribute. The keys provided
must be one of the valid keys for the specified attribute.</p>
<p>To fix the problem, either remove the unknown meta item, or rename it if you
provided the wrong name.</p>
<p>In the erroneous code example above, the wrong name was provided, so changing
to a correct one it will fix the error. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since="1.0.0",
    note="This is a valid meta item for the deprecated attribute."
)]
fn deprecated_function() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0542"><a class="header" href="#error-code-e0542">Error code E0542</a></h1>
<p>The <code>since</code> value is missing in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0542"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[stable(feature = "_stable_fn")] // invalid
fn _stable_fn() {}

#[rustc_const_stable(feature = "_stable_const_fn")] // invalid
const fn _stable_const_fn() {}

#[stable(feature = "_deprecated_fn", since = "0.1.0")]
#[deprecated(
    note = "explanation for deprecation"
)] // invalid
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide the <code>since</code> field. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[stable(feature = "_stable_fn", since = "1.0.0")] // ok!
fn _stable_fn() {}

#[stable(feature = "_stable_const_fn", since = "1.0.0")]
#[rustc_const_stable(feature = "_stable_const_fn", since = "1.0.0")] // ok!
const fn _stable_const_fn() {}

#[stable(feature = "_deprecated_fn", since = "0.1.0")]
#[deprecated(
    since = "1.0.0",
    note = "explanation for deprecation"
)] // ok!
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0543"><a class="header" href="#error-code-e0543">Error code E0543</a></h1>
<p>The <code>note</code> value is missing in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0543"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[stable(since = "0.1.0", feature = "_deprecated_fn")]
#[deprecated(
    since = "1.0.0"
)] // invalid
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide the <code>note</code> field. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[stable(since = "0.1.0", feature = "_deprecated_fn")]
#[deprecated(
    since = "1.0.0",
    note = "explanation for deprecation"
)] // ok!
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0544"><a class="header" href="#error-code-e0544">Error code E0544</a></h1>
<p>Multiple stability attributes were declared on the same item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0544"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "rust1")]

<span class="boring">fn main() {
</span>#[stable(feature = "rust1", since = "1.0.0")]
#[stable(feature = "test", since = "2.0.0")] // invalid
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, ensure that each item has at most one stability attribute.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "rust1")]

<span class="boring">fn main() {
</span>#[stable(feature = "test", since = "2.0.0")] // ok!
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0545"><a class="header" href="#error-code-e0545">Error code E0545</a></h1>
<p>The <code>issue</code> value is incorrect in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0545"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[unstable(feature = "_unstable_fn", issue = "0")] // invalid
fn _unstable_fn() {}

#[rustc_const_unstable(feature = "_unstable_const_fn", issue = "0")] // invalid
const fn _unstable_const_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide a correct value in the <code>issue</code> field.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[unstable(feature = "_unstable_fn", issue = "none")] // ok!
fn _unstable_fn() {}

#[rustc_const_unstable(feature = "_unstable_const_fn", issue = "1")] // ok!
const fn _unstable_const_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0546"><a class="header" href="#error-code-e0546">Error code E0546</a></h1>
<p>The <code>feature</code> value is missing in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0546"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[unstable(issue = "none")] // invalid
fn unstable_fn() {}

#[stable(since = "1.0.0")] // invalid
fn stable_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide the <code>feature</code> field. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[unstable(feature = "unstable_fn", issue = "none")] // ok!
fn unstable_fn() {}

#[stable(feature = "stable_fn", since = "1.0.0")] // ok!
fn stable_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0547"><a class="header" href="#error-code-e0547">Error code E0547</a></h1>
<p>The <code>issue</code> value is missing in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0547"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[unstable(feature = "_unstable_fn")] // invalid
fn _unstable_fn() {}

#[rustc_const_unstable(feature = "_unstable_const_fn")] // invalid
const fn _unstable_const_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide the <code>issue</code> field. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[unstable(feature = "_unstable_fn", issue = "none")] // ok!
fn _unstable_fn() {}

#[rustc_const_unstable(
    feature = "_unstable_const_fn",
    issue = "none"
)] // ok!
const fn _unstable_const_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0549"><a class="header" href="#error-code-e0549">Error code E0549</a></h1>
<p>A <code>deprecated</code> attribute wasn't paired with a <code>stable</code>/<code>unstable</code> attribute with
<code>#![feature(staged_api)]</code> enabled.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0549"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[deprecated(
    since = "1.0.1",
    note = "explanation for deprecation"
)] // invalid
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to add also an attribute <code>stable</code> or <code>unstable</code>.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![allow(internal_features)]
#![stable(since = "1.0.0", feature = "test")]

<span class="boring">fn main() {
</span>#[stable(since = "1.0.0", feature = "test")]
#[deprecated(
    since = "1.0.1",
    note = "explanation for deprecation"
)] // ok!
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0550"><a class="header" href="#error-code-e0550">Error code E0550</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-65"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-65">Note: this error code is no longer emitted by the compiler</a></h4>
<p>More than one <code>deprecated</code> attribute has been put on an item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(note = "because why not?")]
#[deprecated(note = "right?")] // error!
fn the_banished() {}
<span class="boring">}</span></code></pre></pre>
<p>The <code>deprecated</code> attribute can only be present <strong>once</strong> on an item.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(note = "because why not, right?")]
fn the_banished() {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0551"><a class="header" href="#error-code-e0551">Error code E0551</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-66"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-66">Note: this error code is no longer emitted by the compiler</a></h4>
<p>An invalid meta-item was used inside an attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0539"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(note)] // error!
fn i_am_deprecated() {}
<span class="boring">}</span></code></pre></pre>
<p>Meta items are the key-value pairs inside of an attribute. To fix this issue,
you need to give a value to the <code>note</code> key. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(note = "because")] // ok!
fn i_am_deprecated() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0552"><a class="header" href="#error-code-e0552">Error code E0552</a></h1>
<p>A unrecognized representation attribute was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0552"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(D)] // error: unrecognized representation hint
struct MyStruct {
    my_field: usize
}
<span class="boring">}</span></code></pre></pre>
<p>You can use a <code>repr</code> attribute to tell the compiler how you want a struct or
enum to be laid out in memory.</p>
<p>Make sure you're using one of the supported options:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)] // ok!
struct MyStruct {
    my_field: usize
}
<span class="boring">}</span></code></pre></pre>
<p>For more information about specifying representations, see the <a href="https://doc.rust-lang.org/nomicon/other-reprs.html">"Alternative
Representations" section</a> of the Rustonomicon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0554"><a class="header" href="#error-code-e0554">Error code E0554</a></h1>
<p>Feature attributes are only allowed on the nightly release channel. Stable or
beta compilers will not comply.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (depends on release channel)">#![feature(lang_items)] // error: `#![feature]` may not be used on the
                        //        stable release channel</code></pre>
<p>If you need the feature, make sure to use a nightly release of the compiler
(but be warned that the feature may be removed or altered in the future).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0556"><a class="header" href="#error-code-e0556">Error code E0556</a></h1>
<p>The <code>feature</code> attribute was badly formed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0556"><span class="boring">#![allow(unused)]
</span>#![feature(foo_bar_baz, foo(bar), foo = "baz", foo)] // error!
#![feature] // error!
#![feature = "foo"] // error!
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>feature</code> attribute only accept a "feature flag" and can only be used on
nightly. Example:</p>
<pre><code class="language-rust ignore (only works in nightly)">#![feature(flag)]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0557"><a class="header" href="#error-code-e0557">Error code E0557</a></h1>
<p>A feature attribute named a feature that has been removed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0557"><span class="boring">#![allow(unused)]
</span>#![feature(managed_boxes)] // error: feature has been removed
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>Delete the offending feature attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0559"><a class="header" href="#error-code-e0559">Error code E0559</a></h1>
<p>An unknown field was specified into an enum's structure variant.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0559"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Field {
    Fool { x: u32 },
}

let s = Field::Fool { joke: 0 };
// error: struct variant `Field::Fool` has no field named `joke`
<span class="boring">}</span></code></pre></pre>
<p>Verify you didn't misspell the field's name or that the field exists. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Field {
    Fool { joke: u32 },
}

let s = Field::Fool { joke: 0 }; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0560"><a class="header" href="#error-code-e0560">Error code E0560</a></h1>
<p>An unknown field was specified into a structure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0560"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Simba {
    mother: u32,
}

let s = Simba { mother: 1, father: 0 };
// error: structure `Simba` has no field named `father`
<span class="boring">}</span></code></pre></pre>
<p>Verify you didn't misspell the field's name or that the field exists. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Simba {
    mother: u32,
    father: u32,
}

let s = Simba { mother: 1, father: 0 }; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0561"><a class="header" href="#error-code-e0561">Error code E0561</a></h1>
<p>A non-ident or non-wildcard pattern has been used as a parameter of a function
pointer type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0561"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type A1 = fn(mut param: u8); // error!
type A2 = fn(&amp;param: u32); // error!
<span class="boring">}</span></code></pre></pre>
<p>When using an alias over a function type, you cannot e.g. denote a parameter as
being mutable.</p>
<p>To fix the issue, remove patterns (<code>_</code> is allowed though). Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type A1 = fn(param: u8); // ok!
type A2 = fn(_: u32); // ok!
<span class="boring">}</span></code></pre></pre>
<p>You can also omit the parameter name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type A3 = fn(i16); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0562"><a class="header" href="#error-code-e0562">Error code E0562</a></h1>
<p><code>impl Trait</code> is only allowed as a function return and argument type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0562">fn main() {
    let count_to_ten: impl Iterator&lt;Item=usize&gt; = 0..10;
    // error: `impl Trait` not allowed outside of function and inherent method
    //        return types
    for i in count_to_ten {
        println!("{}", i);
    }
}</code></pre></pre>
<p>Make sure <code>impl Trait</code> appears in a function signature.</p>
<pre><pre class="playground"><code class="language-rust">fn count_to_n(n: usize) -&gt; impl Iterator&lt;Item=usize&gt; {
    0..n
}

fn main() {
    for i in count_to_n(10) {  // ok!
        println!("{}", i);
    }
}</code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/stable/reference/types/impl-trait.html">reference</a> for more details on <code>impl Trait</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0565"><a class="header" href="#error-code-e0565">Error code E0565</a></h1>
<p>A literal was used in a built-in attribute that doesn't support literals.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0565">#[repr("C")] // error: meta item in `repr` must be an identifier
struct Repr {}

fn main() {}</code></pre></pre>
<p>Not all attributes support literals in their input,
and in some cases they expect an identifier instead.
That would be the solution in the case of <code>repr</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)] // ok!
struct Repr {}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0566"><a class="header" href="#error-code-e0566">Error code E0566</a></h1>
<p>Conflicting representation hints have been used on a same item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0566"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u32, u64)]
enum Repr { A }
<span class="boring">}</span></code></pre></pre>
<p>In most cases (if not all), using just one representation hint is more than
enough. If you want to have a representation hint depending on the current
architecture, use <code>cfg_attr</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(linux, repr(u32))]
#[cfg_attr(not(linux), repr(u64))]
enum Repr { A }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0567"><a class="header" href="#error-code-e0567">Error code E0567</a></h1>
<p>Generics have been used on an auto trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0567">#![feature(auto_traits)]

auto trait Generic&lt;T&gt; {} // error!
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Since an auto trait is implemented on all existing types, the
compiler would not be able to infer the types of the trait's generic
parameters.</p>
<p>To fix this issue, just remove the generics:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(auto_traits)]

auto trait Generic {} // ok!
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0568"><a class="header" href="#error-code-e0568">Error code E0568</a></h1>
<p>A super trait has been added to an auto trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0568">#![feature(auto_traits)]

auto trait Bound : Copy {} // error!

fn main() {}</code></pre></pre>
<p>Since an auto trait is implemented on all existing types, adding a super trait
would filter out a lot of those types. In the current example, almost none of
all the existing types could implement <code>Bound</code> because very few of them have the
<code>Copy</code> trait.</p>
<p>To fix this issue, just remove the super trait:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(auto_traits)]

auto trait Bound {} // ok!

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0569"><a class="header" href="#error-code-e0569">Error code E0569</a></h1>
<p>If an impl has a generic parameter with the <code>#[may_dangle]</code> attribute, then
that impl must be declared as an <code>unsafe impl</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0569"><span class="boring">#![allow(unused)]
</span>#![feature(dropck_eyepatch)]

<span class="boring">fn main() {
</span>struct Foo&lt;X&gt;(X);
impl&lt;#[may_dangle] X&gt; Drop for Foo&lt;X&gt; {
    fn drop(&amp;mut self) { }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, we are asserting that the destructor for <code>Foo</code> will not
access any data of type <code>X</code>, and require this assertion to be true for
overall safety in our program. The compiler does not currently attempt to
verify this assertion; therefore we must tag this <code>impl</code> as unsafe.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0570"><a class="header" href="#error-code-e0570">Error code E0570</a></h1>
<p>The requested ABI is unsupported by the current target.</p>
<p>The rust compiler maintains for each target a list of unsupported ABIs on
that target. If an ABI is present in such a list this usually means that the
target / ABI combination is currently unsupported by llvm.</p>
<p>If necessary, you can circumvent this check using custom target specifications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0571"><a class="header" href="#error-code-e0571">Error code E0571</a></h1>
<p>A <code>break</code> statement with an argument appeared in a non-<code>loop</code> loop.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0571"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut i = 1;
</span><span class="boring">fn satisfied(n: usize) -&gt; bool { n % 23 == 0 }
</span>let result = while true {
    if satisfied(i) {
        break 2 * i; // error: `break` with value from a `while` loop
    }
    i += 1;
};
<span class="boring">}</span></code></pre></pre>
<p>The <code>break</code> statement can take an argument (which will be the value of the loop
expression if the <code>break</code> statement is executed) in <code>loop</code> loops, but not
<code>for</code>, <code>while</code>, or <code>while let</code> loops.</p>
<p>Make sure <code>break value;</code> statements only occur in <code>loop</code> loops:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut i = 1;
</span><span class="boring">fn satisfied(n: usize) -&gt; bool { n % 23 == 0 }
</span>let result = loop { // This is now a "loop" loop.
    if satisfied(i) {
        break 2 * i; // ok!
    }
    i += 1;
};
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0572"><a class="header" href="#error-code-e0572">Error code E0572</a></h1>
<p>A return statement was found outside of a function body.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0572">const FOO: u32 = return 0; // error: return statement outside of function body

fn main() {}</code></pre></pre>
<p>To fix this issue, just remove the return keyword or move the expression into a
function. Example:</p>
<pre><pre class="playground"><code class="language-rust">const FOO: u32 = 0;

fn some_fn() -&gt; u32 {
    return FOO;
}

fn main() {
    some_fn();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0573"><a class="header" href="#error-code-e0573">Error code E0573</a></h1>
<p>Something other than a type has been used when one was expected.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0573"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Dragon {
    Born,
}

fn oblivion() -&gt; Dragon::Born { // error!
    Dragon::Born
}

const HOBBIT: u32 = 2;
impl HOBBIT {} // error!

enum Wizard {
    Gandalf,
    Saruman,
}

trait Isengard {
    fn wizard(_: Wizard::Saruman); // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In all these errors, a type was expected. For example, in the first error, if
we want to return the <code>Born</code> variant from the <code>Dragon</code> enum, we must set the
function to return the enum and not its variant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Dragon {
    Born,
}

fn oblivion() -&gt; Dragon { // ok!
    Dragon::Born
}
<span class="boring">}</span></code></pre></pre>
<p>In the second error, you can't implement something on an item, only on types.
We would need to create a new type if we wanted to do something similar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Hobbit(u32); // we create a new type

const HOBBIT: Hobbit = Hobbit(2);
impl Hobbit {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>In the third case, we tried to only expect one variant of the <code>Wizard</code> enum,
which is not possible. To make this work, we need to using pattern matching
over the <code>Wizard</code> enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Wizard {
    Gandalf,
    Saruman,
}

trait Isengard {
    fn wizard(w: Wizard) { // ok!
        match w {
            Wizard::Saruman =&gt; {
                // do something
            }
            _ =&gt; {} // ignore everything else
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0574"><a class="header" href="#error-code-e0574">Error code E0574</a></h1>
<p>Something other than a struct, variant or union has been used when one was
expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0574"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod mordor {}

let sauron = mordor { x: () }; // error!

enum Jak {
    Daxter { i: isize },
}

let eco = Jak::Daxter { i: 1 };
match eco {
    Jak { i } =&gt; {} // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In all these errors, a type was expected. For example, in the first error,
we tried to instantiate the <code>mordor</code> module, which is impossible. If you want
to instantiate a type inside a module, you can do it as follow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod mordor {
    pub struct TheRing {
        pub x: usize,
    }
}

let sauron = mordor::TheRing { x: 1 }; // ok!
<span class="boring">}</span></code></pre></pre>
<p>In the second error, we tried to bind the <code>Jak</code> enum directly, which is not
possible: you can only bind one of its variants. To do so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Jak {
    Daxter { i: isize },
}

let eco = Jak::Daxter { i: 1 };
match eco {
    Jak::Daxter { i } =&gt; {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0575"><a class="header" href="#error-code-e0575">Error code E0575</a></h1>
<p>Something other than a type or an associated type was given.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0575"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Rick { Morty }

let _: &lt;u8 as Rick&gt;::Morty; // error!

trait Age {
    type Empire;
    fn Mythology() {}
}

impl Age for u8 {
    type Empire = u16;
}

let _: &lt;u8 as Age&gt;::Mythology; // error!
<span class="boring">}</span></code></pre></pre>
<p>In both cases, we're declaring a variable (called <code>_</code>) and we're giving it a
type. However, <code>&lt;u8 as Rick&gt;::Morty</code> and <code>&lt;u8 as Age&gt;::Mythology</code> aren't types,
therefore the compiler throws an error.</p>
<p><code>&lt;u8 as Rick&gt;::Morty</code> is an enum variant, you cannot use a variant as a type,
you have to use the enum directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Rick { Morty }

let _: Rick; // ok!
<span class="boring">}</span></code></pre></pre>
<p><code>&lt;u8 as Age&gt;::Mythology</code> is a trait method, which is definitely not a type.
However, the <code>Age</code> trait provides an associated type <code>Empire</code> which can be
used as a type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Age {
    type Empire;
    fn Mythology() {}
}

impl Age for u8 {
    type Empire = u16;
}

let _: &lt;u8 as Age&gt;::Empire; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0576"><a class="header" href="#error-code-e0576">Error code E0576</a></h1>
<p>An associated item wasn't found in the given type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0576"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Hello {
    type Who;

    fn hello() -&gt; &lt;Self as Hello&gt;::You; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, we tried to use the nonexistent associated type <code>You</code> of the
<code>Hello</code> trait. To fix this error, use an existing associated type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Hello {
    type Who;

    fn hello() -&gt; &lt;Self as Hello&gt;::Who; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0577"><a class="header" href="#error-code-e0577">Error code E0577</a></h1>
<p>Something other than a module was found in visibility scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0577 edition2018">pub enum Sea {}

pub (in crate::Sea) struct Shark; // error!

fn main() {}</code></pre></pre>
<p><code>Sea</code> is not a module, therefore it is invalid to use it in a visibility path.
To fix this error we need to ensure <code>sea</code> is a module.</p>
<p>Please note that the visibility scope can only be applied on ancestors!</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub mod sea {
    pub (in crate::sea) struct Shark; // ok!
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0578"><a class="header" href="#error-code-e0578">Error code E0578</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-67"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-67">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A module cannot be found and therefore, the visibility cannot be determined.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">foo!();

pub (in ::Sea) struct Shark; // error!

fn main() {}</code></pre>
<p>Because of the call to the <code>foo</code> macro, the compiler guesses that the missing
module could be inside it and fails because the macro definition cannot be
found.</p>
<p>To fix this error, please be sure that the module is in scope:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub mod Sea {
    pub (in crate::Sea) struct Shark;
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0579"><a class="header" href="#error-code-e0579">Error code E0579</a></h1>
<p>A lower range wasn't less than the upper range.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0579">
fn main() {
    match 5u32 {
        // This range is ok, albeit pointless.
        1..2 =&gt; {}
        // This range is empty, and the compiler can tell.
        5..5 =&gt; {} // error!
    }
}</code></pre></pre>
<p>When matching against an exclusive range, the compiler verifies that the range
is non-empty. Exclusive range patterns include the start point but not the end
point, so this is equivalent to requiring the start of the range to be less
than the end of the range.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0580"><a class="header" href="#error-code-e0580">Error code E0580</a></h1>
<p>The <code>main</code> function was incorrectly declared.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0580">fn main(x: i32) { // error: main function has wrong type
    println!("{}", x);
}</code></pre></pre>
<p>The <code>main</code> function prototype should never take arguments.
Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // your code
}</code></pre></pre>
<p>If you want to get command-line arguments, use <code>std::env::args</code>. To exit with a
specified exit code, use <code>std::process::exit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0581"><a class="header" href="#error-code-e0581">Error code E0581</a></h1>
<p>In a <code>fn</code> type, a lifetime appears only in the return type
and not in the arguments types.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0581">fn main() {
    // Here, `'a` appears only in the return type:
    let x: for&lt;'a&gt; fn() -&gt; &amp;'a i32;
}</code></pre></pre>
<p>The problem here is that the lifetime isn't constrained by any of the arguments,
making it impossible to determine how long it's supposed to live.</p>
<p>To fix this issue, either use the lifetime in the arguments, or use the
<code>'static</code> lifetime. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Here, `'a` appears only in the return type:
    let x: for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32;
    let y: fn() -&gt; &amp;'static i32;
}</code></pre></pre>
<p>Note: The examples above used to be (erroneously) accepted by the
compiler, but this was since corrected. See <a href="https://github.com/rust-lang/rust/issues/33685">issue #33685</a> for more
details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0582"><a class="header" href="#error-code-e0582">Error code E0582</a></h1>
<p>A lifetime is only present in an associated-type binding, and not in the input
types to the trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0582">fn bar&lt;F&gt;(t: F)
    // No type can satisfy this requirement, since `'a` does not
    // appear in any of the input types (here, `i32`):
    where F: for&lt;'a&gt; Fn(i32) -&gt; Option&lt;&amp;'a i32&gt;
{
}

fn main() { }</code></pre></pre>
<p>To fix this issue, either use the lifetime in the inputs, or use
<code>'static</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn bar&lt;F, G&gt;(t: F, u: G)
    where F: for&lt;'a&gt; Fn(&amp;'a i32) -&gt; Option&lt;&amp;'a i32&gt;,
          G: Fn(i32) -&gt; Option&lt;&amp;'static i32&gt;,
{
}

fn main() { }</code></pre></pre>
<p>This error also includes the use of associated types with lifetime parameters.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0582"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Assoc&lt;'a&gt;;
}

struct Bar&lt;X, F&gt;
where
    X: Foo,
    F: for&lt;'a&gt; Fn(X::Assoc&lt;'a&gt;) -&gt; &amp;'a i32
{
    x: X,
    f: F
}
<span class="boring">}</span></code></pre></pre>
<p>The latter scenario encounters this error because <code>Foo::Assoc&lt;'a&gt;</code> could be
implemented by a type that does not use the <code>'a</code> parameter, so there is no
guarantee that <code>X::Assoc&lt;'a&gt;</code> actually uses <code>'a</code>.</p>
<p>To fix this we can pass a dummy parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Foo {
</span><span class="boring">    type Assoc&lt;'a&gt;;
</span><span class="boring">}
</span>struct Bar&lt;X, F&gt;
where
    X: Foo,
    F: for&lt;'a&gt; Fn(X::Assoc&lt;'a&gt;, /* dummy */ &amp;'a ()) -&gt; &amp;'a i32
{
    x: X,
    f: F
}
<span class="boring">}</span></code></pre></pre>
<p>Note: The examples above used to be 