window.search = Object.assign(window.search, JSON.parse('{"doc_urls":["what-is-rustc.html#what-is-rustc","what-is-rustc.html#basic-usage","command-line-arguments.html#command-line-arguments","command-line-arguments.html#-h--help-get-help","command-line-arguments.html#--cfg-configure-the-compilation-environment","command-line-arguments.html#--check-cfg-configure-compile-time-checking-of-conditional-compilation","command-line-arguments.html#-l-add-a-directory-to-the-library-search-path","command-line-arguments.html#-l-link-the-generated-crate-to-a-native-library","command-line-arguments.html#linking-modifiers-whole-archive","command-line-arguments.html#linking-modifiers-bundle","command-line-arguments.html#linking-modifiers-verbatim","command-line-arguments.html#--crate-type-a-list-of-types-of-crates-for-the-compiler-to-emit","command-line-arguments.html#--crate-name-specify-the-name-of-the-crate-being-built","command-line-arguments.html#--edition-specify-the-edition-to-use","command-line-arguments.html#--emit-specifies-the-types-of-output-files-to-generate","command-line-arguments.html#custom-paths-for-individual-emit-kinds","command-line-arguments.html#emitting-to-stdout","command-line-arguments.html#--print-print-compiler-information","command-line-arguments.html#-g-include-debug-information","command-line-arguments.html#-o-optimize-your-code","command-line-arguments.html#-o-filename-of-the-output","command-line-arguments.html#--out-dir-directory-to-write-the-output-in","command-line-arguments.html#--explain-provide-a-detailed-explanation-of-an-error-message","command-line-arguments.html#--test-build-a-test-harness","command-line-arguments.html#--target-select-a-target-triple-to-build","command-line-arguments.html#-w-set-lint-warnings","command-line-arguments.html#--force-warn-force-a-lint-to-warn","command-line-arguments.html#-a-set-lint-allowed","command-line-arguments.html#-d-set-lint-denied","command-line-arguments.html#-f-set-lint-forbidden","command-line-arguments.html#-z-set-unstable-options","command-line-arguments.html#--cap-lints-set-the-most-restrictive-lint-level","command-line-arguments.html#-c--codegen-code-generation-options","command-line-arguments.html#-v--version-print-a-version","command-line-arguments.html#-v--verbose-use-verbose-output","command-line-arguments.html#--extern-specify-where-an-external-library-is-located","command-line-arguments.html#--sysroot-override-the-system-root","command-line-arguments.html#--error-format-control-how-errors-are-produced","command-line-arguments.html#--color-configure-coloring-of-output","command-line-arguments.html#--diagnostic-width-specify-the-terminal-width-for-diagnostics","command-line-arguments.html#--remap-path-prefix-remap-source-paths-in-output","command-line-arguments.html#--json-configure-json-messages-printed-by-the-compiler","command-line-arguments.html#path-load-command-line-flags-from-a-path","command-line-arguments/print-options.html#print-options","command-line-arguments/print-options.html#crate-name","command-line-arguments/print-options.html#file-names","command-line-arguments/print-options.html#sysroot","command-line-arguments/print-options.html#target-libdir","command-line-arguments/print-options.html#host-tuple","command-line-arguments/print-options.html#cfg","command-line-arguments/print-options.html#target-list","command-line-arguments/print-options.html#target-cpus","command-line-arguments/print-options.html#target-features","command-line-arguments/print-options.html#relocation-models","command-line-arguments/print-options.html#code-models","command-line-arguments/print-options.html#tls-models","command-line-arguments/print-options.html#native-static-libs","command-line-arguments/print-options.html#link-args","command-line-arguments/print-options.html#deployment-target","codegen-options/index.html#codegen-options","codegen-options/index.html#ar","codegen-options/index.html#code-model","codegen-options/index.html#codegen-units","codegen-options/index.html#collapse-macro-debuginfo","codegen-options/index.html#control-flow-guard","codegen-options/index.html#debug-assertions","codegen-options/index.html#debuginfo","codegen-options/index.html#default-linker-libraries","codegen-options/index.html#dlltool","codegen-options/index.html#dwarf-version","codegen-options/index.html#embed-bitcode","codegen-options/index.html#extra-filename","codegen-options/index.html#force-frame-pointers","codegen-options/index.html#force-unwind-tables","codegen-options/index.html#incremental","codegen-options/index.html#inline-threshold","codegen-options/index.html#instrument-coverage","codegen-options/index.html#link-arg","codegen-options/index.html#link-args","codegen-options/index.html#link-dead-code","codegen-options/index.html#link-self-contained","codegen-options/index.html#linker","codegen-options/index.html#linker-features","codegen-options/index.html#linker-flavor","codegen-options/index.html#linker-plugin-lto","codegen-options/index.html#llvm-args","codegen-options/index.html#lto","codegen-options/index.html#metadata","codegen-options/index.html#no-prepopulate-passes","codegen-options/index.html#no-redzone","codegen-options/index.html#no-stack-check","codegen-options/index.html#no-vectorize-loops","codegen-options/index.html#no-vectorize-slp","codegen-options/index.html#opt-level","codegen-options/index.html#overflow-checks","codegen-options/index.html#panic","codegen-options/index.html#passes","codegen-options/index.html#prefer-dynamic","codegen-options/index.html#profile-generate","codegen-options/index.html#profile-use","codegen-options/index.html#relocation-model","codegen-options/index.html#relro-level","codegen-options/index.html#remark","codegen-options/index.html#rpath","codegen-options/index.html#save-temps","codegen-options/index.html#soft-float","codegen-options/index.html#split-debuginfo","codegen-options/index.html#strip","codegen-options/index.html#symbol-mangling-version","codegen-options/index.html#target-cpu","codegen-options/index.html#target-feature","codegen-options/index.html#tune-cpu","jobserver.html#jobserver","jobserver.html#integration-with-build-systems","jobserver.html#gnu-make","jobserver.html#cmake","lints/index.html#lints","lints/index.html#future-incompatible-lints","lints/levels.html#lint-levels","lints/levels.html#allow","lints/levels.html#expect","lints/levels.html#warn","lints/levels.html#force-warn","lints/levels.html#deny","lints/levels.html#forbid","lints/levels.html#configuring-warning-levels","lints/levels.html#via-compiler-flag","lints/levels.html#via-an-attribute","lints/levels.html#capping-lints","lints/levels.html#priority-of-lint-level-sources","lints/groups.html#lint-groups","lints/listing/index.html#lint-listing","lints/listing/allowed-by-default.html#allowed-by-default-lints","lints/listing/allowed-by-default.html#absolute-paths-not-starting-with-crate","lints/listing/allowed-by-default.html#example","lints/listing/allowed-by-default.html#explanation","lints/listing/allowed-by-default.html#ambiguous-negative-literals","lints/listing/allowed-by-default.html#example-1","lints/listing/allowed-by-default.html#explanation-1","lints/listing/allowed-by-default.html#async-idents","lints/listing/allowed-by-default.html#closure-returning-async-block","lints/listing/allowed-by-default.html#example-2","lints/listing/allowed-by-default.html#explanation-2","lints/listing/allowed-by-default.html#deprecated-safe-2024","lints/listing/allowed-by-default.html#example-3","lints/listing/allowed-by-default.html#explanation-3","lints/listing/allowed-by-default.html#deref-into-dyn-supertrait","lints/listing/allowed-by-default.html#example-4","lints/listing/allowed-by-default.html#explanation-4","lints/listing/allowed-by-default.html#disjoint-capture-migration","lints/listing/allowed-by-default.html#edition-2024-expr-fragment-specifier","lints/listing/allowed-by-default.html#example-5","lints/listing/allowed-by-default.html#explanation-5","lints/listing/allowed-by-default.html#elided-lifetime-in-path","lints/listing/allowed-by-default.html#elided-lifetimes-in-paths","lints/listing/allowed-by-default.html#example-6","lints/listing/allowed-by-default.html#explanation-6","lints/listing/allowed-by-default.html#explicit-outlives-requirements","lints/listing/allowed-by-default.html#example-7","lints/listing/allowed-by-default.html#explanation-7","lints/listing/allowed-by-default.html#ffi-unwind-calls","lints/listing/allowed-by-default.html#example-8","lints/listing/allowed-by-default.html#explanation-8","lints/listing/allowed-by-default.html#fuzzy-provenance-casts","lints/listing/allowed-by-default.html#example-9","lints/listing/allowed-by-default.html#explanation-9","lints/listing/allowed-by-default.html#if-let-rescope","lints/listing/allowed-by-default.html#example-10","lints/listing/allowed-by-default.html#explanation-10","lints/listing/allowed-by-default.html#impl-trait-overcaptures","lints/listing/allowed-by-default.html#example-11","lints/listing/allowed-by-default.html#explanation-11","lints/listing/allowed-by-default.html#impl-trait-redundant-captures","lints/listing/allowed-by-default.html#example-12","lints/listing/allowed-by-default.html#explanation-12","lints/listing/allowed-by-default.html#keyword-idents","lints/listing/allowed-by-default.html#keyword-idents-2018","lints/listing/allowed-by-default.html#example-13","lints/listing/allowed-by-default.html#explanation-13","lints/listing/allowed-by-default.html#keyword-idents-2024","lints/listing/allowed-by-default.html#example-14","lints/listing/allowed-by-default.html#explanation-14","lints/listing/allowed-by-default.html#let-underscore-drop","lints/listing/allowed-by-default.html#example-15","lints/listing/allowed-by-default.html#explanation-15","lints/listing/allowed-by-default.html#linker-messages","lints/listing/allowed-by-default.html#example-16","lints/listing/allowed-by-default.html#explanation-16","lints/listing/allowed-by-default.html#lossy-provenance-casts","lints/listing/allowed-by-default.html#example-17","lints/listing/allowed-by-default.html#explanation-17","lints/listing/allowed-by-default.html#macro-use-extern-crate","lints/listing/allowed-by-default.html#example-18","lints/listing/allowed-by-default.html#explanation-18","lints/listing/allowed-by-default.html#meta-variable-misuse","lints/listing/allowed-by-default.html#example-19","lints/listing/allowed-by-default.html#explanation-19","lints/listing/allowed-by-default.html#missing-copy-implementations","lints/listing/allowed-by-default.html#example-20","lints/listing/allowed-by-default.html#explanation-20","lints/listing/allowed-by-default.html#missing-debug-implementations","lints/listing/allowed-by-default.html#example-21","lints/listing/allowed-by-default.html#explanation-21","lints/listing/allowed-by-default.html#missing-docs","lints/listing/allowed-by-default.html#example-22","lints/listing/allowed-by-default.html#explanation-22","lints/listing/allowed-by-default.html#missing-unsafe-on-extern","lints/listing/allowed-by-default.html#example-23","lints/listing/allowed-by-default.html#explanation-23","lints/listing/allowed-by-default.html#multiple-supertrait-upcastable","lints/listing/allowed-by-default.html#example-24","lints/listing/allowed-by-default.html#explanation-24","lints/listing/allowed-by-default.html#must-not-suspend","lints/listing/allowed-by-default.html#example-25","lints/listing/allowed-by-default.html#explanation-25","lints/listing/allowed-by-default.html#non-ascii-idents","lints/listing/allowed-by-default.html#example-26","lints/listing/allowed-by-default.html#explanation-26","lints/listing/allowed-by-default.html#non-exhaustive-omitted-patterns","lints/listing/allowed-by-default.html#example-27","lints/listing/allowed-by-default.html#explanation-27","lints/listing/allowed-by-default.html#or-patterns-back-compat","lints/listing/allowed-by-default.html#redundant-imports","lints/listing/allowed-by-default.html#example-28","lints/listing/allowed-by-default.html#explanation-28","lints/listing/allowed-by-default.html#redundant-lifetimes","lints/listing/allowed-by-default.html#example-29","lints/listing/allowed-by-default.html#explanation-29","lints/listing/allowed-by-default.html#rust-2021-incompatible-closure-captures","lints/listing/allowed-by-default.html#example-of-drop-reorder","lints/listing/allowed-by-default.html#explanation-30","lints/listing/allowed-by-default.html#example-of-auto-trait","lints/listing/allowed-by-default.html#explanation-31","lints/listing/allowed-by-default.html#rust-2021-incompatible-or-patterns","lints/listing/allowed-by-default.html#example-30","lints/listing/allowed-by-default.html#explanation-32","lints/listing/allowed-by-default.html#rust-2021-prefixes-incompatible-syntax","lints/listing/allowed-by-default.html#example-31","lints/listing/allowed-by-default.html#explanation-33","lints/listing/allowed-by-default.html#rust-2021-prelude-collisions","lints/listing/allowed-by-default.html#example-32","lints/listing/allowed-by-default.html#explanation-34","lints/listing/allowed-by-default.html#rust-2024-guarded-string-incompatible-syntax","lints/listing/allowed-by-default.html#example-33","lints/listing/allowed-by-default.html#explanation-35","lints/listing/allowed-by-default.html#rust-2024-incompatible-pat","lints/listing/allowed-by-default.html#example-34","lints/listing/allowed-by-default.html#explanation-36","lints/listing/allowed-by-default.html#rust-2024-prelude-collisions","lints/listing/allowed-by-default.html#example-35","lints/listing/allowed-by-default.html#explanation-37","lints/listing/allowed-by-default.html#single-use-lifetime","lints/listing/allowed-by-default.html#single-use-lifetimes","lints/listing/allowed-by-default.html#example-36","lints/listing/allowed-by-default.html#explanation-38","lints/listing/allowed-by-default.html#supertrait-item-shadowing-definition","lints/listing/allowed-by-default.html#example-37","lints/listing/allowed-by-default.html#explanation-39","lints/listing/allowed-by-default.html#supertrait-item-shadowing-usage","lints/listing/allowed-by-default.html#example-38","lints/listing/allowed-by-default.html#explanation-40","lints/listing/allowed-by-default.html#tail-expr-drop-order","lints/listing/allowed-by-default.html#example-39","lints/listing/allowed-by-default.html#explanation-41","lints/listing/allowed-by-default.html#trivial-casts","lints/listing/allowed-by-default.html#example-40","lints/listing/allowed-by-default.html#explanation-42","lints/listing/allowed-by-default.html#trivial-numeric-casts","lints/listing/allowed-by-default.html#example-41","lints/listing/allowed-by-default.html#explanation-43","lints/listing/allowed-by-default.html#unit-bindings","lints/listing/allowed-by-default.html#example-42","lints/listing/allowed-by-default.html#explanation-44","lints/listing/allowed-by-default.html#unnameable-types","lints/listing/allowed-by-default.html#example-43","lints/listing/allowed-by-default.html#explanation-45","lints/listing/allowed-by-default.html#unqualified-local-imports","lints/listing/allowed-by-default.html#example-44","lints/listing/allowed-by-default.html#explanation-46","lints/listing/allowed-by-default.html#unreachable-pub","lints/listing/allowed-by-default.html#example-45","lints/listing/allowed-by-default.html#explanation-47","lints/listing/allowed-by-default.html#unsafe-attr-outside-unsafe","lints/listing/allowed-by-default.html#example-46","lints/listing/allowed-by-default.html#explanation-48","lints/listing/allowed-by-default.html#unsafe-code","lints/listing/allowed-by-default.html#example-47","lints/listing/allowed-by-default.html#explanation-49","lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn","lints/listing/allowed-by-default.html#example-48","lints/listing/allowed-by-default.html#explanation-50","lints/listing/allowed-by-default.html#unstable-features","lints/listing/allowed-by-default.html#example-49","lints/listing/allowed-by-default.html#explanation-51","lints/listing/allowed-by-default.html#unused-crate-dependencies","lints/listing/allowed-by-default.html#example-50","lints/listing/allowed-by-default.html#explanation-52","lints/listing/allowed-by-default.html#unused-extern-crates","lints/listing/allowed-by-default.html#example-51","lints/listing/allowed-by-default.html#explanation-53","lints/listing/allowed-by-default.html#unused-import-braces","lints/listing/allowed-by-default.html#example-52","lints/listing/allowed-by-default.html#explanation-54","lints/listing/allowed-by-default.html#unused-lifetimes","lints/listing/allowed-by-default.html#example-53","lints/listing/allowed-by-default.html#explanation-55","lints/listing/allowed-by-default.html#unused-macro-rules","lints/listing/allowed-by-default.html#example-54","lints/listing/allowed-by-default.html#explanation-56","lints/listing/allowed-by-default.html#unused-qualifications","lints/listing/allowed-by-default.html#example-55","lints/listing/allowed-by-default.html#explanation-57","lints/listing/allowed-by-default.html#unused-results","lints/listing/allowed-by-default.html#example-56","lints/listing/allowed-by-default.html#explanation-58","lints/listing/allowed-by-default.html#variant-size-differences","lints/listing/allowed-by-default.html#example-57","lints/listing/allowed-by-default.html#explanation-59","lints/listing/warn-by-default.html#warn-by-default-lints","lints/listing/warn-by-default.html#aarch64-softfloat-neon","lints/listing/warn-by-default.html#example","lints/listing/warn-by-default.html#explanation","lints/listing/warn-by-default.html#ambiguous-glob-reexports","lints/listing/warn-by-default.html#example-1","lints/listing/warn-by-default.html#explanation-1","lints/listing/warn-by-default.html#ambiguous-wide-pointer-comparisons","lints/listing/warn-by-default.html#example-2","lints/listing/warn-by-default.html#explanation-2","lints/listing/warn-by-default.html#anonymous-parameters","lints/listing/warn-by-default.html#example-3","lints/listing/warn-by-default.html#explanation-3","lints/listing/warn-by-default.html#array-into-iter","lints/listing/warn-by-default.html#example-4","lints/listing/warn-by-default.html#explanation-4","lints/listing/warn-by-default.html#asm-sub-register","lints/listing/warn-by-default.html#example-5","lints/listing/warn-by-default.html#explanation-5","lints/listing/warn-by-default.html#async-fn-in-trait","lints/listing/warn-by-default.html#example-6","lints/listing/warn-by-default.html#explanation-6","lints/listing/warn-by-default.html#bad-asm-style","lints/listing/warn-by-default.html#example-7","lints/listing/warn-by-default.html#explanation-7","lints/listing/warn-by-default.html#bare-trait-object","lints/listing/warn-by-default.html#bare-trait-objects","lints/listing/warn-by-default.html#example-8","lints/listing/warn-by-default.html#explanation-8","lints/listing/warn-by-default.html#boxed-slice-into-iter","lints/listing/warn-by-default.html#example-9","lints/listing/warn-by-default.html#explanation-9","lints/listing/warn-by-default.html#break-with-label-and-loop","lints/listing/warn-by-default.html#example-10","lints/listing/warn-by-default.html#explanation-10","lints/listing/warn-by-default.html#clashing-extern-declarations","lints/listing/warn-by-default.html#example-11","lints/listing/warn-by-default.html#explanation-11","lints/listing/warn-by-default.html#coherence-leak-check","lints/listing/warn-by-default.html#example-12","lints/listing/warn-by-default.html#explanation-12","lints/listing/warn-by-default.html#confusable-idents","lints/listing/warn-by-default.html#example-13","lints/listing/warn-by-default.html#explanation-13","lints/listing/warn-by-default.html#const-evaluatable-unchecked","lints/listing/warn-by-default.html#example-14","lints/listing/warn-by-default.html#explanation-14","lints/listing/warn-by-default.html#const-item-mutation","lints/listing/warn-by-default.html#example-15","lints/listing/warn-by-default.html#explanation-15","lints/listing/warn-by-default.html#dangling-pointers-from-locals","lints/listing/warn-by-default.html#example-16","lints/listing/warn-by-default.html#explanation-16","lints/listing/warn-by-default.html#dangling-pointers-from-temporaries","lints/listing/warn-by-default.html#example-17","lints/listing/warn-by-default.html#explanation-17","lints/listing/warn-by-default.html#dead-code","lints/listing/warn-by-default.html#example-18","lints/listing/warn-by-default.html#explanation-18","lints/listing/warn-by-default.html#limitations","lints/listing/warn-by-default.html#deprecated","lints/listing/warn-by-default.html#example-19","lints/listing/warn-by-default.html#explanation-19","lints/listing/warn-by-default.html#deprecated-where-clause-location","lints/listing/warn-by-default.html#example-20","lints/listing/warn-by-default.html#explanation-20","lints/listing/warn-by-default.html#deref-nullptr","lints/listing/warn-by-default.html#example-21","lints/listing/warn-by-default.html#explanation-21","lints/listing/warn-by-default.html#double-negations","lints/listing/warn-by-default.html#example-22","lints/listing/warn-by-default.html#explanation-22","lints/listing/warn-by-default.html#drop-bounds","lints/listing/warn-by-default.html#example-23","lints/listing/warn-by-default.html#explanation-23","lints/listing/warn-by-default.html#dropping-copy-types","lints/listing/warn-by-default.html#example-24","lints/listing/warn-by-default.html#explanation-24","lints/listing/warn-by-default.html#dropping-references","lints/listing/warn-by-default.html#example-25","lints/listing/warn-by-default.html#explanation-25","lints/listing/warn-by-default.html#duplicate-macro-attributes","lints/listing/warn-by-default.html#example-26","lints/listing/warn-by-default.html#explanation-26","lints/listing/warn-by-default.html#dyn-drop","lints/listing/warn-by-default.html#example-27","lints/listing/warn-by-default.html#explanation-27","lints/listing/warn-by-default.html#ellipsis-inclusive-range-patterns","lints/listing/warn-by-default.html#example-28","lints/listing/warn-by-default.html#explanation-28","lints/listing/warn-by-default.html#exported-private-dependencies","lints/listing/warn-by-default.html#example-29","lints/listing/warn-by-default.html#explanation-29","lints/listing/warn-by-default.html#for-loops-over-fallibles","lints/listing/warn-by-default.html#example-30","lints/listing/warn-by-default.html#explanation-30","lints/listing/warn-by-default.html#forbidden-lint-groups","lints/listing/warn-by-default.html#example-31","lints/listing/warn-by-default.html#recommended-fix","lints/listing/warn-by-default.html#explanation-31","lints/listing/warn-by-default.html#forgetting-copy-types","lints/listing/warn-by-default.html#example-32","lints/listing/warn-by-default.html#explanation-32","lints/listing/warn-by-default.html#forgetting-references","lints/listing/warn-by-default.html#example-33","lints/listing/warn-by-default.html#explanation-33","lints/listing/warn-by-default.html#function-item-references","lints/listing/warn-by-default.html#example-34","lints/listing/warn-by-default.html#explanation-34","lints/listing/warn-by-default.html#hidden-glob-reexports","lints/listing/warn-by-default.html#example-35","lints/listing/warn-by-default.html#explanation-35","lints/listing/warn-by-default.html#improper-ctypes","lints/listing/warn-by-default.html#example-36","lints/listing/warn-by-default.html#explanation-36","lints/listing/warn-by-default.html#improper-ctypes-definitions","lints/listing/warn-by-default.html#example-37","lints/listing/warn-by-default.html#explanation-37","lints/listing/warn-by-default.html#incomplete-features","lints/listing/warn-by-default.html#example-38","lints/listing/warn-by-default.html#explanation-38","lints/listing/warn-by-default.html#inline-always-mismatching-target-features","lints/listing/warn-by-default.html#example-39","lints/listing/warn-by-default.html#explanation-39","lints/listing/warn-by-default.html#inline-no-sanitize","lints/listing/warn-by-default.html#example-40","lints/listing/warn-by-default.html#explanation-40","lints/listing/warn-by-default.html#integer-to-ptr-transmutes","lints/listing/warn-by-default.html#example-41","lints/listing/warn-by-default.html#explanation-41","lints/listing/warn-by-default.html#internal-features","lints/listing/warn-by-default.html#example-42","lints/listing/warn-by-default.html#explanation-42","lints/listing/warn-by-default.html#invalid-from-utf8","lints/listing/warn-by-default.html#example-43","lints/listing/warn-by-default.html#explanation-43","lints/listing/warn-by-default.html#invalid-nan-comparisons","lints/listing/warn-by-default.html#example-44","lints/listing/warn-by-default.html#explanation-44","lints/listing/warn-by-default.html#invalid-value","lints/listing/warn-by-default.html#example-45","lints/listing/warn-by-default.html#explanation-45","lints/listing/warn-by-default.html#irrefutable-let-patterns","lints/listing/warn-by-default.html#example-46","lints/listing/warn-by-default.html#explanation-46","lints/listing/warn-by-default.html#large-assignments","lints/listing/warn-by-default.html#example-47","lints/listing/warn-by-default.html#explanation-47","lints/listing/warn-by-default.html#late-bound-lifetime-arguments","lints/listing/warn-by-default.html#example-48","lints/listing/warn-by-default.html#explanation-48","lints/listing/warn-by-default.html#malformed-diagnostic-attributes","lints/listing/warn-by-default.html#example-49","lints/listing/warn-by-default.html#explanation-49","lints/listing/warn-by-default.html#malformed-diagnostic-format-literals","lints/listing/warn-by-default.html#example-50","lints/listing/warn-by-default.html#explanation-50","lints/listing/warn-by-default.html#map-unit-fn","lints/listing/warn-by-default.html#example-51","lints/listing/warn-by-default.html#explanation-51","lints/listing/warn-by-default.html#mismatched-lifetime-syntaxes","lints/listing/warn-by-default.html#example-52","lints/listing/warn-by-default.html#explanation-52","lints/listing/warn-by-default.html#misplaced-diagnostic-attributes","lints/listing/warn-by-default.html#example-53","lints/listing/warn-by-default.html#explanation-53","lints/listing/warn-by-default.html#missing-abi","lints/listing/warn-by-default.html#example-54","lints/listing/warn-by-default.html#explanation-54","lints/listing/warn-by-default.html#mixed-script-confusables","lints/listing/warn-by-default.html#example-55","lints/listing/warn-by-default.html#explanation-55","lints/listing/warn-by-default.html#named-arguments-used-positionally","lints/listing/warn-by-default.html#example-56","lints/listing/warn-by-default.html#explanation-56","lints/listing/warn-by-default.html#no-mangle-generic-items","lints/listing/warn-by-default.html#example-57","lints/listing/warn-by-default.html#explanation-57","lints/listing/warn-by-default.html#non-fmt-panic","lints/listing/warn-by-default.html#non-camel-case-types","lints/listing/warn-by-default.html#example-58","lints/listing/warn-by-default.html#explanation-58","lints/listing/warn-by-default.html#non-contiguous-range-endpoints","lints/listing/warn-by-default.html#example-59","lints/listing/warn-by-default.html#explanation-59","lints/listing/warn-by-default.html#non-fmt-panics","lints/listing/warn-by-default.html#example-60","lints/listing/warn-by-default.html#explanation-60","lints/listing/warn-by-default.html#non-local-definitions","lints/listing/warn-by-default.html#example-61","lints/listing/warn-by-default.html#explanation-61","lints/listing/warn-by-default.html#non-shorthand-field-patterns","lints/listing/warn-by-default.html#example-62","lints/listing/warn-by-default.html#explanation-62","lints/listing/warn-by-default.html#non-snake-case","lints/listing/warn-by-default.html#example-63","lints/listing/warn-by-default.html#explanation-63","lints/listing/warn-by-default.html#non-upper-case-globals","lints/listing/warn-by-default.html#example-64","lints/listing/warn-by-default.html#explanation-64","lints/listing/warn-by-default.html#noop-method-call","lints/listing/warn-by-default.html#example-65","lints/listing/warn-by-default.html#explanation-65","lints/listing/warn-by-default.html#opaque-hidden-inferred-bound","lints/listing/warn-by-default.html#explanation-66","lints/listing/warn-by-default.html#example-66","lints/listing/warn-by-default.html#overlapping-patterns","lints/listing/warn-by-default.html#overlapping-range-endpoints","lints/listing/warn-by-default.html#example-67","lints/listing/warn-by-default.html#explanation-67","lints/listing/warn-by-default.html#path-statements","lints/listing/warn-by-default.html#example-68","lints/listing/warn-by-default.html#explanation-68","lints/listing/warn-by-default.html#private-bounds","lints/listing/warn-by-default.html#example-69","lints/listing/warn-by-default.html#explanation-69","lints/listing/warn-by-default.html#private-interfaces","lints/listing/warn-by-default.html#example-70","lints/listing/warn-by-default.html#explanation-70","lints/listing/warn-by-default.html#ptr-to-integer-transmute-in-consts","lints/listing/warn-by-default.html#example-71","lints/listing/warn-by-default.html#explanation-71","lints/listing/warn-by-default.html#redundant-semicolon","lints/listing/warn-by-default.html#redundant-semicolons","lints/listing/warn-by-default.html#example-72","lints/listing/warn-by-default.html#explanation-72","lints/listing/warn-by-default.html#refining-impl-trait-internal","lints/listing/warn-by-default.html#example-73","lints/listing/warn-by-default.html#explanation-73","lints/listing/warn-by-default.html#refining-impl-trait-reachable","lints/listing/warn-by-default.html#example-74","lints/listing/warn-by-default.html#explanation-74","lints/listing/warn-by-default.html#renamed-and-removed-lints","lints/listing/warn-by-default.html#example-75","lints/listing/warn-by-default.html#explanation-75","lints/listing/warn-by-default.html#repr-transparent-external-private-fields","lints/listing/warn-by-default.html#example-76","lints/listing/warn-by-default.html#explanation-76","lints/listing/warn-by-default.html#self-constructor-from-outer-item","lints/listing/warn-by-default.html#example-77","lints/listing/warn-by-default.html#explanation-77","lints/listing/warn-by-default.html#special-module-name","lints/listing/warn-by-default.html#example-78","lints/listing/warn-by-default.html#explanation-78","lints/listing/warn-by-default.html#stable-features","lints/listing/warn-by-default.html#example-79","lints/listing/warn-by-default.html#explanation-79","lints/listing/warn-by-default.html#static-mut-ref","lints/listing/warn-by-default.html#static-mut-refs","lints/listing/warn-by-default.html#example-80","lints/listing/warn-by-default.html#explanation-80","lints/listing/warn-by-default.html#suspicious-double-ref-op","lints/listing/warn-by-default.html#example-81","lints/listing/warn-by-default.html#explanation-81","lints/listing/warn-by-default.html#tail-call-track-caller","lints/listing/warn-by-default.html#example-82","lints/listing/warn-by-default.html#explanation-82","lints/listing/warn-by-default.html#trivial-bounds","lints/listing/warn-by-default.html#example-83","lints/listing/warn-by-default.html#explanation-83","lints/listing/warn-by-default.html#type-alias-bounds","lints/listing/warn-by-default.html#example-84","lints/listing/warn-by-default.html#explanation-84","lints/listing/warn-by-default.html#tyvar-behind-raw-pointer","lints/listing/warn-by-default.html#example-85","lints/listing/warn-by-default.html#explanation-85","lints/listing/warn-by-default.html#uncommon-codepoints","lints/listing/warn-by-default.html#example-86","lints/listing/warn-by-default.html#explanation-86","lints/listing/warn-by-default.html#unconditional-recursion","lints/listing/warn-by-default.html#example-87","lints/listing/warn-by-default.html#explanation-87","lints/listing/warn-by-default.html#uncovered-param-in-projection","lints/listing/warn-by-default.html#example-88","lints/listing/warn-by-default.html#explanation-88","lints/listing/warn-by-default.html#unexpected-cfgs","lints/listing/warn-by-default.html#example-89","lints/listing/warn-by-default.html#explanation-89","lints/listing/warn-by-default.html#unfulfilled-lint-expectations","lints/listing/warn-by-default.html#example-90","lints/listing/warn-by-default.html#explanation-90","lints/listing/warn-by-default.html#ungated-async-fn-track-caller","lints/listing/warn-by-default.html#example-91","lints/listing/warn-by-default.html#explanation-91","lints/listing/warn-by-default.html#uninhabited-static","lints/listing/warn-by-default.html#example-92","lints/listing/warn-by-default.html#explanation-92","lints/listing/warn-by-default.html#unknown-diagnostic-attributes","lints/listing/warn-by-default.html#example-93","lints/listing/warn-by-default.html#explanation-93","lints/listing/warn-by-default.html#unknown-lints","lints/listing/warn-by-default.html#example-94","lints/listing/warn-by-default.html#explanation-94","lints/listing/warn-by-default.html#unnameable-test-items","lints/listing/warn-by-default.html#example-95","lints/listing/warn-by-default.html#explanation-95","lints/listing/warn-by-default.html#unnecessary-transmutes","lints/listing/warn-by-default.html#example-96","lints/listing/warn-by-default.html#explanation-96","lints/listing/warn-by-default.html#unpredictable-function-pointer-comparisons","lints/listing/warn-by-default.html#example-97","lints/listing/warn-by-default.html#explanation-97","lints/listing/warn-by-default.html#unreachable-code","lints/listing/warn-by-default.html#example-98","lints/listing/warn-by-default.html#explanation-98","lints/listing/warn-by-default.html#unreachable-patterns","lints/listing/warn-by-default.html#example-99","lints/listing/warn-by-default.html#explanation-99","lints/listing/warn-by-default.html#unstable-name-collision","lints/listing/warn-by-default.html#unstable-name-collisions","lints/listing/warn-by-default.html#example-100","lints/listing/warn-by-default.html#explanation-100","lints/listing/warn-by-default.html#unstable-syntax-pre-expansion","lints/listing/warn-by-default.html#example-101","lints/listing/warn-by-default.html#explanation-101","lints/listing/warn-by-default.html#unsupported-calling-conventions","lints/listing/warn-by-default.html#example-102","lints/listing/warn-by-default.html#explanation-102","lints/listing/warn-by-default.html#unsupported-fn-ptr-calling-conventions","lints/listing/warn-by-default.html#example-103","lints/listing/warn-by-default.html#explanation-103","lints/listing/warn-by-default.html#unused-doc-comment","lints/listing/warn-by-default.html#unused-tuple-struct-fields","lints/listing/warn-by-default.html#unused-allocation","lints/listing/warn-by-default.html#example-104","lints/listing/warn-by-default.html#explanation-104","lints/listing/warn-by-default.html#unused-assignments","lints/listing/warn-by-default.html#example-105","lints/listing/warn-by-default.html#explanation-105","lints/listing/warn-by-default.html#unused-associated-type-bounds","lints/listing/warn-by-default.html#example-106","lints/listing/warn-by-default.html#explanation-106","lints/listing/warn-by-default.html#unused-attributes","lints/listing/warn-by-default.html#example-107","lints/listing/warn-by-default.html#explanation-107","lints/listing/warn-by-default.html#unused-braces","lints/listing/warn-by-default.html#example-108","lints/listing/warn-by-default.html#explanation-108","lints/listing/warn-by-default.html#unused-comparisons","lints/listing/warn-by-default.html#example-109","lints/listing/warn-by-default.html#explanation-109","lints/listing/warn-by-default.html#unused-doc-comments","lints/listing/warn-by-default.html#example-110","lints/listing/warn-by-default.html#explanation-110","lints/listing/warn-by-default.html#unused-features","lints/listing/warn-by-default.html#unused-imports","lints/listing/warn-by-default.html#example-111","lints/listing/warn-by-default.html#explanation-111","lints/listing/warn-by-default.html#unused-labels","lints/listing/warn-by-default.html#example-112","lints/listing/warn-by-default.html#explanation-112","lints/listing/warn-by-default.html#unused-macros","lints/listing/warn-by-default.html#example-113","lints/listing/warn-by-default.html#explanation-113","lints/listing/warn-by-default.html#unused-must-use","lints/listing/warn-by-default.html#example-114","lints/listing/warn-by-default.html#explanation-114","lints/listing/warn-by-default.html#unused-mut","lints/listing/warn-by-default.html#example-115","lints/listing/warn-by-default.html#explanation-115","lints/listing/warn-by-default.html#unused-parens","lints/listing/warn-by-default.html#examples","lints/listing/warn-by-default.html#explanation-116","lints/listing/warn-by-default.html#unused-unsafe","lints/listing/warn-by-default.html#example-116","lints/listing/warn-by-default.html#explanation-117","lints/listing/warn-by-default.html#unused-variables","lints/listing/warn-by-default.html#example-117","lints/listing/warn-by-default.html#explanation-118","lints/listing/warn-by-default.html#useless-ptr-null-checks","lints/listing/warn-by-default.html#example-118","lints/listing/warn-by-default.html#explanation-119","lints/listing/warn-by-default.html#uses-power-alignment","lints/listing/warn-by-default.html#example-119","lints/listing/warn-by-default.html#explanation-120","lints/listing/warn-by-default.html#warnings","lints/listing/warn-by-default.html#example-120","lints/listing/warn-by-default.html#explanation-121","lints/listing/warn-by-default.html#while-true","lints/listing/warn-by-default.html#example-121","lints/listing/warn-by-default.html#explanation-122","lints/listing/deny-by-default.html#deny-by-default-lints","lints/listing/deny-by-default.html#ambiguous-associated-items","lints/listing/deny-by-default.html#example","lints/listing/deny-by-default.html#explanation","lints/listing/deny-by-default.html#ambiguous-glob-imports","lints/listing/deny-by-default.html#example-1","lints/listing/deny-by-default.html#explanation-1","lints/listing/deny-by-default.html#arithmetic-overflow","lints/listing/deny-by-default.html#example-2","lints/listing/deny-by-default.html#explanation-2","lints/listing/deny-by-default.html#binary-asm-labels","lints/listing/deny-by-default.html#example-3","lints/listing/deny-by-default.html#explanation-3","lints/listing/deny-by-default.html#bindings-with-variant-name","lints/listing/deny-by-default.html#example-4","lints/listing/deny-by-default.html#explanation-4","lints/listing/deny-by-default.html#conflicting-repr-hints","lints/listing/deny-by-default.html#example-5","lints/listing/deny-by-default.html#explanation-5","lints/listing/deny-by-default.html#dangerous-implicit-autorefs","lints/listing/deny-by-default.html#example-6","lints/listing/deny-by-default.html#explanation-6","lints/listing/deny-by-default.html#default-overrides-default-fields","lints/listing/deny-by-default.html#example-7","lints/listing/deny-by-default.html#explanation-7","lints/listing/deny-by-default.html#dependency-on-unit-never-type-fallback","lints/listing/deny-by-default.html#example-8","lints/listing/deny-by-default.html#explanation-8","lints/listing/deny-by-default.html#elided-lifetimes-in-associated-constant","lints/listing/deny-by-default.html#example-9","lints/listing/deny-by-default.html#explanation-9","lints/listing/deny-by-default.html#enum-intrinsics-non-enums","lints/listing/deny-by-default.html#example-10","lints/listing/deny-by-default.html#explanation-10","lints/listing/deny-by-default.html#exceeding-bitshifts","lints/listing/deny-by-default.html#explicit-builtin-cfgs-in-flags","lints/listing/deny-by-default.html#example-11","lints/listing/deny-by-default.html#explanation-11","lints/listing/deny-by-default.html#ill-formed-attribute-input","lints/listing/deny-by-default.html#example-12","lints/listing/deny-by-default.html#explanation-12","lints/listing/deny-by-default.html#incomplete-include","lints/listing/deny-by-default.html#example-13","lints/listing/deny-by-default.html#explanation-13","lints/listing/deny-by-default.html#ineffective-unstable-trait-impl","lints/listing/deny-by-default.html#example-14","lints/listing/deny-by-default.html#explanation-14","lints/listing/deny-by-default.html#invalid-atomic-ordering","lints/listing/deny-by-default.html#example-15","lints/listing/deny-by-default.html#explanation-15","lints/listing/deny-by-default.html#invalid-doc-attributes","lints/listing/deny-by-default.html#example-16","lints/listing/deny-by-default.html#explanation-16","lints/listing/deny-by-default.html#invalid-from-utf8-unchecked","lints/listing/deny-by-default.html#example-17","lints/listing/deny-by-default.html#explanation-17","lints/listing/deny-by-default.html#invalid-macro-export-arguments","lints/listing/deny-by-default.html#example-18","lints/listing/deny-by-default.html#explanation-18","lints/listing/deny-by-default.html#invalid-null-arguments","lints/listing/deny-by-default.html#example-19","lints/listing/deny-by-default.html#explanation-19","lints/listing/deny-by-default.html#invalid-reference-casting","lints/listing/deny-by-default.html#example-20","lints/listing/deny-by-default.html#explanation-20","lints/listing/deny-by-default.html#invalid-type-param-default","lints/listing/deny-by-default.html#example-21","lints/listing/deny-by-default.html#explanation-21","lints/listing/deny-by-default.html#legacy-derive-helpers","lints/listing/deny-by-default.html#example-22","lints/listing/deny-by-default.html#explanation-22","lints/listing/deny-by-default.html#let-underscore-lock","lints/listing/deny-by-default.html#example-23","lints/listing/deny-by-default.html#explanation-23","lints/listing/deny-by-default.html#long-running-const-eval","lints/listing/deny-by-default.html#example-24","lints/listing/deny-by-default.html#explanation-24","lints/listing/deny-by-default.html#unconditional-warnings","lints/listing/deny-by-default.html#macro-expanded-macro-exports-accessed-by-absolute-paths","lints/listing/deny-by-default.html#example-25","lints/listing/deny-by-default.html#explanation-25","lints/listing/deny-by-default.html#mutable-transmutes","lints/listing/deny-by-default.html#example-26","lints/listing/deny-by-default.html#explanation-26","lints/listing/deny-by-default.html#named-asm-labels","lints/listing/deny-by-default.html#example-27","lints/listing/deny-by-default.html#explanation-27","lints/listing/deny-by-default.html#never-type-fallback-flowing-into-unsafe","lints/listing/deny-by-default.html#never-type-fallback","lints/listing/deny-by-default.html#example-28","lints/listing/deny-by-default.html#explanation-28","lints/listing/deny-by-default.html#no-mangle-const-items","lints/listing/deny-by-default.html#example-29","lints/listing/deny-by-default.html#explanation-29","lints/listing/deny-by-default.html#out-of-scope-macro-calls","lints/listing/deny-by-default.html#example-30","lints/listing/deny-by-default.html#explanation-30","lints/listing/deny-by-default.html#overflowing-literals","lints/listing/deny-by-default.html#example-31","lints/listing/deny-by-default.html#explanation-31","lints/listing/deny-by-default.html#patterns-in-fns-without-body","lints/listing/deny-by-default.html#example-32","lints/listing/deny-by-default.html#explanation-32","lints/listing/deny-by-default.html#private-macro-use","lints/listing/deny-by-default.html#example-33","lints/listing/deny-by-default.html#explanation-33","lints/listing/deny-by-default.html#proc-macro-derive-resolution-fallback","lints/listing/deny-by-default.html#example-34","lints/listing/deny-by-default.html#explanation-34","lints/listing/deny-by-default.html#pub-use-of-private-extern-crate","lints/listing/deny-by-default.html#example-35","lints/listing/deny-by-default.html#explanation-35","lints/listing/deny-by-default.html#semicolon-in-expressions-from-macros","lints/listing/deny-by-default.html#example-36","lints/listing/deny-by-default.html#explanation-36","lints/listing/deny-by-default.html#soft-unstable","lints/listing/deny-by-default.html#test-unstable-lint","lints/listing/deny-by-default.html#example-37","lints/listing/deny-by-default.html#explanation-37","lints/listing/deny-by-default.html#text-direction-codepoint-in-comment","lints/listing/deny-by-default.html#example-38","lints/listing/deny-by-default.html#explanation-38","lints/listing/deny-by-default.html#text-direction-codepoint-in-literal","lints/listing/deny-by-default.html#explanation-39","lints/listing/deny-by-default.html#example-39","lints/listing/deny-by-default.html#unconditional-panic","lints/listing/deny-by-default.html#example-40","lints/listing/deny-by-default.html#explanation-40","lints/listing/deny-by-default.html#undropped-manually-drops","lints/listing/deny-by-default.html#example-41","lints/listing/deny-by-default.html#explanation-41","lints/listing/deny-by-default.html#unknown-crate-types","lints/listing/deny-by-default.html#example-42","lints/listing/deny-by-default.html#explanation-42","lints/listing/deny-by-default.html#useless-deprecated","lints/listing/deny-by-default.html#example-43","lints/listing/deny-by-default.html#explanation-43","json.html#json-output","json.html#diagnostics","json.html#artifact-notifications","json.html#future-incompatible-reports","json.html#unused-dependency-notifications","json.html#timings","tests/index.html#tests","tests/index.html#test-attributes","tests/index.html#cli-arguments","tests/index.html#filters","tests/index.html#action-options","tests/index.html#selection-options","tests/index.html#execution-options","tests/index.html#output-options","tests/index.html#unstable-options","tests/index.html#benchmarks","tests/index.html#custom-test-frameworks","targets/index.html#targets","targets/index.html#target-features","targets/built-in.html#built-in-targets","targets/custom.html#custom-targets","targets/custom.html#json-schema","targets/custom.html#custom-target-lookup-path","targets/known-issues.html#known-issues","targets/known-issues.html#target-features","profile-guided-optimization.html#profile-guided-optimization","profile-guided-optimization.html#what-is-profile-guided-optimization","profile-guided-optimization.html#usage","profile-guided-optimization.html#a-complete-cargo-workflow","profile-guided-optimization.html#troubleshooting","profile-guided-optimization.html#further-reading","profile-guided-optimization.html#community-maintained-tools","instrument-coverage.html#instrumentation-based-code-coverage","instrument-coverage.html#introduction","instrument-coverage.html#how-it-works","instrument-coverage.html#enable-coverage-profiling-in-the-rust-compiler","instrument-coverage.html#building-the-demangler","instrument-coverage.html#compiling-with-coverage-enabled","instrument-coverage.html#running-the-instrumented-binary-to-generate-raw-coverage-profiling-data","instrument-coverage.html#installing-llvm-coverage-tools","instrument-coverage.html#creating-coverage-reports","instrument-coverage.html#interpreting-reports","instrument-coverage.html#test-coverage","instrument-coverage.html#tips-for-listing-the-binaries-automatically","instrument-coverage.html#including-doc-tests","instrument-coverage.html#-c-instrument-coverage","instrument-coverage.html#other-values","instrument-coverage.html#-z-coverage-options","instrument-coverage.html#other-references","linker-plugin-lto.html#linker-plugin-based-lto","linker-plugin-lto.html#usage","linker-plugin-lto.html#rust-staticlib-as-dependency-in-cc-program","linker-plugin-lto.html#cc-code-as-a-dependency-in-rust","linker-plugin-lto.html#explicitly-specifying-the-linker-plugin-to-be-used-by-rustc","linker-plugin-lto.html#usage-with-clang-cl-and-x86_64-pc-windows-msvc","linker-plugin-lto.html#toolchain-compatibility","check-cfg.html#checking-conditional-configurations","check-cfg.html#specifying-expected-names-and-values","check-cfg.html#well-known-names-and-values","check-cfg.html#equivalence-table-with---cfg","check-cfg.html#examples","check-cfg.html#example-cargo-like-feature-example","check-cfg.html#example-multiple-names-and-values","check-cfg.html#example-condition-names-without-values","check-cfg/cargo-specifics.html#cargo-specifics---checking-conditional-configurations","check-cfg/cargo-specifics.html#cargo-feature","check-cfg/cargo-specifics.html#check-cfg-in-lintsrust-table","check-cfg/cargo-specifics.html#cargorustc-check-cfg-for-buildrsbuild-script","remap-source-paths.html#remap-source-paths","remap-source-paths.html#--remap-path-prefix","remap-source-paths.html#example","remap-source-paths.html#caveats-and-limitations","remap-source-paths.html#linkers-generated-paths","remap-source-paths.html#textual-replacement-only","remap-source-paths.html#external-tools","exploit-mitigations.html#exploit-mitigations","exploit-mitigations.html#introduction","exploit-mitigations.html#exploit-mitigations-1","exploit-mitigations.html#position-independent-executable","exploit-mitigations.html#integer-overflow-checks","exploit-mitigations.html#non-executable-memory-regions","exploit-mitigations.html#stack-clashing-protection","exploit-mitigations.html#read-only-relocations-and-immediate-binding","exploit-mitigations.html#heap-corruption-protection","exploit-mitigations.html#stack-smashing-protection","exploit-mitigations.html#forward-edge-control-flow-protection","exploit-mitigations.html#backward-edge-control-flow-protection","exploit-mitigations.html#appendix","exploit-mitigations.html#references","symbol-mangling/index.html#symbol-mangling","symbol-mangling/index.html#per-item-control","symbol-mangling/index.html#decoding","symbol-mangling/index.html#mangling-versions","symbol-mangling/v0.html#v0-symbol-format","symbol-mangling/v0.html#extensions","symbol-mangling/v0.html#grammar-notation","symbol-mangling/v0.html#symbol-name","symbol-mangling/v0.html#symbol-path","symbol-mangling/v0.html#path-crate-root","symbol-mangling/v0.html#path-inherent-impl","symbol-mangling/v0.html#path-trait-impl","symbol-mangling/v0.html#path-impl","symbol-mangling/v0.html#path-trait-definition","symbol-mangling/v0.html#path-nested-path","symbol-mangling/v0.html#path-generic-arguments","symbol-mangling/v0.html#namespace","symbol-mangling/v0.html#identifier","symbol-mangling/v0.html#punycode-identifiers","symbol-mangling/v0.html#disambiguator","symbol-mangling/v0.html#lifetime","symbol-mangling/v0.html#const","symbol-mangling/v0.html#placeholders","symbol-mangling/v0.html#type","symbol-mangling/v0.html#binder","symbol-mangling/v0.html#backref","symbol-mangling/v0.html#instantiating-crate","symbol-mangling/v0.html#vendor-specific-suffix","symbol-mangling/v0.html#common-rules","symbol-mangling/v0.html#base-62-number","symbol-mangling/v0.html#symbol-grammar-summary","symbol-mangling/v0.html#encoding-of-rust-entities","contributing.html#contributing-to-rustc","platform-support.html#platform-support","platform-support.html#tier-1-with-host-tools","platform-support.html#tier-1","platform-support.html#tier-2-with-host-tools","platform-support.html#tier-2-without-host-tools","platform-support.html#tier-3","target-tier-policy.html#target-tier-policy","target-tier-policy.html#table-of-contents","target-tier-policy.html#general","target-tier-policy.html#adding-a-new-target","target-tier-policy.html#tier-3-target-policy","target-tier-policy.html#tier-2-target-policy","target-tier-policy.html#tier-2-with-host-tools","target-tier-policy.html#tier-1-target-policy","target-tier-policy.html#tier-1-with-host-tools","platform-support/TEMPLATE.html#target-name-here","platform-support/TEMPLATE.html#target-maintainers","platform-support/TEMPLATE.html#requirements","platform-support/TEMPLATE.html#building-the-target","platform-support/TEMPLATE.html#building-rust-programs","platform-support/TEMPLATE.html#testing","platform-support/TEMPLATE.html#cross-compilation-toolchains-and-c-code","platform-support/arm64ec-pc-windows-msvc.html#arm64ec-pc-windows-msvc","platform-support/arm64ec-pc-windows-msvc.html#target-maintainers","platform-support/arm64ec-pc-windows-msvc.html#requirements","platform-support/arm64ec-pc-windows-msvc.html#reusing-code-from-other-architectures---x86_64-or-aarch64","platform-support/arm64ec-pc-windows-msvc.html#building-the-target","platform-support/arm64ec-pc-windows-msvc.html#building-rust-programs","platform-support/arm64ec-pc-windows-msvc.html#testing","platform-support/arm64ec-pc-windows-msvc.html#cross-compilation-toolchains-and-c-code","platform-support/apple-darwin.html#-apple-darwin","platform-support/apple-darwin.html#target-maintainers","platform-support/apple-darwin.html#requirements","platform-support/apple-darwin.html#os-version","platform-support/apple-darwin.html#host-tooling","platform-support/apple-darwin.html#binary-format","platform-support/apple-darwin.html#building","platform-support/apple-darwin.html#testing","platform-support/apple-darwin.html#cross-compilation-toolchains-and-c-code","platform-support/i686-apple-darwin.html#i686-apple-darwin","platform-support/i686-apple-darwin.html#target-maintainers","platform-support/i686-apple-darwin.html#requirements","platform-support/i686-apple-darwin.html#building-the-target","platform-support/i686-apple-darwin.html#building-rust-programs","platform-support/i686-apple-darwin.html#testing","platform-support/x86_64h-apple-darwin.html#x86_64h-apple-darwin","platform-support/x86_64h-apple-darwin.html#target-maintainers","platform-support/x86_64h-apple-darwin.html#requirements","platform-support/x86_64h-apple-darwin.html#building-the-target","platform-support/x86_64h-apple-darwin.html#building-rust-programs","platform-support/x86_64h-apple-darwin.html#testing","platform-support/x86_64h-apple-darwin.html#cross-compilation-toolchains-and-c-code","platform-support/arm64e-apple-darwin.html#arm64e-apple-darwin","platform-support/arm64e-apple-darwin.html#target-maintainers","platform-support/arm64e-apple-darwin.html#requirements","platform-support/arm64e-apple-darwin.html#building-the-target","platform-support/arm64e-apple-darwin.html#building-rust-programs","platform-support/arm64e-apple-darwin.html#testing","platform-support/arm64e-apple-darwin.html#cross-compilation-toolchains-and-c-code","platform-support/apple-ios.html#-apple-ios","platform-support/apple-ios.html#target-maintainers","platform-support/apple-ios.html#requirements","platform-support/apple-ios.html#os-version","platform-support/apple-ios.html#building-the-target","platform-support/apple-ios.html#building-rust-programs","platform-support/apple-ios.html#testing","platform-support/apple-ios-macabi.html#-apple-ios-macabi","platform-support/apple-ios-macabi.html#target-maintainers","platform-support/apple-ios-macabi.html#requirements","platform-support/apple-ios-macabi.html#os-version","platform-support/apple-ios-macabi.html#building-the-target","platform-support/apple-ios-macabi.html#sanitizers","platform-support/apple-ios-macabi.html#building-rust-programs","platform-support/apple-ios-macabi.html#testing","platform-support/arm64e-apple-ios.html#arm64e-apple-ios","platform-support/arm64e-apple-ios.html#target-maintainers","platform-support/arm64e-apple-ios.html#requirements","platform-support/arm64e-apple-ios.html#building-the-target","platform-support/arm64e-apple-ios.html#building-rust-programs","platform-support/arm64e-apple-ios.html#testing","platform-support/arm64e-apple-ios.html#cross-compilation-toolchains-and-c-code","platform-support/apple-tvos.html#-apple-tvos","platform-support/apple-tvos.html#target-maintainers","platform-support/apple-tvos.html#requirements","platform-support/apple-tvos.html#os-version","platform-support/apple-tvos.html#incompletely-supported-library-functionality","platform-support/apple-tvos.html#building-the-target","platform-support/apple-tvos.html#building-rust-programs","platform-support/apple-tvos.html#testing","platform-support/arm64e-apple-tvos.html#arm64e-apple-tvos","platform-support/arm64e-apple-tvos.html#target-maintainers","platform-support/arm64e-apple-tvos.html#requirements","platform-support/arm64e-apple-tvos.html#building-the-target","platform-support/arm64e-apple-tvos.html#building-rust-programs","platform-support/arm64e-apple-tvos.html#testing","platform-support/arm64e-apple-tvos.html#cross-compilation-toolchains-and-c-code","platform-support/apple-watchos.html#-apple-watchos","platform-support/apple-watchos.html#target-maintainers","platform-support/apple-watchos.html#requirements","platform-support/apple-watchos.html#os-version","platform-support/apple-watchos.html#building-the-target","platform-support/apple-watchos.html#building-rust-programs","platform-support/apple-watchos.html#testing","platform-support/apple-visionos.html#-apple-visionos","platform-support/apple-visionos.html#target-maintainers","platform-support/apple-visionos.html#requirements","platform-support/apple-visionos.html#os-version","platform-support/apple-visionos.html#building-the-target","platform-support/apple-visionos.html#building-rust-programs","platform-support/apple-visionos.html#testing","platform-support/apple-visionos.html#cross-compilation-toolchains-and-c-code","platform-support/aarch64-nintendo-switch-freestanding.html#aarch64-nintendo-switch-freestanding","platform-support/aarch64-nintendo-switch-freestanding.html#target-maintainers","platform-support/aarch64-nintendo-switch-freestanding.html#requirements","platform-support/aarch64-nintendo-switch-freestanding.html#building","platform-support/aarch64-nintendo-switch-freestanding.html#cross-compilation","platform-support/aarch64-nintendo-switch-freestanding.html#testing","platform-support/aarch64-nintendo-switch-freestanding.html#building-rust-programs","platform-support/aarch64-unknown-linux-gnu.html#aarch64-unknown-linux-gnu","platform-support/aarch64-unknown-linux-gnu.html#target-maintainers","platform-support/aarch64-unknown-linux-gnu.html#requirements","platform-support/aarch64-unknown-linux-gnu.html#building-the-target","platform-support/aarch64-unknown-linux-gnu.html#building-rust-programs","platform-support/aarch64-unknown-linux-gnu.html#cross-compilation","platform-support/aarch64-unknown-linux-gnu.html#testing","platform-support/aarch64-unknown-linux-musl.html#aarch64-unknown-linux-musl","platform-support/aarch64-unknown-linux-musl.html#target-maintainers","platform-support/aarch64-unknown-linux-musl.html#requirements","platform-support/aarch64-unknown-linux-musl.html#building-the-target","platform-support/aarch64-unknown-linux-musl.html#building-rust-programs","platform-support/aarch64-unknown-linux-musl.html#cross-compilation","platform-support/aarch64-unknown-linux-musl.html#testing","platform-support/aarch64-unknown-none.html#aarch64-unknown-none-and-aarch64-unknown-none-softfloat","platform-support/aarch64-unknown-none.html#target-maintainers","platform-support/aarch64-unknown-none.html#target-cpu-and-target-feature-options","platform-support/aarch64-unknown-none.html#requirements","platform-support/aarch64-unknown-none.html#cross-compilation-toolchains-and-c-code","platform-support/aarch64-unknown-none.html#start-up-and-low-level-code","platform-support/aarch64_be-unknown-none-softfloat.html#aarch64_be-unknown-none-softfloat","platform-support/aarch64_be-unknown-none-softfloat.html#target-maintainers","platform-support/aarch64_be-unknown-none-softfloat.html#requirements","platform-support/aarch64_be-unknown-none-softfloat.html#building-the-target","platform-support/aarch64_be-unknown-none-softfloat.html#building-rust-programs","platform-support/aarch64_be-unknown-none-softfloat.html#cross-compilation","platform-support/aarch64_be-unknown-none-softfloat.html#testing","platform-support/aarch64_be-unknown-linux-musl.html#aarch64_be-unknown-linux-musl","platform-support/aarch64_be-unknown-linux-musl.html#target-maintainers","platform-support/aarch64_be-unknown-linux-musl.html#requirements","platform-support/aarch64_be-unknown-linux-musl.html#building-the-target","platform-support/aarch64_be-unknown-linux-musl.html#testing","platform-support/amdgcn-amd-amdhsa.html#amdgcn-amd-amdhsa","platform-support/amdgcn-amd-amdhsa.html#target-maintainers","platform-support/amdgcn-amd-amdhsa.html#requirements","platform-support/amdgcn-amd-amdhsa.html#building-the-target","platform-support/amdgcn-amd-amdhsa.html#building-rust-programs","platform-support/amdgcn-amd-amdhsa.html#running-rust-programs","platform-support/amdgcn-amd-amdhsa.html#additional-information","platform-support/arm-none-eabi.html#armthumb-none-eabihf","platform-support/arm-none-eabi.html#common-target-details","platform-support/arm-none-eabi.html#tier-2-target-list","platform-support/arm-none-eabi.html#tier-3-target-list","platform-support/arm-none-eabi.html#instruction-sets","platform-support/arm-none-eabi.html#target-cpu-and-target-feature-options","platform-support/arm-none-eabi.html#requirements","platform-support/arm-none-eabi.html#building-rust-programs","platform-support/arm-none-eabi.html#testing","platform-support/arm-none-eabi.html#cross-compilation-toolchains-and-c-code","platform-support/armv4t-none-eabi.html#armv4t-none-eabi--thumbv4t-none-eabi","platform-support/armv4t-none-eabi.html#target-maintainers","platform-support/armv4t-none-eabi.html#testing","platform-support/armv5te-none-eabi.html#armv5te-none-eabi","platform-support/armv5te-none-eabi.html#target-maintainers","platform-support/armv5te-none-eabi.html#testing","platform-support/armv7a-none-eabi.html#armv7a-none-eabi-and-armv7a-none-eabihf","platform-support/armv7a-none-eabi.html#target-maintainers","platform-support/armv7a-none-eabi.html#requirements","platform-support/armv7a-none-eabi.html#start-up-and-low-level-code","platform-support/armv7r-none-eabi.html#armv7r-none-eabi-and-armv7r-none-eabihf","platform-support/armv7r-none-eabi.html#target-maintainers","platform-support/armv7r-none-eabi.html#requirements","platform-support/armv7r-none-eabi.html#start-up-and-low-level-code","platform-support/armebv7r-none-eabi.html#armebv7r-none-eabi-and-armebv7r-none-eabihf","platform-support/armebv7r-none-eabi.html#target-maintainers","platform-support/armebv7r-none-eabi.html#requirements","platform-support/armebv7r-none-eabi.html#start-up-and-low-level-code","platform-support/armv8r-none-eabihf.html#armv8r-none-eabihf","platform-support/armv8r-none-eabihf.html#target-maintainers","platform-support/armv8r-none-eabihf.html#requirements","platform-support/armv8r-none-eabihf.html#table-of-supported-cpus-for-armv8r-none-eabihf","platform-support/thumbv6m-none-eabi.html#thumbv6m-none-eabi","platform-support/thumbv6m-none-eabi.html#target-maintainers","platform-support/thumbv6m-none-eabi.html#target-cpu-and-target-feature-options","platform-support/thumbv6m-none-eabi.html#table-of-supported-cpus","platform-support/thumbv6m-none-eabi.html#arm-cortex-m0","platform-support/thumbv6m-none-eabi.html#arm-cortex-m0-1","platform-support/thumbv6m-none-eabi.html#arm-cortex-m1","platform-support/thumbv7em-none-eabi.html#thumbv7em-none-eabi-and-thumbv7em-none-eabihf","platform-support/thumbv7em-none-eabi.html#target-maintainers","platform-support/thumbv7em-none-eabi.html#target-cpu-and-target-feature-options","platform-support/thumbv7em-none-eabi.html#table-of-supported-cpus-for-thumbv7em-none-eabi","platform-support/thumbv7em-none-eabi.html#table-of-supported-cpus-for-thumbv7em-none-eabihf","platform-support/thumbv7em-none-eabi.html#arm-cortex-m4-and-arm-cortex-m4f","platform-support/thumbv7em-none-eabi.html#arm-cortex-m7-and-arm-cortex-m7f","platform-support/thumbv7m-none-eabi.html#thumbv7m-none-eabi","platform-support/thumbv7m-none-eabi.html#target-maintainers","platform-support/thumbv7m-none-eabi.html#target-cpu-and-target-feature-options","platform-support/thumbv7m-none-eabi.html#table-of-supported-cpus","platform-support/thumbv7m-none-eabi.html#arm-cortex-m3","platform-support/thumbv8m.base-none-eabi.html#thumbv8mbase-none-eabi","platform-support/thumbv8m.base-none-eabi.html#target-maintainers","platform-support/thumbv8m.base-none-eabi.html#target-cpu-and-target-feature-options","platform-support/thumbv8m.base-none-eabi.html#table-of-supported-cpus","platform-support/thumbv8m.base-none-eabi.html#arm-cortex-m23","platform-support/thumbv8m.main-none-eabi.html#thumbv8mmain-none-eabi-and-thumbv8mmain-none-eabihf","platform-support/thumbv8m.main-none-eabi.html#target-maintainers","platform-support/thumbv8m.main-none-eabi.html#target-cpu-and-target-feature-options","platform-support/thumbv8m.main-none-eabi.html#table-of-supported-cpus-for-thumbv8mmain-none-eabi","platform-support/thumbv8m.main-none-eabi.html#table-of-supported-cpus-for-thumbv8mmain-none-eabihf","platform-support/thumbv8m.main-none-eabi.html#arm-cortex-m33","platform-support/thumbv8m.main-none-eabi.html#arm-cortex-m35p","platform-support/thumbv8m.main-none-eabi.html#arm-cortex-m55","platform-support/thumbv8m.main-none-eabi.html#arm-cortex-m85","platform-support/arm-linux.html#arm-linux-support-in-rust","platform-support/arm-linux.html#architecture-component","platform-support/arm-linux.html#abi-component","platform-support/arm-linux.html#cross-compilation","platform-support/armeb-unknown-linux-gnueabi.html#armeb-unknown-linux-gnueabi","platform-support/armeb-unknown-linux-gnueabi.html#overview","platform-support/armeb-unknown-linux-gnueabi.html#history","platform-support/armeb-unknown-linux-gnueabi.html#target-maintainers","platform-support/armeb-unknown-linux-gnueabi.html#requirements","platform-support/armeb-unknown-linux-gnueabi.html#target-definition","platform-support/armeb-unknown-linux-gnueabi.html#building-the-target","platform-support/armeb-unknown-linux-gnueabi.html#building-rust-programs","platform-support/armv5te-unknown-linux-gnueabi.html#armv5te-unknown-linux-gnueabi","platform-support/armv5te-unknown-linux-gnueabi.html#target-maintainers","platform-support/armv5te-unknown-linux-gnueabi.html#requirements","platform-support/armv5te-unknown-linux-gnueabi.html#building-the-target","platform-support/armv5te-unknown-linux-gnueabi.html#building-rust-programs","platform-support/armv7-unknown-linux-gnueabi.html#armv7-unknown-linux-gnueabi-and-armv7-unknown-linux-gnueabihf","platform-support/armv7-unknown-linux-gnueabi.html#target-maintainers","platform-support/armv7-unknown-linux-gnueabi.html#requirements","platform-support/armv7-unknown-linux-gnueabi.html#building-the-target","platform-support/armv7-unknown-linux-gnueabi.html#building-rust-programs","platform-support/armv7-unknown-linux-gnueabi.html#cross-compilation","platform-support/armv7-unknown-linux-gnueabi.html#testing","platform-support/armv7-unknown-linux-uclibceabi.html#armv7-unknown-linux-uclibceabi","platform-support/armv7-unknown-linux-uclibceabi.html#target-maintainers","platform-support/armv7-unknown-linux-uclibceabi.html#requirements","platform-support/armv7-unknown-linux-uclibceabi.html#building-the-target","platform-support/armv7-unknown-linux-uclibceabi.html#building-rust-programs","platform-support/armv7-unknown-linux-uclibceabi.html#native-compilation","platform-support/armv7-unknown-linux-uclibceabi.html#cross-compilation","platform-support/armv7-unknown-linux-uclibceabi.html#test-with-qemu","platform-support/armv7-unknown-linux-uclibceabi.html#run-in-a-chroot","platform-support/armv7-unknown-linux-uclibceabihf.html#armv7-unknown-linux-uclibceabihf","platform-support/armv7-unknown-linux-uclibceabihf.html#target-maintainers","platform-support/armv7-unknown-linux-uclibceabihf.html#requirements","platform-support/armv7-unknown-linux-uclibceabihf.html#building","platform-support/armv7-unknown-linux-uclibceabihf.html#get-a-c-toolchain","platform-support/armv7-unknown-linux-uclibceabihf.html#configure-rust","platform-support/armv7-unknown-linux-uclibceabihf.html#build","platform-support/armv7-unknown-linux-uclibceabihf.html#building-and-running-rust-programs","platform-support/armv6k-nintendo-3ds.html#armv6k-nintendo-3ds","platform-support/armv6k-nintendo-3ds.html#target-maintainers","platform-support/armv6k-nintendo-3ds.html#requirements","platform-support/armv6k-nintendo-3ds.html#building-the-target","platform-support/armv6k-nintendo-3ds.html#building-rust-programs","platform-support/armv6k-nintendo-3ds.html#testing","platform-support/armv6k-nintendo-3ds.html#cross-compilation-toolchains-and-c-code","platform-support/armv7-rtems-eabihf.html#armv7-rtems-eabihf","platform-support/armv7-rtems-eabihf.html#target-maintainers","platform-support/armv7-rtems-eabihf.html#requirements","platform-support/armv7-rtems-eabihf.html#building-the-target","platform-support/armv7-rtems-eabihf.html#building-rust-programs","platform-support/armv7-rtems-eabihf.html#testing","platform-support/armv7-rtems-eabihf.html#cross-compilation-toolchains-and-c-code","platform-support/armv7-sony-vita-newlibeabihf.html#armv7-sony-vita-newlibeabihf","platform-support/armv7-sony-vita-newlibeabihf.html#target-maintainers","platform-support/armv7-sony-vita-newlibeabihf.html#requirements","platform-support/armv7-sony-vita-newlibeabihf.html#building-the-target","platform-support/armv7-sony-vita-newlibeabihf.html#building-rust-programs","platform-support/armv7-sony-vita-newlibeabihf.html#testing","platform-support/armv7-sony-vita-newlibeabihf.html#cross-compilation","platform-support/armv7a-vex-v5.html#armv7a-vex-v5","platform-support/armv7a-vex-v5.html#target-maintainers","platform-support/armv7a-vex-v5.html#requirements","platform-support/armv7a-vex-v5.html#building-the-target","platform-support/armv7a-vex-v5.html#building-rust-programs","platform-support/armv7a-vex-v5.html#testing","platform-support/armv7a-vex-v5.html#cross-compilation-toolchains-and-c-code","platform-support/android.html#-linux-android-and--linux-androideabi","platform-support/android.html#target-maintainers","platform-support/android.html#requirements","platform-support/android.html#ndkapi-update-policy","platform-support/android.html#building-the-target","platform-support/android.html#architecture-notes","platform-support/android.html#riscv64-linux-android","platform-support/android.html#aarch64-linux-android-on-nightly-compilers","platform-support/openharmony.html#-unknown-linux-ohos","platform-support/openharmony.html#target-maintainers","platform-support/openharmony.html#requirements","platform-support/openharmony.html#host-toolchain","platform-support/openharmony.html#setup","platform-support/openharmony.html#building-rust-programs","platform-support/openharmony.html#building-the-target-from-source","platform-support/openharmony.html#testing","platform-support/openharmony.html#cross-compilation-toolchains-and-c-code","platform-support/hurd.html#i686-unknown-hurd-gnu-and-x86_64-unknown-hurd-gnu","platform-support/hurd.html#target-maintainers","platform-support/hurd.html#requirements","platform-support/hurd.html#building-the-target","platform-support/hurd.html#building-rust-programs","platform-support/hurd.html#testing","platform-support/hurd.html#cross-compilation-toolchains-and-c-code","platform-support/aarch64-unknown-teeos.html#aarch64-unknown-teeos","platform-support/aarch64-unknown-teeos.html#target-maintainers","platform-support/aarch64-unknown-teeos.html#setup","platform-support/aarch64-unknown-teeos.html#building-the-target","platform-support/aarch64-unknown-teeos.html#building-rust-programs","platform-support/aarch64-unknown-teeos.html#testing","platform-support/avr-none.html#avr-none","platform-support/avr-none.html#target-maintainers","platform-support/avr-none.html#requirements","platform-support/avr-none.html#building-the-target","platform-support/avr-none.html#building-rust-programs","platform-support/avr-none.html#testing","platform-support/esp-idf.html#-espidf","platform-support/esp-idf.html#target-maintainers","platform-support/esp-idf.html#requirements","platform-support/esp-idf.html#building-the-target","platform-support/esp-idf.html#cross-compilation-toolchains-and-c-code","platform-support/fuchsia.html#aarch64-unknown-fuchsia-and-x86_64-unknown-fuchsia","platform-support/fuchsia.html#target-maintainers","platform-support/fuchsia.html#table-of-contents","platform-support/fuchsia.html#requirements","platform-support/fuchsia.html#walkthrough-structure","platform-support/fuchsia.html#compiling-a-rust-binary-targeting-fuchsia","platform-support/fuchsia.html#targeting-fuchsia-with-rustup-and-cargo","platform-support/fuchsia.html#targeting-fuchsia-with-a-compiler-built-from-source","platform-support/fuchsia.html#creating-a-fuchsia-package","platform-support/fuchsia.html#creating-a-fuchsia-component","platform-support/fuchsia.html#building-a-fuchsia-package","platform-support/fuchsia.html#publishing-a-fuchsia-package","platform-support/fuchsia.html#creating-a-fuchsia-package-repository","platform-support/fuchsia.html#publishing-fuchsia-package-to-repository","platform-support/fuchsia.html#running-a-fuchsia-component-on-an-emulator","platform-support/fuchsia.html#starting-the-fuchsia-emulator","platform-support/fuchsia.html#watching-emulator-logs","platform-support/fuchsia.html#serving-a-fuchsia-package","platform-support/fuchsia.html#running-a-fuchsia-component","platform-support/fuchsia.html#gitignore-extensions","platform-support/fuchsia.html#testing","platform-support/fuchsia.html#running-unit-tests","platform-support/fuchsia.html#running-the-compiler-test-suite","platform-support/fuchsia.html#debugging","platform-support/fuchsia.html#zxdb","platform-support/fuchsia.html#attaching-zxdb","platform-support/fuchsia.html#using-zxdb","platform-support/fuchsia.html#displaying-source-code-in-zxdb","platform-support/fuchsia.html#debugging-the-compiler-test-suite","platform-support/trusty.html#aarch64-unknown-trusty-and-armv7-unknown-trusty","platform-support/trusty.html#target-maintainers","platform-support/trusty.html#requirements","platform-support/trusty.html#building-the-target","platform-support/trusty.html#building-rust-programs","platform-support/trusty.html#testing","platform-support/trusty.html#cross-compilation-toolchains-and-c-code","platform-support/kmc-solid.html#-kmc-solid_","platform-support/kmc-solid.html#target-maintainers","platform-support/kmc-solid.html#requirements","platform-support/kmc-solid.html#building","platform-support/kmc-solid.html#cross-compilation","platform-support/kmc-solid.html#testing","platform-support/kmc-solid.html#building-rust-programs","platform-support/csky-unknown-linux-gnuabiv2.html#csky-unknown-linux-gnuabiv2","platform-support/csky-unknown-linux-gnuabiv2.html#target-maintainers","platform-support/csky-unknown-linux-gnuabiv2.html#requirements","platform-support/csky-unknown-linux-gnuabiv2.html#building-the-target","platform-support/csky-unknown-linux-gnuabiv2.html#get-a-c-toolchain","platform-support/csky-unknown-linux-gnuabiv2.html#configure-rust","platform-support/csky-unknown-linux-gnuabiv2.html#build","platform-support/csky-unknown-linux-gnuabiv2.html#building-and-running-rust-programs","platform-support/hexagon-unknown-linux-musl.html#hexagon-unknown-linux-musl","platform-support/hexagon-unknown-linux-musl.html#target-maintainers","platform-support/hexagon-unknown-linux-musl.html#requirements","platform-support/hexagon-unknown-linux-musl.html#building-the-target","platform-support/hexagon-unknown-linux-musl.html#testing","platform-support/hexagon-unknown-linux-musl.html#building-rust-programs","platform-support/hexagon-unknown-none-elf.html#hexagon-unknown-none-elf","platform-support/hexagon-unknown-none-elf.html#target-maintainers","platform-support/hexagon-unknown-none-elf.html#requirements","platform-support/hexagon-unknown-none-elf.html#building-the-target","platform-support/hexagon-unknown-none-elf.html#building-rust-programs","platform-support/hexagon-unknown-none-elf.html#testing","platform-support/hexagon-unknown-none-elf.html#cross-compilation-toolchains-and-c-code","platform-support/hexagon-unknown-none-elf.html#standalone-os","platform-support/hexagon-unknown-none-elf.html#qurt-os","platform-support/illumos.html#aarch64-unknown-illumos-and-x86_64-unknown-illumos","platform-support/illumos.html#target-maintainers","platform-support/illumos.html#requirements","platform-support/illumos.html#building-the-target","platform-support/illumos.html#building-rust-programs","platform-support/illumos.html#testing","platform-support/illumos.html#cross-compilation-toolchains-and-c-code","platform-support/loongarch-linux.html#loongarch-unknown-linux-","platform-support/loongarch-linux.html#target-maintainers","platform-support/loongarch-linux.html#requirements","platform-support/loongarch-linux.html#os-version","platform-support/loongarch-linux.html#host-toolchain","platform-support/loongarch-linux.html#cpu-features","platform-support/loongarch-linux.html#building","platform-support/loongarch-linux.html#cross-compilation","platform-support/loongarch-linux.html#testing","platform-support/loongarch-linux.html#building-rust-programs","platform-support/loongarch-none.html#loongarch-unknown-none","platform-support/loongarch-none.html#target-maintainers","platform-support/loongarch-none.html#requirements","platform-support/loongarch-none.html#building-the-target","platform-support/loongarch-none.html#testing","platform-support/loongarch-none.html#building-rust-programs","platform-support/loongarch-none.html#loongarch32-unknown-none","platform-support/loongarch-none.html#loongarch64-unknown-none","platform-support/loongarch-none.html#cross-compilation-toolchains-and-c-code","platform-support/lynxos178.html#-lynxos178-","platform-support/lynxos178.html#target-maintainers","platform-support/lynxos178.html#requirements","platform-support/lynxos178.html#building-the-target","platform-support/lynxos178.html#building-rust-programs","platform-support/lynxos178.html#testing","platform-support/lynxos178.html#cross-compilation-toolchains-and-c-code","platform-support/m68k-unknown-linux-gnu.html#m68k-unknown-linux-gnu","platform-support/m68k-unknown-linux-gnu.html#target-maintainers","platform-support/m68k-unknown-linux-gnu.html#requirements","platform-support/m68k-unknown-linux-gnu.html#building","platform-support/m68k-unknown-linux-gnu.html#cross-compilation","platform-support/m68k-unknown-linux-gnu.html#testing","platform-support/m68k-unknown-linux-gnu.html#building-rust-programs","platform-support/m68k-unknown-none-elf.html#m68k-unknown-none-elf","platform-support/m68k-unknown-none-elf.html#target-maintainers","platform-support/m68k-unknown-none-elf.html#requirements","platform-support/m68k-unknown-none-elf.html#building","platform-support/m68k-unknown-none-elf.html#cross-compilation","platform-support/m68k-unknown-none-elf.html#testing","platform-support/m68k-unknown-none-elf.html#building-rust-programs","platform-support/mips64-openwrt-linux-musl.html#mips64-openwrt-linux-musl","platform-support/mips64-openwrt-linux-musl.html#target-maintainers","platform-support/mips64-openwrt-linux-musl.html#requirements","platform-support/mips64-openwrt-linux-musl.html#building-the-target","platform-support/mips64-openwrt-linux-musl.html#building-rust-programs","platform-support/mips64-openwrt-linux-musl.html#testing","platform-support/mips64-unknown-linux-muslabi64.html#mips64-unknown-linux-muslabi64","platform-support/mips64-unknown-linux-muslabi64.html#target-maintainers","platform-support/mips64-unknown-linux-muslabi64.html#requirements","platform-support/mips64-unknown-linux-muslabi64.html#building-the-target","platform-support/mips64-unknown-linux-muslabi64.html#building-rust-programs","platform-support/mips64-unknown-linux-muslabi64.html#cross-compilation","platform-support/mips64-unknown-linux-muslabi64.html#testing","platform-support/mipsel-sony-psx.html#mipsel-sony-psx","platform-support/mipsel-sony-psx.html#designated-developer","platform-support/mipsel-sony-psx.html#requirements","platform-support/mipsel-sony-psx.html#building","platform-support/mipsel-sony-psx.html#cross-compilation","platform-support/mipsel-sony-psx.html#testing","platform-support/mipsel-sony-psx.html#building-rust-programs","platform-support/mipsel-unknown-linux-gnu.html#mipsel-unknown-linux-gnu","platform-support/mipsel-unknown-linux-gnu.html#target-maintainers","platform-support/mipsel-unknown-linux-gnu.html#requirements","platform-support/mipsel-unknown-linux-gnu.html#building-the-target","platform-support/mipsel-unknown-linux-gnu.html#building-rust-programs","platform-support/mips-mti-none-elf.html#mips-mti-none-elf","platform-support/mips-mti-none-elf.html#target-maintainers","platform-support/mips-mti-none-elf.html#background","platform-support/mips-mti-none-elf.html#requirements","platform-support/mips-mti-none-elf.html#cross-compilation-toolchains-and-c-code","platform-support/mips-release-6.html#mipsisar6-unknown-linux-gnu","platform-support/mips-release-6.html#target-maintainers","platform-support/mips-release-6.html#requirements","platform-support/mips-release-6.html#cc-toolchain","platform-support/mips-release-6.html#target-libraries","platform-support/mips-release-6.html#building","platform-support/mips-release-6.html#prerequisite-disable-debuginfo","platform-support/mips-release-6.html#prerequisite-enable-rustixs-libc-backend","platform-support/mips-release-6.html#prerequisite-supplying-openssl","platform-support/mips-release-6.html#launching-xpy","platform-support/mips-release-6.html#tips","platform-support/mips-release-6.html#building-rust-programs","platform-support/mips-release-6.html#testing","platform-support/mips-release-6.html#tips-for-building-rust-programs-for-mips-r6","platform-support/nvptx64-nvidia-cuda.html#nvptx64-nvidia-cuda","platform-support/nvptx64-nvidia-cuda.html#target-maintainers","platform-support/nvptx64-nvidia-cuda.html#requirements","platform-support/nvptx64-nvidia-cuda.html#target-and-features","platform-support/nvptx64-nvidia-cuda.html#building-rust-kernels","platform-support/powerpc-unknown-openbsd.html#designated-maintainers","platform-support/powerpc-unknown-linux-gnuspe.html#powerpc-unknown-linux-gnuspe","platform-support/powerpc-unknown-linux-gnuspe.html#target-maintainers","platform-support/powerpc-unknown-linux-muslspe.html#powerpc-unknown-linux-muslspe","platform-support/powerpc-unknown-linux-muslspe.html#target-maintainers","platform-support/powerpc-unknown-linux-muslspe.html#requirements","platform-support/powerpc-unknown-linux-muslspe.html#building-the-target","platform-support/powerpc-unknown-linux-muslspe.html#building-rust-programs","platform-support/powerpc-unknown-linux-muslspe.html#testing","platform-support/aix.html#powerpc64-ibm-aix","platform-support/aix.html#target-maintainers","platform-support/aix.html#requirements","platform-support/aix.html#testing","platform-support/aix.html#interoperability-with-c-code","platform-support/powerpc64-unknown-linux-musl.html#powerpc64-unknown-linux-musl","platform-support/powerpc64-unknown-linux-musl.html#target-maintainers","platform-support/powerpc64-unknown-linux-musl.html#requirements","platform-support/powerpc64-unknown-linux-musl.html#building-the-target","platform-support/powerpc64-unknown-linux-musl.html#building-rust-programs","platform-support/powerpc64-unknown-linux-musl.html#cross-compilation","platform-support/powerpc64-unknown-linux-musl.html#testing","platform-support/powerpc64le-unknown-linux-gnu.html#powerpc64le-unknown-linux-gnu","platform-support/powerpc64le-unknown-linux-gnu.html#target-maintainers","platform-support/powerpc64le-unknown-linux-gnu.html#requirements","platform-support/powerpc64le-unknown-linux-gnu.html#building-the-target","platform-support/powerpc64le-unknown-linux-gnu.html#building-rust-programs","platform-support/powerpc64le-unknown-linux-gnu.html#cross-compilation","platform-support/powerpc64le-unknown-linux-gnu.html#testing","platform-support/powerpc64le-unknown-linux-musl.html#powerpc64le-unknown-linux-musl","platform-support/powerpc64le-unknown-linux-musl.html#target-maintainers","platform-support/powerpc64le-unknown-linux-musl.html#requirements","platform-support/powerpc64le-unknown-linux-musl.html#building-the-target","platform-support/powerpc64le-unknown-linux-musl.html#building-rust-programs","platform-support/powerpc64le-unknown-linux-musl.html#cross-compilation","platform-support/powerpc64le-unknown-linux-musl.html#testing","platform-support/riscv32e-unknown-none-elf.html#riscv32eememc-unknown-none-elf","platform-support/riscv32e-unknown-none-elf.html#target-maintainers","platform-support/riscv32e-unknown-none-elf.html#requirements","platform-support/riscv32e-unknown-none-elf.html#building-the-target","platform-support/riscv32e-unknown-none-elf.html#testing","platform-support/riscv32e-unknown-none-elf.html#cross-compilation-toolchains-and-c-code","platform-support/riscv32-unknown-none-elf.html#riscv32iimimaimcimacimafc-unknown-none-elf","platform-support/riscv32-unknown-none-elf.html#target-maintainers","platform-support/riscv32-unknown-none-elf.html#requirements","platform-support/riscv32-unknown-none-elf.html#building-the-target","platform-support/riscv32-unknown-none-elf.html#testing","platform-support/riscv32-unknown-none-elf.html#cross-compilation-toolchains-and-c-code","platform-support/riscv32im-risc0-zkvm-elf.html#riscv32im-risc0-zkvm-elf","platform-support/riscv32im-risc0-zkvm-elf.html#target-maintainers","platform-support/riscv32im-risc0-zkvm-elf.html#background","platform-support/riscv32im-risc0-zkvm-elf.html#requirements","platform-support/riscv32im-risc0-zkvm-elf.html#building-for-the-zkvm","platform-support/riscv32im-risc0-zkvm-elf.html#building-rust-programs","platform-support/riscv32im-risc0-zkvm-elf.html#testing","platform-support/riscv32im-risc0-zkvm-elf.html#cross-compilation-toolchains-and-c-code","platform-support/riscv32imac-unknown-xous-elf.html#riscv32imac-unknown-xous-elf","platform-support/riscv32imac-unknown-xous-elf.html#target-maintainers","platform-support/riscv32imac-unknown-xous-elf.html#requirements","platform-support/riscv32imac-unknown-xous-elf.html#building-the-target","platform-support/riscv32imac-unknown-xous-elf.html#building-rust-programs","platform-support/riscv32imac-unknown-xous-elf.html#cross-compilation","platform-support/riscv32imac-unknown-xous-elf.html#testing","platform-support/riscv64gc-unknown-linux-gnu.html#riscv64gc-unknown-linux-gnu","platform-support/riscv64gc-unknown-linux-gnu.html#target-maintainers","platform-support/riscv64gc-unknown-linux-gnu.html#requirements","platform-support/riscv64gc-unknown-linux-gnu.html#building-the-target","platform-support/riscv64gc-unknown-linux-gnu.html#building-rust-programs","platform-support/riscv64gc-unknown-linux-gnu.html#testing","platform-support/riscv64gc-unknown-linux-gnu.html#cross-compilation-toolchains-and-c-code","platform-support/riscv64gc-unknown-linux-musl.html#riscv64gc-unknown-linux-musl","platform-support/riscv64gc-unknown-linux-musl.html#target-maintainers","platform-support/riscv64gc-unknown-linux-musl.html#requirements","platform-support/riscv64gc-unknown-linux-musl.html#building-the-target","platform-support/riscv64gc-unknown-linux-musl.html#building-rust-programs","platform-support/riscv64gc-unknown-linux-musl.html#cross-compilation","platform-support/riscv64gc-unknown-linux-musl.html#testing","platform-support/riscv64a23-unknown-linux-gnu.html#riscv64a23-unknown-linux-gnu","platform-support/riscv64a23-unknown-linux-gnu.html#target-maintainers","platform-support/riscv64a23-unknown-linux-gnu.html#requirements","platform-support/riscv64a23-unknown-linux-gnu.html#building-the-target","platform-support/riscv64a23-unknown-linux-gnu.html#building-rust-programs","platform-support/s390x-unknown-linux-gnu.html#s390x-unknown-linux-gnu","platform-support/s390x-unknown-linux-gnu.html#target-maintainers","platform-support/s390x-unknown-linux-gnu.html#requirements","platform-support/s390x-unknown-linux-gnu.html#building-the-target","platform-support/s390x-unknown-linux-gnu.html#building-rust-programs","platform-support/s390x-unknown-linux-gnu.html#testing","platform-support/s390x-unknown-linux-gnu.html#cross-compilation-toolchains-and-c-code","platform-support/s390x-unknown-linux-musl.html#s390x-unknown-linux-musl","platform-support/s390x-unknown-linux-musl.html#target-maintainers","platform-support/s390x-unknown-linux-musl.html#requirements","platform-support/s390x-unknown-linux-musl.html#building-the-target","platform-support/s390x-unknown-linux-musl.html#building-rust-programs","platform-support/s390x-unknown-linux-musl.html#testing","platform-support/s390x-unknown-linux-musl.html#cross-compilation-toolchains-and-c-code","platform-support/sparc-unknown-none-elf.html#sparc-unknown-none-elf","platform-support/sparc-unknown-none-elf.html#target-maintainers","platform-support/sparc-unknown-none-elf.html#requirements","platform-support/sparc-unknown-none-elf.html#building-the-target","platform-support/sparc-unknown-none-elf.html#building-rust-programs","platform-support/sparc-unknown-none-elf.html#testing","platform-support/sparc-unknown-none-elf.html#cross-compilation-toolchains-and-c-code","platform-support/solaris.html#sparcv9-sun-solaris","platform-support/solaris.html#x86_64-pc-solaris","platform-support/solaris.html#target-maintainers","platform-support/solaris.html#requirements","platform-support/solaris.html#testing","platform-support/nto-qnx.html#nto-qnx","platform-support/nto-qnx.html#target-maintainers","platform-support/nto-qnx.html#requirements","platform-support/nto-qnx.html#disabling-relocation-read-only-relro","platform-support/nto-qnx.html#small-example-application","platform-support/nto-qnx.html#conditional-compilation","platform-support/nto-qnx.html#building-the-target","platform-support/nto-qnx.html#running-the-rust-test-suite","platform-support/nto-qnx.html#building-rust-programs","platform-support/nto-qnx.html#testing","platform-support/nto-qnx.html#rust-std-library-test-suite","platform-support/nto-qnx.html#cross-compilation-toolchains-and-c-code","platform-support/unikraft-linux-musl.html#-unikraft-linux-musl","platform-support/unikraft-linux-musl.html#target-maintainers","platform-support/unikraft-linux-musl.html#requirements","platform-support/unikraft-linux-musl.html#building-the-targets","platform-support/unikraft-linux-musl.html#building-rust-programs","platform-support/unikraft-linux-musl.html#testing","platform-support/unikraft-linux-musl.html#cross-compilation-toolchains-and-c-code","platform-support/hermit.html#-unknown-hermit","platform-support/hermit.html#target-maintainers","platform-support/hermit.html#requirements","platform-support/hermit.html#building-the-target","platform-support/hermit.html#building-rust-programs","platform-support/hermit.html#testing","platform-support/hermit.html#cross-compilation-toolchains-and-c-code","platform-support/freebsd.html#-unknown-freebsd","platform-support/freebsd.html#target-maintainers","platform-support/freebsd.html#requirements","platform-support/freebsd.html#building-rust-programs","platform-support/freebsd.html#testing","platform-support/managarm.html#-unknown-managarm-mlibc","platform-support/managarm.html#target-maintainers","platform-support/managarm.html#requirements","platform-support/managarm.html#building-the-target","platform-support/managarm.html#building-rust-programs","platform-support/managarm.html#testing","platform-support/motor.html#x86_64-unknown-motor","platform-support/motor.html#target-maintainers","platform-support/motor.html#requirements","platform-support/motor.html#building-the-target-toolchain","platform-support/motor.html#building-rust-programs","platform-support/motor.html#testing","platform-support/motor.html#cross-compilation-toolchains-and-c-code","platform-support/netbsd.html#-unknown-netbsd","platform-support/netbsd.html#target-maintainers","platform-support/netbsd.html#requirements","platform-support/netbsd.html#building","platform-support/netbsd.html#cross-compilation","platform-support/netbsd.html#testing","platform-support/netbsd.html#building-rust-programs","platform-support/openbsd.html#-unknown-openbsd","platform-support/openbsd.html#target-maintainers","platform-support/openbsd.html#requirements","platform-support/openbsd.html#building","platform-support/openbsd.html#cross-compilation","platform-support/openbsd.html#testing","platform-support/openbsd.html#building-rust-programs","platform-support/redox.html#-unknown-redox","platform-support/redox.html#target-maintainers","platform-support/redox.html#requirements","platform-support/redox.html#building-the-target","platform-support/redox.html#building-rust-programs-and-testing","platform-support/redox.html#cross-compilation-toolchains-and-c-code","platform-support/unknown-uefi.html#-unknown-uefi","platform-support/unknown-uefi.html#target-maintainers","platform-support/unknown-uefi.html#requirements","platform-support/unknown-uefi.html#building-rust-for-uefi-targets","platform-support/unknown-uefi.html#building-rust-programs","platform-support/unknown-uefi.html#building-a-driver","platform-support/unknown-uefi.html#testing","platform-support/unknown-uefi.html#cross-compilation-toolchains-and-c-code","platform-support/unknown-uefi.html#ecosystem","platform-support/unknown-uefi.html#example-freestanding","platform-support/unknown-uefi.html#example-hello-world","platform-support/unknown-uefi.html#rust-std-for-uefi","platform-support/unknown-uefi.html#build-std","platform-support/unknown-uefi.html#implemented-features","platform-support/unknown-uefi.html#example-hello-world-with-std","platform-support/unknown-uefi.html#bootservices","platform-support/windows-msvc.html#-pc-windows-msvc","platform-support/windows-msvc.html#target-maintainers","platform-support/windows-msvc.html#requirements","platform-support/windows-msvc.html#os-version","platform-support/windows-msvc.html#host-tooling","platform-support/windows-msvc.html#platform-details","platform-support/windows-msvc.html#building-rust-programs","platform-support/windows-msvc.html#testing","platform-support/windows-msvc.html#cross-compilation-toolchains-and-c-code","platform-support/uwp-windows-msvc.html#x86_64-uwp-windows-msvc-i686-uwp-windows-msvc-thumbv7a-uwp-windows-msvc-and-aarch64-uwp-windows-msvc","platform-support/uwp-windows-msvc.html#target-maintainers","platform-support/uwp-windows-msvc.html#requirements","platform-support/uwp-windows-msvc.html#building-the-targets","platform-support/uwp-windows-msvc.html#building-rust-programs","platform-support/uwp-windows-msvc.html#testing","platform-support/uwp-windows-msvc.html#cross-compilation-toolchains-and-c-code","platform-support/vxworks.html#-wrs-vxworks","platform-support/vxworks.html#target-maintainers","platform-support/vxworks.html#requirements","platform-support/vxworks.html#os-version","platform-support/vxworks.html#building","platform-support/vxworks.html#building-the-target","platform-support/vxworks.html#building-rust-programs","platform-support/vxworks.html#cross-compilation-toolchains-and-c-code","platform-support/wasm32-wasip1.html#wasm32-wasip1","platform-support/wasm32-wasip1.html#target-maintainers","platform-support/wasm32-wasip1.html#requirements","platform-support/wasm32-wasip1.html#building-the-target","platform-support/wasm32-wasip1.html#building-rust-programs","platform-support/wasm32-wasip1.html#cross-compilation","platform-support/wasm32-wasip1.html#testing","platform-support/wasm32-wasip1.html#conditionally-compiling-code","platform-support/wasm32-wasip1.html#enabled-webassembly-features","platform-support/wasm32-wasip1.html#unwinding","platform-support/wasm32-wasip1-threads.html#wasm32-wasip1-threads","platform-support/wasm32-wasip1-threads.html#target-maintainers","platform-support/wasm32-wasip1-threads.html#requirements","platform-support/wasm32-wasip1-threads.html#no-interop-with-c-required","platform-support/wasm32-wasip1-threads.html#interop-with-c-required","platform-support/wasm32-wasip1-threads.html#platform-requirements","platform-support/wasm32-wasip1-threads.html#building-the-target","platform-support/wasm32-wasip1-threads.html#building-rust-programs","platform-support/wasm32-wasip1-threads.html#cross-compilation","platform-support/wasm32-wasip1-threads.html#testing","platform-support/wasm32-wasip1-threads.html#conditionally-compiling-code","platform-support/wasm32-wasip1-threads.html#enabled-webassembly-features","platform-support/wasm32-wasip2.html#wasm32-wasip2","platform-support/wasm32-wasip2.html#target-maintainers","platform-support/wasm32-wasip2.html#requirements","platform-support/wasm32-wasip2.html#platform-requirements","platform-support/wasm32-wasip2.html#building-the-target","platform-support/wasm32-wasip2.html#testing","platform-support/wasm32-wasip2.html#conditionally-compiling-code","platform-support/wasm32-wasip2.html#enabled-webassembly-features","platform-support/wasm32-wasip2.html#unwinding","platform-support/wasm32-wasip3.html#wasm32-wasip3","platform-support/wasm32-wasip3.html#target-maintainers","platform-support/wasm32-wasip3.html#requirements","platform-support/wasm32-wasip3.html#platform-requirements","platform-support/wasm32-wasip3.html#building-the-target","platform-support/wasm32-wasip3.html#testing","platform-support/wasm32-wasip3.html#conditionally-compiling-code","platform-support/wasm32-wasip3.html#enabled-webassembly-features","platform-support/wasm32-wali-linux.html#wasm32-wali-linux-","platform-support/wasm32-wali-linux.html#target-maintainers","platform-support/wasm32-wali-linux.html#requirements","platform-support/wasm32-wali-linux.html#compilation","platform-support/wasm32-wali-linux.html#execution","platform-support/wasm32-wali-linux.html#building-the-target","platform-support/wasm32-wali-linux.html#building-rust-programs","platform-support/wasm32-wali-linux.html#restrictions","platform-support/wasm32-wali-linux.html#testing","platform-support/wasm32-wali-linux.html#cross-compilation-toolchains-and-c-code","platform-support/wasm32-unknown-emscripten.html#wasm32-unknown-emscripten","platform-support/wasm32-unknown-emscripten.html#target-maintainers","platform-support/wasm32-unknown-emscripten.html#requirements","platform-support/wasm32-unknown-emscripten.html#building-the-target","platform-support/wasm32-unknown-emscripten.html#building-rust-programs","platform-support/wasm32-unknown-emscripten.html#cross-compilation","platform-support/wasm32-unknown-emscripten.html#emscripten-abi-compatibility","platform-support/wasm32-unknown-emscripten.html#testing","platform-support/wasm32-unknown-emscripten.html#conditionally-compiling-code","platform-support/wasm32-unknown-emscripten.html#enabled-webassembly-features","platform-support/wasm32-unknown-unknown.html#wasm32-unknown-unknown","platform-support/wasm32-unknown-unknown.html#target-maintainers","platform-support/wasm32-unknown-unknown.html#requirements","platform-support/wasm32-unknown-unknown.html#building-the-target","platform-support/wasm32-unknown-unknown.html#building-rust-programs","platform-support/wasm32-unknown-unknown.html#cross-compilation","platform-support/wasm32-unknown-unknown.html#testing","platform-support/wasm32-unknown-unknown.html#conditionally-compiling-code","platform-support/wasm32-unknown-unknown.html#enabled-webassembly-features","platform-support/wasm32-unknown-unknown.html#unwinding","platform-support/wasm32v1-none.html#wasm32v1-none","platform-support/wasm32v1-none.html#target-maintainers","platform-support/wasm32v1-none.html#requirements","platform-support/wasm32v1-none.html#conditionally-compiling-code","platform-support/wasm32v1-none.html#enabled-webassembly-features","platform-support/wasm32v1-none.html#rationale-relative-to-wasm32-unknown-unknown","platform-support/wasm32v1-none.html#unwinding","platform-support/wasm64-unknown-unknown.html#wasm64-unknown-unknown","platform-support/wasm64-unknown-unknown.html#target-maintainers","platform-support/wasm64-unknown-unknown.html#requirements","platform-support/wasm64-unknown-unknown.html#building-the-target","platform-support/wasm64-unknown-unknown.html#building-rust-programs","platform-support/wasm64-unknown-unknown.html#testing","platform-support/wasm64-unknown-unknown.html#cross-compilation-toolchains-and-c-code","platform-support/windows-gnu.html#-windows-gnu","platform-support/windows-gnu.html#target-maintainers","platform-support/windows-gnu.html#requirements","platform-support/windows-gnu.html#building-rust-programs","platform-support/windows-gnullvm.html#-windows-gnullvm","platform-support/windows-gnullvm.html#target-maintainers","platform-support/windows-gnullvm.html#requirements","platform-support/windows-gnullvm.html#building-the-target","platform-support/windows-gnullvm.html#building-rust-programs","platform-support/windows-gnullvm.html#testing","platform-support/windows-gnullvm.html#cross-compilation-toolchains-and-c-code","platform-support/win7-windows-gnu.html#-win7-windows-gnu","platform-support/win7-windows-gnu.html#target-maintainers","platform-support/win7-windows-gnu.html#requirements","platform-support/win7-windows-gnu.html#building-the-target","platform-support/win7-windows-gnu.html#building-rust-programs","platform-support/win7-windows-gnu.html#testing","platform-support/win7-windows-gnu.html#cross-compilation-toolchains-and-c-code","platform-support/win7-windows-msvc.html#-win7-windows-msvc","platform-support/win7-windows-msvc.html#target-maintainers","platform-support/win7-windows-msvc.html#requirements","platform-support/win7-windows-msvc.html#building-the-target","platform-support/win7-windows-msvc.html#building-rust-programs","platform-support/win7-windows-msvc.html#testing","platform-support/win7-windows-msvc.html#cross-compilation-toolchains-and-c-code","platform-support/x86_64-fortanix-unknown-sgx.html#x86_64-fortanix-unknown-sgx","platform-support/x86_64-fortanix-unknown-sgx.html#target-maintainers","platform-support/x86_64-fortanix-unknown-sgx.html#requirements","platform-support/x86_64-fortanix-unknown-sgx.html#building-the-target","platform-support/x86_64-fortanix-unknown-sgx.html#building-rust-programs","platform-support/x86_64-fortanix-unknown-sgx.html#testing","platform-support/x86_64-fortanix-unknown-sgx.html#cross-compilation-toolchains-and-c-code","platform-support/x86_64-pc-cygwin.html#x86_64-pc-cygwin","platform-support/x86_64-pc-cygwin.html#target-maintainers","platform-support/x86_64-pc-cygwin.html#requirements","platform-support/x86_64-pc-cygwin.html#building-the-target","platform-support/x86_64-pc-cygwin.html#building-rust-programs","platform-support/x86_64-pc-cygwin.html#testing","platform-support/x86_64-pc-cygwin.html#cross-compilation-toolchains-and-c-code","platform-support/x86_64-unknown-linux-none.html#x86_64-unknown-linux-none","platform-support/x86_64-unknown-linux-none.html#target-maintainers","platform-support/x86_64-unknown-linux-none.html#requirements","platform-support/x86_64-unknown-linux-none.html#building-the-target","platform-support/x86_64-unknown-linux-none.html#building-rust-programs","platform-support/x86_64-unknown-linux-none.html#testing","platform-support/x86_64-unknown-linux-none.html#cross-compilation-toolchains-and-c-code","platform-support/x86_64-unknown-none.html#x86_64-unknown-none","platform-support/x86_64-unknown-none.html#target-maintainers","platform-support/x86_64-unknown-none.html#requirements","platform-support/x86_64-unknown-none.html#building-the-target","platform-support/x86_64-unknown-none.html#building-rust-programs","platform-support/x86_64-unknown-none.html#testing","platform-support/x86_64-unknown-none.html#cross-compilation-toolchains-and-c-code","platform-support/xtensa.html#xtensa--none-elf","platform-support/xtensa.html#target-maintainers","platform-support/xtensa.html#requirements","platform-support/xtensa.html#building-the-targets","platform-support/nuttx.html#-nuttx-elf","platform-support/nuttx.html#target-maintainers","platform-support/nuttx.html#requirements","platform-support/nuttx.html#building-the-target","platform-support/nuttx.html#testing","platform-support/nuttx.html#cross-compilation-toolchains-and-c-code"],"index":{"documentStore":{"docInfo":{"0":{"body":66,"breadcrumbs":2,"title":1},"1":{"body":78,"breadcrumbs":3,"title":2},"10":{"body":136,"breadcrumbs":6,"title":3},"100":{"body":209,"breadcrumbs":7,"title":2},"1000":{"body":38,"breadcrumbs":9,"title":2},"1001":{"body":24,"breadcrumbs":10,"title":3},"1002":{"body":17,"breadcrumbs":8,"title":1},"1003":{"body":20,"breadcrumbs":10,"title":3},"1004":{"body":1,"breadcrumbs":9,"title":2},"1005":{"body":67,"breadcrumbs":8,"title":1},"1006":{"body":10,"breadcrumbs":9,"title":2},"1007":{"body":24,"breadcrumbs":10,"title":3},"1008":{"body":21,"breadcrumbs":8,"title":1},"1009":{"body":40,"breadcrumbs":12,"title":5},"101":{"body":103,"breadcrumbs":7,"title":2},"1010":{"body":9,"breadcrumbs":10,"title":3},"1011":{"body":1,"breadcrumbs":9,"title":2},"1012":{"body":15,"breadcrumbs":8,"title":1},"1013":{"body":13,"breadcrumbs":9,"title":2},"1014":{"body":17,"breadcrumbs":10,"title":3},"1015":{"body":8,"breadcrumbs":8,"title":1},"1016":{"body":13,"breadcrumbs":12,"title":5},"1017":{"body":49,"breadcrumbs":6,"title":2},"1018":{"body":3,"breadcrumbs":6,"title":2},"1019":{"body":41,"breadcrumbs":5,"title":1},"102":{"body":12,"breadcrumbs":6,"title":1},"1020":{"body":20,"breadcrumbs":6,"title":2},"1021":{"body":53,"breadcrumbs":6,"title":2},"1022":{"body":60,"breadcrumbs":7,"title":3},"1023":{"body":42,"breadcrumbs":5,"title":1},"1024":{"body":25,"breadcrumbs":10,"title":3},"1025":{"body":3,"breadcrumbs":9,"title":2},"1026":{"body":43,"breadcrumbs":8,"title":1},"1027":{"body":23,"breadcrumbs":9,"title":2},"1028":{"body":21,"breadcrumbs":9,"title":2},"1029":{"body":13,"breadcrumbs":8,"title":1},"103":{"body":106,"breadcrumbs":6,"title":1},"1030":{"body":39,"breadcrumbs":10,"title":3},"1031":{"body":24,"breadcrumbs":8,"title":1},"1032":{"body":5,"breadcrumbs":10,"title":3},"1033":{"body":1,"breadcrumbs":9,"title":2},"1034":{"body":7,"breadcrumbs":8,"title":1},"1035":{"body":13,"breadcrumbs":9,"title":2},"1036":{"body":17,"breadcrumbs":10,"title":3},"1037":{"body":8,"breadcrumbs":8,"title":1},"1038":{"body":13,"breadcrumbs":12,"title":5},"1039":{"body":26,"breadcrumbs":6,"title":2},"104":{"body":29,"breadcrumbs":7,"title":2},"1040":{"body":2,"breadcrumbs":6,"title":2},"1041":{"body":41,"breadcrumbs":5,"title":1},"1042":{"body":32,"breadcrumbs":6,"title":2},"1043":{"body":62,"breadcrumbs":8,"title":4},"1044":{"body":27,"breadcrumbs":6,"title":2},"1045":{"body":3,"breadcrumbs":7,"title":3},"1046":{"body":3,"breadcrumbs":5,"title":1},"1047":{"body":5,"breadcrumbs":10,"title":3},"1048":{"body":1,"breadcrumbs":9,"title":2},"1049":{"body":12,"breadcrumbs":8,"title":1},"105":{"body":34,"breadcrumbs":7,"title":2},"1050":{"body":13,"breadcrumbs":9,"title":2},"1051":{"body":17,"breadcrumbs":10,"title":3},"1052":{"body":8,"breadcrumbs":8,"title":1},"1053":{"body":13,"breadcrumbs":12,"title":5},"1054":{"body":42,"breadcrumbs":6,"title":2},"1055":{"body":5,"breadcrumbs":6,"title":2},"1056":{"body":41,"breadcrumbs":5,"title":1},"1057":{"body":20,"breadcrumbs":6,"title":2},"1058":{"body":27,"breadcrumbs":6,"title":2},"1059":{"body":3,"breadcrumbs":7,"title":3},"106":{"body":134,"breadcrumbs":7,"title":2},"1060":{"body":3,"breadcrumbs":5,"title":1},"1061":{"body":20,"breadcrumbs":6,"title":2},"1062":{"body":2,"breadcrumbs":6,"title":2},"1063":{"body":36,"breadcrumbs":5,"title":1},"1064":{"body":20,"breadcrumbs":6,"title":2},"1065":{"body":33,"breadcrumbs":6,"title":2},"1066":{"body":3,"breadcrumbs":7,"title":3},"1067":{"body":3,"breadcrumbs":5,"title":1},"1068":{"body":12,"breadcrumbs":9,"title":5},"1069":{"body":7,"breadcrumbs":10,"title":4},"107":{"body":115,"breadcrumbs":6,"title":1},"1070":{"body":2,"breadcrumbs":8,"title":2},"1071":{"body":6,"breadcrumbs":7,"title":1},"1072":{"body":14,"breadcrumbs":7,"title":1},"1073":{"body":4,"breadcrumbs":8,"title":2},"1074":{"body":7,"breadcrumbs":7,"title":1},"1075":{"body":33,"breadcrumbs":9,"title":3},"1076":{"body":16,"breadcrumbs":10,"title":4},"1077":{"body":4,"breadcrumbs":8,"title":2},"1078":{"body":13,"breadcrumbs":7,"title":1},"1079":{"body":45,"breadcrumbs":8,"title":2},"108":{"body":38,"breadcrumbs":8,"title":3},"1080":{"body":8,"breadcrumbs":9,"title":3},"1081":{"body":4,"breadcrumbs":8,"title":2},"1082":{"body":13,"breadcrumbs":7,"title":1},"1083":{"body":13,"breadcrumbs":10,"title":4},"1084":{"body":2,"breadcrumbs":8,"title":2},"1085":{"body":13,"breadcrumbs":7,"title":1},"1086":{"body":43,"breadcrumbs":8,"title":2},"1087":{"body":8,"breadcrumbs":9,"title":3},"1088":{"body":4,"breadcrumbs":8,"title":2},"1089":{"body":13,"breadcrumbs":7,"title":1},"109":{"body":44,"breadcrumbs":7,"title":2},"1090":{"body":38,"breadcrumbs":12,"title":7},"1091":{"body":11,"breadcrumbs":7,"title":2},"1092":{"body":80,"breadcrumbs":10,"title":5},"1093":{"body":77,"breadcrumbs":6,"title":1},"1094":{"body":14,"breadcrumbs":10,"title":5},"1095":{"body":24,"breadcrumbs":10,"title":5},"1096":{"body":14,"breadcrumbs":10,"title":4},"1097":{"body":1,"breadcrumbs":8,"title":2},"1098":{"body":109,"breadcrumbs":7,"title":1},"1099":{"body":14,"breadcrumbs":8,"title":2},"11":{"body":75,"breadcrumbs":10,"title":7},"110":{"body":102,"breadcrumbs":7,"title":2},"1100":{"body":18,"breadcrumbs":9,"title":3},"1101":{"body":73,"breadcrumbs":8,"title":2},"1102":{"body":12,"breadcrumbs":7,"title":1},"1103":{"body":8,"breadcrumbs":10,"title":4},"1104":{"body":2,"breadcrumbs":8,"title":2},"1105":{"body":35,"breadcrumbs":7,"title":1},"1106":{"body":54,"breadcrumbs":8,"title":2},"1107":{"body":10,"breadcrumbs":7,"title":1},"1108":{"body":9,"breadcrumbs":8,"title":3},"1109":{"body":1,"breadcrumbs":7,"title":2},"111":{"body":49,"breadcrumbs":7,"title":2},"1110":{"body":80,"breadcrumbs":6,"title":1},"1111":{"body":3,"breadcrumbs":7,"title":2},"1112":{"body":114,"breadcrumbs":8,"title":3},"1113":{"body":32,"breadcrumbs":8,"title":3},"1114":{"body":6,"breadcrumbs":7,"title":2},"1115":{"body":0,"breadcrumbs":8,"title":3},"1116":{"body":30,"breadcrumbs":8,"title":3},"1117":{"body":51,"breadcrumbs":9,"title":4},"1118":{"body":33,"breadcrumbs":9,"title":4},"1119":{"body":283,"breadcrumbs":7,"title":2},"112":{"body":73,"breadcrumbs":2,"title":1},"1120":{"body":154,"breadcrumbs":10,"title":5},"1121":{"body":106,"breadcrumbs":6,"title":1},"1122":{"body":103,"breadcrumbs":8,"title":3},"1123":{"body":17,"breadcrumbs":6,"title":1},"1124":{"body":43,"breadcrumbs":10,"title":5},"1125":{"body":36,"breadcrumbs":14,"title":6},"1126":{"body":2,"breadcrumbs":10,"title":2},"1127":{"body":35,"breadcrumbs":9,"title":1},"1128":{"body":47,"breadcrumbs":11,"title":3},"1129":{"body":1,"breadcrumbs":10,"title":2},"113":{"body":11,"breadcrumbs":4,"title":3},"1130":{"body":31,"breadcrumbs":9,"title":1},"1131":{"body":56,"breadcrumbs":14,"title":6},"1132":{"body":11,"breadcrumbs":10,"title":2},"1133":{"body":159,"breadcrumbs":9,"title":1},"1134":{"body":31,"breadcrumbs":13,"title":5},"1135":{"body":43,"breadcrumbs":14,"title":6},"1136":{"body":12,"breadcrumbs":10,"title":2},"1137":{"body":55,"breadcrumbs":9,"title":1},"1138":{"body":31,"breadcrumbs":13,"title":5},"1139":{"body":61,"breadcrumbs":14,"title":6},"114":{"body":87,"breadcrumbs":3,"title":2},"1140":{"body":1,"breadcrumbs":10,"title":2},"1141":{"body":94,"breadcrumbs":9,"title":1},"1142":{"body":31,"breadcrumbs":13,"title":5},"1143":{"body":42,"breadcrumbs":11,"title":3},"1144":{"body":12,"breadcrumbs":10,"title":2},"1145":{"body":73,"breadcrumbs":9,"title":1},"1146":{"body":52,"breadcrumbs":14,"title":6},"1147":{"body":63,"breadcrumbs":11,"title":3},"1148":{"body":7,"breadcrumbs":10,"title":2},"1149":{"body":8,"breadcrumbs":13,"title":5},"115":{"body":47,"breadcrumbs":2,"title":1},"1150":{"body":21,"breadcrumbs":11,"title":3},"1151":{"body":10,"breadcrumbs":11,"title":3},"1152":{"body":10,"breadcrumbs":11,"title":3},"1153":{"body":10,"breadcrumbs":11,"title":3},"1154":{"body":52,"breadcrumbs":14,"title":6},"1155":{"body":11,"breadcrumbs":10,"title":2},"1156":{"body":8,"breadcrumbs":13,"title":5},"1157":{"body":43,"breadcrumbs":14,"title":6},"1158":{"body":47,"breadcrumbs":14,"title":6},"1159":{"body":33,"breadcrumbs":14,"title":6},"116":{"body":70,"breadcrumbs":2,"title":1},"1160":{"body":44,"breadcrumbs":14,"title":6},"1161":{"body":57,"breadcrumbs":11,"title":3},"1162":{"body":11,"breadcrumbs":10,"title":2},"1163":{"body":8,"breadcrumbs":13,"title":5},"1164":{"body":11,"breadcrumbs":11,"title":3},"1165":{"body":10,"breadcrumbs":11,"title":3},"1166":{"body":59,"breadcrumbs":11,"title":3},"1167":{"body":11,"breadcrumbs":10,"title":2},"1168":{"body":8,"breadcrumbs":13,"title":5},"1169":{"body":11,"breadcrumbs":11,"title":3},"117":{"body":124,"breadcrumbs":4,"title":3},"1170":{"body":10,"breadcrumbs":11,"title":3},"1171":{"body":53,"breadcrumbs":14,"title":6},"1172":{"body":11,"breadcrumbs":10,"title":2},"1173":{"body":8,"breadcrumbs":13,"title":5},"1174":{"body":137,"breadcrumbs":14,"title":6},"1175":{"body":126,"breadcrumbs":14,"title":6},"1176":{"body":32,"breadcrumbs":11,"title":3},"1177":{"body":32,"breadcrumbs":11,"title":3},"1178":{"body":72,"breadcrumbs":11,"title":3},"1179":{"body":72,"breadcrumbs":11,"title":3},"118":{"body":33,"breadcrumbs":5,"title":2},"1180":{"body":155,"breadcrumbs":9,"title":4},"1181":{"body":293,"breadcrumbs":7,"title":2},"1182":{"body":177,"breadcrumbs":7,"title":2},"1183":{"body":284,"breadcrumbs":7,"title":2},"1184":{"body":21,"breadcrumbs":13,"title":4},"1185":{"body":45,"breadcrumbs":10,"title":1},"1186":{"body":26,"breadcrumbs":10,"title":1},"1187":{"body":1,"breadcrumbs":11,"title":2},"1188":{"body":15,"breadcrumbs":10,"title":1},"1189":{"body":15,"breadcrumbs":11,"title":2},"119":{"body":33,"breadcrumbs":4,"title":1},"1190":{"body":141,"breadcrumbs":11,"title":2},"1191":{"body":32,"breadcrumbs":12,"title":3},"1192":{"body":21,"breadcrumbs":13,"title":4},"1193":{"body":5,"breadcrumbs":11,"title":2},"1194":{"body":9,"breadcrumbs":10,"title":1},"1195":{"body":6,"breadcrumbs":11,"title":2},"1196":{"body":18,"breadcrumbs":12,"title":3},"1197":{"body":26,"breadcrumbs":17,"title":8},"1198":{"body":4,"breadcrumbs":11,"title":2},"1199":{"body":13,"breadcrumbs":10,"title":1},"12":{"body":4,"breadcrumbs":10,"title":7},"120":{"body":75,"breadcrumbs":4,"title":1},"1200":{"body":49,"breadcrumbs":11,"title":2},"1201":{"body":8,"breadcrumbs":12,"title":3},"1202":{"body":4,"breadcrumbs":11,"title":2},"1203":{"body":13,"breadcrumbs":10,"title":1},"1204":{"body":31,"breadcrumbs":13,"title":4},"1205":{"body":1,"breadcrumbs":11,"title":2},"1206":{"body":11,"breadcrumbs":10,"title":1},"1207":{"body":150,"breadcrumbs":11,"title":2},"1208":{"body":9,"breadcrumbs":12,"title":3},"1209":{"body":81,"breadcrumbs":11,"title":2},"121":{"body":42,"breadcrumbs":4,"title":1},"1210":{"body":116,"breadcrumbs":11,"title":2},"1211":{"body":63,"breadcrumbs":11,"title":2},"1212":{"body":91,"breadcrumbs":11,"title":2},"1213":{"body":28,"breadcrumbs":13,"title":4},"1214":{"body":1,"breadcrumbs":11,"title":2},"1215":{"body":17,"breadcrumbs":10,"title":1},"1216":{"body":0,"breadcrumbs":10,"title":1},"1217":{"body":25,"breadcrumbs":11,"title":2},"1218":{"body":30,"breadcrumbs":11,"title":2},"1219":{"body":6,"breadcrumbs":10,"title":1},"122":{"body":36,"breadcrumbs":5,"title":2},"1220":{"body":84,"breadcrumbs":13,"title":4},"1221":{"body":21,"breadcrumbs":8,"title":3},"1222":{"body":10,"breadcrumbs":7,"title":2},"1223":{"body":107,"breadcrumbs":6,"title":1},"1224":{"body":64,"breadcrumbs":7,"title":2},"1225":{"body":93,"breadcrumbs":8,"title":3},"1226":{"body":54,"breadcrumbs":6,"title":1},"1227":{"body":49,"breadcrumbs":10,"title":5},"1228":{"body":21,"breadcrumbs":8,"title":3},"1229":{"body":1,"breadcrumbs":7,"title":2},"123":{"body":62,"breadcrumbs":4,"title":1},"1230":{"body":52,"breadcrumbs":6,"title":1},"1231":{"body":5,"breadcrumbs":7,"title":2},"1232":{"body":47,"breadcrumbs":8,"title":3},"1233":{"body":49,"breadcrumbs":6,"title":1},"1234":{"body":23,"breadcrumbs":10,"title":5},"1235":{"body":22,"breadcrumbs":10,"title":4},"1236":{"body":3,"breadcrumbs":8,"title":2},"1237":{"body":51,"breadcrumbs":7,"title":1},"1238":{"body":24,"breadcrumbs":8,"title":2},"1239":{"body":84,"breadcrumbs":9,"title":3},"124":{"body":44,"breadcrumbs":4,"title":1},"1240":{"body":35,"breadcrumbs":7,"title":1},"1241":{"body":12,"breadcrumbs":8,"title":2},"1242":{"body":24,"breadcrumbs":8,"title":3},"1243":{"body":11,"breadcrumbs":7,"title":2},"1244":{"body":162,"breadcrumbs":6,"title":1},"1245":{"body":16,"breadcrumbs":7,"title":2},"1246":{"body":136,"breadcrumbs":8,"title":3},"1247":{"body":26,"breadcrumbs":6,"title":1},"1248":{"body":8,"breadcrumbs":10,"title":5},"1249":{"body":10,"breadcrumbs":8,"title":4},"125":{"body":38,"breadcrumbs":6,"title":3},"1250":{"body":3,"breadcrumbs":6,"title":2},"1251":{"body":22,"breadcrumbs":5,"title":1},"1252":{"body":26,"breadcrumbs":7,"title":3},"1253":{"body":46,"breadcrumbs":6,"title":2},"1254":{"body":0,"breadcrumbs":6,"title":2},"1255":{"body":40,"breadcrumbs":7,"title":3},"1256":{"body":18,"breadcrumbs":9,"title":5},"1257":{"body":26,"breadcrumbs":7,"title":3},"1258":{"body":2,"breadcrumbs":6,"title":2},"1259":{"body":16,"breadcrumbs":5,"title":1},"126":{"body":192,"breadcrumbs":6,"title":3},"1260":{"body":27,"breadcrumbs":6,"title":2},"1261":{"body":148,"breadcrumbs":5,"title":1},"1262":{"body":75,"breadcrumbs":7,"title":3},"1263":{"body":112,"breadcrumbs":7,"title":3},"1264":{"body":13,"breadcrumbs":5,"title":1},"1265":{"body":8,"breadcrumbs":9,"title":5},"1266":{"body":10,"breadcrumbs":12,"title":8},"1267":{"body":1,"breadcrumbs":6,"title":2},"1268":{"body":13,"breadcrumbs":5,"title":1},"1269":{"body":14,"breadcrumbs":6,"title":2},"127":{"body":115,"breadcrumbs":5,"title":2},"1270":{"body":24,"breadcrumbs":7,"title":3},"1271":{"body":6,"breadcrumbs":5,"title":1},"1272":{"body":14,"breadcrumbs":9,"title":5},"1273":{"body":87,"breadcrumbs":8,"title":3},"1274":{"body":3,"breadcrumbs":7,"title":2},"1275":{"body":61,"breadcrumbs":6,"title":1},"1276":{"body":104,"breadcrumbs":7,"title":2},"1277":{"body":41,"breadcrumbs":8,"title":3},"1278":{"body":11,"breadcrumbs":6,"title":1},"1279":{"body":8,"breadcrumbs":6,"title":2},"128":{"body":95,"breadcrumbs":5,"title":2},"1280":{"body":1,"breadcrumbs":6,"title":2},"1281":{"body":51,"breadcrumbs":5,"title":1},"1282":{"body":8,"breadcrumbs":6,"title":2},"1283":{"body":83,"breadcrumbs":7,"title":3},"1284":{"body":21,"breadcrumbs":5,"title":1},"1285":{"body":12,"breadcrumbs":4,"title":1},"1286":{"body":3,"breadcrumbs":5,"title":2},"1287":{"body":79,"breadcrumbs":4,"title":1},"1288":{"body":47,"breadcrumbs":5,"title":2},"1289":{"body":17,"breadcrumbs":8,"title":5},"129":{"body":253,"breadcrumbs":7,"title":4},"1290":{"body":13,"breadcrumbs":10,"title":6},"1291":{"body":10,"breadcrumbs":6,"title":2},"1292":{"body":73,"breadcrumbs":6,"title":2},"1293":{"body":38,"breadcrumbs":5,"title":1},"1294":{"body":22,"breadcrumbs":6,"title":2},"1295":{"body":23,"breadcrumbs":9,"title":5},"1296":{"body":183,"breadcrumbs":8,"title":4},"1297":{"body":321,"breadcrumbs":9,"title":5},"1298":{"body":149,"breadcrumbs":7,"title":3},"1299":{"body":75,"breadcrumbs":7,"title":3},"13":{"body":14,"breadcrumbs":7,"title":4},"130":{"body":510,"breadcrumbs":5,"title":2},"1300":{"body":44,"breadcrumbs":7,"title":3},"1301":{"body":14,"breadcrumbs":7,"title":3},"1302":{"body":20,"breadcrumbs":8,"title":4},"1303":{"body":10,"breadcrumbs":8,"title":4},"1304":{"body":39,"breadcrumbs":8,"title":4},"1305":{"body":17,"breadcrumbs":7,"title":3},"1306":{"body":14,"breadcrumbs":7,"title":3},"1307":{"body":38,"breadcrumbs":7,"title":3},"1308":{"body":26,"breadcrumbs":7,"title":3},"1309":{"body":13,"breadcrumbs":6,"title":2},"131":{"body":14,"breadcrumbs":5,"title":2},"1310":{"body":0,"breadcrumbs":5,"title":1},"1311":{"body":107,"breadcrumbs":7,"title":3},"1312":{"body":221,"breadcrumbs":8,"title":4},"1313":{"body":0,"breadcrumbs":5,"title":1},"1314":{"body":20,"breadcrumbs":5,"title":1},"1315":{"body":43,"breadcrumbs":6,"title":2},"1316":{"body":124,"breadcrumbs":6,"title":2},"1317":{"body":74,"breadcrumbs":8,"title":4},"1318":{"body":178,"breadcrumbs":8,"title":4},"1319":{"body":12,"breadcrumbs":10,"title":6},"132":{"body":91,"breadcrumbs":9,"title":3},"1320":{"body":2,"breadcrumbs":6,"title":2},"1321":{"body":36,"breadcrumbs":5,"title":1},"1322":{"body":17,"breadcrumbs":6,"title":2},"1323":{"body":19,"breadcrumbs":7,"title":3},"1324":{"body":22,"breadcrumbs":5,"title":1},"1325":{"body":10,"breadcrumbs":9,"title":5},"1326":{"body":59,"breadcrumbs":6,"title":2},"1327":{"body":1,"breadcrumbs":6,"title":2},"1328":{"body":20,"breadcrumbs":5,"title":1},"1329":{"body":35,"breadcrumbs":5,"title":1},"133":{"body":15,"breadcrumbs":10,"title":4},"1330":{"body":4,"breadcrumbs":6,"title":2},"1331":{"body":7,"breadcrumbs":5,"title":1},"1332":{"body":43,"breadcrumbs":7,"title":3},"1333":{"body":52,"breadcrumbs":10,"title":4},"1334":{"body":1,"breadcrumbs":8,"title":2},"1335":{"body":0,"breadcrumbs":7,"title":1},"1336":{"body":0,"breadcrumbs":8,"title":2},"1337":{"body":24,"breadcrumbs":8,"title":2},"1338":{"body":50,"breadcrumbs":8,"title":2},"1339":{"body":6,"breadcrumbs":7,"title":1},"134":{"body":55,"breadcrumbs":7,"title":1},"1340":{"body":98,"breadcrumbs":10,"title":4},"1341":{"body":23,"breadcrumbs":10,"title":4},"1342":{"body":1,"breadcrumbs":8,"title":2},"1343":{"body":104,"breadcrumbs":7,"title":1},"1344":{"body":92,"breadcrumbs":8,"title":2},"1345":{"body":7,"breadcrumbs":7,"title":1},"1346":{"body":103,"breadcrumbs":9,"title":3},"1347":{"body":17,"breadcrumbs":10,"title":4},"1348":{"body":1,"breadcrumbs":8,"title":2},"1349":{"body":44,"breadcrumbs":7,"title":1},"135":{"body":100,"breadcrumbs":7,"title":1},"1350":{"body":70,"breadcrumbs":8,"title":2},"1351":{"body":24,"breadcrumbs":9,"title":3},"1352":{"body":16,"breadcrumbs":7,"title":1},"1353":{"body":32,"breadcrumbs":11,"title":5},"1354":{"body":190,"breadcrumbs":8,"title":2},"1355":{"body":215,"breadcrumbs":8,"title":2},"1356":{"body":22,"breadcrumbs":9,"title":6},"1357":{"body":2,"breadcrumbs":5,"title":2},"1358":{"body":27,"breadcrumbs":4,"title":1},"1359":{"body":12,"breadcrumbs":5,"title":2},"136":{"body":12,"breadcrumbs":9,"title":3},"1360":{"body":25,"breadcrumbs":6,"title":3},"1361":{"body":6,"breadcrumbs":4,"title":1},"1362":{"body":21,"breadcrumbs":8,"title":5},"1363":{"body":63,"breadcrumbs":8,"title":3},"1364":{"body":2,"breadcrumbs":7,"title":2},"1365":{"body":0,"breadcrumbs":6,"title":1},"1366":{"body":43,"breadcrumbs":7,"title":2},"1367":{"body":66,"breadcrumbs":7,"title":2},"1368":{"body":11,"breadcrumbs":7,"title":2},"1369":{"body":84,"breadcrumbs":6,"title":1},"137":{"body":72,"breadcrumbs":7,"title":1},"1370":{"body":95,"breadcrumbs":7,"title":2},"1371":{"body":15,"breadcrumbs":6,"title":1},"1372":{"body":62,"breadcrumbs":8,"title":3},"1373":{"body":66,"breadcrumbs":8,"title":3},"1374":{"body":2,"breadcrumbs":7,"title":2},"1375":{"body":135,"breadcrumbs":6,"title":1},"1376":{"body":27,"breadcrumbs":7,"title":2},"1377":{"body":12,"breadcrumbs":6,"title":1},"1378":{"body":0,"breadcrumbs":8,"title":3},"1379":{"body":30,"breadcrumbs":8,"title":3},"138":{"body":16,"breadcrumbs":7,"title":1},"1380":{"body":44,"breadcrumbs":8,"title":3},"1381":{"body":72,"breadcrumbs":10,"title":5},"1382":{"body":31,"breadcrumbs":4,"title":1},"1383":{"body":2,"breadcrumbs":5,"title":2},"1384":{"body":28,"breadcrumbs":4,"title":1},"1385":{"body":18,"breadcrumbs":5,"title":2},"1386":{"body":93,"breadcrumbs":6,"title":3},"1387":{"body":39,"breadcrumbs":4,"title":1},"1388":{"body":11,"breadcrumbs":8,"title":5},"1389":{"body":5,"breadcrumbs":10,"title":4},"139":{"body":6,"breadcrumbs":8,"title":2},"1390":{"body":2,"breadcrumbs":8,"title":2},"1391":{"body":166,"breadcrumbs":7,"title":1},"1392":{"body":14,"breadcrumbs":7,"title":1},"1393":{"body":14,"breadcrumbs":8,"title":2},"1394":{"body":7,"breadcrumbs":7,"title":1},"1395":{"body":34,"breadcrumbs":9,"title":3},"1396":{"body":6,"breadcrumbs":10,"title":4},"1397":{"body":1,"breadcrumbs":8,"title":2},"1398":{"body":168,"breadcrumbs":7,"title":1},"1399":{"body":16,"breadcrumbs":7,"title":1},"14":{"body":137,"breadcrumbs":9,"title":6},"140":{"body":10,"breadcrumbs":10,"title":4},"1400":{"body":14,"breadcrumbs":8,"title":2},"1401":{"body":7,"breadcrumbs":7,"title":1},"1402":{"body":78,"breadcrumbs":9,"title":3},"1403":{"body":2,"breadcrumbs":10,"title":4},"1404":{"body":2,"breadcrumbs":8,"title":2},"1405":{"body":28,"breadcrumbs":7,"title":1},"1406":{"body":12,"breadcrumbs":8,"title":2},"1407":{"body":17,"breadcrumbs":9,"title":3},"1408":{"body":16,"breadcrumbs":7,"title":1},"1409":{"body":15,"breadcrumbs":10,"title":4},"141":{"body":49,"breadcrumbs":7,"title":1},"1410":{"body":1,"breadcrumbs":8,"title":2},"1411":{"body":13,"breadcrumbs":7,"title":1},"1412":{"body":43,"breadcrumbs":8,"title":2},"1413":{"body":18,"breadcrumbs":9,"title":3},"1414":{"body":4,"breadcrumbs":8,"title":2},"1415":{"body":13,"breadcrumbs":7,"title":1},"1416":{"body":6,"breadcrumbs":8,"title":3},"1417":{"body":1,"breadcrumbs":7,"title":2},"1418":{"body":6,"breadcrumbs":6,"title":1},"1419":{"body":13,"breadcrumbs":6,"title":1},"142":{"body":46,"breadcrumbs":7,"title":1},"1420":{"body":4,"breadcrumbs":7,"title":2},"1421":{"body":7,"breadcrumbs":6,"title":1},"1422":{"body":50,"breadcrumbs":8,"title":3},"1423":{"body":9,"breadcrumbs":10,"title":4},"1424":{"body":1,"breadcrumbs":8,"title":2},"1425":{"body":8,"breadcrumbs":7,"title":1},"1426":{"body":28,"breadcrumbs":8,"title":2},"1427":{"body":17,"breadcrumbs":9,"title":3},"1428":{"body":17,"breadcrumbs":10,"title":4},"1429":{"body":1,"breadcrumbs":8,"title":2},"143":{"body":9,"breadcrumbs":9,"title":3},"1430":{"body":19,"breadcrumbs":7,"title":1},"1431":{"body":22,"breadcrumbs":7,"title":1},"1432":{"body":21,"breadcrumbs":11,"title":5},"1433":{"body":86,"breadcrumbs":10,"title":4},"1434":{"body":4,"breadcrumbs":8,"title":2},"1435":{"body":0,"breadcrumbs":7,"title":1},"1436":{"body":23,"breadcrumbs":8,"title":2},"1437":{"body":87,"breadcrumbs":8,"title":2},"1438":{"body":16,"breadcrumbs":7,"title":1},"1439":{"body":21,"breadcrumbs":9,"title":3},"144":{"body":84,"breadcrumbs":7,"title":1},"1440":{"body":45,"breadcrumbs":11,"title":5},"1441":{"body":42,"breadcrumbs":9,"title":3},"1442":{"body":84,"breadcrumbs":8,"title":2},"1443":{"body":82,"breadcrumbs":7,"title":1},"1444":{"body":19,"breadcrumbs":9,"title":3},"1445":{"body":50,"breadcrumbs":7,"title":1},"1446":{"body":22,"breadcrumbs":12,"title":6},"1447":{"body":11,"breadcrumbs":8,"title":3},"1448":{"body":2,"breadcrumbs":7,"title":2},"1449":{"body":59,"breadcrumbs":6,"title":1},"145":{"body":79,"breadcrumbs":7,"title":1},"1450":{"body":102,"breadcrumbs":7,"title":2},"1451":{"body":69,"breadcrumbs":8,"title":3},"1452":{"body":10,"breadcrumbs":7,"title":2},"1453":{"body":61,"breadcrumbs":10,"title":4},"1454":{"body":5,"breadcrumbs":8,"title":2},"1455":{"body":40,"breadcrumbs":10,"title":4},"1456":{"body":1,"breadcrumbs":8,"title":2},"1457":{"body":18,"breadcrumbs":7,"title":1},"1458":{"body":14,"breadcrumbs":8,"title":2},"1459":{"body":24,"breadcrumbs":9,"title":3},"146":{"body":30,"breadcrumbs":9,"title":3},"1460":{"body":8,"breadcrumbs":7,"title":1},"1461":{"body":11,"breadcrumbs":8,"title":3},"1462":{"body":2,"breadcrumbs":7,"title":2},"1463":{"body":37,"breadcrumbs":6,"title":1},"1464":{"body":12,"breadcrumbs":6,"title":1},"1465":{"body":23,"breadcrumbs":8,"title":3},"1466":{"body":18,"breadcrumbs":10,"title":4},"1467":{"body":3,"breadcrumbs":8,"title":2},"1468":{"body":13,"breadcrumbs":7,"title":1},"1469":{"body":43,"breadcrumbs":8,"title":2},"147":{"body":64,"breadcrumbs":7,"title":1},"1470":{"body":18,"breadcrumbs":9,"title":3},"1471":{"body":4,"breadcrumbs":8,"title":2},"1472":{"body":13,"breadcrumbs":7,"title":1},"1473":{"body":10,"breadcrumbs":10,"title":4},"1474":{"body":2,"breadcrumbs":8,"title":2},"1475":{"body":13,"breadcrumbs":7,"title":1},"1476":{"body":43,"breadcrumbs":8,"title":2},"1477":{"body":7,"breadcrumbs":9,"title":3},"1478":{"body":4,"breadcrumbs":8,"title":2},"1479":{"body":13,"breadcrumbs":7,"title":1},"148":{"body":34,"breadcrumbs":7,"title":1},"1480":{"body":13,"breadcrumbs":10,"title":4},"1481":{"body":3,"breadcrumbs":8,"title":2},"1482":{"body":13,"breadcrumbs":7,"title":1},"1483":{"body":43,"breadcrumbs":8,"title":2},"1484":{"body":8,"breadcrumbs":9,"title":3},"1485":{"body":4,"breadcrumbs":8,"title":2},"1486":{"body":13,"breadcrumbs":7,"title":1},"1487":{"body":12,"breadcrumbs":10,"title":4},"1488":{"body":1,"breadcrumbs":8,"title":2},"1489":{"body":17,"breadcrumbs":7,"title":1},"149":{"body":10,"breadcrumbs":9,"title":3},"1490":{"body":6,"breadcrumbs":8,"title":2},"1491":{"body":16,"breadcrumbs":7,"title":1},"1492":{"body":17,"breadcrumbs":11,"title":5},"1493":{"body":24,"breadcrumbs":10,"title":4},"1494":{"body":7,"breadcrumbs":8,"title":2},"1495":{"body":31,"breadcrumbs":7,"title":1},"1496":{"body":6,"breadcrumbs":8,"title":2},"1497":{"body":16,"breadcrumbs":7,"title":1},"1498":{"body":17,"breadcrumbs":11,"title":5},"1499":{"body":13,"breadcrumbs":10,"title":4},"15":{"body":39,"breadcrumbs":8,"title":5},"150":{"body":28,"breadcrumbs":11,"title":5},"1500":{"body":2,"breadcrumbs":8,"title":2},"1501":{"body":61,"breadcrumbs":7,"title":1},"1502":{"body":72,"breadcrumbs":7,"title":1},"1503":{"body":59,"breadcrumbs":8,"title":2},"1504":{"body":38,"breadcrumbs":9,"title":3},"1505":{"body":63,"breadcrumbs":7,"title":1},"1506":{"body":24,"breadcrumbs":11,"title":5},"1507":{"body":24,"breadcrumbs":10,"title":4},"1508":{"body":1,"breadcrumbs":8,"title":2},"1509":{"body":28,"breadcrumbs":7,"title":1},"151":{"body":56,"breadcrumbs":7,"title":1},"1510":{"body":33,"breadcrumbs":8,"title":2},"1511":{"body":30,"breadcrumbs":9,"title":3},"1512":{"body":4,"breadcrumbs":8,"title":2},"1513":{"body":7,"breadcrumbs":7,"title":1},"1514":{"body":18,"breadcrumbs":10,"title":4},"1515":{"body":7,"breadcrumbs":8,"title":2},"1516":{"body":10,"breadcrumbs":7,"title":1},"1517":{"body":23,"breadcrumbs":8,"title":2},"1518":{"body":35,"breadcrumbs":9,"title":3},"1519":{"body":18,"breadcrumbs":7,"title":1},"152":{"body":141,"breadcrumbs":7,"title":1},"1520":{"body":180,"breadcrumbs":11,"title":5},"1521":{"body":10,"breadcrumbs":10,"title":4},"1522":{"body":2,"breadcrumbs":8,"title":2},"1523":{"body":10,"breadcrumbs":7,"title":1},"1524":{"body":43,"breadcrumbs":8,"title":2},"1525":{"body":8,"breadcrumbs":9,"title":3},"1526":{"body":4,"breadcrumbs":8,"title":2},"1527":{"body":10,"breadcrumbs":7,"title":1},"1528":{"body":15,"breadcrumbs":10,"title":4},"1529":{"body":2,"breadcrumbs":8,"title":2},"153":{"body":8,"breadcrumbs":9,"title":3},"1530":{"body":20,"breadcrumbs":7,"title":1},"1531":{"body":18,"breadcrumbs":8,"title":2},"1532":{"body":26,"breadcrumbs":9,"title":3},"1533":{"body":14,"breadcrumbs":10,"title":4},"1534":{"body":2,"breadcrumbs":8,"title":2},"1535":{"body":40,"breadcrumbs":7,"title":1},"1536":{"body":23,"breadcrumbs":8,"title":2},"1537":{"body":34,"breadcrumbs":9,"title":3},"1538":{"body":77,"breadcrumbs":7,"title":1},"1539":{"body":138,"breadcrumbs":11,"title":5},"154":{"body":7,"breadcrumbs":9,"title":3},"1540":{"body":12,"breadcrumbs":10,"title":4},"1541":{"body":1,"breadcrumbs":8,"title":2},"1542":{"body":40,"breadcrumbs":7,"title":1},"1543":{"body":27,"breadcrumbs":8,"title":2},"1544":{"body":18,"breadcrumbs":9,"title":3},"1545":{"body":18,"breadcrumbs":7,"title":1},"1546":{"body":95,"breadcrumbs":11,"title":5},"1547":{"body":26,"breadcrumbs":10,"title":4},"1548":{"body":1,"breadcrumbs":8,"title":2},"1549":{"body":70,"breadcrumbs":7,"title":1},"155":{"body":40,"breadcrumbs":7,"title":1},"1550":{"body":33,"breadcrumbs":8,"title":2},"1551":{"body":44,"breadcrumbs":9,"title":3},"1552":{"body":16,"breadcrumbs":7,"title":1},"1553":{"body":346,"breadcrumbs":11,"title":5},"1554":{"body":0,"breadcrumbs":6,"title":3},"1555":{"body":6,"breadcrumbs":6,"title":3},"1556":{"body":2,"breadcrumbs":5,"title":2},"1557":{"body":20,"breadcrumbs":4,"title":1},"1558":{"body":39,"breadcrumbs":4,"title":1},"1559":{"body":22,"breadcrumbs":6,"title":2},"156":{"body":30,"breadcrumbs":7,"title":1},"1560":{"body":6,"breadcrumbs":6,"title":2},"1561":{"body":212,"breadcrumbs":5,"title":1},"1562":{"body":67,"breadcrumbs":8,"title":4},"1563":{"body":95,"breadcrumbs":7,"title":3},"1564":{"body":36,"breadcrumbs":6,"title":2},"1565":{"body":121,"breadcrumbs":6,"title":2},"1566":{"body":110,"breadcrumbs":8,"title":4},"1567":{"body":23,"breadcrumbs":7,"title":3},"1568":{"body":5,"breadcrumbs":5,"title":1},"1569":{"body":196,"breadcrumbs":9,"title":5},"157":{"body":7,"breadcrumbs":9,"title":3},"1570":{"body":29,"breadcrumbs":9,"title":5},"1571":{"body":16,"breadcrumbs":8,"title":3},"1572":{"body":1,"breadcrumbs":7,"title":2},"1573":{"body":65,"breadcrumbs":6,"title":1},"1574":{"body":17,"breadcrumbs":7,"title":2},"1575":{"body":32,"breadcrumbs":8,"title":3},"1576":{"body":25,"breadcrumbs":6,"title":1},"1577":{"body":29,"breadcrumbs":10,"title":5},"1578":{"body":33,"breadcrumbs":6,"title":2},"1579":{"body":2,"breadcrumbs":6,"title":2},"158":{"body":35,"breadcrumbs":7,"title":1},"1580":{"body":34,"breadcrumbs":5,"title":1},"1581":{"body":52,"breadcrumbs":6,"title":2},"1582":{"body":42,"breadcrumbs":7,"title":3},"1583":{"body":29,"breadcrumbs":5,"title":1},"1584":{"body":8,"breadcrumbs":9,"title":5},"1585":{"body":10,"breadcrumbs":6,"title":2},"1586":{"body":2,"breadcrumbs":6,"title":2},"1587":{"body":78,"breadcrumbs":5,"title":1},"1588":{"body":46,"breadcrumbs":7,"title":3},"1589":{"body":15,"breadcrumbs":5,"title":1},"159":{"body":67,"breadcrumbs":7,"title":1},"1590":{"body":2,"breadcrumbs":8,"title":3},"1591":{"body":3,"breadcrumbs":7,"title":2},"1592":{"body":23,"breadcrumbs":6,"title":1},"1593":{"body":45,"breadcrumbs":7,"title":2},"1594":{"body":25,"breadcrumbs":8,"title":3},"1595":{"body":5,"breadcrumbs":6,"title":1},"1596":{"body":9,"breadcrumbs":7,"title":3},"1597":{"body":1,"breadcrumbs":6,"title":2},"1598":{"body":12,"breadcrumbs":5,"title":1},"1599":{"body":31,"breadcrumbs":7,"title":3},"16":{"body":44,"breadcrumbs":5,"title":2},"160":{"body":13,"breadcrumbs":9,"title":3},"1600":{"body":5,"breadcrumbs":7,"title":3},"1601":{"body":17,"breadcrumbs":5,"title":1},"1602":{"body":9,"breadcrumbs":9,"title":5},"1603":{"body":171,"breadcrumbs":6,"title":2},"1604":{"body":80,"breadcrumbs":6,"title":2},"1605":{"body":23,"breadcrumbs":5,"title":1},"1606":{"body":6,"breadcrumbs":5,"title":1},"1607":{"body":82,"breadcrumbs":6,"title":2},"1608":{"body":43,"breadcrumbs":5,"title":1},"1609":{"body":48,"breadcrumbs":7,"title":3},"161":{"body":63,"breadcrumbs":7,"title":1},"1610":{"body":104,"breadcrumbs":6,"title":2},"1611":{"body":19,"breadcrumbs":6,"title":2},"1612":{"body":14,"breadcrumbs":5,"title":1},"1613":{"body":17,"breadcrumbs":5,"title":1},"1614":{"body":7,"breadcrumbs":6,"title":2},"1615":{"body":4,"breadcrumbs":5,"title":1},"1616":{"body":6,"breadcrumbs":7,"title":3},"1617":{"body":26,"breadcrumbs":6,"title":2},"1618":{"body":1,"breadcrumbs":6,"title":2},"1619":{"body":32,"breadcrumbs":5,"title":1},"162":{"body":22,"breadcrumbs":7,"title":1},"1620":{"body":31,"breadcrumbs":6,"title":2},"1621":{"body":35,"breadcrumbs":8,"title":4},"1622":{"body":11,"breadcrumbs":9,"title":5},"1623":{"body":24,"breadcrumbs":6,"title":2},"1624":{"body":9,"breadcrumbs":6,"title":2},"1625":{"body":218,"breadcrumbs":5,"title":1},"1626":{"body":29,"breadcrumbs":8,"title":4},"1627":{"body":35,"breadcrumbs":7,"title":3},"1628":{"body":33,"breadcrumbs":6,"title":2},"1629":{"body":48,"breadcrumbs":5,"title":1},"163":{"body":7,"breadcrumbs":9,"title":3},"1630":{"body":188,"breadcrumbs":9,"title":5},"1631":{"body":115,"breadcrumbs":5,"title":1},"1632":{"body":57,"breadcrumbs":6,"title":2},"1633":{"body":142,"breadcrumbs":7,"title":3},"1634":{"body":6,"breadcrumbs":7,"title":3},"1635":{"body":53,"breadcrumbs":6,"title":2},"1636":{"body":77,"breadcrumbs":6,"title":2},"1637":{"body":81,"breadcrumbs":8,"title":4},"1638":{"body":33,"breadcrumbs":5,"title":1},"1639":{"body":29,"breadcrumbs":8,"title":3},"164":{"body":62,"breadcrumbs":7,"title":1},"1640":{"body":5,"breadcrumbs":7,"title":2},"1641":{"body":0,"breadcrumbs":6,"title":1},"1642":{"body":13,"breadcrumbs":7,"title":2},"1643":{"body":19,"breadcrumbs":7,"title":2},"1644":{"body":35,"breadcrumbs":7,"title":2},"1645":{"body":41,"breadcrumbs":8,"title":3},"1646":{"body":5,"breadcrumbs":6,"title":1},"1647":{"body":30,"breadcrumbs":10,"title":5},"1648":{"body":12,"breadcrumbs":21,"title":16},"1649":{"body":1,"breadcrumbs":7,"title":2},"165":{"body":74,"breadcrumbs":7,"title":1},"1650":{"body":31,"breadcrumbs":6,"title":1},"1651":{"body":19,"breadcrumbs":7,"title":2},"1652":{"body":43,"breadcrumbs":8,"title":3},"1653":{"body":7,"breadcrumbs":6,"title":1},"1654":{"body":38,"breadcrumbs":10,"title":5},"1655":{"body":38,"breadcrumbs":6,"title":2},"1656":{"body":2,"breadcrumbs":6,"title":2},"1657":{"body":0,"breadcrumbs":5,"title":1},"1658":{"body":5,"breadcrumbs":6,"title":2},"1659":{"body":14,"breadcrumbs":5,"title":1},"166":{"body":16,"breadcrumbs":7,"title":1},"1660":{"body":43,"breadcrumbs":6,"title":2},"1661":{"body":22,"breadcrumbs":7,"title":3},"1662":{"body":12,"breadcrumbs":9,"title":5},"1663":{"body":146,"breadcrumbs":6,"title":2},"1664":{"body":27,"breadcrumbs":6,"title":2},"1665":{"body":108,"breadcrumbs":5,"title":1},"1666":{"body":51,"breadcrumbs":6,"title":2},"1667":{"body":22,"breadcrumbs":7,"title":3},"1668":{"body":4,"breadcrumbs":6,"title":2},"1669":{"body":26,"breadcrumbs":5,"title":1},"167":{"body":144,"breadcrumbs":7,"title":1},"1670":{"body":24,"breadcrumbs":7,"title":3},"1671":{"body":15,"breadcrumbs":7,"title":3},"1672":{"body":13,"breadcrumbs":5,"title":1},"1673":{"body":52,"breadcrumbs":8,"title":3},"1674":{"body":4,"breadcrumbs":7,"title":2},"1675":{"body":101,"breadcrumbs":6,"title":1},"1676":{"body":68,"breadcrumbs":8,"title":3},"1677":{"body":181,"breadcrumbs":8,"title":3},"1678":{"body":40,"breadcrumbs":7,"title":2},"1679":{"body":32,"breadcrumbs":7,"title":2},"168":{"body":100,"breadcrumbs":7,"title":1},"1680":{"body":28,"breadcrumbs":8,"title":3},"1681":{"body":4,"breadcrumbs":7,"title":2},"1682":{"body":87,"breadcrumbs":6,"title":1},"1683":{"body":34,"breadcrumbs":8,"title":3},"1684":{"body":40,"breadcrumbs":8,"title":3},"1685":{"body":42,"breadcrumbs":6,"title":2},"1686":{"body":2,"breadcrumbs":6,"title":2},"1687":{"body":7,"breadcrumbs":5,"title":1},"1688":{"body":29,"breadcrumbs":6,"title":2},"1689":{"body":51,"breadcrumbs":6,"title":2},"169":{"body":32,"breadcrumbs":9,"title":3},"1690":{"body":15,"breadcrumbs":5,"title":1},"1691":{"body":10,"breadcrumbs":7,"title":3},"1692":{"body":15,"breadcrumbs":7,"title":3},"1693":{"body":13,"breadcrumbs":5,"title":1},"1694":{"body":119,"breadcrumbs":6,"title":2},"1695":{"body":1,"breadcrumbs":6,"title":2},"1696":{"body":7,"breadcrumbs":5,"title":1},"1697":{"body":23,"breadcrumbs":6,"title":2},"1698":{"body":51,"breadcrumbs":6,"title":2},"1699":{"body":15,"breadcrumbs":5,"title":1},"17":{"body":5,"breadcrumbs":7,"title":4},"170":{"body":96,"breadcrumbs":7,"title":1},"1700":{"body":10,"breadcrumbs":7,"title":3},"1701":{"body":15,"breadcrumbs":7,"title":3},"1702":{"body":77,"breadcrumbs":9,"title":3},"1703":{"body":1,"breadcrumbs":8,"title":2},"1704":{"body":0,"breadcrumbs":7,"title":1},"1705":{"body":103,"breadcrumbs":7,"title":1},"1706":{"body":38,"breadcrumbs":7,"title":1},"1707":{"body":77,"breadcrumbs":8,"title":2},"1708":{"body":73,"breadcrumbs":9,"title":3},"1709":{"body":13,"breadcrumbs":7,"title":1},"171":{"body":27,"breadcrumbs":7,"title":1},"1710":{"body":28,"breadcrumbs":7,"title":1},"1711":{"body":10,"breadcrumbs":11,"title":5},"1712":{"body":185,"breadcrumbs":8,"title":3},"1713":{"body":2,"breadcrumbs":7,"title":2},"1714":{"body":35,"breadcrumbs":6,"title":1},"1715":{"body":37,"breadcrumbs":7,"title":2},"1716":{"body":23,"breadcrumbs":8,"title":3},"1717":{"body":4,"breadcrumbs":7,"title":2},"1718":{"body":82,"breadcrumbs":8,"title":3},"1719":{"body":50,"breadcrumbs":6,"title":1},"172":{"body":33,"breadcrumbs":10,"title":4},"1720":{"body":22,"breadcrumbs":8,"title":3},"1721":{"body":115,"breadcrumbs":8,"title":3},"1722":{"body":127,"breadcrumbs":8,"title":3},"1723":{"body":23,"breadcrumbs":7,"title":2},"1724":{"body":93,"breadcrumbs":6,"title":1},"1725":{"body":26,"breadcrumbs":7,"title":2},"1726":{"body":23,"breadcrumbs":8,"title":3},"1727":{"body":4,"breadcrumbs":7,"title":2},"1728":{"body":28,"breadcrumbs":6,"title":1},"1729":{"body":19,"breadcrumbs":8,"title":3},"173":{"body":39,"breadcrumbs":7,"title":1},"1730":{"body":388,"breadcrumbs":8,"title":3},"1731":{"body":219,"breadcrumbs":6,"title":1},"1732":{"body":71,"breadcrumbs":6,"title":2},"1733":{"body":2,"breadcrumbs":6,"title":2},"1734":{"body":55,"breadcrumbs":5,"title":1},"1735":{"body":19,"breadcrumbs":7,"title":3},"1736":{"body":146,"breadcrumbs":7,"title":3},"1737":{"body":148,"breadcrumbs":9,"title":5},"1738":{"body":50,"breadcrumbs":5,"title":1},"1739":{"body":12,"breadcrumbs":8,"title":3},"174":{"body":7,"breadcrumbs":7,"title":1},"1740":{"body":1,"breadcrumbs":7,"title":2},"1741":{"body":198,"breadcrumbs":6,"title":1},"1742":{"body":21,"breadcrumbs":7,"title":2},"1743":{"body":36,"breadcrumbs":8,"title":3},"1744":{"body":23,"breadcrumbs":6,"title":1},"1745":{"body":29,"breadcrumbs":10,"title":5},"1746":{"body":26,"breadcrumbs":6,"title":2},"1747":{"body":22,"breadcrumbs":6,"title":2},"1748":{"body":30,"breadcrumbs":5,"title":1},"1749":{"body":21,"breadcrumbs":7,"title":3},"175":{"body":7,"breadcrumbs":8,"title":2},"1750":{"body":33,"breadcrumbs":6,"title":2},"1751":{"body":2,"breadcrumbs":6,"title":2},"1752":{"body":45,"breadcrumbs":5,"title":1},"1753":{"body":92,"breadcrumbs":6,"title":2},"1754":{"body":27,"breadcrumbs":7,"title":3},"1755":{"body":42,"breadcrumbs":5,"title":1},"1756":{"body":31,"breadcrumbs":9,"title":5},"1757":{"body":18,"breadcrumbs":8,"title":3},"1758":{"body":1,"breadcrumbs":7,"title":2},"1759":{"body":27,"breadcrumbs":6,"title":1},"176":{"body":8,"breadcrumbs":9,"title":3},"1760":{"body":17,"breadcrumbs":7,"title":2},"1761":{"body":23,"breadcrumbs":8,"title":3},"1762":{"body":18,"breadcrumbs":6,"title":1},"1763":{"body":9,"breadcrumbs":10,"title":5},"1764":{"body":18,"breadcrumbs":8,"title":3},"1765":{"body":1,"breadcrumbs":7,"title":2},"1766":{"body":34,"breadcrumbs":6,"title":1},"1767":{"body":17,"breadcrumbs":7,"title":2},"1768":{"body":23,"breadcrumbs":8,"title":3},"1769":{"body":18,"breadcrumbs":6,"title":1},"177":{"body":48,"breadcrumbs":7,"title":1},"1770":{"body":111,"breadcrumbs":10,"title":5},"1771":{"body":18,"breadcrumbs":10,"title":4},"1772":{"body":8,"breadcrumbs":8,"title":2},"1773":{"body":75,"breadcrumbs":7,"title":1},"1774":{"body":18,"breadcrumbs":8,"title":2},"1775":{"body":7,"breadcrumbs":9,"title":3},"1776":{"body":20,"breadcrumbs":7,"title":1},"1777":{"body":28,"breadcrumbs":11,"title":5},"1778":{"body":33,"breadcrumbs":8,"title":3},"1779":{"body":1,"breadcrumbs":7,"title":2},"178":{"body":87,"breadcrumbs":7,"title":1},"1780":{"body":13,"breadcrumbs":6,"title":1},"1781":{"body":16,"breadcrumbs":7,"title":2},"1782":{"body":24,"breadcrumbs":8,"title":3},"1783":{"body":6,"breadcrumbs":6,"title":1},"1784":{"body":9,"breadcrumbs":10,"title":5},"1785":{"body":9,"breadcrumbs":10,"title":4},"1786":{"body":1,"breadcrumbs":8,"title":2},"1787":{"body":50,"breadcrumbs":7,"title":1},"1788":{"body":14,"breadcrumbs":8,"title":2},"1789":{"body":24,"breadcrumbs":9,"title":3},"179":{"body":8,"breadcrumbs":9,"title":3},"1790":{"body":7,"breadcrumbs":7,"title":1},"1791":{"body":5,"breadcrumbs":11,"title":5},"1792":{"body":12,"breadcrumbs":8,"title":3},"1793":{"body":2,"breadcrumbs":7,"title":2},"1794":{"body":131,"breadcrumbs":6,"title":1},"1795":{"body":16,"breadcrumbs":7,"title":2},"1796":{"body":30,"breadcrumbs":8,"title":3},"1797":{"body":15,"breadcrumbs":6,"title":1},"1798":{"body":69,"breadcrumbs":10,"title":5},"1799":{"body":5,"breadcrumbs":8,"title":3},"18":{"body":3,"breadcrumbs":7,"title":4},"180":{"body":49,"breadcrumbs":7,"title":1},"1800":{"body":2,"breadcrumbs":7,"title":2},"1801":{"body":45,"breadcrumbs":6,"title":1},"1802":{"body":17,"breadcrumbs":7,"title":2},"1803":{"body":66,"breadcrumbs":5,"title":2},"1804":{"body":1,"breadcrumbs":5,"title":2},"1805":{"body":77,"breadcrumbs":4,"title":1},"1806":{"body":27,"breadcrumbs":5,"title":2},"1807":{"body":16,"breadcrumbs":4,"title":1},"1808":{"body":21,"breadcrumbs":8,"title":5},"181":{"body":87,"breadcrumbs":7,"title":1},"182":{"body":19,"breadcrumbs":8,"title":2},"183":{"body":77,"breadcrumbs":7,"title":1},"184":{"body":51,"breadcrumbs":7,"title":1},"185":{"body":5,"breadcrumbs":8,"title":2},"186":{"body":43,"breadcrumbs":7,"title":1},"187":{"body":45,"breadcrumbs":7,"title":1},"188":{"body":7,"breadcrumbs":9,"title":3},"189":{"body":74,"breadcrumbs":7,"title":1},"19":{"body":4,"breadcrumbs":6,"title":3},"190":{"body":75,"breadcrumbs":7,"title":1},"191":{"body":6,"breadcrumbs":10,"title":4},"192":{"body":38,"breadcrumbs":7,"title":1},"193":{"body":49,"breadcrumbs":7,"title":1},"194":{"body":9,"breadcrumbs":9,"title":3},"195":{"body":28,"breadcrumbs":7,"title":1},"196":{"body":31,"breadcrumbs":7,"title":1},"197":{"body":9,"breadcrumbs":9,"title":3},"198":{"body":37,"breadcrumbs":7,"title":1},"199":{"body":47,"breadcrumbs":7,"title":1},"2":{"body":6,"breadcrumbs":6,"title":3},"20":{"body":4,"breadcrumbs":6,"title":3},"200":{"body":8,"breadcrumbs":9,"title":3},"201":{"body":29,"breadcrumbs":7,"title":1},"202":{"body":43,"breadcrumbs":7,"title":1},"203":{"body":7,"breadcrumbs":8,"title":2},"204":{"body":29,"breadcrumbs":7,"title":1},"205":{"body":23,"breadcrumbs":7,"title":1},"206":{"body":8,"breadcrumbs":9,"title":3},"207":{"body":58,"breadcrumbs":7,"title":1},"208":{"body":21,"breadcrumbs":7,"title":1},"209":{"body":8,"breadcrumbs":9,"title":3},"21":{"body":9,"breadcrumbs":8,"title":5},"210":{"body":28,"breadcrumbs":7,"title":1},"211":{"body":29,"breadcrumbs":7,"title":1},"212":{"body":10,"breadcrumbs":7,"title":1},"213":{"body":56,"breadcrumbs":7,"title":1},"214":{"body":41,"breadcrumbs":7,"title":1},"215":{"body":6,"breadcrumbs":9,"title":3},"216":{"body":25,"breadcrumbs":7,"title":1},"217":{"body":22,"breadcrumbs":7,"title":1},"218":{"body":37,"breadcrumbs":10,"title":4},"219":{"body":79,"breadcrumbs":7,"title":1},"22":{"body":12,"breadcrumbs":9,"title":6},"220":{"body":37,"breadcrumbs":7,"title":1},"221":{"body":9,"breadcrumbs":9,"title":3},"222":{"body":15,"breadcrumbs":8,"title":2},"223":{"body":35,"breadcrumbs":7,"title":1},"224":{"body":18,"breadcrumbs":7,"title":1},"225":{"body":10,"breadcrumbs":8,"title":2},"226":{"body":43,"breadcrumbs":7,"title":1},"227":{"body":10,"breadcrumbs":7,"title":1},"228":{"body":36,"breadcrumbs":11,"title":5},"229":{"body":101,"breadcrumbs":9,"title":3},"23":{"body":16,"breadcrumbs":7,"title":4},"230":{"body":10,"breadcrumbs":7,"title":1},"231":{"body":105,"breadcrumbs":9,"title":3},"232":{"body":21,"breadcrumbs":7,"title":1},"233":{"body":7,"breadcrumbs":10,"title":4},"234":{"body":75,"breadcrumbs":7,"title":1},"235":{"body":9,"breadcrumbs":7,"title":1},"236":{"body":9,"breadcrumbs":11,"title":5},"237":{"body":56,"breadcrumbs":7,"title":1},"238":{"body":30,"breadcrumbs":7,"title":1},"239":{"body":12,"breadcrumbs":10,"title":4},"24":{"body":3,"breadcrumbs":8,"title":5},"240":{"body":76,"breadcrumbs":7,"title":1},"241":{"body":32,"breadcrumbs":7,"title":1},"242":{"body":11,"breadcrumbs":12,"title":6},"243":{"body":100,"breadcrumbs":7,"title":1},"244":{"body":30,"breadcrumbs":7,"title":1},"245":{"body":10,"breadcrumbs":10,"title":4},"246":{"body":158,"breadcrumbs":7,"title":1},"247":{"body":17,"breadcrumbs":7,"title":1},"248":{"body":12,"breadcrumbs":10,"title":4},"249":{"body":68,"breadcrumbs":7,"title":1},"25":{"body":21,"breadcrumbs":7,"title":4},"250":{"body":29,"breadcrumbs":7,"title":1},"251":{"body":8,"breadcrumbs":9,"title":3},"252":{"body":6,"breadcrumbs":9,"title":3},"253":{"body":39,"breadcrumbs":7,"title":1},"254":{"body":47,"breadcrumbs":7,"title":1},"255":{"body":12,"breadcrumbs":10,"title":4},"256":{"body":50,"breadcrumbs":7,"title":1},"257":{"body":29,"breadcrumbs":7,"title":1},"258":{"body":12,"breadcrumbs":10,"title":4},"259":{"body":62,"breadcrumbs":7,"title":1},"26":{"body":13,"breadcrumbs":8,"title":5},"260":{"body":29,"breadcrumbs":7,"title":1},"261":{"body":35,"breadcrumbs":10,"title":4},"262":{"body":148,"breadcrumbs":7,"title":1},"263":{"body":122,"breadcrumbs":7,"title":1},"264":{"body":10,"breadcrumbs":8,"title":2},"265":{"body":36,"breadcrumbs":7,"title":1},"266":{"body":65,"breadcrumbs":7,"title":1},"267":{"body":8,"breadcrumbs":9,"title":3},"268":{"body":31,"breadcrumbs":7,"title":1},"269":{"body":61,"breadcrumbs":7,"title":1},"27":{"body":21,"breadcrumbs":6,"title":3},"270":{"body":30,"breadcrumbs":8,"title":2},"271":{"body":35,"breadcrumbs":7,"title":1},"272":{"body":31,"breadcrumbs":7,"title":1},"273":{"body":9,"breadcrumbs":8,"title":2},"274":{"body":39,"breadcrumbs":7,"title":1},"275":{"body":43,"breadcrumbs":7,"title":1},"276":{"body":14,"breadcrumbs":9,"title":3},"277":{"body":44,"breadcrumbs":7,"title":1},"278":{"body":54,"breadcrumbs":7,"title":1},"279":{"body":22,"breadcrumbs":8,"title":2},"28":{"body":21,"breadcrumbs":7,"title":4},"280":{"body":34,"breadcrumbs":7,"title":1},"281":{"body":63,"breadcrumbs":7,"title":1},"282":{"body":9,"breadcrumbs":10,"title":4},"283":{"body":54,"breadcrumbs":7,"title":1},"284":{"body":39,"breadcrumbs":7,"title":1},"285":{"body":12,"breadcrumbs":8,"title":2},"286":{"body":127,"breadcrumbs":7,"title":1},"287":{"body":18,"breadcrumbs":7,"title":1},"288":{"body":11,"breadcrumbs":10,"title":4},"289":{"body":66,"breadcrumbs":7,"title":1},"29":{"body":21,"breadcrumbs":7,"title":4},"290":{"body":69,"breadcrumbs":7,"title":1},"291":{"body":5,"breadcrumbs":8,"title":2},"292":{"body":18,"breadcrumbs":7,"title":1},"293":{"body":34,"breadcrumbs":7,"title":1},"294":{"body":7,"breadcrumbs":9,"title":3},"295":{"body":26,"breadcrumbs":7,"title":1},"296":{"body":73,"breadcrumbs":7,"title":1},"297":{"body":9,"breadcrumbs":9,"title":3},"298":{"body":33,"breadcrumbs":7,"title":1},"299":{"body":71,"breadcrumbs":7,"title":1},"3":{"body":6,"breadcrumbs":6,"title":3},"30":{"body":38,"breadcrumbs":7,"title":4},"300":{"body":8,"breadcrumbs":9,"title":3},"301":{"body":27,"breadcrumbs":7,"title":1},"302":{"body":13,"breadcrumbs":7,"title":1},"303":{"body":7,"breadcrumbs":8,"title":2},"304":{"body":27,"breadcrumbs":7,"title":1},"305":{"body":10,"breadcrumbs":7,"title":1},"306":{"body":29,"breadcrumbs":9,"title":3},"307":{"body":35,"breadcrumbs":7,"title":1},"308":{"body":34,"breadcrumbs":7,"title":1},"309":{"body":6,"breadcrumbs":8,"title":2},"31":{"body":7,"breadcrumbs":9,"title":6},"310":{"body":36,"breadcrumbs":7,"title":1},"311":{"body":30,"breadcrumbs":7,"title":1},"312":{"body":7,"breadcrumbs":8,"title":2},"313":{"body":25,"breadcrumbs":7,"title":1},"314":{"body":56,"breadcrumbs":7,"title":1},"315":{"body":8,"breadcrumbs":9,"title":3},"316":{"body":30,"breadcrumbs":7,"title":1},"317":{"body":51,"breadcrumbs":7,"title":1},"318":{"body":152,"breadcrumbs":9,"title":3},"319":{"body":22,"breadcrumbs":9,"title":3},"32":{"body":5,"breadcrumbs":8,"title":5},"320":{"body":44,"breadcrumbs":7,"title":1},"321":{"body":34,"breadcrumbs":7,"title":1},"322":{"body":27,"breadcrumbs":9,"title":3},"323":{"body":66,"breadcrumbs":7,"title":1},"324":{"body":39,"breadcrumbs":7,"title":1},"325":{"body":7,"breadcrumbs":10,"title":4},"326":{"body":54,"breadcrumbs":7,"title":1},"327":{"body":4,"breadcrumbs":7,"title":1},"328":{"body":7,"breadcrumbs":8,"title":2},"329":{"body":56,"breadcrumbs":7,"title":1},"33":{"body":5,"breadcrumbs":7,"title":4},"330":{"body":69,"breadcrumbs":7,"title":1},"331":{"body":6,"breadcrumbs":8,"title":2},"332":{"body":82,"breadcrumbs":7,"title":1},"333":{"body":32,"breadcrumbs":7,"title":1},"334":{"body":9,"breadcrumbs":9,"title":3},"335":{"body":45,"breadcrumbs":7,"title":1},"336":{"body":60,"breadcrumbs":7,"title":1},"337":{"body":10,"breadcrumbs":9,"title":3},"338":{"body":68,"breadcrumbs":7,"title":1},"339":{"body":139,"breadcrumbs":7,"title":1},"34":{"body":7,"breadcrumbs":8,"title":5},"340":{"body":7,"breadcrumbs":9,"title":3},"341":{"body":29,"breadcrumbs":7,"title":1},"342":{"body":24,"breadcrumbs":7,"title":1},"343":{"body":8,"breadcrumbs":9,"title":3},"344":{"body":8,"breadcrumbs":9,"title":3},"345":{"body":54,"breadcrumbs":7,"title":1},"346":{"body":20,"breadcrumbs":7,"title":1},"347":{"body":7,"breadcrumbs":9,"title":3},"348":{"body":81,"breadcrumbs":7,"title":1},"349":{"body":34,"breadcrumbs":7,"title":1},"35":{"body":153,"breadcrumbs":8,"title":5},"350":{"body":10,"breadcrumbs":9,"title":3},"351":{"body":39,"breadcrumbs":7,"title":1},"352":{"body":56,"breadcrumbs":7,"title":1},"353":{"body":10,"breadcrumbs":9,"title":3},"354":{"body":50,"breadcrumbs":7,"title":1},"355":{"body":73,"breadcrumbs":7,"title":1},"356":{"body":11,"breadcrumbs":9,"title":3},"357":{"body":70,"breadcrumbs":7,"title":1},"358":{"body":45,"breadcrumbs":7,"title":1},"359":{"body":8,"breadcrumbs":8,"title":2},"36":{"body":10,"breadcrumbs":7,"title":4},"360":{"body":50,"breadcrumbs":7,"title":1},"361":{"body":63,"breadcrumbs":7,"title":1},"362":{"body":7,"breadcrumbs":9,"title":3},"363":{"body":57,"breadcrumbs":7,"title":1},"364":{"body":25,"breadcrumbs":7,"title":1},"365":{"body":7,"breadcrumbs":9,"title":3},"366":{"body":50,"breadcrumbs":7,"title":1},"367":{"body":142,"breadcrumbs":7,"title":1},"368":{"body":10,"breadcrumbs":9,"title":3},"369":{"body":63,"breadcrumbs":7,"title":1},"37":{"body":29,"breadcrumbs":8,"title":5},"370":{"body":38,"breadcrumbs":7,"title":1},"371":{"body":9,"breadcrumbs":9,"title":3},"372":{"body":89,"breadcrumbs":7,"title":1},"373":{"body":38,"breadcrumbs":7,"title":1},"374":{"body":6,"breadcrumbs":8,"title":2},"375":{"body":17,"breadcrumbs":7,"title":1},"376":{"body":43,"breadcrumbs":7,"title":1},"377":{"body":42,"breadcrumbs":7,"title":1},"378":{"body":6,"breadcrumbs":7,"title":1},"379":{"body":18,"breadcrumbs":7,"title":1},"38":{"body":23,"breadcrumbs":7,"title":4},"380":{"body":16,"breadcrumbs":7,"title":1},"381":{"body":8,"breadcrumbs":9,"title":3},"382":{"body":44,"breadcrumbs":7,"title":1},"383":{"body":29,"breadcrumbs":7,"title":1},"384":{"body":9,"breadcrumbs":8,"title":2},"385":{"body":44,"breadcrumbs":7,"title":1},"386":{"body":9,"breadcrumbs":7,"title":1},"387":{"body":6,"breadcrumbs":8,"title":2},"388":{"body":38,"breadcrumbs":7,"title":1},"389":{"body":32,"breadcrumbs":7,"title":1},"39":{"body":16,"breadcrumbs":9,"title":6},"390":{"body":6,"breadcrumbs":8,"title":2},"391":{"body":26,"breadcrumbs":7,"title":1},"392":{"body":92,"breadcrumbs":7,"title":1},"393":{"body":9,"breadcrumbs":9,"title":3},"394":{"body":57,"breadcrumbs":7,"title":1},"395":{"body":11,"breadcrumbs":7,"title":1},"396":{"body":9,"breadcrumbs":8,"title":2},"397":{"body":55,"breadcrumbs":7,"title":1},"398":{"body":17,"breadcrumbs":7,"title":1},"399":{"body":15,"breadcrumbs":9,"title":3},"4":{"body":23,"breadcrumbs":7,"title":4},"40":{"body":35,"breadcrumbs":10,"title":7},"400":{"body":14,"breadcrumbs":7,"title":1},"401":{"body":21,"breadcrumbs":7,"title":1},"402":{"body":6,"breadcrumbs":8,"title":2},"403":{"body":30,"breadcrumbs":7,"title":1},"404":{"body":76,"breadcrumbs":7,"title":1},"405":{"body":6,"breadcrumbs":10,"title":4},"406":{"body":43,"breadcrumbs":7,"title":1},"407":{"body":13,"breadcrumbs":7,"title":1},"408":{"body":8,"breadcrumbs":9,"title":3},"409":{"body":23,"breadcrumbs":7,"title":1},"41":{"body":182,"breadcrumbs":9,"title":6},"410":{"body":48,"breadcrumbs":7,"title":1},"411":{"body":8,"breadcrumbs":9,"title":3},"412":{"body":42,"breadcrumbs":7,"title":1},"413":{"body":62,"breadcrumbs":7,"title":1},"414":{"body":17,"breadcrumbs":9,"title":3},"415":{"body":47,"breadcrumbs":7,"title":1},"416":{"body":6,"breadcrumbs":8,"title":2},"417":{"body":23,"breadcrumbs":7,"title":1},"418":{"body":9,"breadcrumbs":9,"title":3},"419":{"body":57,"breadcrumbs":7,"title":1},"42":{"body":29,"breadcrumbs":9,"title":6},"420":{"body":26,"breadcrumbs":7,"title":1},"421":{"body":9,"breadcrumbs":8,"title":2},"422":{"body":48,"breadcrumbs":7,"title":1},"423":{"body":12,"breadcrumbs":7,"title":1},"424":{"body":8,"breadcrumbs":9,"title":3},"425":{"body":30,"breadcrumbs":7,"title":1},"426":{"body":26,"breadcrumbs":7,"title":1},"427":{"body":11,"breadcrumbs":9,"title":3},"428":{"body":84,"breadcrumbs":7,"title":1},"429":{"body":27,"breadcrumbs":7,"title":1},"43":{"body":47,"breadcrumbs":7,"title":2},"430":{"body":8,"breadcrumbs":8,"title":2},"431":{"body":36,"breadcrumbs":7,"title":1},"432":{"body":32,"breadcrumbs":7,"title":1},"433":{"body":8,"breadcrumbs":9,"title":3},"434":{"body":41,"breadcrumbs":7,"title":1},"435":{"body":23,"breadcrumbs":7,"title":1},"436":{"body":11,"breadcrumbs":8,"title":2},"437":{"body":26,"breadcrumbs":7,"title":1},"438":{"body":15,"breadcrumbs":7,"title":1},"439":{"body":14,"breadcrumbs":11,"title":5},"44":{"body":20,"breadcrumbs":7,"title":2},"440":{"body":64,"breadcrumbs":7,"title":1},"441":{"body":24,"breadcrumbs":7,"title":1},"442":{"body":7,"breadcrumbs":8,"title":2},"443":{"body":27,"breadcrumbs":7,"title":1},"444":{"body":12,"breadcrumbs":7,"title":1},"445":{"body":11,"breadcrumbs":9,"title":3},"446":{"body":86,"breadcrumbs":7,"title":1},"447":{"body":29,"breadcrumbs":7,"title":1},"448":{"body":12,"breadcrumbs":8,"title":2},"449":{"body":19,"breadcrumbs":7,"title":1},"45":{"body":6,"breadcrumbs":7,"title":2},"450":{"body":10,"breadcrumbs":7,"title":1},"451":{"body":11,"breadcrumbs":8,"title":2},"452":{"body":24,"breadcrumbs":7,"title":1},"453":{"body":11,"breadcrumbs":7,"title":1},"454":{"body":8,"breadcrumbs":9,"title":3},"455":{"body":26,"breadcrumbs":7,"title":1},"456":{"body":10,"breadcrumbs":7,"title":1},"457":{"body":9,"breadcrumbs":8,"title":2},"458":{"body":39,"breadcrumbs":7,"title":1},"459":{"body":28,"breadcrumbs":7,"title":1},"46":{"body":16,"breadcrumbs":6,"title":1},"460":{"body":8,"breadcrumbs":8,"title":2},"461":{"body":23,"breadcrumbs":7,"title":1},"462":{"body":44,"breadcrumbs":7,"title":1},"463":{"body":9,"breadcrumbs":8,"title":2},"464":{"body":18,"breadcrumbs":7,"title":1},"465":{"body":30,"breadcrumbs":7,"title":1},"466":{"body":12,"breadcrumbs":10,"title":4},"467":{"body":67,"breadcrumbs":7,"title":1},"468":{"body":51,"breadcrumbs":7,"title":1},"469":{"body":6,"breadcrumbs":9,"title":3},"47":{"body":20,"breadcrumbs":7,"title":2},"470":{"body":18,"breadcrumbs":7,"title":1},"471":{"body":33,"breadcrumbs":7,"title":1},"472":{"body":7,"breadcrumbs":10,"title":4},"473":{"body":21,"breadcrumbs":7,"title":1},"474":{"body":16,"breadcrumbs":7,"title":1},"475":{"body":7,"breadcrumbs":9,"title":3},"476":{"body":79,"breadcrumbs":7,"title":1},"477":{"body":3,"breadcrumbs":7,"title":1},"478":{"body":53,"breadcrumbs":9,"title":3},"479":{"body":185,"breadcrumbs":7,"title":1},"48":{"body":32,"breadcrumbs":7,"title":2},"480":{"body":39,"breadcrumbs":7,"title":1},"481":{"body":7,"breadcrumbs":9,"title":3},"482":{"body":17,"breadcrumbs":7,"title":1},"483":{"body":22,"breadcrumbs":7,"title":1},"484":{"body":8,"breadcrumbs":8,"title":2},"485":{"body":32,"breadcrumbs":7,"title":1},"486":{"body":24,"breadcrumbs":7,"title":1},"487":{"body":10,"breadcrumbs":9,"title":3},"488":{"body":42,"breadcrumbs":7,"title":1},"489":{"body":50,"breadcrumbs":7,"title":1},"49":{"body":38,"breadcrumbs":6,"title":1},"490":{"body":15,"breadcrumbs":10,"title":4},"491":{"body":77,"breadcrumbs":7,"title":1},"492":{"body":25,"breadcrumbs":7,"title":1},"493":{"body":6,"breadcrumbs":9,"title":3},"494":{"body":48,"breadcrumbs":7,"title":1},"495":{"body":13,"breadcrumbs":7,"title":1},"496":{"body":8,"breadcrumbs":9,"title":3},"497":{"body":12,"breadcrumbs":10,"title":4},"498":{"body":26,"breadcrumbs":7,"title":1},"499":{"body":26,"breadcrumbs":7,"title":1},"5":{"body":58,"breadcrumbs":11,"title":8},"50":{"body":7,"breadcrumbs":7,"title":2},"500":{"body":9,"breadcrumbs":10,"title":4},"501":{"body":45,"breadcrumbs":7,"title":1},"502":{"body":20,"breadcrumbs":7,"title":1},"503":{"body":9,"breadcrumbs":9,"title":3},"504":{"body":86,"breadcrumbs":7,"title":1},"505":{"body":28,"breadcrumbs":7,"title":1},"506":{"body":12,"breadcrumbs":9,"title":3},"507":{"body":72,"breadcrumbs":7,"title":1},"508":{"body":54,"breadcrumbs":7,"title":1},"509":{"body":11,"breadcrumbs":10,"title":4},"51":{"body":13,"breadcrumbs":7,"title":2},"510":{"body":59,"breadcrumbs":7,"title":1},"511":{"body":13,"breadcrumbs":7,"title":1},"512":{"body":13,"breadcrumbs":9,"title":3},"513":{"body":24,"breadcrumbs":7,"title":1},"514":{"body":14,"breadcrumbs":7,"title":1},"515":{"body":8,"breadcrumbs":10,"title":4},"516":{"body":29,"breadcrumbs":7,"title":1},"517":{"body":10,"breadcrumbs":7,"title":1},"518":{"body":13,"breadcrumbs":9,"title":3},"519":{"body":58,"breadcrumbs":7,"title":1},"52":{"body":19,"breadcrumbs":7,"title":2},"520":{"body":39,"breadcrumbs":7,"title":1},"521":{"body":17,"breadcrumbs":10,"title":4},"522":{"body":22,"breadcrumbs":7,"title":1},"523":{"body":97,"breadcrumbs":7,"title":1},"524":{"body":7,"breadcrumbs":8,"title":2},"525":{"body":9,"breadcrumbs":9,"title":3},"526":{"body":34,"breadcrumbs":7,"title":1},"527":{"body":18,"breadcrumbs":7,"title":1},"528":{"body":6,"breadcrumbs":8,"title":2},"529":{"body":16,"breadcrumbs":7,"title":1},"53":{"body":29,"breadcrumbs":7,"title":2},"530":{"body":4,"breadcrumbs":7,"title":1},"531":{"body":23,"breadcrumbs":8,"title":2},"532":{"body":46,"breadcrumbs":7,"title":1},"533":{"body":13,"breadcrumbs":7,"title":1},"534":{"body":20,"breadcrumbs":8,"title":2},"535":{"body":56,"breadcrumbs":7,"title":1},"536":{"body":13,"breadcrumbs":7,"title":1},"537":{"body":10,"breadcrumbs":10,"title":4},"538":{"body":50,"breadcrumbs":7,"title":1},"539":{"body":46,"breadcrumbs":7,"title":1},"54":{"body":24,"breadcrumbs":7,"title":2},"540":{"body":6,"breadcrumbs":8,"title":2},"541":{"body":6,"breadcrumbs":8,"title":2},"542":{"body":19,"breadcrumbs":7,"title":1},"543":{"body":8,"breadcrumbs":7,"title":1},"544":{"body":20,"breadcrumbs":10,"title":4},"545":{"body":101,"breadcrumbs":7,"title":1},"546":{"body":58,"breadcrumbs":7,"title":1},"547":{"body":22,"breadcrumbs":10,"title":4},"548":{"body":102,"breadcrumbs":7,"title":1},"549":{"body":58,"breadcrumbs":7,"title":1},"55":{"body":30,"breadcrumbs":7,"title":2},"550":{"body":6,"breadcrumbs":9,"title":3},"551":{"body":17,"breadcrumbs":7,"title":1},"552":{"body":17,"breadcrumbs":7,"title":1},"553":{"body":16,"breadcrumbs":11,"title":5},"554":{"body":69,"breadcrumbs":7,"title":1},"555":{"body":33,"breadcrumbs":7,"title":1},"556":{"body":34,"breadcrumbs":10,"title":4},"557":{"body":126,"breadcrumbs":7,"title":1},"558":{"body":11,"breadcrumbs":7,"title":1},"559":{"body":8,"breadcrumbs":9,"title":3},"56":{"body":65,"breadcrumbs":8,"title":3},"560":{"body":31,"breadcrumbs":7,"title":1},"561":{"body":43,"breadcrumbs":7,"title":1},"562":{"body":7,"breadcrumbs":8,"title":2},"563":{"body":19,"breadcrumbs":7,"title":1},"564":{"body":12,"breadcrumbs":7,"title":1},"565":{"body":8,"breadcrumbs":9,"title":3},"566":{"body":13,"breadcrumbs":9,"title":3},"567":{"body":583,"breadcrumbs":7,"title":1},"568":{"body":21,"breadcrumbs":7,"title":1},"569":{"body":19,"breadcrumbs":10,"title":4},"57":{"body":35,"breadcrumbs":7,"title":2},"570":{"body":28,"breadcrumbs":7,"title":1},"571":{"body":14,"breadcrumbs":7,"title":1},"572":{"body":11,"breadcrumbs":10,"title":4},"573":{"body":26,"breadcrumbs":7,"title":1},"574":{"body":24,"breadcrumbs":7,"title":1},"575":{"body":9,"breadcrumbs":8,"title":2},"576":{"body":24,"breadcrumbs":7,"title":1},"577":{"body":65,"breadcrumbs":7,"title":1},"578":{"body":6,"breadcrumbs":9,"title":3},"579":{"body":52,"breadcrumbs":7,"title":1},"58":{"body":39,"breadcrumbs":7,"title":2},"580":{"body":99,"breadcrumbs":7,"title":1},"581":{"body":7,"breadcrumbs":10,"title":4},"582":{"body":40,"breadcrumbs":7,"title":1},"583":{"body":41,"breadcrumbs":7,"title":1},"584":{"body":7,"breadcrumbs":8,"title":2},"585":{"body":28,"breadcrumbs":7,"title":1},"586":{"body":46,"breadcrumbs":7,"title":1},"587":{"body":8,"breadcrumbs":8,"title":2},"588":{"body":30,"breadcrumbs":7,"title":1},"589":{"body":15,"breadcrumbs":7,"title":1},"59":{"body":17,"breadcrumbs":7,"title":2},"590":{"body":37,"breadcrumbs":9,"title":3},"591":{"body":114,"breadcrumbs":7,"title":1},"592":{"body":3,"breadcrumbs":7,"title":1},"593":{"body":7,"breadcrumbs":8,"title":2},"594":{"body":20,"breadcrumbs":7,"title":1},"595":{"body":29,"breadcrumbs":7,"title":1},"596":{"body":6,"breadcrumbs":9,"title":3},"597":{"body":16,"breadcrumbs":7,"title":1},"598":{"body":22,"breadcrumbs":7,"title":1},"599":{"body":14,"breadcrumbs":11,"title":5},"6":{"body":48,"breadcrumbs":9,"title":6},"60":{"body":3,"breadcrumbs":6,"title":1},"600":{"body":48,"breadcrumbs":7,"title":1},"601":{"body":11,"breadcrumbs":7,"title":1},"602":{"body":5,"breadcrumbs":8,"title":2},"603":{"body":49,"breadcrumbs":7,"title":1},"604":{"body":27,"breadcrumbs":7,"title":1},"605":{"body":6,"breadcrumbs":9,"title":3},"606":{"body":16,"breadcrumbs":7,"title":1},"607":{"body":28,"breadcrumbs":7,"title":1},"608":{"body":6,"breadcrumbs":8,"title":2},"609":{"body":12,"breadcrumbs":7,"title":1},"61":{"body":82,"breadcrumbs":7,"title":2},"610":{"body":21,"breadcrumbs":7,"title":1},"611":{"body":10,"breadcrumbs":9,"title":3},"612":{"body":21,"breadcrumbs":7,"title":1},"613":{"body":40,"breadcrumbs":7,"title":1},"614":{"body":6,"breadcrumbs":8,"title":2},"615":{"body":29,"breadcrumbs":7,"title":1},"616":{"body":17,"breadcrumbs":7,"title":1},"617":{"body":7,"breadcrumbs":10,"title":4},"618":{"body":69,"breadcrumbs":7,"title":1},"619":{"body":23,"breadcrumbs":7,"title":1},"62":{"body":53,"breadcrumbs":7,"title":2},"620":{"body":6,"breadcrumbs":8,"title":2},"621":{"body":33,"breadcrumbs":7,"title":1},"622":{"body":11,"breadcrumbs":7,"title":1},"623":{"body":5,"breadcrumbs":8,"title":2},"624":{"body":24,"breadcrumbs":7,"title":1},"625":{"body":27,"breadcrumbs":7,"title":1},"626":{"body":8,"breadcrumbs":9,"title":3},"627":{"body":10,"breadcrumbs":9,"title":3},"628":{"body":91,"breadcrumbs":7,"title":1},"629":{"body":52,"breadcrumbs":7,"title":1},"63":{"body":49,"breadcrumbs":8,"title":3},"630":{"body":10,"breadcrumbs":10,"title":4},"631":{"body":52,"breadcrumbs":7,"title":1},"632":{"body":60,"breadcrumbs":7,"title":1},"633":{"body":56,"breadcrumbs":9,"title":3},"634":{"body":37,"breadcrumbs":7,"title":1},"635":{"body":13,"breadcrumbs":7,"title":1},"636":{"body":31,"breadcrumbs":11,"title":5},"637":{"body":43,"breadcrumbs":7,"title":1},"638":{"body":13,"breadcrumbs":7,"title":1},"639":{"body":8,"breadcrumbs":9,"title":3},"64":{"body":54,"breadcrumbs":8,"title":3},"640":{"body":8,"breadcrumbs":10,"title":4},"641":{"body":6,"breadcrumbs":8,"title":2},"642":{"body":21,"breadcrumbs":7,"title":1},"643":{"body":14,"breadcrumbs":7,"title":1},"644":{"body":6,"breadcrumbs":8,"title":2},"645":{"body":27,"breadcrumbs":7,"title":1},"646":{"body":20,"breadcrumbs":7,"title":1},"647":{"body":19,"breadcrumbs":10,"title":4},"648":{"body":46,"breadcrumbs":7,"title":1},"649":{"body":12,"breadcrumbs":7,"title":1},"65":{"body":30,"breadcrumbs":7,"title":2},"650":{"body":6,"breadcrumbs":8,"title":2},"651":{"body":31,"breadcrumbs":7,"title":1},"652":{"body":32,"breadcrumbs":7,"title":1},"653":{"body":7,"breadcrumbs":8,"title":2},"654":{"body":22,"breadcrumbs":7,"title":1},"655":{"body":7,"breadcrumbs":7,"title":1},"656":{"body":9,"breadcrumbs":8,"title":2},"657":{"body":19,"breadcrumbs":7,"title":1},"658":{"body":6,"breadcrumbs":7,"title":1},"659":{"body":8,"breadcrumbs":9,"title":3},"66":{"body":70,"breadcrumbs":6,"title":1},"660":{"body":29,"breadcrumbs":7,"title":1},"661":{"body":14,"breadcrumbs":7,"title":1},"662":{"body":20,"breadcrumbs":8,"title":2},"663":{"body":6,"breadcrumbs":8,"title":2},"664":{"body":16,"breadcrumbs":7,"title":1},"665":{"body":21,"breadcrumbs":7,"title":1},"666":{"body":6,"breadcrumbs":8,"title":2},"667":{"body":15,"breadcrumbs":7,"title":1},"668":{"body":14,"breadcrumbs":7,"title":1},"669":{"body":21,"breadcrumbs":8,"title":2},"67":{"body":32,"breadcrumbs":8,"title":3},"670":{"body":19,"breadcrumbs":7,"title":1},"671":{"body":25,"breadcrumbs":7,"title":1},"672":{"body":8,"breadcrumbs":8,"title":2},"673":{"body":34,"breadcrumbs":7,"title":1},"674":{"body":10,"breadcrumbs":7,"title":1},"675":{"body":8,"breadcrumbs":8,"title":2},"676":{"body":21,"breadcrumbs":7,"title":1},"677":{"body":6,"breadcrumbs":7,"title":1},"678":{"body":7,"breadcrumbs":8,"title":2},"679":{"body":22,"breadcrumbs":7,"title":1},"68":{"body":29,"breadcrumbs":6,"title":1},"680":{"body":7,"breadcrumbs":7,"title":1},"681":{"body":7,"breadcrumbs":8,"title":2},"682":{"body":17,"breadcrumbs":7,"title":1},"683":{"body":11,"breadcrumbs":7,"title":1},"684":{"body":6,"breadcrumbs":8,"title":2},"685":{"body":21,"breadcrumbs":7,"title":1},"686":{"body":14,"breadcrumbs":7,"title":1},"687":{"body":12,"breadcrumbs":10,"title":4},"688":{"body":46,"breadcrumbs":7,"title":1},"689":{"body":11,"breadcrumbs":7,"title":1},"69":{"body":48,"breadcrumbs":7,"title":2},"690":{"body":80,"breadcrumbs":9,"title":3},"691":{"body":29,"breadcrumbs":7,"title":1},"692":{"body":37,"breadcrumbs":7,"title":1},"693":{"body":8,"breadcrumbs":7,"title":1},"694":{"body":25,"breadcrumbs":7,"title":1},"695":{"body":19,"breadcrumbs":7,"title":1},"696":{"body":4,"breadcrumbs":7,"title":1},"697":{"body":16,"breadcrumbs":7,"title":1},"698":{"body":15,"breadcrumbs":7,"title":1},"699":{"body":52,"breadcrumbs":9,"title":3},"7":{"body":118,"breadcrumbs":9,"title":6},"70":{"body":175,"breadcrumbs":7,"title":2},"700":{"body":9,"breadcrumbs":9,"title":3},"701":{"body":90,"breadcrumbs":7,"title":1},"702":{"body":55,"breadcrumbs":7,"title":1},"703":{"body":13,"breadcrumbs":9,"title":3},"704":{"body":111,"breadcrumbs":7,"title":1},"705":{"body":18,"breadcrumbs":7,"title":1},"706":{"body":6,"breadcrumbs":8,"title":2},"707":{"body":19,"breadcrumbs":7,"title":1},"708":{"body":24,"breadcrumbs":7,"title":1},"709":{"body":12,"breadcrumbs":9,"title":3},"71":{"body":18,"breadcrumbs":7,"title":2},"710":{"body":57,"breadcrumbs":7,"title":1},"711":{"body":37,"breadcrumbs":7,"title":1},"712":{"body":10,"breadcrumbs":9,"title":3},"713":{"body":36,"breadcrumbs":7,"title":1},"714":{"body":56,"breadcrumbs":7,"title":1},"715":{"body":7,"breadcrumbs":9,"title":3},"716":{"body":39,"breadcrumbs":7,"title":1},"717":{"body":24,"breadcrumbs":7,"title":1},"718":{"body":9,"breadcrumbs":9,"title":3},"719":{"body":81,"breadcrumbs":7,"title":1},"72":{"body":36,"breadcrumbs":8,"title":3},"720":{"body":63,"breadcrumbs":7,"title":1},"721":{"body":12,"breadcrumbs":10,"title":4},"722":{"body":72,"breadcrumbs":7,"title":1},"723":{"body":36,"breadcrumbs":7,"title":1},"724":{"body":14,"breadcrumbs":11,"title":5},"725":{"body":94,"breadcrumbs":7,"title":1},"726":{"body":38,"breadcrumbs":7,"title":1},"727":{"body":20,"breadcrumbs":10,"title":4},"728":{"body":74,"breadcrumbs":7,"title":1},"729":{"body":30,"breadcrumbs":7,"title":1},"73":{"body":33,"breadcrumbs":8,"title":3},"730":{"body":14,"breadcrumbs":10,"title":4},"731":{"body":35,"breadcrumbs":7,"title":1},"732":{"body":26,"breadcrumbs":7,"title":1},"733":{"body":6,"breadcrumbs":8,"title":2},"734":{"body":9,"breadcrumbs":10,"title":4},"735":{"body":28,"breadcrumbs":7,"title":1},"736":{"body":21,"breadcrumbs":7,"title":1},"737":{"body":11,"breadcrumbs":10,"title":4},"738":{"body":41,"breadcrumbs":7,"title":1},"739":{"body":39,"breadcrumbs":7,"title":1},"74":{"body":39,"breadcrumbs":6,"title":1},"740":{"body":11,"breadcrumbs":8,"title":2},"741":{"body":21,"breadcrumbs":7,"title":1},"742":{"body":77,"breadcrumbs":7,"title":1},"743":{"body":6,"breadcrumbs":10,"title":4},"744":{"body":37,"breadcrumbs":7,"title":1},"745":{"body":18,"breadcrumbs":7,"title":1},"746":{"body":9,"breadcrumbs":9,"title":3},"747":{"body":31,"breadcrumbs":7,"title":1},"748":{"body":49,"breadcrumbs":7,"title":1},"749":{"body":5,"breadcrumbs":9,"title":3},"75":{"body":9,"breadcrumbs":7,"title":2},"750":{"body":27,"breadcrumbs":7,"title":1},"751":{"body":18,"breadcrumbs":7,"title":1},"752":{"body":11,"breadcrumbs":9,"title":3},"753":{"body":24,"breadcrumbs":7,"title":1},"754":{"body":10,"breadcrumbs":7,"title":1},"755":{"body":9,"breadcrumbs":10,"title":4},"756":{"body":45,"breadcrumbs":7,"title":1},"757":{"body":12,"breadcrumbs":7,"title":1},"758":{"body":8,"breadcrumbs":9,"title":3},"759":{"body":44,"breadcrumbs":7,"title":1},"76":{"body":35,"breadcrumbs":7,"title":2},"760":{"body":13,"breadcrumbs":7,"title":1},"761":{"body":11,"breadcrumbs":9,"title":3},"762":{"body":39,"breadcrumbs":7,"title":1},"763":{"body":23,"breadcrumbs":7,"title":1},"764":{"body":10,"breadcrumbs":10,"title":4},"765":{"body":40,"breadcrumbs":7,"title":1},"766":{"body":23,"breadcrumbs":7,"title":1},"767":{"body":9,"breadcrumbs":9,"title":3},"768":{"body":25,"breadcrumbs":7,"title":1},"769":{"body":37,"breadcrumbs":7,"title":1},"77":{"body":31,"breadcrumbs":7,"title":2},"770":{"body":17,"breadcrumbs":8,"title":2},"771":{"body":67,"breadcrumbs":7,"title":1},"772":{"body":51,"breadcrumbs":7,"title":1},"773":{"body":16,"breadcrumbs":10,"title":4},"774":{"body":47,"breadcrumbs":7,"title":1},"775":{"body":25,"breadcrumbs":7,"title":1},"776":{"body":60,"breadcrumbs":8,"title":2},"777":{"body":12,"breadcrumbs":13,"title":7},"778":{"body":76,"breadcrumbs":7,"title":1},"779":{"body":31,"breadcrumbs":7,"title":1},"78":{"body":11,"breadcrumbs":7,"title":2},"780":{"body":9,"breadcrumbs":8,"title":2},"781":{"body":29,"breadcrumbs":7,"title":1},"782":{"body":13,"breadcrumbs":7,"title":1},"783":{"body":9,"breadcrumbs":9,"title":3},"784":{"body":42,"breadcrumbs":7,"title":1},"785":{"body":32,"breadcrumbs":7,"title":1},"786":{"body":11,"breadcrumbs":11,"title":5},"787":{"body":76,"breadcrumbs":9,"title":3},"788":{"body":77,"breadcrumbs":7,"title":1},"789":{"body":39,"breadcrumbs":7,"title":1},"79":{"body":38,"breadcrumbs":8,"title":3},"790":{"body":7,"breadcrumbs":9,"title":3},"791":{"body":26,"breadcrumbs":7,"title":1},"792":{"body":10,"breadcrumbs":7,"title":1},"793":{"body":12,"breadcrumbs":10,"title":4},"794":{"body":56,"breadcrumbs":7,"title":1},"795":{"body":47,"breadcrumbs":7,"title":1},"796":{"body":7,"breadcrumbs":8,"title":2},"797":{"body":26,"breadcrumbs":7,"title":1},"798":{"body":14,"breadcrumbs":7,"title":1},"799":{"body":10,"breadcrumbs":10,"title":4},"8":{"body":42,"breadcrumbs":7,"title":4},"80":{"body":175,"breadcrumbs":8,"title":3},"800":{"body":50,"breadcrumbs":7,"title":1},"801":{"body":73,"breadcrumbs":7,"title":1},"802":{"body":7,"breadcrumbs":9,"title":3},"803":{"body":21,"breadcrumbs":7,"title":1},"804":{"body":15,"breadcrumbs":7,"title":1},"805":{"body":11,"breadcrumbs":11,"title":5},"806":{"body":75,"breadcrumbs":7,"title":1},"807":{"body":27,"breadcrumbs":7,"title":1},"808":{"body":10,"breadcrumbs":11,"title":5},"809":{"body":59,"breadcrumbs":7,"title":1},"81":{"body":55,"breadcrumbs":6,"title":1},"810":{"body":34,"breadcrumbs":7,"title":1},"811":{"body":16,"breadcrumbs":9,"title":3},"812":{"body":70,"breadcrumbs":7,"title":1},"813":{"body":39,"breadcrumbs":7,"title":1},"814":{"body":20,"breadcrumbs":8,"title":2},"815":{"body":7,"breadcrumbs":9,"title":3},"816":{"body":45,"breadcrumbs":7,"title":1},"817":{"body":18,"breadcrumbs":7,"title":1},"818":{"body":15,"breadcrumbs":10,"title":4},"819":{"body":55,"breadcrumbs":7,"title":1},"82":{"body":170,"breadcrumbs":7,"title":2},"820":{"body":38,"breadcrumbs":7,"title":1},"821":{"body":14,"breadcrumbs":10,"title":4},"822":{"body":51,"breadcrumbs":7,"title":1},"823":{"body":68,"breadcrumbs":7,"title":1},"824":{"body":7,"breadcrumbs":8,"title":2},"825":{"body":21,"breadcrumbs":7,"title":1},"826":{"body":26,"breadcrumbs":7,"title":1},"827":{"body":9,"breadcrumbs":9,"title":3},"828":{"body":28,"breadcrumbs":7,"title":1},"829":{"body":11,"breadcrumbs":7,"title":1},"83":{"body":98,"breadcrumbs":7,"title":2},"830":{"body":9,"breadcrumbs":9,"title":3},"831":{"body":14,"breadcrumbs":7,"title":1},"832":{"body":7,"breadcrumbs":7,"title":1},"833":{"body":6,"breadcrumbs":8,"title":2},"834":{"body":69,"breadcrumbs":7,"title":1},"835":{"body":5,"breadcrumbs":7,"title":1},"836":{"body":67,"breadcrumbs":4,"title":2},"837":{"body":539,"breadcrumbs":3,"title":1},"838":{"body":102,"breadcrumbs":4,"title":2},"839":{"body":52,"breadcrumbs":5,"title":3},"84":{"body":106,"breadcrumbs":8,"title":3},"840":{"body":106,"breadcrumbs":5,"title":3},"841":{"body":95,"breadcrumbs":3,"title":1},"842":{"body":217,"breadcrumbs":2,"title":1},"843":{"body":57,"breadcrumbs":3,"title":2},"844":{"body":27,"breadcrumbs":3,"title":2},"845":{"body":45,"breadcrumbs":2,"title":1},"846":{"body":27,"breadcrumbs":3,"title":2},"847":{"body":111,"breadcrumbs":3,"title":2},"848":{"body":226,"breadcrumbs":3,"title":2},"849":{"body":170,"breadcrumbs":3,"title":2},"85":{"body":26,"breadcrumbs":7,"title":2},"850":{"body":34,"breadcrumbs":3,"title":2},"851":{"body":20,"breadcrumbs":2,"title":1},"852":{"body":17,"breadcrumbs":4,"title":3},"853":{"body":46,"breadcrumbs":2,"title":1},"854":{"body":54,"breadcrumbs":3,"title":2},"855":{"body":56,"breadcrumbs":5,"title":2},"856":{"body":69,"breadcrumbs":5,"title":2},"857":{"body":46,"breadcrumbs":5,"title":2},"858":{"body":55,"breadcrumbs":7,"title":4},"859":{"body":15,"breadcrumbs":5,"title":2},"86":{"body":138,"breadcrumbs":6,"title":1},"860":{"body":121,"breadcrumbs":5,"title":2},"861":{"body":12,"breadcrumbs":6,"title":3},"862":{"body":53,"breadcrumbs":6,"title":3},"863":{"body":217,"breadcrumbs":4,"title":1},"864":{"body":200,"breadcrumbs":6,"title":3},"865":{"body":44,"breadcrumbs":4,"title":1},"866":{"body":30,"breadcrumbs":5,"title":2},"867":{"body":71,"breadcrumbs":6,"title":3},"868":{"body":0,"breadcrumbs":8,"title":4},"869":{"body":14,"breadcrumbs":5,"title":1},"87":{"body":29,"breadcrumbs":6,"title":1},"870":{"body":122,"breadcrumbs":5,"title":1},"871":{"body":70,"breadcrumbs":9,"title":5},"872":{"body":45,"breadcrumbs":6,"title":2},"873":{"body":144,"breadcrumbs":7,"title":3},"874":{"body":168,"breadcrumbs":12,"title":8},"875":{"body":130,"breadcrumbs":8,"title":4},"876":{"body":143,"breadcrumbs":7,"title":3},"877":{"body":109,"breadcrumbs":6,"title":2},"878":{"body":252,"breadcrumbs":6,"title":2},"879":{"body":80,"breadcrumbs":8,"title":4},"88":{"body":30,"breadcrumbs":7,"title":2},"880":{"body":184,"breadcrumbs":7,"title":3},"881":{"body":39,"breadcrumbs":7,"title":3},"882":{"body":19,"breadcrumbs":5,"title":1},"883":{"body":5,"breadcrumbs":7,"title":3},"884":{"body":23,"breadcrumbs":5,"title":1},"885":{"body":39,"breadcrumbs":8,"title":4},"886":{"body":39,"breadcrumbs":5,"title":1},"887":{"body":104,"breadcrumbs":9,"title":5},"888":{"body":90,"breadcrumbs":8,"title":4},"889":{"body":30,"breadcrumbs":10,"title":6},"89":{"body":27,"breadcrumbs":6,"title":1},"890":{"body":181,"breadcrumbs":11,"title":7},"891":{"body":111,"breadcrumbs":6,"title":2},"892":{"body":76,"breadcrumbs":6,"title":3},"893":{"body":245,"breadcrumbs":7,"title":4},"894":{"body":88,"breadcrumbs":7,"title":4},"895":{"body":61,"breadcrumbs":6,"title":3},"896":{"body":0,"breadcrumbs":4,"title":1},"897":{"body":96,"breadcrumbs":7,"title":4},"898":{"body":69,"breadcrumbs":7,"title":4},"899":{"body":55,"breadcrumbs":8,"title":5},"9":{"body":83,"breadcrumbs":6,"title":3},"90":{"body":3,"breadcrumbs":7,"title":2},"900":{"body":36,"breadcrumbs":10,"title":5},"901":{"body":29,"breadcrumbs":7,"title":2},"902":{"body":47,"breadcrumbs":9,"title":4},"903":{"body":36,"breadcrumbs":10,"title":5},"904":{"body":39,"breadcrumbs":6,"title":3},"905":{"body":30,"breadcrumbs":6,"title":3},"906":{"body":12,"breadcrumbs":4,"title":1},"907":{"body":0,"breadcrumbs":5,"title":2},"908":{"body":39,"breadcrumbs":6,"title":3},"909":{"body":18,"breadcrumbs":5,"title":2},"91":{"body":4,"breadcrumbs":7,"title":2},"910":{"body":25,"breadcrumbs":5,"title":2},"911":{"body":29,"breadcrumbs":4,"title":2},"912":{"body":137,"breadcrumbs":3,"title":1},"913":{"body":174,"breadcrumbs":4,"title":2},"914":{"body":88,"breadcrumbs":5,"title":3},"915":{"body":214,"breadcrumbs":5,"title":3},"916":{"body":159,"breadcrumbs":6,"title":4},"917":{"body":158,"breadcrumbs":5,"title":3},"918":{"body":205,"breadcrumbs":6,"title":4},"919":{"body":214,"breadcrumbs":5,"title":3},"92":{"body":7,"breadcrumbs":7,"title":2},"920":{"body":73,"breadcrumbs":5,"title":3},"921":{"body":170,"breadcrumbs":7,"title":5},"922":{"body":192,"breadcrumbs":7,"title":5},"923":{"body":114,"breadcrumbs":3,"title":1},"924":{"body":526,"breadcrumbs":3,"title":1},"925":{"body":30,"breadcrumbs":4,"title":2},"926":{"body":32,"breadcrumbs":5,"title":3},"927":{"body":44,"breadcrumbs":3,"title":1},"928":{"body":28,"breadcrumbs":4,"title":2},"929":{"body":142,"breadcrumbs":8,"title":3},"93":{"body":39,"breadcrumbs":7,"title":2},"930":{"body":42,"breadcrumbs":6,"title":1},"931":{"body":71,"breadcrumbs":7,"title":2},"932":{"body":97,"breadcrumbs":7,"title":2},"933":{"body":83,"breadcrumbs":7,"title":2},"934":{"body":145,"breadcrumbs":8,"title":3},"935":{"body":73,"breadcrumbs":8,"title":3},"936":{"body":81,"breadcrumbs":8,"title":3},"937":{"body":93,"breadcrumbs":7,"title":2},"938":{"body":64,"breadcrumbs":8,"title":3},"939":{"body":163,"breadcrumbs":8,"title":3},"94":{"body":39,"breadcrumbs":7,"title":2},"940":{"body":107,"breadcrumbs":8,"title":3},"941":{"body":73,"breadcrumbs":6,"title":1},"942":{"body":120,"breadcrumbs":6,"title":1},"943":{"body":104,"breadcrumbs":7,"title":2},"944":{"body":92,"breadcrumbs":6,"title":1},"945":{"body":147,"breadcrumbs":6,"title":1},"946":{"body":151,"breadcrumbs":6,"title":1},"947":{"body":58,"breadcrumbs":6,"title":1},"948":{"body":539,"breadcrumbs":6,"title":1},"949":{"body":89,"breadcrumbs":6,"title":1},"95":{"body":61,"breadcrumbs":6,"title":1},"950":{"body":156,"breadcrumbs":6,"title":1},"951":{"body":73,"breadcrumbs":7,"title":2},"952":{"body":97,"breadcrumbs":8,"title":3},"953":{"body":131,"breadcrumbs":7,"title":2},"954":{"body":97,"breadcrumbs":8,"title":3},"955":{"body":368,"breadcrumbs":8,"title":3},"956":{"body":62,"breadcrumbs":8,"title":3},"957":{"body":27,"breadcrumbs":4,"title":2},"958":{"body":35,"breadcrumbs":4,"title":2},"959":{"body":242,"breadcrumbs":6,"title":4},"96":{"body":25,"breadcrumbs":6,"title":1},"960":{"body":46,"breadcrumbs":4,"title":2},"961":{"body":378,"breadcrumbs":6,"title":4},"962":{"body":677,"breadcrumbs":7,"title":5},"963":{"body":1595,"breadcrumbs":4,"title":2},"964":{"body":0,"breadcrumbs":8,"title":3},"965":{"body":24,"breadcrumbs":7,"title":2},"966":{"body":490,"breadcrumbs":6,"title":1},"967":{"body":110,"breadcrumbs":8,"title":3},"968":{"body":771,"breadcrumbs":9,"title":4},"969":{"body":1009,"breadcrumbs":9,"title":4},"97":{"body":45,"breadcrumbs":7,"title":2},"970":{"body":500,"breadcrumbs":9,"title":4},"971":{"body":590,"breadcrumbs":9,"title":4},"972":{"body":405,"breadcrumbs":9,"title":4},"973":{"body":9,"breadcrumbs":9,"title":3},"974":{"body":2,"breadcrumbs":8,"title":2},"975":{"body":53,"breadcrumbs":7,"title":1},"976":{"body":12,"breadcrumbs":8,"title":2},"977":{"body":24,"breadcrumbs":9,"title":3},"978":{"body":25,"breadcrumbs":7,"title":1},"979":{"body":23,"breadcrumbs":11,"title":5},"98":{"body":31,"breadcrumbs":7,"title":2},"980":{"body":16,"breadcrumbs":10,"title":4},"981":{"body":1,"breadcrumbs":8,"title":2},"982":{"body":57,"breadcrumbs":7,"title":1},"983":{"body":130,"breadcrumbs":11,"title":5},"984":{"body":14,"breadcrumbs":8,"title":2},"985":{"body":8,"breadcrumbs":9,"title":3},"986":{"body":6,"breadcrumbs":7,"title":1},"987":{"body":21,"breadcrumbs":11,"title":5},"988":{"body":25,"breadcrumbs":6,"title":2},"989":{"body":2,"breadcrumbs":6,"title":2},"99":{"body":25,"breadcrumbs":7,"title":2},"990":{"body":0,"breadcrumbs":5,"title":1},"991":{"body":41,"breadcrumbs":6,"title":2},"992":{"body":36,"breadcrumbs":6,"title":2},"993":{"body":10,"breadcrumbs":6,"title":2},"994":{"body":8,"breadcrumbs":5,"title":1},"995":{"body":12,"breadcrumbs":5,"title":1},"996":{"body":61,"breadcrumbs":9,"title":5},"997":{"body":5,"breadcrumbs":10,"title":3},"998":{"body":2,"breadcrumbs":9,"title":2},"999":{"body":7,"breadcrumbs":8,"title":1}},"docs":{"0":{"body":"Welcome to \\"The rustc book\\"! rustc is the compiler for the Rust programming language, provided by the project itself. Compilers take your source code and produce binary code, either as a library or executable. Most Rust programmers don\'t invoke rustc directly, but instead do it through Cargo . It\'s all in service of rustc though! If you want to see how Cargo calls rustc, you can $ cargo build --verbose And it will print out each rustc invocation. This book can help you understand what each of these options does. Additionally, while most Rustaceans use Cargo, not all do: sometimes they integrate rustc into other build systems. This book should provide a guide to all of the options you\'d need to do so.","breadcrumbs":"What is rustc?  What is rustc?","id":"0","title":"What is rustc?"},"1":{"body":"Let\'s say you\'ve got a little hello world program in a file hello.rs: fn main() { println!(\\"Hello, world!\\");\\n} To turn this source code into an executable, you can use rustc: $ rustc hello.rs\\n$ ./hello # on a *NIX\\n$ .\\\\hello.exe # on Windows Note that we only ever pass rustc the crate root , not every file we wish to compile. For example, if we had a main.rs that looked like this: mod foo; fn main() { foo::hello();\\n} And a foo.rs that had this: pub fn hello() { println!(\\"Hello, world!\\");\\n} To compile this, we\'d run this command: $ rustc main.rs No need to tell rustc about foo.rs; the mod statements give it everything that it needs. This is different than how you would use a C compiler, where you invoke the compiler on each file, and then link everything together. In other words, the crate is a translation unit, not a particular module.","breadcrumbs":"What is rustc?  Basic usage","id":"1","title":"Basic usage"},"10":{"body":"This modifier is compatible with all linking kinds. +verbatim means that rustc itself won\'t add any target-specified library prefixes or suffixes (like lib or .a) to the library name, and will try its best to ask for the same thing from the linker. For ld-like linkers supporting GNU extensions rustc will use the -l:filename syntax (note the colon) when passing the library, so the linker won\'t add any prefixes or suffixes to it. See -l namespec in ld documentation for more details. For linkers not supporting any verbatim modifiers (e.g. link.exe or ld64) the library name will be passed as is. So the most reliable cross-platform use scenarios for this option are when no linker is involved, for example bundling native libraries into rlibs. -verbatim means that rustc will either add a target-specific prefix and suffix to the library name before passing it to linker, or won\'t prevent linker from implicitly adding it. In case of raw-dylib kind in particular .dll will be added to the library name on Windows. The default for this modifier is -verbatim. NOTE: Even with +verbatim and -l:filename syntax ld-like linkers do not typically support passing absolute paths to libraries. Usually such paths need to be passed as input files without using any options like -l, e.g. ld /my/absolute/path. -Clink-arg=/my/absolute/path can be used for doing this from stable rustc.","breadcrumbs":"Command-line Arguments  Linking modifiers: verbatim","id":"10","title":"Linking modifiers: verbatim"},"100":{"body":"This option controls generation of position-independent code (PIC) . Supported values for this option are: Primary relocation models static - non-relocatable code, machine instructions may use absolute addressing modes. pic - fully relocatable position independent code, machine instructions need to use relative addressing modes. Equivalent to the \\"uppercase\\" -fPIC or -fPIE options in other compilers, depending on the produced crate types. This is the default model for majority of supported targets. pie - position independent executable, relocatable code but without support for symbol interpositioning (replacing symbols by name using LD_PRELOAD and similar). Equivalent to the \\"uppercase\\" -fPIE option in other compilers. pie code cannot be linked into shared libraries (you\'ll get a linking error on attempt to do this). Special relocation models dynamic-no-pic - relocatable external references, non-relocatable code. Only makes sense on Darwin and is rarely used. If StackOverflow tells you to use this as an opt-out of PIC or PIE, don\'t believe it, use -C relocation-model=static instead. ropi, rwpi and ropi-rwpi - relocatable code and read-only data, relocatable read-write data, and combination of both, respectively. Only makes sense for certain embedded ARM targets. default - relocation model default to the current target. Only makes sense as an override for some other explicitly specified relocation model previously set on the command line. Supported values can also be discovered by running rustc --print relocation-models. Linking effects In addition to codegen effects, relocation-model has effects during linking. If the relocation model is pic and the current target supports position-independent executables (PIE), the linker will be instructed (-pie) to produce one. If the target doesn\'t support both position-independent and statically linked executables, then -C target-feature=+crt-static \\"wins\\" over -C relocation-model=pic, and the linker is instructed (-static) to produce a statically linked but not position-independent executable.","breadcrumbs":"Command-line Arguments  Codegen Options  relocation-model","id":"100","title":"relocation-model"},"1000":{"body":"You\'ll need the macOS 10.13 SDK shipped with Xcode 9. The location of the SDK can be passed to rustc using the common SDKROOT environment variable. Once you have that, you can build Rust with support for the target by adding it to the target list in bootstrap.toml: [build]\\ntarget = [\\"i686-apple-darwin\\"] Using the unstable -Zbuild-std with a nightly Cargo may also work.","breadcrumbs":"Platform Support  *-apple-darwin  i686-apple-darwin  Building the target","id":"1000","title":"Building the target"},"1001":{"body":"Rust no longer ships pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy using build-std or similar.","breadcrumbs":"Platform Support  *-apple-darwin  i686-apple-darwin  Building Rust programs","id":"1001","title":"Building Rust programs"},"1002":{"body":"Running this target requires an Intel Macbook running macOS 10.14 or earlier, as later versions removed support for running 32-bit binaries.","breadcrumbs":"Platform Support  *-apple-darwin  i686-apple-darwin  Testing","id":"1002","title":"Testing"},"1003":{"body":"Tier: 3 Target for macOS on late-generation x86_64 Apple chips, usable as the x86_64h entry in universal binaries, and equivalent to LLVM\'s x86_64h-apple-macosx* targets.","breadcrumbs":"Platform Support  *-apple-darwin  x86_64h-apple-darwin  x86_64h-apple-darwin","id":"1003","title":"x86_64h-apple-darwin"},"1004":{"body":"@thomcc","breadcrumbs":"Platform Support  *-apple-darwin  x86_64h-apple-darwin  Target maintainers","id":"1004","title":"Target maintainers"},"1005":{"body":"This target is an x86_64 target that only supports Apple\'s late-gen (Haswell-compatible) Intel chips. It enables a set of target features available on these chips (AVX2 and similar), and MachO binaries built with this target may be used as the x86_64h entry in universal binaries (\\"fat\\" MachO binaries), and will fail to load on machines that do not support this. It should support the full standard library (std and alloc either with default or user-defined allocators). This target is probably most useful when targeted via cross-compilation (including from x86_64-apple-darwin), but if built manually, the host tools work. It is similar to x86_64-apple-darwin in nearly all respects.","breadcrumbs":"Platform Support  *-apple-darwin  x86_64h-apple-darwin  Requirements","id":"1005","title":"Requirements"},"1006":{"body":"Users on Apple targets can build this by adding it to the target list in bootstrap.toml, or with -Zbuild-std.","breadcrumbs":"Platform Support  *-apple-darwin  x86_64h-apple-darwin  Building the target","id":"1006","title":"Building the target"},"1007":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar.","breadcrumbs":"Platform Support  *-apple-darwin  x86_64h-apple-darwin  Building Rust programs","id":"1007","title":"Building Rust programs"},"1008":{"body":"Code built with this target can be run on the set of Intel macOS machines that support running x86_64h binaries (relatively recent Intel macs). The Rust test suite seems to work.","breadcrumbs":"Platform Support  *-apple-darwin  x86_64h-apple-darwin  Testing","id":"1008","title":"Testing"},"1009":{"body":"Cross-compilation to this target from Apple hosts should generally work without much configuration, so long as XCode and the CommandLineTools are installed. Targeting it from non-Apple hosts is difficult, but no more so than targeting x86_64-apple-darwin. When compiling C code for this target, either the \\"x86_64h-apple-macosx*\\" LLVM targets should be used, or an argument like -arch x86_64h should be passed to the C compiler.","breadcrumbs":"Platform Support  *-apple-darwin  x86_64h-apple-darwin  Cross-compilation toolchains and C code","id":"1009","title":"Cross-compilation toolchains and C code"},"101":{"body":"This flag controls what level of RELRO (Relocation Read-Only) is enabled. RELRO is an exploit mitigation which makes the Global Offset Table (GOT) read-only. Supported values for this option are: off: Dynamically linked functions are resolved lazily and the GOT is writable. partial: Dynamically linked functions are resolved lazily and written into the Procedure Linking Table (PLT) part of the GOT (.got.plt). The non-PLT part of the GOT (.got) is made read-only and both are moved to prevent writing from buffer overflows. full: Dynamically linked functions are resolved at the start of program execution and the Global Offset Table (.got/.got.plt) is populated eagerly and then made read-only. The GOT is also moved to prevent writing from buffer overflows. Full RELRO uses more memory and increases process startup time. This flag is ignored on platforms where RELRO is not supported (targets which do not use the ELF binary format), such as Windows or macOS. Each rustc target has its own default for RELRO. rustc enables Full RELRO by default on platforms where it is supported.","breadcrumbs":"Command-line Arguments  Codegen Options  relro-level","id":"101","title":"relro-level"},"1010":{"body":"Tier: 3 (with Host Tools) ARM64e macOS (11.0+, Big Sur+)","breadcrumbs":"Platform Support  *-apple-darwin  arm64e-apple-darwin  arm64e-apple-darwin","id":"1010","title":"arm64e-apple-darwin"},"1011":{"body":"@arttet","breadcrumbs":"Platform Support  *-apple-darwin  arm64e-apple-darwin  Target maintainers","id":"1011","title":"Target maintainers"},"1012":{"body":"Target for macOS on late-generation M series Apple chips. See the docs on *-apple-darwin for general macOS requirements.","breadcrumbs":"Platform Support  *-apple-darwin  arm64e-apple-darwin  Requirements","id":"1012","title":"Requirements"},"1013":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml: [build]\\ntarget = [\\"arm64e-apple-darwin\\"]","breadcrumbs":"Platform Support  *-apple-darwin  arm64e-apple-darwin  Building the target","id":"1013","title":"Building the target"},"1014":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will need to build Rust with the target enabled (see Building the target above).","breadcrumbs":"Platform Support  *-apple-darwin  arm64e-apple-darwin  Building Rust programs","id":"1014","title":"Building Rust programs"},"1015":{"body":"The target does support running binaries on macOS platforms with arm64e architecture.","breadcrumbs":"Platform Support  *-apple-darwin  arm64e-apple-darwin  Testing","id":"1015","title":"Testing"},"1016":{"body":"The targets do support C code. To build compatible C code, you have to use XCode with the same compiler and flags.","breadcrumbs":"Platform Support  *-apple-darwin  arm64e-apple-darwin  Cross-compilation toolchains and C code","id":"1016","title":"Cross-compilation toolchains and C code"},"1017":{"body":"Apple iOS / iPadOS targets. Tier: 2 (without Host Tools) aarch64-apple-ios: Apple iOS on ARM64. aarch64-apple-ios-sim: Apple iOS Simulator on ARM64. x86_64-apple-ios: Apple iOS Simulator on 64-bit x86. Tier: 3 armv7s-apple-ios: Apple iOS on Armv7-A. i386-apple-ios: Apple iOS Simulator on 32-bit x86.","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios","id":"1017","title":"*-apple-ios"},"1018":{"body":"@badboy @deg4uss3r @madsmtm","breadcrumbs":"Platform Support  *-apple-ios  Target maintainers","id":"1018","title":"Target maintainers"},"1019":{"body":"These targets are cross-compiled, and require the corresponding iOS SDK (iPhoneOS.sdk or iPhoneSimulator.sdk), as provided by Xcode. To build the ARM64 targets, Xcode 12 or higher is required. The path to the SDK can be passed to rustc using the common SDKROOT environment variable, or will be inferred when compiling on host macOS using roughly the same logic as xcrun --sdk iphoneos --show-sdk-path.","breadcrumbs":"Platform Support  *-apple-ios  Requirements","id":"1019","title":"Requirements"},"102":{"body":"This flag lets you print remarks for optimization passes. The list of passes should be separated by spaces. all will remark on every pass.","breadcrumbs":"Command-line Arguments  Codegen Options  remark","id":"102","title":"remark"},"1020":{"body":"The minimum supported version is iOS 10.0. This can be raised per-binary by changing the deployment target. rustc respects the common environment variables used by Xcode to do so, in this case IPHONEOS_DEPLOYMENT_TARGET.","breadcrumbs":"Platform Support  *-apple-ios  OS version","id":"1020","title":"OS version"},"1021":{"body":"The tier 2 targets are distributed through rustup, and can be installed using one of: $ rustup target add aarch64-apple-ios\\n$ rustup target add aarch64-apple-ios-sim\\n$ rustup target add x86_64-apple-ios The tier 3 targets can be built by enabling them for a rustc build in bootstrap.toml, by adding, for example: [build]\\ntarget = [\\"armv7s-apple-ios\\", \\"i386-apple-ios\\"] Using the unstable -Zbuild-std with a nightly Cargo may also work.","breadcrumbs":"Platform Support  *-apple-ios  Building the target","id":"1021","title":"Building the target"},"1022":{"body":"Rust programs can be built for these targets by specifying --target, if rustc has been built with support for them. For example: $ rustc --target aarch64-apple-ios your-code.rs Or if using Cargo and -Zbuild-std: $ cargo +nightly build -Zbuild-std --target armv7s-apple-ios The simulator variants can be differentiated from the variants running on-device with the target_env = \\"sim\\" cfg (or target_abi = \\"sim\\" before Rust 1.91.0). if cfg!(all(target_vendor = \\"apple\\", target_env = \\"sim\\")) { // Do something on the iOS/tvOS/visionOS/watchOS Simulator.\\n} else { // Everything else, like Windows and non-Simulator iOS.\\n} This is similar to the TARGET_OS_SIMULATOR define in C code.","breadcrumbs":"Platform Support  *-apple-ios  Building Rust programs","id":"1022","title":"Building Rust programs"},"1023":{"body":"Running and testing your code naturally requires either an actual device running iOS, or the equivalent Xcode simulator environment. There exists several tools in the ecosystem for running a Cargo project on one of these. One of these tools is cargo-dinghy . madsmtm/objc2#459 contains a more exhaustive list. See also testing on emulators in the rustc-dev-guide for instructions on running the standard library\'s test suite.","breadcrumbs":"Platform Support  *-apple-ios  Testing","id":"1023","title":"Testing"},"1024":{"body":"Apple Mac Catalyst targets. Tier: 2 (without Host Tools) aarch64-apple-ios-macabi: Mac Catalyst on ARM64. x86_64-apple-ios-macabi: Mac Catalyst on 64-bit x86.","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios-macabi  *-apple-ios-macabi","id":"1024","title":"*-apple-ios-macabi"},"1025":{"body":"@badboy @BlackHoleFox @madsmtm","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios-macabi  Target maintainers","id":"1025","title":"Target maintainers"},"1026":{"body":"These targets are cross-compiled, and require the corresponding macOS SDK (MacOSX.sdk) which contain ./System/iOSSupport headers to allow linking to iOS-specific headers, as provided by Xcode 11 or higher. The path to the SDK can be passed to rustc using the common SDKROOT environment variable, or will be inferred when compiling on host macOS using roughly the same logic as xcrun --sdk macosx --show-sdk-path.","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios-macabi  Requirements","id":"1026","title":"Requirements"},"1027":{"body":"The minimum supported version is iOS 13.1 on x86 and 14.0 on Aarch64. This can be raised per-binary by changing the deployment target. rustc respects the common environment variables used by Xcode to do so, in this case IPHONEOS_DEPLOYMENT_TARGET.","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios-macabi  OS version","id":"1027","title":"OS version"},"1028":{"body":"The targets are distributed through rustup, and can be installed using one of: $ rustup target add aarch64-apple-ios-macabi\\n$ rustup target add x86_64-apple-ios-macabi","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios-macabi  Building the target","id":"1028","title":"Building the target"},"1029":{"body":"Due to CMake having poor support for Mac Catalyst, sanitizer runtimes are not currently available, see #129069 .","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios-macabi  Sanitizers","id":"1029","title":"Sanitizers"},"103":{"body":"This flag controls whether rustc sets an rpath for the binary. It takes one of the following values: y, yes, on, true or no value: enable rpath. n, no, off or false: disable rpath (the default). This flag only does something on Unix-like platforms (Mach-O and ELF), it is ignored on other platforms. If enabled, rustc will add output-relative (using @load_path on Mach-O and $ORIGIN on ELF respectively) rpaths to all dylib dependencies. For example, for the following directory structure, with libdep.so being a dylib crate compiled with -Cprefer-dynamic: dep |- libdep.so\\na.rs rustc a.rs --extern dep=dep/libdep.so -Crpath will, on x86-64 Linux, result in approximately the following DT_RUNPATH: $ORIGIN/dep:$ORIGIN/$RELATIVE_PATH_TO_SYSROOT/lib/rustlib/x86_64-unknown-linux-gnu/lib (where RELATIVE_PATH_TO_SYSROOT depends on the build directory location). This is primarily useful for local development, to ensure that all the dylib dependencies can be found appropriately. To set the rpath to a different value (which can be useful for distribution), -Clink-arg with a platform-specific linker argument can be used to set the rpath directly.","breadcrumbs":"Command-line Arguments  Codegen Options  rpath","id":"103","title":"rpath"},"1030":{"body":"Rust programs can be built for these targets by specifying --target, if rustc has been built with support for them. For example: $ rustc --target aarch64-apple-ios-macabi your-code.rs The target can be differentiated from the iOS targets with the target_env = \\"macabi\\" cfg (or target_abi = \\"macabi\\" before Rust 1.91.0). if cfg!(target_env = \\"macabi\\") { // Do something only on Mac Catalyst.\\n} This is similar to the TARGET_OS_MACCATALYST define in C code.","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios-macabi  Building Rust programs","id":"1030","title":"Building Rust programs"},"1031":{"body":"Mac Catalyst binaries can be run directly on macOS 10.15 Catalina or newer. x86 binaries can be run on Apple Silicon by using Rosetta. Note that using certain UIKit functionality requires the binary to be bundled.","breadcrumbs":"Platform Support  *-apple-ios  *-apple-ios-macabi  Testing","id":"1031","title":"Testing"},"1032":{"body":"Tier: 3 ARM64e iOS (14.0+)","breadcrumbs":"Platform Support  *-apple-ios  arm64e-apple-ios  arm64e-apple-ios","id":"1032","title":"arm64e-apple-ios"},"1033":{"body":"@arttet","breadcrumbs":"Platform Support  *-apple-ios  arm64e-apple-ios  Target maintainers","id":"1033","title":"Target maintainers"},"1034":{"body":"See the docs on *-apple-ios for general iOS requirements.","breadcrumbs":"Platform Support  *-apple-ios  arm64e-apple-ios  Requirements","id":"1034","title":"Requirements"},"1035":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml: [build]\\ntarget = [\\"arm64e-apple-ios\\"]","breadcrumbs":"Platform Support  *-apple-ios  arm64e-apple-ios  Building the target","id":"1035","title":"Building the target"},"1036":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will need to build Rust with the target enabled (see Building the target above).","breadcrumbs":"Platform Support  *-apple-ios  arm64e-apple-ios  Building Rust programs","id":"1036","title":"Building Rust programs"},"1037":{"body":"The target does support running binaries on iOS platforms with arm64e architecture.","breadcrumbs":"Platform Support  *-apple-ios  arm64e-apple-ios  Testing","id":"1037","title":"Testing"},"1038":{"body":"The targets do support C code. To build compatible C code, you have to use XCode with the same compiler and flags.","breadcrumbs":"Platform Support  *-apple-ios  arm64e-apple-ios  Cross-compilation toolchains and C code","id":"1038","title":"Cross-compilation toolchains and C code"},"1039":{"body":"Apple tvOS targets. Tier: 3 aarch64-apple-tvos: Apple tvOS on ARM64. aarch64-apple-tvos-sim: Apple tvOS Simulator on ARM64. x86_64-apple-tvos: Apple tvOS Simulator on x86_64.","breadcrumbs":"Platform Support  *-apple-tvos  *-apple-tvos","id":"1039","title":"*-apple-tvos"},"104":{"body":"This flag controls whether temporary files generated during compilation are deleted once compilation finishes. It takes one of the following values: y, yes, on, true or no value: save temporary files. n, no, off or false: delete temporary files (the default).","breadcrumbs":"Command-line Arguments  Codegen Options  save-temps","id":"104","title":"save-temps"},"1040":{"body":"@thomcc @madsmtm","breadcrumbs":"Platform Support  *-apple-tvos  Target maintainers","id":"1040","title":"Target maintainers"},"1041":{"body":"These targets are cross-compiled, and require the corresponding tvOS SDK (AppleTVOS.sdk or AppleTVSimulator.sdk), as provided by Xcode. To build the ARM64 targets, Xcode 12 or higher is required. The path to the SDK can be passed to rustc using the common SDKROOT environment variable, or will be inferred when compiling on host macOS using roughly the same logic as xcrun --sdk appletvos --show-sdk-path.","breadcrumbs":"Platform Support  *-apple-tvos  Requirements","id":"1041","title":"Requirements"},"1042":{"body":"The minimum supported version is tvOS 10.0, although the actual minimum version you can target may be newer than this, for example due to the versions of Xcode and your SDKs. The version can be raised per-binary by changing the deployment target. rustc respects the common environment variables used by Xcode to do so, in this case TVOS_DEPLOYMENT_TARGET.","breadcrumbs":"Platform Support  *-apple-tvos  OS version","id":"1042","title":"OS version"},"1043":{"body":"The targets support most of the standard library including the allocator to the best of my knowledge, however they are very new, not yet well-tested, and it is possible that there are various bugs. The following APIs are currently known to have missing or incomplete support: std::process::Command\'s API will return an error if it is configured in a manner which cannot be performed using posix_spawn -- this is because the more flexible fork/exec-based approach is prohibited on these platforms in favor of posix_spawn{,p} (which still probably will get you rejected from app stores, so is likely sideloading-only). A concrete set of cases where this will occur is difficult to enumerate (and would quickly become stale), but in some cases it may be worked around by tweaking the manner in which Command is invoked.","breadcrumbs":"Platform Support  *-apple-tvos  Incompletely supported library functionality","id":"1043","title":"Incompletely supported library functionality"},"1044":{"body":"The targets can be built by enabling them for a rustc build in bootstrap.toml, by adding, for example: [build]\\nbuild-stage = 1\\ntarget = [\\"aarch64-apple-tvos\\", \\"aarch64-apple-tvos-sim\\"] Using the unstable -Zbuild-std with a nightly Cargo may also work.","breadcrumbs":"Platform Support  *-apple-tvos  Building the target","id":"1044","title":"Building the target"},"1045":{"body":"See the instructions for iOS .","breadcrumbs":"Platform Support  *-apple-tvos  Building Rust programs","id":"1045","title":"Building Rust programs"},"1046":{"body":"See the instructions for iOS .","breadcrumbs":"Platform Support  *-apple-tvos  Testing","id":"1046","title":"Testing"},"1047":{"body":"Tier: 3 ARM64e tvOS (10.0+)","breadcrumbs":"Platform Support  *-apple-tvos  arm64e-apple-tvos  arm64e-apple-tvos","id":"1047","title":"arm64e-apple-tvos"},"1048":{"body":"@arttet","breadcrumbs":"Platform Support  *-apple-tvos  arm64e-apple-tvos  Target maintainers","id":"1048","title":"Target maintainers"},"1049":{"body":"This target is cross-compiled and supports std. To build this target Xcode 12 or higher on macOS is required.","breadcrumbs":"Platform Support  *-apple-tvos  arm64e-apple-tvos  Requirements","id":"1049","title":"Requirements"},"105":{"body":"This option controls whether rustc generates code that emulates floating point instructions in software. It takes one of the following values: y, yes, on, true or no value: use soft floats. n, no, off or false: use hardware floats (the default). This flag only works on *eabihf targets and is unsound and deprecated .","breadcrumbs":"Command-line Arguments  Codegen Options  soft-float","id":"105","title":"soft-float"},"1050":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml: [build]\\ntarget = [\\"arm64e-apple-tvos\\"]","breadcrumbs":"Platform Support  *-apple-tvos  arm64e-apple-tvos  Building the target","id":"1050","title":"Building the target"},"1051":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will need to build Rust with the target enabled (see Building the target above).","breadcrumbs":"Platform Support  *-apple-tvos  arm64e-apple-tvos  Building Rust programs","id":"1051","title":"Building Rust programs"},"1052":{"body":"The target does support running binaries on tvOS platforms with arm64e architecture.","breadcrumbs":"Platform Support  *-apple-tvos  arm64e-apple-tvos  Testing","id":"1052","title":"Testing"},"1053":{"body":"The targets do support C code. To build compatible C code, you have to use XCode with the same compiler and flags.","breadcrumbs":"Platform Support  *-apple-tvos  arm64e-apple-tvos  Cross-compilation toolchains and C code","id":"1053","title":"Cross-compilation toolchains and C code"},"1054":{"body":"Apple watchOS targets. Tier: 3 aarch64-apple-watchos: Apple WatchOS on ARM64. aarch64-apple-watchos-sim: Apple WatchOS Simulator on ARM64. x86_64-apple-watchos-sim: Apple WatchOS Simulator on 64-bit x86. arm64_32-apple-watchos: Apple WatchOS on Arm 64_32. armv7k-apple-watchos: Apple WatchOS on Armv7k.","breadcrumbs":"Platform Support  *-apple-watchos  *-apple-watchos","id":"1054","title":"*-apple-watchos"},"1055":{"body":"@deg4uss3r @vladimir-ea @leohowell @madsmtm","breadcrumbs":"Platform Support  *-apple-watchos  Target maintainers","id":"1055","title":"Target maintainers"},"1056":{"body":"These targets are cross-compiled, and require the corresponding watchOS SDK (WatchOS.sdk or WatchSimulator.sdk), as provided by Xcode. To build the ARM64 targets, Xcode 12 or higher is required. The path to the SDK can be passed to rustc using the common SDKROOT environment variable, or will be inferred when compiling on host macOS using roughly the same logic as xcrun --sdk watchos --show-sdk-path.","breadcrumbs":"Platform Support  *-apple-watchos  Requirements","id":"1056","title":"Requirements"},"1057":{"body":"The minimum supported version is watchOS 5.0. This can be raised per-binary by changing the deployment target. rustc respects the common environment variables used by Xcode to do so, in this case WATCHOS_DEPLOYMENT_TARGET.","breadcrumbs":"Platform Support  *-apple-watchos  OS version","id":"1057","title":"OS version"},"1058":{"body":"The targets can be built by enabling them for a rustc build in bootstrap.toml, by adding, for example: [build]\\nbuild-stage = 1\\ntarget = [\\"aarch64-apple-watchos\\", \\"aarch64-apple-watchos-sim\\"] Using the unstable -Zbuild-std with a nightly Cargo may also work.","breadcrumbs":"Platform Support  *-apple-watchos  Building the target","id":"1058","title":"Building the target"},"1059":{"body":"See the instructions for iOS .","breadcrumbs":"Platform Support  *-apple-watchos  Building Rust programs","id":"1059","title":"Building Rust programs"},"106":{"body":"This option controls the emission of \\"split debuginfo\\" for debug information that rustc generates. The default behavior of this option is platform-specific, and not all possible values for this option work on all platforms. Possible values are: off - This is the default for platforms with ELF binaries and windows-gnu (not Windows MSVC and not macOS). This typically means that DWARF debug information can be found in the final artifact in sections of the executable. This option is not supported on Windows MSVC. On macOS this options prevents the final execution of dsymutil to generate debuginfo. packed - This is the default for Windows MSVC and macOS. The term \\"packed\\" here means that all the debug information is packed into a separate file from the main executable. On Windows MSVC this is a *.pdb file, on macOS this is a *.dSYM folder, and on other platforms this is a *.dwp file. unpacked - This means that debug information will be found in separate files for each compilation unit (object file). This is not supported on Windows MSVC. On macOS this means the original object files will contain debug information. On other Unix platforms this means that *.dwo files will contain debug information. Note that all three options are supported on Linux and Apple platforms, packed is supported on Windows-MSVC, and all other platforms support off. Attempting to use an unsupported option requires using the nightly channel with the -Z unstable-options flag.","breadcrumbs":"Command-line Arguments  Codegen Options  split-debuginfo","id":"106","title":"split-debuginfo"},"1060":{"body":"See the instructions for iOS .","breadcrumbs":"Platform Support  *-apple-watchos  Testing","id":"1060","title":"Testing"},"1061":{"body":"Apple visionOS / xrOS targets. Tier: 3 aarch64-apple-visionos: Apple visionOS on arm64. aarch64-apple-visionos-sim: Apple visionOS Simulator on arm64.","breadcrumbs":"Platform Support  *-apple-visionos  *-apple-visionos","id":"1061","title":"*-apple-visionos"},"1062":{"body":"@agg23 @madsmtm","breadcrumbs":"Platform Support  *-apple-visionos  Target maintainers","id":"1062","title":"Target maintainers"},"1063":{"body":"These targets are cross-compiled, and require the corresponding visionOS SDK (XROS.sdk or XRSimulator.sdk), as provided by Xcode 15 or newer. The path to the SDK can be passed to rustc using the common SDKROOT environment variable, or will be inferred when compiling on host macOS using roughly the same logic as xcrun --sdk xros --show-sdk-path.","breadcrumbs":"Platform Support  *-apple-visionos  Requirements","id":"1063","title":"Requirements"},"1064":{"body":"The minimum supported version is visionOS 1.0. This can be raised per-binary by changing the deployment target. rustc respects the common environment variables used by Xcode to do so, in this case XROS_DEPLOYMENT_TARGET.","breadcrumbs":"Platform Support  *-apple-visionos  OS version","id":"1064","title":"OS version"},"1065":{"body":"The targets can be built by enabling them for a rustc build in bootstrap.toml, by adding, for example: [build]\\ntarget = [\\"aarch64-apple-visionos\\", \\"aarch64-apple-visionos-sim\\"] Using the unstable -Zbuild-std with a nightly Cargo may also work. Note: Currently, a newer version of libc and cc may be required, this will be fixed in #124560 .","breadcrumbs":"Platform Support  *-apple-visionos  Building the target","id":"1065","title":"Building the target"},"1066":{"body":"See the instructions for iOS .","breadcrumbs":"Platform Support  *-apple-visionos  Building Rust programs","id":"1066","title":"Building Rust programs"},"1067":{"body":"See the instructions for iOS .","breadcrumbs":"Platform Support  *-apple-visionos  Testing","id":"1067","title":"Testing"},"1068":{"body":"The Clang target is suffixed with -xros for historical reasons. LLVM 18 or newer is required to build this target.","breadcrumbs":"Platform Support  *-apple-visionos  Cross-compilation toolchains and C code","id":"1068","title":"Cross-compilation toolchains and C code"},"1069":{"body":"Tier: 3 Nintendo Switch with pure-Rust toolchain.","breadcrumbs":"Platform Support  aarch64-nintendo-switch-freestanding  aarch64-nintendo-switch-freestanding","id":"1069","title":"aarch64-nintendo-switch-freestanding"},"107":{"body":"The option -C strip=val controls stripping of debuginfo and similar auxiliary data from binaries during linking. Supported values for this option are: none - debuginfo and symbols are not modified. debuginfo - debuginfo sections and debuginfo symbols from the symbol table section are stripped at link time and are not copied to the produced binary. This should leave backtraces mostly-intact but may make using a debugger like gdb or lldb ineffectual. Prior to 1.79, this unintentionally disabled the generation of *.pdb files on MSVC, resulting in the absence of symbols. symbols - same as debuginfo, but the rest of the symbol table section is stripped as well, depending on platform support. On platforms which depend on this symbol table for backtraces, profiling, and similar, this can affect them so negatively as to make the trace incomprehensible. Programs which may be combined with others, such as CLI pipelines and developer tooling, or even anything which wants crash-reporting, should usually avoid -Cstrip=symbols. Note that, at any level, removing debuginfo only necessarily impacts \\"friendly\\" introspection. -Cstrip cannot be relied on as a meaningful security or obfuscation measure, as disassemblers and decompilers can extract considerable information even in the absence of symbols.","breadcrumbs":"Command-line Arguments  Codegen Options  strip","id":"107","title":"strip"},"1070":{"body":"@leo60228 @jam1garner","breadcrumbs":"Platform Support  aarch64-nintendo-switch-freestanding  Target Maintainers","id":"1070","title":"Target Maintainers"},"1071":{"body":"This target is cross-compiled. It has no special requirements for the host.","breadcrumbs":"Platform Support  aarch64-nintendo-switch-freestanding  Requirements","id":"1071","title":"Requirements"},"1072":{"body":"The target can be built by enabling it for a rustc build: [build]\\nbuild-stage = 1\\ntarget = [\\"aarch64-nintendo-switch-freestanding\\"]","breadcrumbs":"Platform Support  aarch64-nintendo-switch-freestanding  Building","id":"1072","title":"Building"},"1073":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  aarch64-nintendo-switch-freestanding  Cross-compilation","id":"1073","title":"Cross-compilation"},"1074":{"body":"Currently there is no support to run the rustc test suite for this target.","breadcrumbs":"Platform Support  aarch64-nintendo-switch-freestanding  Testing","id":"1074","title":"Testing"},"1075":{"body":"If rustc has support for that target and the library artifacts are available, then Rust programs can be built for that target: rustc --target aarch64-nintendo-switch-freestanding your-code.rs To generate binaries in the NRO format that can be easily run on-device, you can use cargo-nx : cargo nx --triple=aarch64-nintendo-switch-freestanding","breadcrumbs":"Platform Support  aarch64-nintendo-switch-freestanding  Building Rust programs","id":"1075","title":"Building Rust programs"},"1076":{"body":"Tier: 1 (with Host Tools) Target for 64-bit little endian ARMv8-A Linux 4.1+ programs using glibc 2.17+.","breadcrumbs":"Platform Support  aarch64-unknown-linux-gnu  aarch64-unknown-linux-gnu","id":"1076","title":"aarch64-unknown-linux-gnu"},"1077":{"body":"@rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  aarch64-unknown-linux-gnu  Target maintainers","id":"1077","title":"Target maintainers"},"1078":{"body":"Building the target itself requires a 64-bit little endian ARMv8-A compiler that is supported by cc-rs.","breadcrumbs":"Platform Support  aarch64-unknown-linux-gnu  Requirements","id":"1078","title":"Requirements"},"1079":{"body":"The target can be built by enabling it for a rustc build: [build]\\ntarget = [\\"aarch64-unknown-linux-gnu\\"] If cross-compiling, make sure your C compiler is included in $PATH, then add it to the bootstrap.toml: [target.aarch64-unknown-linux-musl]\\ncc = \\"aarch64-linux-gnu-gcc\\"\\ncxx = \\"aarch64-linux-gnu-g++\\"\\nar = \\"aarch64-linux-gnu-ar\\"\\nlinker = \\"aarch64-linux-gnu-gcc\\"","breadcrumbs":"Platform Support  aarch64-unknown-linux-gnu  Building the target","id":"1079","title":"Building the target"},"108":{"body":"This option controls the name mangling format for encoding Rust item names for the purpose of generating object code and linking. Supported values for this option are: v0  The \\"v0\\" mangling scheme. The default, if not specified, will use a compiler-chosen default which may change in the future. See the Symbol Mangling chapter for details on symbol mangling and the mangling format.","breadcrumbs":"Command-line Arguments  Codegen Options  symbol-mangling-version","id":"108","title":"symbol-mangling-version"},"1080":{"body":"This target is distributed through rustup, and otherwise requires no special configuration.","breadcrumbs":"Platform Support  aarch64-unknown-linux-gnu  Building Rust programs","id":"1080","title":"Building Rust programs"},"1081":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  aarch64-unknown-linux-gnu  Cross-compilation","id":"1081","title":"Cross-compilation"},"1082":{"body":"This target can be tested as normal with x.py on a 64-bit little endian ARMv8-A host or via QEMU emulation.","breadcrumbs":"Platform Support  aarch64-unknown-linux-gnu  Testing","id":"1082","title":"Testing"},"1083":{"body":"Tier: 2 Target for 64-bit little endian ARMv8-A Linux programs using musl libc.","breadcrumbs":"Platform Support  aarch64-unknown-linux-musl  aarch64-unknown-linux-musl","id":"1083","title":"aarch64-unknown-linux-musl"},"1084":{"body":"@Gelbpunkt @famfo","breadcrumbs":"Platform Support  aarch64-unknown-linux-musl  Target maintainers","id":"1084","title":"Target maintainers"},"1085":{"body":"Building the target itself requires a 64-bit little endian ARMv8-A compiler that is supported by cc-rs.","breadcrumbs":"Platform Support  aarch64-unknown-linux-musl  Requirements","id":"1085","title":"Requirements"},"1086":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"aarch64-unknown-linux-musl\\"] Make sure your C compiler is included in $PATH, then add it to the bootstrap.toml: [target.aarch64-unknown-linux-musl]\\ncc = \\"aarch64-linux-musl-gcc\\"\\ncxx = \\"aarch64-linux-musl-g++\\"\\nar = \\"aarch64-linux-musl-ar\\"\\nlinker = \\"aarch64-linux-musl-gcc\\"","breadcrumbs":"Platform Support  aarch64-unknown-linux-musl  Building the target","id":"1086","title":"Building the target"},"1087":{"body":"This target is distributed through rustup, and otherwise requires no special configuration.","breadcrumbs":"Platform Support  aarch64-unknown-linux-musl  Building Rust programs","id":"1087","title":"Building Rust programs"},"1088":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  aarch64-unknown-linux-musl  Cross-compilation","id":"1088","title":"Cross-compilation"},"1089":{"body":"This target can be tested as normal with x.py on a 64-bit little endian ARMv8-A host or via QEMU emulation.","breadcrumbs":"Platform Support  aarch64-unknown-linux-musl  Testing","id":"1089","title":"Testing"},"109":{"body":"This instructs rustc to generate code specifically for a particular processor. You can run rustc --print target-cpus to see the valid options to pass and the default target CPU for the current build target. Each target has a default base CPU. Special values include: native can be passed to use the processor of the host machine. generic refers to an LLVM target with minimal features but modern tuning.","breadcrumbs":"Command-line Arguments  Codegen Options  target-cpu","id":"109","title":"target-cpu"},"1090":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal targets for CPUs in the Armv8-A architecture family, running in AArch64 mode. For the AArch32 mode carried over from Armv7-A, see armv7a-none-eabi instead. Processors in this family include the Arm Cortex-A35, 53, 76, etc .","breadcrumbs":"Platform Support  aarch64-unknown-none*  aarch64-unknown-none and aarch64-unknown-none-softfloat","id":"1090","title":"aarch64-unknown-none and aarch64-unknown-none-softfloat"},"1091":{"body":"Rust Embedded Devices Working Group Arm Team @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  aarch64-unknown-none*  Target maintainers","id":"1091","title":"Target maintainers"},"1092":{"body":"All AArch64 processors include an FPU. The difference between the -none and -none-softfloat targets is whether the FPU is used for passing function arguments. You may prefer the -softfloat target when writing a kernel or interfacing with pre-compiled binaries that use the soft-float ABI. When using the hardfloat targets, the minimum floating-point features assumed are those of the fp-armv8, which excludes NEON SIMD support. If your processor supports a different set of floating-point features than the default expectations of fp-armv8, then these should also be enabled or disabled as needed with -C target-feature=(+/-). It is also possible to tell Rust (or LLVM) that you have a specific model of Arm processor, using the -Ctarget-cpu option. Doing so may change the default set of target-features enabled.","breadcrumbs":"Platform Support  aarch64-unknown-none*  Target CPU and Target Feature options","id":"1092","title":"Target CPU and Target Feature options"},"1093":{"body":"These targets are cross-compiled and use static linking. By default, the lld linker included with Rust will be used; however, you may want to use the GNU linker instead. This can be obtained for Windows/Mac/Linux from the Arm Developer Website , or possibly from your OS\'s package manager. To use it, add the following to your .cargo/config.toml: [target.aarch64-unknown-none]\\nlinker = \\"aarch64-none-elf-ld\\" The GNU linker can also be used by specifying aarch64-none-elf-gcc as the linker. This is needed when using GCC\'s link time optimization. These targets don\'t provide a linker script, so you\'ll need to bring your own according to the specific device you are using. Pass -Clink-arg=-Tyour_script.ld as a rustc argument to make the linker use your_script.ld during linking.","breadcrumbs":"Platform Support  aarch64-unknown-none*  Requirements","id":"1093","title":"Requirements"},"1094":{"body":"This target supports C code compiled with the aarch64-none-elf target triple and a suitable -march or -mcpu flag.","breadcrumbs":"Platform Support  aarch64-unknown-none*  Cross-compilation toolchains and C code","id":"1094","title":"Cross-compilation toolchains and C code"},"1095":{"body":"The Rust Embedded Devices Working Group Arm Team maintain the aarch64-cpu crate, which may be useful for writing bare-metal code using this target. The TrustedFirmware group also maintain Rust crates for this target .","breadcrumbs":"Platform Support  aarch64-unknown-none*  Start-up and Low-Level Code","id":"1095","title":"Start-up and Low-Level Code"},"1096":{"body":"Tier: 3 Target for freestanding/bare-metal big-endian ARM64 binaries in ELF format: firmware, kernels, etc.","breadcrumbs":"Platform Support  aarch64_be-unknown-none-softfloat  aarch64_be-unknown-none-softfloat","id":"1096","title":"aarch64_be-unknown-none-softfloat"},"1097":{"body":"@Gelbpunkt","breadcrumbs":"Platform Support  aarch64_be-unknown-none-softfloat  Target maintainers","id":"1097","title":"Target maintainers"},"1098":{"body":"This target is cross-compiled. There is no support for std. There is no default allocator, but it\'s possible to use alloc by supplying an allocator. The target does not assume existence of a FPU and does not make use of any non-GPR register. This allows the generated code to run in environments, such as kernels, which may need to avoid the use of such registers or which may have special considerations about the use of such registers (e.g. saving and restoring them to avoid breaking userspace code using the same registers). You can change code generation to use additional CPU features via the -C target-feature= codegen options to rustc, or via the #[target_feature] mechanism within Rust code. By default, code generated with the soft-float target should run on any big-endian ARM64 hardware, enabling additional target features may raise this baseline. extern \\"C\\" uses the architecture\'s standard calling convention . The targets generate binaries in the ELF format. Any alternate formats or special considerations for binary layout will require linker options or linker scripts.","breadcrumbs":"Platform Support  aarch64_be-unknown-none-softfloat  Requirements","id":"1098","title":"Requirements"},"1099":{"body":"You can build Rust with support for the target by adding it to the target list in bootstrap.toml: [build]\\ntarget = [\\"aarch64_be-unknown-none-softfloat\\"]","breadcrumbs":"Platform Support  aarch64_be-unknown-none-softfloat  Building the target","id":"1099","title":"Building the target"},"11":{"body":"This instructs rustc on which crate type to build. This flag accepts a comma-separated list of values, and may be specified multiple times. The valid crate types are: lib  Generates a library kind preferred by the compiler, currently defaults to rlib. rlib  A Rust static library. staticlib  A native static library. dylib  A Rust dynamic library. cdylib  A native dynamic library. bin  A runnable executable program. proc-macro  Generates a format suitable for a procedural macro library that may be loaded by the compiler. The crate type may be specified with the crate_type attribute . The --crate-type command-line value will override the crate_type attribute. More details may be found in the linkage chapter of the reference.","breadcrumbs":"Command-line Arguments  --crate-type: a list of types of crates for the compiler to emit","id":"11","title":"--crate-type: a list of types of crates for the compiler to emit"},"110":{"body":"Individual targets will support different features; this flag lets you control enabling or disabling a feature. Each feature should be prefixed with a + to enable it or - to disable it. Features from multiple -C target-feature options are combined. Multiple features can be specified in a single option by separating them with commas - -C target-feature=+x,-y. If some feature is specified more than once with both + and -, then values passed later override values passed earlier. For example, -C target-feature=+x,-y,+z -Ctarget-feature=-x,+y is equivalent to -C target-feature=-x,+y,+z. To see the valid options and an example of use, run rustc --print target-features. Using this flag is unsafe and might result in undefined runtime behavior . See also the target_feature attribute for controlling features per-function. This also supports the feature +crt-static and -crt-static to control static C runtime linkage . Each target and target-cpu has a default set of enabled features.","breadcrumbs":"Command-line Arguments  Codegen Options  target-feature","id":"110","title":"target-feature"},"1100":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will first need to build Rust with the target enabled (see \\"Building the target\\" above).","breadcrumbs":"Platform Support  aarch64_be-unknown-none-softfloat  Building Rust programs","id":"1100","title":"Building Rust programs"},"1101":{"body":"For cross builds, you will need an appropriate ARM64 C/C++ toolchain for linking, or if you want to compile C code along with Rust (such as for Rust crates with C dependencies). Rust may be able to use an aarch64_be-unknown-linux-{gnu,musl}- toolchain with appropriate standalone flags to build for this target (depending on the assumptions of that toolchain, see below), or you may wish to use a separate aarch64_be-unknown-none-softfloat toolchain. On some ARM64 hosts that use ELF binaries, you may be able to use the host C toolchain, if it does not introduce assumptions about the host environment that don\'t match the expectations of a standalone environment. Otherwise, you may need a separate toolchain for standalone/freestanding development, just as when cross-compiling from a non-ARM64 platform.","breadcrumbs":"Platform Support  aarch64_be-unknown-none-softfloat  Cross-compilation","id":"1101","title":"Cross-compilation"},"1102":{"body":"As the target supports a variety of different environments and does not support std, it does not support running the Rust test suite.","breadcrumbs":"Platform Support  aarch64_be-unknown-none-softfloat  Testing","id":"1102","title":"Testing"},"1103":{"body":"Tier: 3 ARM64 Linux (big-endian) with musl-libc.","breadcrumbs":"Platform Support  aarch64_be-unknown-linux-musl  aarch64_be-unknown-linux-musl","id":"1103","title":"aarch64_be-unknown-linux-musl"},"1104":{"body":"@neuschaefer @Gelbpunkt","breadcrumbs":"Platform Support  aarch64_be-unknown-linux-musl  Target maintainers","id":"1104","title":"Target maintainers"},"1105":{"body":"The target requires a aarch64_be-*-linux-musl toolchain, which likely has to be built from source because this is a rare combination. Buildroot provides a way of doing so: select Target options  Target Architecture  AArch64 (big endian) select Toolchain  C library  musl select Toolchain  Enable C++ support Host tools are supported.","breadcrumbs":"Platform Support  aarch64_be-unknown-linux-musl  Requirements","id":"1105","title":"Requirements"},"1106":{"body":"The target can be enabled in bootstrap.toml: [build]\\ntarget = [\\"aarch64_be-unknown-linux-musl\\"] [target.aarch64_be-unknown-linux-musl]\\ncc = \\"/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-cc\\"\\ncxx = \\"/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-c++\\"\\nlinker = \\"/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-cc\\"\\nar = \\"/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-ar\\"\\nranlib = \\"/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-ranlib\\"\\nmusl-root = \\"/path/to/buildroot/staging\\"\\nrunner = \\"qemu-aarch64_be -L /path/to/buildroot/target\\"\\ncrt-static = \\"/path/to/buildroot/target\\"","breadcrumbs":"Platform Support  aarch64_be-unknown-linux-musl  Building the target","id":"1106","title":"Building the target"},"1107":{"body":"Binaries can be run under qemu-aarch64_be or under a big-endian Linux kernel.","breadcrumbs":"Platform Support  aarch64_be-unknown-linux-musl  Testing","id":"1107","title":"Testing"},"1108":{"body":"Tier: 3 AMD GPU target for compute/HSA (Heterogeneous System Architecture).","breadcrumbs":"Platform Support  amdgcn-amd-amdhsa  amdgcn-amd-amdhsa","id":"1108","title":"amdgcn-amd-amdhsa"},"1109":{"body":"@Flakebi","breadcrumbs":"Platform Support  amdgcn-amd-amdhsa  Target maintainers","id":"1109","title":"Target maintainers"},"111":{"body":"This instructs rustc to schedule code specifically for a particular processor. This does not affect the compatibility (instruction sets or ABI), but should make your code slightly more efficient on the selected CPU. The valid options are the same as those for target-cpu . The default is None, which LLVM translates as the target-cpu. This is an unstable option. Use -Z tune-cpu=machine to specify a value. Due to limitations in LLVM (12.0.0-git9218f92), this option is currently effective only for x86 targets.","breadcrumbs":"Command-line Arguments  Codegen Options  tune-cpu","id":"111","title":"tune-cpu"},"1110":{"body":"AMD GPUs can be targeted via cross-compilation. Supported GPUs depend on the LLVM version that is used by Rust. In general, most GPUs starting from gfx7 (Sea Islands/CI) are supported as compilation targets, though older GPUs are not supported by the latest host runtime. Details about supported GPUs can be found in LLVMs documentation and ROCm documentation . Binaries can be loaded by HIP or by the HSA runtime implemented in ROCR-Runtime . The format of binaries is a linked ELF. Binaries must be built with no-std. They can use core and alloc (alloc only if an allocator is supplied). At least one function needs to use the \\"gpu-kernel\\" calling convention and should be marked with no_mangle for simplicity. Functions using the \\"gpu-kernel\\" calling convention are kernel entrypoints and can be used from the host runtime.","breadcrumbs":"Platform Support  amdgcn-amd-amdhsa  Requirements","id":"1110","title":"Requirements"},"1111":{"body":"The target is included in rustc.","breadcrumbs":"Platform Support  amdgcn-amd-amdhsa  Building the target","id":"1111","title":"Building the target"},"1112":{"body":"The amdgpu target supports many hardware generations, which need different binaries. The generations are exposed as different target-cpus in the backend. As there are many, Rust does not ship pre-compiled libraries for this target. Therefore, you have to build your own copy of core by using cargo -Zbuild-std=core or similar. To build a binary, create a no-std library: // src/lib.rs\\n#![feature(abi_gpu_kernel)]\\n#![no_std] #[panic_handler]\\nfn panic(_: &core::panic::PanicInfo) -> ! { loop {}\\n} #[no_mangle]\\npub extern \\"gpu-kernel\\" fn kernel(/* Arguments */) { // Code\\n} Build the library as cdylib: # Cargo.toml\\n[lib]\\ncrate-type = [\\"cdylib\\"] [profile.dev]\\nlto = true # LTO must be explicitly enabled for now\\n[profile.release]\\nlto = true The target-cpu must be from the list supported by LLVM (or printed with rustc --target amdgcn-amd-amdhsa --print target-cpus). The GPU version on the current system can be found e.g. with rocminfo . Example .cargo/config.toml file to set the target and GPU generation: # .cargo/config.toml\\n[build]\\ntarget = \\"amdgcn-amd-amdhsa\\"\\nrustflags = [\\"-Ctarget-cpu=gfx1100\\"] [unstable]\\nbuild-std = [\\"core\\"] # Optional: \\"alloc\\"","breadcrumbs":"Platform Support  amdgcn-amd-amdhsa  Building Rust programs","id":"1112","title":"Building Rust programs"},"1113":{"body":"To run a binary on an AMD GPU, a host runtime is needed. On Linux and Windows, HIP can be used to load and run binaries. Example code on how to load a compiled binary and run it is available in ROCm examples . On Linux, binaries can also run through the HSA runtime as implemented in ROCR-Runtime .","breadcrumbs":"Platform Support  amdgcn-amd-amdhsa  Running Rust programs","id":"1113","title":"Running Rust programs"},"1114":{"body":"More information can be found on the LLVM page for amdgpu .","breadcrumbs":"Platform Support  amdgcn-amd-amdhsa  Additional information","id":"1114","title":"Additional information"},"1115":{"body":"","breadcrumbs":"Platform Support  arm-none-eabi  {arm,thumb}*-none-eabi(hf)?","id":"1115","title":"{arm,thumb}*-none-eabi(hf)?"},"1116":{"body":"This documentation covers details that apply to a range of bare-metal targets for 32-bit Arm CPUs. The arm-none-eabi flavor of the GNU compiler toolchain is often used to assist compilation to these targets. Details that apply only to only a specific target in this group are covered in their own document.","breadcrumbs":"Platform Support  arm-none-eabi  Common Target Details","id":"1116","title":"Common Target Details"},"1117":{"body":"Arm A-Profile Architectures armv7a-none-eabi Arm R-Profile Architectures armv7r-none-eabi and armv7r-none-eabihf armebv7r-none-eabi and armebv7r-none-eabihf Arm M-Profile Architectures thumbv6m-none-eabi thumbv7m-none-eabi thumbv7em-none-eabi and thumbv7em-none-eabihf thumbv8m.base-none-eabi thumbv8m.main-none-eabi and thumbv8m.main-none-eabihf Legacy Arm Architectures None","breadcrumbs":"Platform Support  arm-none-eabi  Tier 2 Target List","id":"1117","title":"Tier 2 Target List"},"1118":{"body":"Arm A-Profile Architectures armv7a-none-eabihf Arm R-Profile Architectures armv8r-none-eabihf Arm M-Profile Architectures None Legacy Arm Architectures armv4t-none-eabi and thumbv4t-none-eabi armv5te-none-eabi and thumbv5te-none-eabi","breadcrumbs":"Platform Support  arm-none-eabi  Tier 3 Target List","id":"1118","title":"Tier 3 Target List"},"1119":{"body":"There are two 32-bit instruction set architectures (ISAs) defined by Arm: The A32 ISA , with fixed-width 32-bit instructions. Previously known as the Arm ISA, this originated with the original ARM1 of 1985 and has been updated by various revisions to the architecture specifications ever since. The T32 ISA , with a mix of 16-bit and 32-bit width instructions. Note that this term includes both the original 16-bit width Thumb ISA introduced with the Armv4T architecture in 1994, and the later 16/32-bit sized Thumb-2 ISA introduced with the Armv6T2 architecture in 2003. Again, these ISAs have been revised by subsequent revisions to the relevant Arm architecture specifications. There is also a 64-bit ISA with fixed-width 32-bit instructions called the A64 ISA , but targets which implement that instruction set generally start with aarch64* and are discussed elsewhere. Rust targets starting with arm* generate Arm (A32) code by default, whilst targets named thumb* generate Thumb (T32) code by default. Most Arm chips support both Thumb mode and Arm mode, with the notable exception that M-profile processors (thumbv*m*-none-eabi* targets) only support Thumb-mode. Rust targets ending with eabi use the so-called soft-float ABI : functions which take f32 or f64 as arguments will have those values packed into integer registers. This means that an FPU is not required from an ABI perspective, but within a function floating-point instructions may still be used if the code is compiled with a target-cpu or target-feature option that enables FPU support. Rust targets ending in eabihf use the so-called hard-float ABI : functions which take f32 or f64 as arguments will have them passed via FPU registers. These targets therefore require the availability of an FPU and will assume some baseline level of floating-point support is available (which can vary depending on the target). More advanced floating-point instructions may be generated if the code is compiled with a target-cpu or target-feature option that enables such additional FPU support. For example, if a given hard-float target has baseline single-precision (f32) support in hardware, there may be target-cpu or target-feature options that tell LLVM to assume your processor in fact also has double-precision (f64) support. You may of course use the f32 and f64 types in your code, regardless of the ABI being used, or the level of support your processor has for performing such operations in hardware. Any floating-point operations that LLVM assumes your processor cannot support will be lowered to library calls (like __aeabi_dadd) which perform the floating-point operation in software using integer instructions.","breadcrumbs":"Platform Support  arm-none-eabi  Instruction Sets","id":"1119","title":"Instruction Sets"},"112":{"body":"Internally, rustc may take advantage of parallelism. rustc will coordinate with the build system calling it if a GNU Make jobserver is passed in the MAKEFLAGS environment variable. Other flags may have an effect as well, such as CARGO_MAKEFLAGS . If a jobserver is not passed, then rustc will choose the number of jobs to use. Starting with Rust 1.76.0, rustc will warn if a jobserver appears to be available but is not accessible, e.g.: $ echo \'fn main() {}\' | MAKEFLAGS=--jobserver-auth=3,4 rustc -\\nwarning: failed to connect to jobserver from environment variable `MAKEFLAGS=\\"--jobserver-auth=3,4\\"`: cannot open file descriptor 3 from the jobserver environment variable value: Bad file descriptor (os error 9) | = note: the build environment is likely misconfigured","breadcrumbs":"Jobserver  Jobserver","id":"112","title":"Jobserver"},"1120":{"body":"It is possible to tell Rust (or LLVM) that you have a specific model of Arm processor, using the -C target-cpu option. You can also control whether Rust (or LLVM) will include instructions that target optional hardware features, e.g. hardware floating-point, or Advanced SIMD operations, using -C target-feature . It is important to note that selecting a target-cpu will typically enable all the optional features available from Arm on that model of CPU and your particular implementation of that CPU may not have those features available. In that case, you can use -C target-feature=-option to turn off the specific CPU features you do not have available, leaving you with the optimized instruction scheduling and support for the features you do have. More details are available in the detailed target-specific documentation. Many target-features are currently unstable and subject to change, and if you use them you should disassemble the compiler output and manually inspect it to ensure only appropriate instructions for your CPU have been generated. If you wish to use the target-cpu and target-feature options, you can add them to your .cargo/config.toml file alongside any other flags your project uses (likely linker related ones): rustflags = [ # Usual Arm bare-metal linker setup \\"-Clink-arg=-Tlink.x\\", \\"-Clink-arg=--nmagic\\", # tell Rust we have a Cortex-M55 \\"-Ctarget-cpu=cortex-m55\\", # tell Rust our Cortex-M55 doesn\'t have Floating-Point M-Profile Vector # Extensions (but it does have everything else a Cortex-M55 could have). \\"-Ctarget-feature=-mve.fp\\"\\n] [build]\\ntarget = \\"thumbv8m.main-none-eabihf\\"","breadcrumbs":"Platform Support  arm-none-eabi  Target CPU and Target Feature options","id":"1120","title":"Target CPU and Target Feature options"},"1121":{"body":"These targets are cross-compiled and use static linking. By default, the lld linker included with Rust will be used; however, you may want to use the GNU linker instead. This can be obtained for Windows/Mac/Linux from the Arm Developer Website , or possibly from your OS\'s package manager. To use it, add the following to your .cargo/config.toml: [target.<your-target>]\\nlinker = \\"arm-none-eabi-ld\\" The GNU linker can also be used by specifying arm-none-eabi-gcc as the linker. This is needed when using GCC\'s link time optimization. These targets don\'t provide a linker script, so you\'ll need to bring your own according to the specific device you are using. Pass -Clink-arg=-Tyour_script.ld as a rustc argument to make the linker use your_script.ld during linking. For the arm* targets, Thumb-mode code generation can be enabled by using -C target-feature=+thumb-mode. Using the unstable #![feature(arm_target_feature)], the attribute #[target_feature(enable = \\"thumb-mode\\")] can be applied to individual unsafe functions to cause those functions to be compiled to Thumb-mode code.","breadcrumbs":"Platform Support  arm-none-eabi  Requirements","id":"1121","title":"Requirements"},"1122":{"body":"For the Tier 3 targets in this family, rust does not ship pre-compiled artifacts. Just use the build-std nightly cargo feature to build the core library. You can pass this as a command line argument to cargo, or your .cargo/config.toml file might include the following lines: [unstable]\\nbuild-std = [\\"core\\"] Most of core should work as expected, with the following notes: Floating-point operations are emulated in software unless LLVM is told to enable FPU support (either by using an eabihf target, specifying a target-cpu with FPU support, or using a target-feature to support for a specific kind of FPU) Integer division is also emulated in software on some targets, depending on the target, target-cpu and target-features. Older Arm architectures (e.g. Armv4, Armv5TE and Armv6-M) are limited to basic load and store operations, and not more advanced operations like fetch_add or compare_exchange . alloc is also supported, as long as you provide your own global allocator. Rust programs are output as ELF files.","breadcrumbs":"Platform Support  arm-none-eabi  Building Rust Programs","id":"1122","title":"Building Rust Programs"},"1123":{"body":"This is a cross-compiled target that you will need to emulate during testing. The exact emulator that you\'ll need depends on the specific device you want to run your code on.","breadcrumbs":"Platform Support  arm-none-eabi  Testing","id":"1123","title":"Testing"},"1124":{"body":"The target supports C code compiled with the arm-none-eabi target triple and a suitable -march or -mcpu flag. gcc or clang can be used, but note that gcc uses -fshort-enums by default for arm-none* targets, while clang does not. rustc matches the gcc behavior, i.e., the size of a #[repr(C)] enum in Rust can be as little as 1 byte, rather than 4, as they are on arm-linux targets.","breadcrumbs":"Platform Support  arm-none-eabi  Cross-compilation toolchains and C code","id":"1124","title":"Cross-compilation toolchains and C code"},"1125":{"body":"Tier: 3 Library Support: core and alloc (bare-metal, #![no_std]) These two targets are part of the arm-none-eabi target group, and all the information there applies. Both of these targets can be used on the Game Boy Advance (GBA), among other things. On the GBA, one should usually use the thumb target to get the best overall performance.","breadcrumbs":"Platform Support  arm-none-eabi  armv4t-none-eabi  armv4t-none-eabi / thumbv4t-none-eabi","id":"1125","title":"armv4t-none-eabi / thumbv4t-none-eabi"},"1126":{"body":"@Lokathor @corwinkuiper","breadcrumbs":"Platform Support  arm-none-eabi  armv4t-none-eabi  Target Maintainers","id":"1126","title":"Target Maintainers"},"1127":{"body":"This is a cross-compiled target that you will need to emulate during testing. Because this is a device-agnostic target, and the exact emulator that you\'ll need depends on the specific device you want to run your code on. When building for the GBA, mgba-test-runner can be used to make a normal set of rust tests be run within the mgba emulator.","breadcrumbs":"Platform Support  arm-none-eabi  armv4t-none-eabi  Testing","id":"1127","title":"Testing"},"1128":{"body":"Tier: 3 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for any cpu in the Armv5TE architecture family, supporting ARM/Thumb code interworking (aka A32/T32), with A32 code as the default code generation. The thumbv5te-none-eabi target is the same as this one, but the instruction set defaults to T32. See arm-none-eabi for information applicable to all arm-none-eabi targets.","breadcrumbs":"Platform Support  arm-none-eabi  armv5te-none-eabi  armv5te-none-eabi","id":"1128","title":"armv5te-none-eabi"},"1129":{"body":"@QuinnPainter","breadcrumbs":"Platform Support  arm-none-eabi  armv5te-none-eabi  Target Maintainers","id":"1129","title":"Target Maintainers"},"113":{"body":"The following subsections contain recommendations on how to integrate rustc with build systems so that the jobserver is handled appropriately.","breadcrumbs":"Jobserver  Integration with build systems","id":"113","title":"Integration with build systems"},"1130":{"body":"This is a cross-compiled target that you will need to emulate during testing. Because this is a device-agnostic target, and the exact emulator that you\'ll need depends on the specific device you want to run your code on. For example, when programming for the DS, you can use one of the several available DS emulators, such as melonDS .","breadcrumbs":"Platform Support  arm-none-eabi  armv5te-none-eabi  Testing","id":"1130","title":"Testing"},"1131":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Armv7-A architecture family, supporting dual ARM/Thumb mode, with ARM mode as the default. Note, this is for processors running in AArch32 mode. For the AArch64 mode added in Armv8-A, see aarch64-unknown-none instead. Processors in this family include the Arm Cortex-A5, 8, 32, etc . See arm-none-eabi for information applicable to all arm-none-eabi targets.","breadcrumbs":"Platform Support  arm-none-eabi  armv7a-none-eabi{,hf}  armv7a-none-eabi and armv7a-none-eabihf","id":"1131","title":"armv7a-none-eabi and armv7a-none-eabihf"},"1132":{"body":"Rust Embedded Devices Working Group Arm Team @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  arm-none-eabi  armv7a-none-eabi{,hf}  Target maintainers","id":"1132","title":"Target maintainers"},"1133":{"body":"Almost all Armv7-A processors include an FPU (a VFPv3 or a VFPv4). The difference between the -eabi and -eabihf targets is whether the FPU is used for passing function arguments. You may prefer the -eabi soft-float target when the processor does not have a floating point unit or the compiled code should not use the floating point unit. When using the hardfloat targets, the minimum floating-point features assumed are those of the VFPv3-D16, which includes single- and double-precision, with 16 double-precision registers. This floating-point unit appears in Cortex-A8 and Cortex-A9 processors. See VFP in the Cortex-A processors for more details on the possible FPU variants. If your processor supports a different set of floating-point features than the default expectations of VFPv3-D16, then these should also be enabled or disabled as needed with -C target-feature=(+/-). In general, the following four combinations are possible: VFPv3-D16, target feature +vfp3 and -d32 VFPv3-D32, target feature +vfp3 and +d32 VFPv4-D16, target feature +vfp4 and -d32 VFPv4-D32, target feature +vfp4 and +d32 An Armv7-A processor may optionally include a NEON hardware unit which provides Single Instruction Multiple Data (SIMD) operations. The implementation of this unit implies VFPv3-D32. The target feature +neon may be added to inform the compiler about the availability of NEON. You can refer to the arm-none-eabi documentation for a generic guide on target feature and target CPU specification and how to enable and disable them via .cargo/config.toml file.","breadcrumbs":"Platform Support  arm-none-eabi  armv7a-none-eabi{,hf}  Requirements","id":"1133","title":"Requirements"},"1134":{"body":"The Rust Embedded Devices Working Group Arm Team maintain the cortex-ar and cortex-a-rt crates, which may be useful for writing bare-metal code using this target. The cortex-ar repository includes several examples which run in QEMU and build using these targets.","breadcrumbs":"Platform Support  arm-none-eabi  armv7a-none-eabi{,hf}  Start-up and Low-Level Code","id":"1134","title":"Start-up and Low-Level Code"},"1135":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Armv7-R architecture family, supporting dual ARM/Thumb mode, with ARM mode as the default. Processors in this family include the Arm Cortex-R4, 5, 7, and 8 . See arm-none-eabi for information applicable to all arm-none-eabi targets.","breadcrumbs":"Platform Support  arm-none-eabi  armv7r-none-eabi{,hf}  armv7r-none-eabi and armv7r-none-eabihf","id":"1135","title":"armv7r-none-eabi and armv7r-none-eabihf"},"1136":{"body":"@chrisnc Rust Embedded Devices Working Group Arm Team @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  arm-none-eabi  armv7r-none-eabi{,hf}  Target maintainers","id":"1136","title":"Target maintainers"},"1137":{"body":"When using the hardfloat targets, the minimum floating-point features assumed are those of the vfpv3-d16, which includes single- and double-precision, with 16 double-precision registers. This floating-point unit appears in Cortex-R4F and Cortex-R5F processors. See VFP in the Cortex-R processors for more details on the possible FPU variants. If your processor supports a different set of floating-point features than the default expectations of vfpv3-d16, then these should also be enabled or disabled as needed with -C target-feature=(+/-).","breadcrumbs":"Platform Support  arm-none-eabi  armv7r-none-eabi{,hf}  Requirements","id":"1137","title":"Requirements"},"1138":{"body":"The Rust Embedded Devices Working Group Arm Team maintain the cortex-ar and cortex-r-rt crates, which may be useful for writing bare-metal code using this target. Those crates include several examples which run in QEMU and build using these targets.","breadcrumbs":"Platform Support  arm-none-eabi  armv7r-none-eabi{,hf}  Start-up and Low-Level Code","id":"1138","title":"Start-up and Low-Level Code"},"1139":{"body":"Tier: 3 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Armv7-R architecture family running in Big Endian mode. These processors support dual ARM/Thumb mode, with ARM mode as the default. NOTE: You should almost always prefer the little-endian versions of these target. Big Endian Arm systems are highly unusual. Processors in this family include the Arm Cortex-R4, 5, 7, and 8 . See arm-none-eabi for information applicable to all arm-none-eabi targets.","breadcrumbs":"Platform Support  arm-none-eabi  armebv7r-none-eabi{,hf}  armebv7r-none-eabi and armebv7r-none-eabihf","id":"1139","title":"armebv7r-none-eabi and armebv7r-none-eabihf"},"114":{"body":"When calling rustc from GNU Make, it is recommended that all rustc invocations are marked as recursive in the Makefile (by prefixing the command line with the + indicator), so that GNU Make enables the jobserver for them. For instance: x: +@echo \'fn main() {}\' | rustc - In particular, GNU Make 4.3 (a widely used version as of 2024) passes a simple pipe jobserver in MAKEFLAGS even when it was not made available for the child process, which in turn means rustc will warn about it. For instance, if the + indicator is removed from the example above and GNU Make is called with e.g. make -j2, then the aforementioned warning will trigger. For calls to rustc inside $(shell ...) inside a recursive Make, one can disable the jobserver manually by clearing the MAKEFLAGS variable, e.g.: S := $(shell MAKEFLAGS= rustc --print sysroot) x: @$(MAKE) y y: @echo $(S)","breadcrumbs":"Jobserver  GNU Make","id":"114","title":"GNU Make"},"1140":{"body":"@chrisnc","breadcrumbs":"Platform Support  arm-none-eabi  armebv7r-none-eabi{,hf}  Target maintainers","id":"1140","title":"Target maintainers"},"1141":{"body":"Note that some variants of the Cortex-R have both big-endian instructions and data. This configuration is known as BE-32, while data-only big-endianness is known as BE-8. To build programs for BE-32 processors, the GNU linker must be used with the -mbe32 option. See ARM Cortex-R Series Programmer\'s Guide: Endianness for more details about different endian modes. When using the hardfloat targets, the minimum floating-point features assumed are those of the vfpv3-d16, which includes single- and double-precision, with 16 double-precision registers. This floating-point unit appears in Cortex-R4F and Cortex-R5F processors. See VFP in the Cortex-R processors for more details on the possible FPU variants. If your processor supports a different set of floating-point features than the default expectations of vfpv3-d16, then these should also be enabled or disabled as needed with -C target-feature=(+/-).","breadcrumbs":"Platform Support  arm-none-eabi  armebv7r-none-eabi{,hf}  Requirements","id":"1141","title":"Requirements"},"1142":{"body":"The [Rust Embedded Devices Working Group Arm Team] maintain the cortex-ar and cortex-r-rt crates, which may be useful for writing bare-metal code using this target. Those crates include several examples which run in QEMU and build using these targets.","breadcrumbs":"Platform Support  arm-none-eabi  armebv7r-none-eabi{,hf}  Start-up and Low-Level Code","id":"1142","title":"Start-up and Low-Level Code"},"1143":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Armv8-R architecture family, supporting dual ARM/Thumb mode, with ARM mode as the default. Processors in this family include the Arm Cortex-R52 and Cortex-R52+ . See arm-none-eabi for information applicable to all arm-none-eabi targets.","breadcrumbs":"Platform Support  arm-none-eabi  armv8r-none-eabihf  armv8r-none-eabihf","id":"1143","title":"armv8r-none-eabihf"},"1144":{"body":"@chrisnc Rust Embedded Devices Working Group Arm Team @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  arm-none-eabi  armv8r-none-eabihf  Target maintainers","id":"1144","title":"Target maintainers"},"1145":{"body":"The Cortex-R52 family always includes a floating-point unit, so there is no non-hf version of this target. The floating-point features assumed by this target are those of the single-precision-only config of the Cortex-R52, which has 16 double-precision registers, accessible as 32 single-precision registers. The other variant of Cortex-R52 includes double-precision, 32 double-precision registers, and Advanced SIMD (Neon). The manual refers to this as the \\"Full Advanced SIMD config\\". To compile code for this variant, use: -C target-feature=+fp64,+d32,+neon. See the Advanced SIMD and floating-point support section of the Cortex-R52 Processor Technical Reference Manual for more details.","breadcrumbs":"Platform Support  arm-none-eabi  armv8r-none-eabihf  Requirements","id":"1145","title":"Requirements"},"1146":{"body":"CPU FPU Neon Target CPU Target Features Any SP No None None Cortex-R52 SP No cortex-r52 -fp64,-d32,-neon Cortex-R52 DP No cortex-r52 -neon Cortex-R52 DP Yes cortex-r52 None Cortex-R52+ SP No cortex-r52plus -fp64,-d32,-neon Cortex-R52+ DP No cortex-r52plus -neon Cortex-R52+ DP Yes cortex-r52plus None","breadcrumbs":"Platform Support  arm-none-eabi  armv8r-none-eabihf  Table of supported CPUs for armv8r-none-eabihf","id":"1146","title":"Table of supported CPUs for armv8r-none-eabihf"},"1147":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Armv6-M architecture family, supporting a subset of the T32 ISA . Processors in this family include the: Arm Cortex-M0 Arm Cortex-M0+ Arm Cortex-M1 See arm-none-eabi for information applicable to all arm-none-eabi targets. This target uses the soft-float ABI: functions which take f32 or f64 as arguments will have those values packed into integer registers. This is the only option because there is no FPU support in Armv6-M .","breadcrumbs":"Platform Support  arm-none-eabi  thumbv6m-none-eabi  thumbv6m-none-eabi","id":"1147","title":"thumbv6m-none-eabi"},"1148":{"body":"Rust Embedded Devices Working Group Arm Team","breadcrumbs":"Platform Support  arm-none-eabi  thumbv6m-none-eabi  Target maintainers","id":"1148","title":"Target maintainers"},"1149":{"body":"See the bare-metal Arm docs for details on how to use these flags.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv6m-none-eabi  Target CPU and Target Feature options","id":"1149","title":"Target CPU and Target Feature options"},"115":{"body":"CMake 3.28 supports the JOB_SERVER_AWARE option in its add_custom_target command, e.g.: cmake_minimum_required(VERSION 3.28)\\nproject(x)\\nadd_custom_target(x JOB_SERVER_AWARE TRUE COMMAND echo \'fn main() {}\' | rustc -\\n) For earlier versions, when using CMake with the Makefile generator, one workaround is to have $(MAKE) somewhere in the command so that GNU Make treats it as a recursive Make call, e.g.: cmake_minimum_required(VERSION 3.22)\\nproject(x)\\nadd_custom_target(x COMMAND DUMMY_VARIABLE=$(MAKE) echo \'fn main() {}\' | rustc -\\n)","breadcrumbs":"Jobserver  CMake","id":"115","title":"CMake"},"1150":{"body":"CPU FPU Target CPU Target Features Cortex-M0 No cortex-m0 None Cortex-M0+ No cortex-m0plus None Cortex-M1 No cortex-m1 None","breadcrumbs":"Platform Support  arm-none-eabi  thumbv6m-none-eabi  Table of supported CPUs","id":"1150","title":"Table of supported CPUs"},"1151":{"body":"The target CPU option is cortex-m0. There are no relevant feature flags, and the FPU is not available.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv6m-none-eabi  Arm Cortex-M0","id":"1151","title":"Arm Cortex-M0"},"1152":{"body":"The target CPU option is cortex-m0plus. There are no relevant feature flags, and the FPU is not available.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv6m-none-eabi  Arm Cortex-M0+","id":"1152","title":"Arm Cortex-M0+"},"1153":{"body":"The target CPU option is cortex-m1. There are no relevant feature flags, and the FPU is not available.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv6m-none-eabi  Arm Cortex-M1","id":"1153","title":"Arm Cortex-M1"},"1154":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Armv7E-M architecture family, supporting a subset of the T32 ISA . Processors in this family include the: Arm Cortex-M4 and Arm Cortex-M4F Arm Cortex-M7 and Arm Cortex-M7F See arm-none-eabi for information applicable to all arm-none-eabi targets, in particular the difference between the eabi and eabihf ABI.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7em-none-eabi*  thumbv7em-none-eabi and thumbv7em-none-eabihf","id":"1154","title":"thumbv7em-none-eabi and thumbv7em-none-eabihf"},"1155":{"body":"Rust Embedded Devices Working Group Arm Team @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7em-none-eabi*  Target maintainers","id":"1155","title":"Target maintainers"},"1156":{"body":"See the bare-metal Arm docs for details on how to use these flags.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7em-none-eabi*  Target CPU and Target Feature options","id":"1156","title":"Target CPU and Target Feature options"},"1157":{"body":"CPU FPU DSP Target CPU Target Features Any No Yes None None Cortex-M4 No Yes cortex-m4 -fpregs Cortex-M4F SP Yes cortex-m4 None Cortex-M7 No Yes cortex-m7 -fpregs Cortex-M7F SP Yes cortex-m7 -fp64 Cortex-M7F DP Yes cortex-m7 None","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7em-none-eabi*  Table of supported CPUs for thumbv7em-none-eabi","id":"1157","title":"Table of supported CPUs for thumbv7em-none-eabi"},"1158":{"body":"CPU FPU DSP Target CPU Target Features Any SP Yes None None Cortex-M4F SP Yes cortex-m4 None Cortex-M7F SP Yes cortex-m7 -fp64 Cortex-M7F DP Yes cortex-m7 None Never use the -fpregs target-feature with the thumbv7em-none-eabihf target as it will cause compilation units to have different ABIs, which is unsound.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7em-none-eabi*  Table of supported CPUs for thumbv7em-none-eabihf","id":"1158","title":"Table of supported CPUs for thumbv7em-none-eabihf"},"1159":{"body":"The target CPU is cortex-m4. All Cortex-M4 have DSP extensions support is controlled by the dsp target-feature enabled by default with this target Cortex-M4F has a single precision FPU support is enabled by default with this target-cpu disable support using the -fpregs target-feature (eabi only)","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7em-none-eabi*  Arm Cortex-M4 and Arm Cortex-M4F","id":"1159","title":"Arm Cortex-M4 and Arm Cortex-M4F"},"116":{"body":"In software, a \\"lint\\" is a tool used to help improve your source code. The Rust compiler contains a number of lints, and when it compiles your code, it will also run the lints. These lints may produce a warning, an error, or nothing at all, depending on how you\'ve configured things. Here\'s a small example: $ cat main.rs\\nfn main() { let x = 5;\\n}\\n$ rustc main.rs\\nwarning: unused variable: `x` --> main.rs:2:9 |\\n2 | let x = 5; | ^ | = note: `#[warn(unused_variables)]` on by default = note: to avoid this warning, consider using `_x` instead This is the unused_variables lint, and it tells you that you\'ve introduced a variable that you don\'t use in your code. That\'s not wrong , so it\'s not an error, but it might be a bug, so you get a warning.","breadcrumbs":"Lints  Lints","id":"116","title":"Lints"},"1160":{"body":"The target CPU is cortex-m7. All Cortex-M7 have DSP extensions support is controlled by the dsp target-feature enabled by default with this target Cortex-M7F have either a single-precision or double-precision FPU double-precision support is enabled by default with this target-cpu opt-out by using the -f64 target-feature disable support entirely using the -fpregs target-feature (eabi only)","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7em-none-eabi*  Arm Cortex-M7 and Arm Cortex-M7F","id":"1160","title":"Arm Cortex-M7 and Arm Cortex-M7F"},"1161":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Armv7-M architecture family, supporting a subset of the T32 ISA . Processors in this family include the: Arm Cortex-M3 See arm-none-eabi for information applicable to all arm-none-eabi targets. This target uses the soft-float ABI: functions which take f32 or f64 as arguments will have those values packed into integer registers. This is the only option because there is no FPU support in Armv7-M .","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7m-none-eabi  thumbv7m-none-eabi","id":"1161","title":"thumbv7m-none-eabi"},"1162":{"body":"Rust Embedded Devices Working Group Arm Team @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7m-none-eabi  Target maintainers","id":"1162","title":"Target maintainers"},"1163":{"body":"See the bare-metal Arm docs for details on how to use these flags.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7m-none-eabi  Target CPU and Target Feature options","id":"1163","title":"Target CPU and Target Feature options"},"1164":{"body":"CPU FPU Target CPU Target Features Cortex-M3 No cortex-m3 None","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7m-none-eabi  Table of supported CPUs","id":"1164","title":"Table of supported CPUs"},"1165":{"body":"The target CPU option is cortex-m3. There are no relevant feature flags, and the FPU is not available.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv7m-none-eabi  Arm Cortex-M3","id":"1165","title":"Arm Cortex-M3"},"1166":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Baseline Armv8-M architecture family, supporting a subset of the T32 ISA . Processors in this family include the: Arm Cortex-M23 See arm-none-eabi for information applicable to all arm-none-eabi targets. This target uses the soft-float ABI: functions which take f32 or f64 as arguments will have those values packed into integer registers. This is the only option because there is no FPU support in Armv8-M Baseline.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.base-none-eabi  thumbv8m.base-none-eabi","id":"1166","title":"thumbv8m.base-none-eabi"},"1167":{"body":"Rust Embedded Devices Working Group Arm Team @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.base-none-eabi  Target maintainers","id":"1167","title":"Target maintainers"},"1168":{"body":"See the bare-metal Arm docs for details on how to use these flags.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.base-none-eabi  Target CPU and Target Feature options","id":"1168","title":"Target CPU and Target Feature options"},"1169":{"body":"CPU FPU Target CPU Target Features Cortex-M23 No cortex-m23 None","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.base-none-eabi  Table of supported CPUs","id":"1169","title":"Table of supported CPUs"},"117":{"body":"Sometimes the compiler needs to be changed to fix an issue that can cause existing code to stop compiling. \\"Future-incompatible\\" lints are issued in these cases to give users of Rust a smooth transition to the new behavior. Initially, the compiler will continue to accept the problematic code and issue a warning. The warning has a description of the problem, a notice that this will become an error in the future, and a link to a tracking issue that provides detailed information and an opportunity for feedback. This gives users some time to fix the code to accommodate the change. After some time, the warning may become an error. The following is an example of what a future-incompatible looks like: warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133) --> lint_example.rs:11:13 |\\n11 | let y = &x.data.0; | ^^^^^^^^^ | = note: `#[warn(safe_packed_borrows)]` on by default = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release! = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043> = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior For more information about the process and policy of future-incompatible changes, see RFC 1589 .","breadcrumbs":"Lints  Future-incompatible lints","id":"117","title":"Future-incompatible lints"},"1170":{"body":"The target CPU option is cortex-m23. There are no relevant feature flags, and the FPU is not available.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.base-none-eabi  Arm Cortex-M23","id":"1170","title":"Arm Cortex-M23"},"1171":{"body":"Tier: 2 Library Support: core and alloc (bare-metal, #![no_std]) Bare-metal target for CPUs in the Mainline Armv8-M architecture family, supporting a subset of the T32 ISA . Processors in this family include the: Arm Cortex-M33 Arm Cortex-M35P Arm Cortex-M55 Arm Cortex-M85 See arm-none-eabi for information applicable to all arm-none-eabi targets, in particular the difference between the eabi and eabihf ABI.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  thumbv8m.main-none-eabi and thumbv8m.main-none-eabihf","id":"1171","title":"thumbv8m.main-none-eabi and thumbv8m.main-none-eabihf"},"1172":{"body":"Rust Embedded Devices Working Group Arm Team @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  Target maintainers","id":"1172","title":"Target maintainers"},"1173":{"body":"See the bare-metal Arm docs for details on how to use these flags.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  Target CPU and Target Feature options","id":"1173","title":"Target CPU and Target Feature options"},"1174":{"body":"CPU FPU DSP MVE Target CPU Target Features Unspecified No No No None None Cortex-M33 No No No cortex-m33 -fpregs,-dsp Cortex-M33 No Yes No cortex-m33 -fpregs Cortex-M33 SP No No cortex-m33 -dsp Cortex-M33 SP Yes No cortex-m33 None Cortex-M35P No No No cortex-m35p -fpregs,-dsp Cortex-M35P No Yes No cortex-m35p -fpregs Cortex-M35P SP No No cortex-m35p -dsp Cortex-M35P SP Yes No cortex-m35p None Cortex-M55 No Yes No cortex-m55 -fpregs,-mve Cortex-M55 DP Yes No cortex-m55 -mve Cortex-M55 No Yes Int cortex-m55 -fpregs,-mve.fp,+mve Cortex-M55 DP Yes Int cortex-m55 -mve.fp Cortex-M55 DP Yes Int+Float cortex-m55 None Cortex-M85 No Yes No cortex-m85 -fpregs,-mve Cortex-M85 DP Yes No cortex-m85 -mve Cortex-M85 No Yes Int cortex-m85 -fpregs,-mve.fp,+mve Cortex-M85 DP Yes Int cortex-m85 -mve.fp Cortex-M85 DP Yes Int+Float cortex-m85 None","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  Table of supported CPUs for thumbv8m.main-none-eabi","id":"1174","title":"Table of supported CPUs for thumbv8m.main-none-eabi"},"1175":{"body":"CPU FPU DSP MVE Target CPU Target Features Unspecified SP No No None None Cortex-M33 SP No No cortex-m33 -dsp Cortex-M33 SP Yes No cortex-m33 None Cortex-M33P SP No No cortex-m35p -dsp Cortex-M33P SP Yes No cortex-m35p None Cortex-M55 DP Yes No cortex-m55 -mve Cortex-M55 DP Yes Int cortex-m55 -mve.fp Cortex-M55 DP Yes Int+Float cortex-m55 None Cortex-M85 DP Yes No cortex-m85 -mve Cortex-M85 DP Yes Int cortex-m85 -mve.fp Cortex-M85 DP Yes Int+Float cortex-m85 None Technically you can use this hard-float ABI on a CPU which has no FPU but does have Integer MVE, because MVE provides the same set of registers as the FPU (including s0 and d0). The particular set of flags that might enable this unusual scenario are currently not recorded here. Never use the -fpregs target-feature with the thumbv8m.main-none-eabihf target as it will cause compilation units to have different ABIs, which is unsound.","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  Table of supported CPUs for thumbv8m.main-none-eabihf","id":"1175","title":"Table of supported CPUs for thumbv8m.main-none-eabihf"},"1176":{"body":"The target CPU is cortex-m33. Has optional DSP extensions support is controlled by the dsp target-feature enabled by default with this target-cpu Has an optional single precision FPU support is enabled by default with this target-cpu disable support using the -fpregs target-feature (eabi only)","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  Arm Cortex-M33","id":"1176","title":"Arm Cortex-M33"},"1177":{"body":"The target CPU is cortex-m35p. Has optional DSP extensions support is controlled by the dsp target-feature enabled by default with this target-cpu Has an optional single precision FPU support is enabled by default with this target-cpu disable support using the -fpregs target-feature (eabi only)","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  Arm Cortex-M35P","id":"1177","title":"Arm Cortex-M35P"},"1178":{"body":"The target CPU is cortex-m55. Has DSP extensions support is controlled by the dsp target-feature enabled by default with this target-cpu Has an optional double-precision FPU that also supports half-precision FP16 values support is enabled by default with this target-cpu disable support using the -fpregs target-feature (eabi only) Has optional support for M-Profile Vector Extensions Also known as Helium Technology Available with only integer support, or both integer/float support The appropriate feature for the MVE is either mve (integer) or mve.fp (float) mve.fp is enabled by default on this target CPU disable using -mve.fp (disable float MVE) or -mve (disable all MVE)","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  Arm Cortex-M55","id":"1178","title":"Arm Cortex-M55"},"1179":{"body":"The target CPU is cortex-m85. Has DSP extensions support is controlled by the dsp target-feature enabled by default with this target-cpu Has an optional double-precision FPU that also supports half-precision FP16 values support is enabled by default with this target-cpu disable support using the -fpregs target-feature (eabi only) Has optional support for M-Profile Vector Extensions Also known as Helium Technology Available with only integer support, or both integer/float support The appropriate feature for the MVE is either mve (integer) or mve.fp (float) mve.fp is enabled by default on this target CPU disable using -mve.fp (disable float MVE) or -mve (disable all MVE)","breadcrumbs":"Platform Support  arm-none-eabi  thumbv8m.main-none-eabi*  Arm Cortex-M85","id":"1179","title":"Arm Cortex-M85"},"118":{"body":"In rustc, lints are divided into six levels : allow expect warn force-warn deny forbid Each lint has a default level (explained in the lint listing later in this chapter), and the compiler has a default warning level. First, let\'s explain what these levels mean, and then we\'ll talk about configuration.","breadcrumbs":"Lints  Lint Levels  Lint Levels","id":"118","title":"Lint Levels"},"1180":{"body":"The Arm Architecture has been around since the mid-1980s, going through nine major revisions, many minor revisions, and spanning both 32-bith and 64-bit architectures. This page covers 32-bit Arm platforms that run some form of Linux (but not Android). Those targets are: arm-unknown-linux-gnueabi arm-unknown-linux-gnueabihf arm-unknown-linux-musleabi arm-unknown-linux-musleabihf armeb-unknown-linux-gnueabi armv4t-unknown-linux-gnueabi armv5te-unknown-linux-gnueabi armv5te-unknown-linux-musleabi armv5te-unknown-linux-uclibceabi armv7-unknown-linux-gnueabi armv7-unknown-linux-gnueabihf armv7-unknown-linux-musleabi armv7-unknown-linux-musleabihf armv7-unknown-linux-ohos armv7-unknown-linux-uclibceabi armv7-unknown-linux-uclibceabihf thumbv7neon-unknown-linux-gnueabihf thumbv7neon-unknown-linux-musleabihf Some of these targets have dedicated pages and some do not. This is largely due to historical accident, or the enthusiasm of the maintainers. This document attempts to cover all the targets, but only in broad terms. To make sense of this list, the architecture and ABI component of the <architecture>-unknown-linux-<abi> tuple will be discussed separately. The second part of the tuple is unknown because these systems don\'t come from any one specific vendor (like powerpc-ibm-aix or aarch64-apple-darwin). The third part is linux, because this page only discusses Linux targets.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  Arm Linux support in Rust","id":"1180","title":"Arm Linux support in Rust"},"1181":{"body":"arm armeb armv4t armv5te armv7 thumbv7neon The architecture component simply called arm corresponds to the Armv6 architecture - that is, version 6 of the Arm Architecture as defined in version 6 of the Arm Architecture Reference Manual (the Arm ARM). This was the last \'legacy\' release of the Arm architecture, before they split into Application, Real-Time and Microcontroller profiles (leading to Armv7-A, Armv7-R and Armv7-M). Processors that implement the Armv6 architecture include the ARM1176JZF-S, as found in BCM2835 SoC that powers the Raspberry Pi Zero. Arm processors are generally fairly backwards compatible, especially for user-mode code, so code compiled for the arm architecture should also work on newer ARMv7-A systems, or even 64/32-bit Armv8-A systems. The armeb architecture component specifies an Armv6 processor running in Big Endian mode (eb is for big-endian - the letters are backwards because engineers used to little-endian systems perceive big-endian numbers to be written into memory backwards, and they thought it was funnier like that). Most Arm processors can operate in either little-endian or big-endian mode and little-endian mode is by far the most common. However, if for whatever reason you wish to store your Most Significant Bytes first, these targets are available. They just aren\'t terribly well tested, or compatible with most existing pre-compiled Arm libraries. Targets that start with armv4t are for processors implementing the Armv4T architecture from 1994. These include the ARM7TDMI, as found in the Nokia 6110 brick-phone and the Game Boy Advance. The \'T\' stands for Thumb and indicate that the processors can execute smaller 16-bit versions of some of the 32-bit Arm instructions. Because a Thumb is like a small version of an Arm. Targets that start with armv5te are for processors implementing the Armv5TE architecture. These are mostly from the ARM9 family, like the ARM946E-S found in the Nintendo DS. If you are programming an Arm machine from the early 2000s, this might be what you need. The armv7 is arguably a misnomer, and it should be armv7a. This is because it corresponds to the Application profile of Armv7 (i.e. Armv7-A), as opposed to the Real-Time or Microcontroller profile. Processors implementing this architecture include the Cortex-A7 and Cortex-A8. The thumbv7neon component indicates support for a processor that implements ARMv7-A (the same as armv7), it generates Thumb instructions (technically Thumb-2, also known as the T32 ISA) as opposed to Arm instructions (also known as the A32 ISA). These instructions are smaller, giving more code per KB of RAM, but may have a performance penalty if they take two instructions to do something Arm instructions could do in one. It\'s a complex trade-off and you should be doing benchmarks to work out which is better for you, if you strongly care about code size and/or performance. This component also enables support for Arm\'s SIMD extensions, known as Neon. These extensions will improve performance for certain kinds of repetitive operations.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  Architecture Component","id":"1181","title":"Architecture Component"},"1182":{"body":"gnueabi gnueabihf musleabi musleabihf ohos uclibceabi uclibceabihf You will need to select the appropriate ABI to match the system you want to be running this code on. For example, running eabihf code on an eabi system will not work correctly. The gnueabi ABI component indicates support for using the GNU C Library (glibc), and the Arm Embedded ABI (EABI). The EABI is a replacement for the original ABI (now called the Old ABI or OABI), and it is the standard ABI for 32-bit Arm systems. With this ABI, function parameters that are f32 or f64 are passed as if they were integers, instead of being passed via in FPU registers. Generally these targets also disable the use of the FPU entirely, although that isn\'t always true. The gnueabihf ABI component is like gnueabi, except that it support the \'hard-float\' of the EABI. That is, function parameters that are f32 or f64 are passed in FPU registers. Naturally, this makes the FPU mandatory. Most \'desktop\' Linux distributions (Debian, Ubuntu, Fedora, etc) use the GNU C Library and so you should probably select either gnueabi or gnueabihf, depending on whether your distribution is using \'soft-float\' (EABI) or \'hard-float\' (EABIHF). Debian happens to offer both kinds . The musleabi and musleabihf ABI components offer support for the musl C library . This C library can be used to create \'static binaries\' that have no run-time library requirements (a feature that glibc does not support). There are soft-float (eabi) and hard-float (eabihf) variants, as per the gnu* targets above. The uclibceabi and uclibceabihf ABI components are for the uClibc-ng C library . This is sometimes used in light-weight embedded Linux distributions, like those created with buildroot .","breadcrumbs":"Platform Support  arm*-unknown-linux-*  ABI Component","id":"1182","title":"ABI Component"},"1183":{"body":"Unfortunately, 32-bit Arm machines are generally not the fastest around, and they don\'t have much RAM. This means you are likely to be cross-compiling. To do this, you need to give Rust a suitable linker to use - one that knows the Arm architecture, and more importantly, knows where to find a suitable C Library to link against. To do that, you can add the linker property to your .cargo/config.toml. Typically you would refer to a suitable copy of GCC that has built as a cross-compiler, alongside a C library. [target.arm-unknown-linux-gnueabi]\\nlinker = \\"arm-linux-gnueabi-gcc\\" On Debian Linux, you could install such a cross-compilation toolchain with apt install gcc-arm-linux-gnueabi. For more exotic combinations, you might need to build a bespoke version of GCC using crosstool-ng . Note that for GCC, all 32-bit Arm architectures are handled in the same build there are no separate Armv4T or Armv6 builds of GCC. The architecture is selected with flags, like -march=armv6, but they aren\'t required for the linker. Let\'s assume we are on some Debian machine, and we want to build a basic Arm Linux binary for a distribution using the GNU C Library, targeting Armv6 with a hard-float ABI. Such a binary should work on a Raspberry Pi, for example. The commands are: sudo apt install -y gcc-arm-linux-gnueabihf\\nrustup target add arm-unknown-linux-gnueabihf\\ncargo new --bin armdemo\\ncd armdemo\\nmkdir .cargo\\ncat > .cargo/config.toml << EOF\\n[target.arm-unknown-linux-gnueabihf]\\nlinker = \\"arm-linux-gnueabihf-gcc\\"\\nEOF\\ncargo build --target=arm-unknown-linux-gnueabihf This will give us our ARM Linux binary for the GNU C Library with a soft-float ABI: $ file ./target/arm-unknown-linux-gnueabi/debug/armdemo\\n./target/arm-unknown-linux-gnueabi/debug/armdemo: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, BuildID[sha1]=dd0b9aa5ae876330fd4e2fcf393850f083ec7fcd, for GNU/Linux 3.2.0, with debug_info, not stripped If you are building C code as part of your Rust project, you may want to direct cc-rs to use an appropriate cross-compiler with the CROSS_COMPILE environment variable. You may also want to set the CFLAGS environment variable for the target. For example: export CROSS_COMPILE=arm-linux-gnueabi\\nexport CFLAGS_arm_unknown_linux_gnueabi=\\"-march=armv6\\" (Note that the dashes (-) turn to underscores (_) to form the name of the CFLAGS environment variable) If you are building for a Tier 3 target using -Zbuild-std (on Nightly Rust), you need to set these variables as well: export CXX_arm_unknown_linux_gnueabi=arm-linux-gnueabi-g++\\nexport CC_arm_unknown_linux_gnueabi=arm-linux-gnueabi-gcc\\ncargo +nightly build -Zbuild-std --target=arm-unknown-linux-gnueabi","breadcrumbs":"Platform Support  arm*-unknown-linux-*  Cross Compilation","id":"1183","title":"Cross Compilation"},"1184":{"body":"Tier: 3 Target for cross-compiling Linux user-mode applications targeting the Arm BE8 architecture. See arm-linux for information applicable to all Arm Linux targets.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armeb-unknown-linux-gnueabi  armeb-unknown-linux-gnueabi","id":"1184","title":"armeb-unknown-linux-gnueabi"},"1185":{"body":"BE8 architecture retains the same little-endian ordered code-stream used by conventional little endian Arm systems, however the data accesses are in big-endian. BE8 is used primarily in high-performance networking applications where the ability to read packets in their native \\"Network Byte Order\\" is important (many network protocols transmit data in big-endian byte order for their wire formats).","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armeb-unknown-linux-gnueabi  Overview","id":"1185","title":"Overview"},"1186":{"body":"BE8 architecture is the default big-endian architecture for Arm since Armv6 . It\'s predecessor, used for Armv4 and Armv5 devices was BE32 . On Armv6 architecture, endianness can be configured via system registers . However, BE32 was withdrawn for Armv7 onwards.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armeb-unknown-linux-gnueabi  History","id":"1186","title":"History"},"1187":{"body":"@WorksButNotTested","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armeb-unknown-linux-gnueabi  Target Maintainers","id":"1187","title":"Target Maintainers"},"1188":{"body":"The target is cross-compiled. This target supports std in the normal way (indeed only nominal changes are required from the standard Arm configuration).","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armeb-unknown-linux-gnueabi  Requirements","id":"1188","title":"Requirements"},"1189":{"body":"The target definition can be seen here . In particular, it should be noted that the features specify that this target is built for the Armv8 core. Though this can likely be modified as required.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armeb-unknown-linux-gnueabi  Target definition","id":"1189","title":"Target definition"},"119":{"body":"These lints exist, but by default, do nothing. For example, consider this source: pub fn foo() {} Compiling this file produces no warnings: $ rustc lib.rs --crate-type=lib\\n$ But this code violates the missing_docs lint. These lints exist mostly to be manually turned on via configuration, as we\'ll talk about later in this section.","breadcrumbs":"Lints  Lint Levels  allow","id":"119","title":"allow"},"1190":{"body":"Because it is Tier 3, rust does not yet ship pre-compiled artifacts for this target. Therefore, you can build Rust with support for the target by adding it to the target list in bootstrap.toml, a sample configuration is shown below. It is expected that the user already have a working GNU compiler toolchain and update the paths accordingly. [llvm]\\ndownload-ci-llvm = false\\noptimize = true\\nninja = true\\ntargets = \\"ARM;X86\\"\\nclang = false [build]\\ntarget = [\\"x86_64-unknown-linux-gnu\\", \\"armeb-unknown-linux-gnueabi\\"]\\ndocs = false\\ndocs-minification = false\\ncompiler-docs = false\\n[install]\\nprefix = \\"/home/user/x-tools/rust/\\" [rust]\\ndebug-logging=true\\nbacktrace = true\\nincremental = true [target.x86_64-unknown-linux-gnu] [dist] [target.armeb-unknown-linux-gnueabi]\\ncc = \\"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-gcc\\"\\ncxx = \\"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-g++\\"\\nar = \\"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-ar\\"\\nranlib = \\"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-ranlib\\"\\nlinker = \\"/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-gcc\\"\\nllvm-config = \\"/home/user/x-tools/clang/bin/llvm-config\\"\\nllvm-filecheck = \\"/home/user/x-tools/clang/bin/FileCheck\\"","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armeb-unknown-linux-gnueabi  Building the target","id":"1190","title":"Building the target"},"1191":{"body":"The following .cargo/config is needed inside any project directory to build for the BE8 target: [build]\\ntarget = \\"armeb-unknown-linux-gnueabi\\" [target.armeb-unknown-linux-gnueabi]\\nlinker = \\"armeb-unknown-linux-gnueabi-gcc\\" Note that it is expected that the user has a suitable linker from the GNU toolchain.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armeb-unknown-linux-gnueabi  Building Rust programs","id":"1191","title":"Building Rust programs"},"1192":{"body":"Tier: 2 This target supports Linux programs with glibc on ARMv5TE CPUs without floating-point units. See arm-linux for information applicable to all Arm Linux targets.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv5te-unknown-linux-gnueabi  armv5te-unknown-linux-gnueabi","id":"1192","title":"armv5te-unknown-linux-gnueabi"},"1193":{"body":"There are currently no formally documented target maintainers.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv5te-unknown-linux-gnueabi  Target maintainers","id":"1193","title":"Target maintainers"},"1194":{"body":"The target is for cross-compilation only. Host tools are not supported. std is fully supported.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv5te-unknown-linux-gnueabi  Requirements","id":"1194","title":"Requirements"},"1195":{"body":"Because this target is tier 2, artifacts are available from rustup.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv5te-unknown-linux-gnueabi  Building the target","id":"1195","title":"Building the target"},"1196":{"body":"For building rust programs, you might want to specify GCC as linker in .cargo/config.toml as follows: [target.armv5te-unknown-linux-gnueabi]\\nlinker = \\"arm-linux-gnueabi-gcc\\"","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv5te-unknown-linux-gnueabi  Building Rust programs","id":"1196","title":"Building Rust programs"},"1197":{"body":"Tier: 2 (with Host Tools) for armv7-unknown-linux-gnueabihf Tier: 2 for armv7-unknown-linux-gnueabi Target for 32-bit little endian ARMv7-A Linux 3.2+ programs using glibc 2.17+.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-gnueabi  armv7-unknown-linux-gnueabi and armv7-unknown-linux-gnueabihf","id":"1197","title":"armv7-unknown-linux-gnueabi and armv7-unknown-linux-gnueabihf"},"1198":{"body":"@rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-gnueabi  Target maintainers","id":"1198","title":"Target maintainers"},"1199":{"body":"Building the targets themselves requires a 32-bit little endian ARMv7-A compiler that is supported by cc-rs.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-gnueabi  Requirements","id":"1199","title":"Requirements"},"12":{"body":"This informs rustc of the name of your crate.","breadcrumbs":"Command-line Arguments  --crate-name: specify the name of the crate being built","id":"12","title":"--crate-name: specify the name of the crate being built"},"120":{"body":"Sometimes, it can be helpful to suppress lints, but at the same time ensure that the code in question still emits them. The \'expect\' level does exactly this. If the lint in question is not emitted, the unfulfilled_lint_expectations lint triggers on the expect attribute, notifying you that the expectation is no longer fulfilled. fn main() { #[expect(unused_variables)] let unused = \\"Everyone ignores me\\"; #[expect(unused_variables)] // `unused_variables` lint is not emitted let used = \\"I\'m useful\\"; // the expectation is therefore unfulfilled println!(\\"The `used` value is equal to: {:?}\\", used);\\n} This will produce the following warning: warning: this lint expectation is unfulfilled --> src/main.rs:7:14 |\\n7 | #[expect(unused_variables)] | ^^^^^^^^^^^^^^^^ | = note: `#[warn(unfulfilled_lint_expectations)]` on by default This level can only be defined via the #[expect] attribute, there is no equivalent flag. Lints with the special \'force-warn\' level will still be emitted as usual.","breadcrumbs":"Lints  Lint Levels  expect","id":"120","title":"expect"},"1200":{"body":"These targets can be built by enabling it for a rustc build: [build]\\ntarget = [\\"armv7-unknown-linux-gnueabihf\\", \\"armv7-unknown-linux-gnueabi\\"] If cross-compiling, make sure your C compiler is included in $PATH, then add it to the bootstrap.toml: [target.aarch64-unknown-linux-musl]\\ncc = \\"arm-linux-gnu-gcc\\"\\ncxx = \\"arm-linux-gnu-g++\\"\\nar = \\"arm-linux-gnu-ar\\"\\nlinker = \\"arm-linux-gnu-gcc\\"","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-gnueabi  Building the target","id":"1200","title":"Building the target"},"1201":{"body":"These targets is distributed through rustup, and otherwise requires no special configuration.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-gnueabi  Building Rust programs","id":"1201","title":"Building Rust programs"},"1202":{"body":"These targets can be cross-compiled from any host.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-gnueabi  Cross-compilation","id":"1202","title":"Cross-compilation"},"1203":{"body":"These targets can be tested as normal with x.py on a 32-bit little endian ARMv7-A host or via QEMU emulation.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-gnueabi  Testing","id":"1203","title":"Testing"},"1204":{"body":"Tier: 3 This target supports Armv7-A softfloat CPUs and uses the uclibc-ng standard library. This is a common configuration on many consumer routers (e.g., Netgear R7000, Asus RT-AC68U). See arm-linux for information applicable to all Arm Linux targets.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  armv7-unknown-linux-uclibceabi","id":"1204","title":"armv7-unknown-linux-uclibceabi"},"1205":{"body":"@lancethepants","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  Target maintainers","id":"1205","title":"Target maintainers"},"1206":{"body":"This target is cross compiled, and requires a cross toolchain. This target supports host tools and std.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  Requirements","id":"1206","title":"Requirements"},"1207":{"body":"You will need to download or build a \'C\' cross toolchain that targets Armv7-A softfloat and that uses the uclibc-ng standard library. If your target hardware is something like a router or an embedded device, keep in mind that manufacturer supplied SDKs for this class of CPU could be outdated and potentially unsuitable for bootstrapping rust. Here is a sample toolchain that is built using buildroot . It uses modern toolchain components, older thus universal kernel headers (2.6.36.4), and is used for a project called Tomatoware . This toolchain is patched so that its sysroot is located at /mmc (e.g., /mmc/bin, /mmc/lib, /mmc/include). This is useful in scenarios where the root filesystem is read-only but you are able attach external storage loaded with user applications. Tomatoware is an example of this that even allows you to run various compilers and developer tools natively on the target device. Utilizing the Tomatoware toolchain this target can be built for cross compilation and native compilation (host tools) with project rust-bootstrap-armv7-unknown-linux-uclibceabi . Here is a sample config if using your own toolchain. [build]\\nbuild-stage = 2\\ntarget = [\\"armv7-unknown-linux-uclibceabi\\"] [target.armv7-unknown-linux-uclibceabi]\\ncc = \\"/path/to/arm-unknown-linux-uclibcgnueabi-gcc\\"\\ncxx = \\"/path/to/arm-unknown-linux-uclibcgnueabi-g++\\"\\nar = \\"path/to/arm-unknown-linux-uclibcgnueabi-ar\\"\\nranlib = \\"path/to/arm-unknown-linux-uclibcgnueabi-ranlib\\"\\nlinker = \\"/path/to/arm-unknown-linux-uclibcgnueabi-gcc\\"","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  Building the target","id":"1207","title":"Building the target"},"1208":{"body":"The following assumes you are using the Tomatoware toolchain and environment. Adapt if you are using your own toolchain.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  Building Rust programs","id":"1208","title":"Building Rust programs"},"1209":{"body":"Since this target supports host tools, you can natively build rust applications directly on your target device. This can be convenient because it removes the complexities of cross compiling and you can immediately test and deploy your binaries. One downside is that compiling on your Armv7-A CPU will probably be much slower than cross compilation on your x86 machine. To setup native compilation: Download Tomatoware to your device using the latest nightly release found here . Extract tar zxvf arm-soft-mmc.tgz -C /mmc Add /mmc/bin:/mmc:sbin/ to your PATH, or source /mmc/etc/profile apt update && apt install rust If you bootstrap rust on your own using the project above, it will create a .deb file that you then can install with dpkg -i rust_1.xx.x-x_arm.deb After completing these steps you can use rust normally in a native environment.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  Native compilation","id":"1209","title":"Native compilation"},"121":{"body":"The \'warn\' lint level will produce a warning if you violate the lint. For example, this code runs afoul of the unused_variables lint: pub fn foo() { let x = 5;\\n} This will produce this warning: $ rustc lib.rs --crate-type=lib\\nwarning: unused variable: `x` --> lib.rs:2:9 |\\n2 | let x = 5; | ^ | = note: `#[warn(unused_variables)]` on by default = note: to avoid this warning, consider using `_x` instead","breadcrumbs":"Lints  Lint Levels  warn","id":"121","title":"warn"},"1210":{"body":"To cross compile, you\'ll need to: Build the rust cross toolchain using rust-bootstrap-armv7-unknown-linux-uclibceabi or your own built toolchain. Link your built toolchain with rustup toolchain link stage2 \\\\\\n${HOME}/rust-bootstrap-armv7-unknown-linux-uclibceabi/src/rust/rust/build/x86_64-unknown-linux-gnu/stage2 Build with: CC_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \\\\\\nCXX_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-g++ \\\\\\nAR_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-ar \\\\\\nCFLAGS_armv7_unknown_linux_uclibceabi=\\"-march=armv7-a -mtune=cortex-a9\\" \\\\\\nCXXFLAGS_armv7_unknown_linux_uclibceabi=\\"-march=armv7-a -mtune=cortex-a9\\" \\\\\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_LINKER=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \\\\\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_RUSTFLAGS=\'-Clink-arg=-s -Clink-arg=-Wl,--dynamic-linker=/mmc/lib/ld-uClibc.so.1 -Clink-arg=-Wl,-rpath,/mmc/lib\' \\\\\\ncargo +stage2 \\\\\\nbuild \\\\\\n--target armv7-unknown-linux-uclibceabi \\\\\\n--release Copy the binary to your target device and run. We specify CC, CXX, AR, CFLAGS, and CXXFLAGS environment variables because sometimes a project or a subproject requires the use of your \'C\' cross toolchain. Since Tomatoware has a modified sysroot we also pass via RUSTFLAGS the location of the dynamic-linker and rpath.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  Cross Compilation","id":"1210","title":"Cross Compilation"},"1211":{"body":"To test a cross-compiled binary on your build system follow the instructions for Cross Compilation, install qemu-arm-static, and run with the following. CC_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \\\\\\nCXX_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-g++ \\\\\\nAR_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-ar \\\\\\nCFLAGS_armv7_unknown_linux_uclibceabi=\\"-march=armv7-a -mtune=cortex-a9\\" \\\\\\nCXXFLAGS_armv7_unknown_linux_uclibceabi=\\"-march=armv7-a -mtune=cortex-a9\\" \\\\\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_LINKER=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \\\\\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_RUNNER=\\"qemu-arm-static -L /opt/tomatoware/arm-soft-mmc/arm-tomatoware-linux-uclibcgnueabi/sysroot/\\" \\\\\\ncargo +stage2 \\\\\\nrun \\\\\\n--target armv7-unknown-linux-uclibceabi \\\\\\n--release","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  Test with QEMU","id":"1211","title":"Test with QEMU"},"1212":{"body":"It\'s also possible to build in a chroot environment. This is a convenient way to work without needing to access the target hardware. To build the chroot: sudo debootstrap --arch armel bullseye $HOME/debian sudo chroot $HOME/debian/ /bin/bash mount proc /proc -t proc mount -t sysfs /sys sys/ export PATH=/mmc/bin:/mmc/sbin:$PATH From here you can setup your environment (e.g., add user, install wget). Download Tomatoware to the chroot environment using the latest nightly release found here . Extract tar zxvf arm-soft-mmc.tgz -C /mmc Add /mmc/bin:/mmc:sbin/ to your PATH, or source /mmc/etc/profile sudo /mmc/bin/apt update && sudo /mmc/bin/apt install rust After completing these steps you can use rust normally in a chroot environment. Remember when using sudo the root user\'s PATH could differ from your user\'s PATH.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabi  Run in a chroot","id":"1212","title":"Run in a chroot"},"1213":{"body":"Tier: 3 This tier supports the Armv7-A processor running a Linux kernel and uClibc-ng standard library. It provides full support for rust and the rust standard library. See arm-linux for information applicable to all Arm Linux targets.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabihf  armv7-unknown-linux-uclibceabihf","id":"1213","title":"armv7-unknown-linux-uclibceabihf"},"1214":{"body":"@skrap","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabihf  Target Maintainers","id":"1214","title":"Target Maintainers"},"1215":{"body":"This target is cross compiled, and requires a cross toolchain. You can find suitable pre-built toolchains at bootlin or build one yourself via buildroot .","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabihf  Requirements","id":"1215","title":"Requirements"},"1216":{"body":"","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabihf  Building","id":"1216","title":"Building"},"1217":{"body":"Compiling rust for this target has been tested on x86_64 linux hosts. Other host types have not been tested, but may work, if you can find a suitable cross compilation toolchain for them. If you don\'t already have a suitable toolchain, download one here , and unpack it into a directory.","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabihf  Get a C toolchain","id":"1217","title":"Get a C toolchain"},"1218":{"body":"The target can be built by enabling it for a rustc build, by placing the following in bootstrap.toml: [build]\\ntarget = [\\"armv7-unknown-linux-uclibceabihf\\"]\\nstage = 2 [target.armv7-unknown-linux-uclibceabihf]\\n# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN\\ncc = \\"/TOOLCHAIN_PATH/bin/arm-buildroot-linux-uclibcgnueabihf-gcc\\"","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabihf  Configure rust","id":"1218","title":"Configure rust"},"1219":{"body":"# in rust dir\\n./x.py build --stage 2","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabihf  Build","id":"1219","title":"Build"},"122":{"body":"\'force-warn\' is a special lint level. It\'s the same as \'warn\' in that a lint at this level will produce a warning, but unlike the \'warn\' level, the \'force-warn\' level cannot be overridden. If a lint is set to \'force-warn\', it is guaranteed to warn: no more, no less. This is true even if the overall lint level is capped via cap-lints.","breadcrumbs":"Lints  Lint Levels  force-warn","id":"122","title":"force-warn"},"1220":{"body":"To test cross-compiled binaries on a x86_64 system, you can use the qemu-arm userspace emulation program. This avoids having a full emulated ARM system by doing dynamic binary translation and dynamic system call translation. It lets you run ARM programs directly on your x86_64 kernel. It\'s very convenient! To use: Install qemu-arm according to your distro. Link your built toolchain via: rustup toolchain link stage2 ${RUST}/build/x86_64-unknown-linux-gnu/stage2 Create a test program cargo new hello_world\\ncd hello_world Build and run CARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABIHF_RUNNER=\\"qemu-arm -L ${TOOLCHAIN}/arm-buildroot-linux-uclibcgnueabihf/sysroot/\\" \\\\\\nCARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABIHF_LINKER=${TOOLCHAIN}/bin/arm-buildroot-linux-uclibcgnueabihf-gcc \\\\\\ncargo +stage2 run --target armv7-unknown-linux-uclibceabihf","breadcrumbs":"Platform Support  arm*-unknown-linux-*  armv7-unknown-linux-uclibceabihf  Building and Running Rust Programs","id":"1220","title":"Building and Running Rust Programs"},"1221":{"body":"Tier: 3 The Nintendo 3DS platform, which has an Armv6k processor, and its associated operating system (horizon). Rust support for this target is not affiliated with Nintendo, and is not derived from nor used with any official Nintendo SDK.","breadcrumbs":"Platform Support  armv6k-nintendo-3ds  armv6k-nintendo-3ds","id":"1221","title":"armv6k-nintendo-3ds"},"1222":{"body":"This target is maintained by members of the @rust3ds organization: @Meziu @AzureMarker @ian-h-chamberlain","breadcrumbs":"Platform Support  armv6k-nintendo-3ds  Target maintainers","id":"1222","title":"Target maintainers"},"1223":{"body":"This target is cross-compiled. Dynamic linking is not supported. #![no_std] crates can be built using build-std to build core and optionally alloc, and either panic_abort or panic_unwind. std is partially supported, but mostly works. Some APIs are unimplemented and will simply return an error, such as std::process. An allocator is provided by default. In order to support some APIs, binaries must be linked against libc written for the target, using a linker for the target. These are provided by the devkitARM toolchain. See Cross-compilation toolchains and C code for more details. Additionally, some helper crates provide implementations of some libc functions use by std that may otherwise be missing. These, or an alternate implementation of the relevant functions, are required to use std: pthread-3ds provides pthread APIs for std::thread. shim-3ds fulfills some other missing libc APIs (e.g. getrandom). Binaries built for this target should be compatible with all variants of the 3DS (and 2DS) hardware and firmware, but testing is limited and some versions may not work correctly. This target generates binaries in the ELF format.","breadcrumbs":"Platform Support  armv6k-nintendo-3ds  Requirements","id":"1223","title":"Requirements"},"1224":{"body":"You can build Rust with support for the target by adding it to the target list in bootstrap.toml and providing paths to the devkitARM toolchain. [build]\\nbuild-stage = 1\\ntarget = [\\"armv6k-nintendo-3ds\\"] [target.armv6k-nintendo-3ds]\\ncc = \\"/opt/devkitpro/devkitARM/bin/arm-none-eabi-gcc\\"\\ncxx = \\"/opt/devkitpro/devkitARM/bin/arm-none-eabi-g++\\"\\nar = \\"/opt/devkitpro/devkitARM/bin/arm-none-eabi-ar\\"\\nranlib = \\"/opt/devkitpro/devkitARM/bin/arm-none-eabi-ranlib\\"\\nlinker = \\"/opt/devkitpro/devkitARM/bin/arm-none-eabi-gcc\\" Also, to build compiler_builtins for the target, export these flags before building the Rust toolchain: export CFLAGS_armv6k_nintendo_3ds=\\"-mfloat-abi=hard -mtune=mpcore -mtp=soft -march=armv6k\\"","breadcrumbs":"Platform Support  armv6k-nintendo-3ds  Building the target","id":"1224","title":"Building the target"},"1225":{"body":"Rust does not yet ship pre-compiled artifacts for this target. The recommended way to build binaries is by using the cargo-3ds tool, which uses build-std and provides commands that work like the usual cargo run, cargo build, etc. The cargo 3ds new will automatically set up a new project with the dependencies needed to build a simple binary. You can also build Rust with the target enabled (see Building the target above). As mentioned in Requirements , programs that use std must link against both the devkitARM toolchain and libraries providing the libc APIs used in std. There is a general-purpose utility crate for working with nonstandard APIs provided by the OS: ctru-rs . Add it to Cargo.toml to use it in your program: [dependencies]\\nctru-rs = { git = \\"https://github.com/rust3ds/ctru-rs.git\\" } Depending on ctru-rs ensures that all the necessary symbols are available at link time.","breadcrumbs":"Platform Support  armv6k-nintendo-3ds  Building Rust programs","id":"1225","title":"Building Rust programs"},"1226":{"body":"Binaries built for this target can be run in an emulator (most commonly Citra ), or sent to a device through the use of a tool like devkitARM\'s 3dslink. They may also simply be copied to an SD card to be inserted in the device. The cargo-3ds tool mentioned in Building Rust programs supports the use of 3dslink with cargo 3ds run. The default Rust test runner is not supported, but custom test frameworks can be used with cargo 3ds test to run unit tests on a device. The Rust test suite for library/std is not yet supported.","breadcrumbs":"Platform Support  armv6k-nintendo-3ds  Testing","id":"1226","title":"Testing"},"1227":{"body":"C code can be built for this target using the devkitARM toolchain . This toolchain provides arm-none-eabi-gcc as the linker used to link Rust programs as well. The toolchain also provides a libc implementation, which is required by std for many of its APIs, and a helper library libctru which is used by several of the helper crates listed in Requirements . This toolchain does not, however, include all of the APIs expected by std, and the remaining APIs are implemented by pthread-3ds and linker-fix-3ds.","breadcrumbs":"Platform Support  armv6k-nintendo-3ds  Cross-compilation toolchains and C code","id":"1227","title":"Cross-compilation toolchains and C code"},"1228":{"body":"Tier: 3 ARM targets for the RTEMS realtime operating system using the RTEMS gcc cross-compiler for linking against the libraries of a specified Board Support Package (BSP).","breadcrumbs":"Platform Support  armv7-rtems-eabihf  armv7-rtems-eabihf","id":"1228","title":"armv7-rtems-eabihf"},"1229":{"body":"@thesummer","breadcrumbs":"Platform Support  armv7-rtems-eabihf  Target maintainers","id":"1229","title":"Target maintainers"},"123":{"body":"A \'deny\' lint produces an error if you violate it. For example, this code runs into the exceeding_bitshifts lint. fn main() { 100u8 << 10;\\n} $ rustc main.rs\\nerror: bitshift exceeds the type\'s number of bits --> main.rs:2:13 |\\n2 | 100u8 << 10; | ^^^^^^^^^^^ | = note: `#[deny(exceeding_bitshifts)]` on by default What\'s the difference between an error from a lint and a regular old error? Lints are configurable via levels, so in a similar way to \'allow\' lints, warnings that are \'deny\' by default let you allow them. Similarly, you may wish to set up a lint that is warn by default to produce an error instead. This lint level gives you that.","breadcrumbs":"Lints  Lint Levels  deny","id":"123","title":"deny"},"1230":{"body":"The target does not support host tools. Only cross-compilation is possible. The cross-compiler toolchain can be obtained by following the installation instructions of the RTEMS Documentation . Additionally to the cross-compiler also a compiled BSP for a board fitting the architecture needs to be available on the host. Currently tested has been the BSP xilinx_zynq_a9_qemu of RTEMS 6. std support is available, but not yet fully tested. Do NOT use in flight software! The target follows the EABI calling convention for extern \\"C\\". The resulting binaries are in ELF format.","breadcrumbs":"Platform Support  armv7-rtems-eabihf  Requirements","id":"1230","title":"Requirements"},"1231":{"body":"The target can be built by the standard compiler of Rust.","breadcrumbs":"Platform Support  armv7-rtems-eabihf  Building the target","id":"1231","title":"Building the target"},"1232":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar. In order to build an RTEMS executable it is also necessary to have a basic RTEMS configuration (in C) compiled to link against as this configures the operating system. An example can be found at this rtems-sys crate which could be added as an dependency to your application.","breadcrumbs":"Platform Support  armv7-rtems-eabihf  Building Rust programs","id":"1232","title":"Building Rust programs"},"1233":{"body":"The resulting binaries run fine on an emulated target (possibly also on a real Zedboard or similar). For example, on qemu the following command can execute the binary: qemu-system-arm -no-reboot -serial null -serial mon:stdio -net none -nographic -M xilinx-zynq-a9 -m 512M -kernel <binary file> While basic execution of the unit test harness seems to work. However, running the Rust testsuite on the (emulated) hardware has not yet been tested.","breadcrumbs":"Platform Support  armv7-rtems-eabihf  Testing","id":"1233","title":"Testing"},"1234":{"body":"Compatible C-code can be built with the RTEMS cross-compiler toolchain arm-rtems6-gcc. For more information how to build the toolchain, RTEMS itself and RTEMS applications please have a look at the RTEMS Documentation .","breadcrumbs":"Platform Support  armv7-rtems-eabihf  Cross-compilation toolchains and C code","id":"1234","title":"Cross-compilation toolchains and C code"},"1235":{"body":"Tier: 3 This tier supports the ARM Cortex A9 processor running on a PlayStation Vita console. Rust support for this target is not affiliated with Sony, and is not derived from nor used with any official Sony SDK.","breadcrumbs":"Platform Support  armv7-sony-vita-newlibeabihf  armv7-sony-vita-newlibeabihf","id":"1235","title":"armv7-sony-vita-newlibeabihf"},"1236":{"body":"@nikarh @pheki @zetanumbers","breadcrumbs":"Platform Support  armv7-sony-vita-newlibeabihf  Target maintainers","id":"1236","title":"Target maintainers"},"1237":{"body":"This target is cross-compiled, and requires installing VITASDK toolchain on your system. Dynamic linking is not supported. #![no_std] crates can be built using build-std to build core, and optionally alloc, and panic_abort. std is partially supported, but mostly works. Some APIs are unimplemented and will simply return an error, such as std::process. This target generates binaries in the ELF format with thumb ISA by default. Binaries are linked with arm-vita-eabi-gcc provided by VITASDK toolchain.","breadcrumbs":"Platform Support  armv7-sony-vita-newlibeabihf  Requirements","id":"1237","title":"Requirements"},"1238":{"body":"Rust does not ship pre-compiled artifacts for this target. You can use build-std flag to build ELF binaries with std: cargo build -Z build-std=std,panic_abort --target=armv7-sony-vita-newlibeabihf --release","breadcrumbs":"Platform Support  armv7-sony-vita-newlibeabihf  Building the target","id":"1238","title":"Building the target"},"1239":{"body":"The recommended way to build artifacts that can be installed and run on PlayStation Vita is by using the cargo-vita tool. This tool uses build-std and VITASDK toolchain to build artifacts runnable on Vita. To install the tool run: cargo install cargo-vita VITASDK toolchain must be installed, and the VITASDK environment variable must be set to its location, e.g.: export VITASDK=/opt/vitasdk Add the following section to your project\'s Cargo.toml: [package.metadata.vita]\\n# A unique 9 character alphanumeric identifier of the app.\\ntitle_id = \\"RUSTAPP01\\"\\n# A title that will be used for the app. Optional, name will be used if not defined\\ntitle_name = \\"My application\\" To build a VPK with ELF in the release profile, run: cargo vita build vpk --release After building a *.vpk file it can be uploaded to a PlayStation Vita and installed, or used with a Vita3K emulator.","breadcrumbs":"Platform Support  armv7-sony-vita-newlibeabihf  Building Rust programs","id":"1239","title":"Building Rust programs"},"124":{"body":"\'forbid\' is a special lint level that fills the same role for \'deny\' that \'force-warn\' does for \'warn\'. It\'s the same as \'deny\' in that a lint at this level will produce an error, but unlike the \'deny\' level, the \'forbid\' level can not be overridden to be anything lower than an error. However, lint levels may still be capped with --cap-lints (see below) so rustc --cap-lints warn will make lints set to \'forbid\' just warn.","breadcrumbs":"Lints  Lint Levels  forbid","id":"124","title":"forbid"},"1240":{"body":"The default Rust test runner is supported, and tests can be compiled to an elf and packed to a *.vpk file using cargo-vita tool. Filtering tests is not currently supported since passing command-line arguments to the executable is not supported on Vita, so the runner will always execute all tests. The Rust test suite for library/std is not yet supported.","breadcrumbs":"Platform Support  armv7-sony-vita-newlibeabihf  Testing","id":"1240","title":"Testing"},"1241":{"body":"This target can be cross-compiled from x86_64 on Windows, MacOS or Linux systems. Other hosts are not supported for cross-compilation.","breadcrumbs":"Platform Support  armv7-sony-vita-newlibeabihf  Cross-compilation","id":"1241","title":"Cross-compilation"},"1242":{"body":"Tier: 3 Allows compiling user programs for the VEX V5 Brain , a microcontroller for educational and competitive robotics. Rust support for this target is not affiliated with VEX Robotics or IFI, and does not link to any official VEX SDK.","breadcrumbs":"Platform Support  armv7a-vex-v5  armv7a-vex-v5","id":"1242","title":"armv7a-vex-v5"},"1243":{"body":"This target is maintained by members of the vexide organization: @lewisfm @Tropix126 @Gavin-Niederman @max-niederman","breadcrumbs":"Platform Support  armv7a-vex-v5  Target maintainers","id":"1243","title":"Target maintainers"},"1244":{"body":"This target is cross-compiled. Dynamic linking is unsupported. #![no_std] crates can be built using build-std to build core and panic_abort and optionally alloc. Unwinding panics are not yet supported on this target. std has only partial support due platform limitations. Notably: std::process and std::net are unimplemented. std::thread only supports sleeping and yielding, as this is a single-threaded environment. std::time has full support for Instant, but no support for SystemTime. std::io has full support for stdin/stdout/stderr. stdout and stderr both write to to USB channel 1 on this platform and are not differentiated. std::fs has limited support for reading or writing to files. Directory operations, file deletion, and some file opening features are unsupported and will return errors. A global allocator implemented on top of dlmalloc is provided. Modules that do not need to interact with the OS beyond allocation such as std::collections, std::hash, std::future, std::sync, etc are fully supported. Random number generation and hashing is insecure, as there is no reliable source of entropy on this platform. In order to support some APIs, users are expected to provide a supporting runtime SDK for libstd to link against. This library may be provided either by vex-sdk-build (which will download an official SDK from VEX) or through an open-source implementation such as vex-sdk-jumptable . When compiling for this target, the \\"C\\" calling convention maps to AAPCS with VFP registers (hard float ABI) and the \\"system\\" calling convention maps to AAPCS without VFP registers (softfp ABI). This target generates binaries in the ELF format that may be uploaded to the brain with external tools.","breadcrumbs":"Platform Support  armv7a-vex-v5  Requirements","id":"1244","title":"Requirements"},"1245":{"body":"You can build Rust with support for this target by adding it to the target list in bootstrap.toml, and then running ./x build --target armv7a-vex-v5 compiler.","breadcrumbs":"Platform Support  armv7a-vex-v5  Building the target","id":"1245","title":"Building the target"},"1246":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar. When the compiler builds a binary, an ELF build artifact will be produced. Additional tools are required for this artifact to be recognizable to VEXos as a user program. The cargo-v5 tool is capable of creating binaries that can be uploaded to the V5 brain. This tool wraps the cargo build command by supplying arguments necessary to build the target and produce an artifact recognizable to VEXos, while also providing functionality for uploading over USB to a V5 Controller or Brain. To install the tool, run: cargo install cargo-v5 The following fields in your project\'s Cargo.toml are read by cargo-v5 to configure upload behavior: [package.metadata.v5]\\n# Slot number to upload the user program to. This should be from 1-8.\\nslot = 1\\n# Program icon/thumbnail that will be displayed on the dashboard.\\nicon = \\"cool-x\\"\\n# Use gzip compression when uploading binaries.\\ncompress = true To build an uploadable BIN file using the release profile, run: cargo v5 build --release Programs can also be directly uploaded to the brain over a USB connection immediately after building: cargo v5 upload --release","breadcrumbs":"Platform Support  armv7a-vex-v5  Building Rust programs","id":"1246","title":"Building Rust programs"},"1247":{"body":"Binaries built for this target can be run in an emulator (such as vex-v5-qemu ), or uploaded to a physical device over a serial (USB) connection. The default Rust test runner is not supported. The Rust test suite for library/std is not yet supported.","breadcrumbs":"Platform Support  armv7a-vex-v5  Testing","id":"1247","title":"Testing"},"1248":{"body":"This target can be cross-compiled from any host. Linking to C libraries is not supported.","breadcrumbs":"Platform Support  armv7a-vex-v5  Cross-compilation toolchains and C code","id":"1248","title":"Cross-compilation toolchains and C code"},"1249":{"body":"Tier: 2 Android is a mobile operating system built on top of the Linux kernel.","breadcrumbs":"Platform Support  *-android and *-androideabi  *-linux-android and *-linux-androideabi","id":"1249","title":"*-linux-android and *-linux-androideabi"},"125":{"body":"Remember our missing_docs example from the \'allow\' lint level? $ cat lib.rs\\npub fn foo() {}\\n$ rustc lib.rs --crate-type=lib\\n$ We can configure this lint to operate at a higher level, both with compiler flags, as well as with an attribute in the source code. You can also \\"cap\\" lints so that the compiler can choose to ignore certain lint levels. We\'ll talk about that last.","breadcrumbs":"Lints  Lint Levels  Configuring warning levels","id":"125","title":"Configuring warning levels"},"1250":{"body":"@chriswailes @maurer @mgeisler","breadcrumbs":"Platform Support  *-android and *-androideabi  Target maintainers","id":"1250","title":"Target maintainers"},"1251":{"body":"This target is cross-compiled from a host environment. Development may be done from the source tree or using the Android NDK. Android targets support std. Generated binaries use the ELF file format.","breadcrumbs":"Platform Support  *-android and *-androideabi  Requirements","id":"1251","title":"Requirements"},"1252":{"body":"Rust will support the most recent Long Term Support (LTS) Android Native Development Kit (NDK). By default Rust will support all API levels supported by the NDK, but a higher minimum API level may be required if deemed necessary.","breadcrumbs":"Platform Support  *-android and *-androideabi  NDK/API Update Policy","id":"1252","title":"NDK/API Update Policy"},"1253":{"body":"To build Rust binaries for Android you\'ll need a copy of the most recent LTS edition of the Android NDK . Supported Android targets are: aarch64-linux-android arm-linux-androideabi armv7-linux-androideabi i686-linux-android thumbv7neon-linux-androideabi x86_64-linux-android The riscv64-linux-android target is supported as a Tier 3 target. A list of all supported targets can be found here","breadcrumbs":"Platform Support  *-android and *-androideabi  Building the target","id":"1253","title":"Building the target"},"1254":{"body":"","breadcrumbs":"Platform Support  *-android and *-androideabi  Architecture Notes","id":"1254","title":"Architecture Notes"},"1255":{"body":"Currently the riscv64-linux-android target requires the following architecture features/extensions: a (atomics) d (double-precision floating-point) c (compressed instruction set) f (single-precision floating-point) m (multiplication and division) v (vector) Zba (address calculation instructions) Zbb (base instructions) Zbs (single-bit instructions)","breadcrumbs":"Platform Support  *-android and *-androideabi  riscv64-linux-android","id":"1255","title":"riscv64-linux-android"},"1256":{"body":"As soon as -Zfixed-x18 compiler flag is supplied, the ShadowCallStack sanitizer instrumentation is also made available by supplying the second compiler flag -Zsanitizer=shadow-call-stack.","breadcrumbs":"Platform Support  *-android and *-androideabi  aarch64-linux-android on Nightly compilers","id":"1256","title":"aarch64-linux-android on Nightly compilers"},"1257":{"body":"Tier: 2 (with Host Tools) aarch64-unknown-linux-ohos armv7-unknown-linux-ohos x86_64-unknown-linux-ohos Tier: 3 loongarch64-unknown-linux-ohos Targets for the OpenHarmony operating system.","breadcrumbs":"Platform Support  *-linux-ohos  *-unknown-linux-ohos","id":"1257","title":"*-unknown-linux-ohos"},"1258":{"body":"@Amanieu @cceerczw","breadcrumbs":"Platform Support  *-linux-ohos  Target maintainers","id":"1258","title":"Target maintainers"},"1259":{"body":"All the ohos targets of Tier 2 with host tools support all extended rust tools. (exclude miri, the support of miri will be added soon)","breadcrumbs":"Platform Support  *-linux-ohos  Requirements","id":"1259","title":"Requirements"},"126":{"body":"The -A, -W, --force-warn -D, and -F flags let you turn one or more lints into allowed, warning, force-warn, deny, or forbid levels, like this: $ rustc lib.rs --crate-type=lib -W missing-docs\\nwarning: missing documentation for crate --> lib.rs:1:1 |\\n1 | pub fn foo() {} | ^^^^^^^^^^^^ | = note: requested on the command line with `-W missing-docs` warning: missing documentation for a function --> lib.rs:1:1 |\\n1 | pub fn foo() {} | ^^^^^^^^^^^^ $ rustc lib.rs --crate-type=lib -D missing-docs\\nerror: missing documentation for crate --> lib.rs:1:1 |\\n1 | pub fn foo() {} | ^^^^^^^^^^^^ | = note: requested on the command line with `-D missing-docs` error: missing documentation for a function --> lib.rs:1:1 |\\n1 | pub fn foo() {} | ^^^^^^^^^^^^ error: aborting due to 2 previous errors You can also pass each flag more than once for changing multiple lints: $ rustc lib.rs --crate-type=lib -D missing-docs -D unused-variables And of course, you can mix these five flags together: $ rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables The order of these command line arguments is taken into account. The following allows the unused-variables lint, because it is the last argument for that lint: $ rustc lib.rs --crate-type=lib -D unused-variables -A unused-variables You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the unused group, but explicitly allows the unused-variables lint in that group (forbid still trumps everything regardless of ordering): $ rustc lib.rs --crate-type=lib -D unused -A unused-variables Since force-warn and forbid cannot be overridden, setting one of them will prevent any later level for the same lint from taking effect.","breadcrumbs":"Lints  Lint Levels  Via compiler flag","id":"126","title":"Via compiler flag"},"1260":{"body":"The targets require a reasonably up-to-date OpenHarmony SDK on the host. The targets support cargo, which require ohos-openssl . miri isn\'t supported yet, since its dependencies (libffi and tikv-jemalloc-sys) don\'t support compiling for the OHOS targets.","breadcrumbs":"Platform Support  *-linux-ohos  Host toolchain","id":"1260","title":"Host toolchain"},"1261":{"body":"The OpenHarmony SDK doesn\'t currently support Rust compilation directly, so some setup is required. First, you must obtain the OpenHarmony SDK from this page . Select the version of OpenHarmony you are developing for and download the \\"Public SDK package for the standard system\\". Create the following shell scripts that wrap Clang from the OpenHarmony SDK: aarch64-unknown-linux-ohos-clang.sh #!/bin/sh\\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang \\\\ -target aarch64-linux-ohos \\\\ --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\\ -D__MUSL__ \\\\ \\"$@\\" aarch64-unknown-linux-ohos-clang++.sh #!/bin/sh\\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \\\\ -target aarch64-linux-ohos \\\\ --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\\ -D__MUSL__ \\\\ \\"$@\\" armv7-unknown-linux-ohos-clang.sh #!/bin/sh\\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang \\\\ -target arm-linux-ohos \\\\ --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\\ -D__MUSL__ \\\\ -march=armv7-a \\\\ -mfloat-abi=softfp \\\\ -mtune=generic-armv7-a \\\\ -mthumb \\\\ \\"$@\\" armv7-unknown-linux-ohos-clang++.sh #!/bin/sh\\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \\\\ -target arm-linux-ohos \\\\ --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\\ -D__MUSL__ \\\\ -march=armv7-a \\\\ -mfloat-abi=softfp \\\\ -mtune=generic-armv7-a \\\\ -mthumb \\\\ \\"$@\\" x86_64-unknown-linux-ohos-clang.sh #!/bin/sh\\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang \\\\ -target x86_64-linux-ohos \\\\ --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\\ -D__MUSL__ \\\\ \\"$@\\" x86_64-unknown-linux-ohos-clang++.sh #!/bin/sh\\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \\\\ -target x86_64-linux-ohos \\\\ --sysroot=/path/to/ohos-sdk/linux/native/sysroot \\\\ -D__MUSL__ \\\\ \\"$@\\" Future versions of the OpenHarmony SDK will avoid the need for this process.","breadcrumbs":"Platform Support  *-linux-ohos  Setup","id":"1261","title":"Setup"},"1262":{"body":"Rustup ships pre-compiled artifacts for this target, which you can install with: rustup target add aarch64-unknown-linux-ohos\\nrustup target add armv7-unknown-linux-ohos\\nrustup target add x86_64-unknown-linux-ohos You will need to configure the linker to use in ~/.cargo/config.toml: [target.aarch64-unknown-linux-ohos]\\nar = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\\"\\nlinker = \\"/path/to/aarch64-unknown-linux-ohos-clang.sh\\" [target.armv7-unknown-linux-ohos]\\nar = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\\"\\nlinker = \\"/path/to/armv7-unknown-linux-ohos-clang.sh\\" [target.x86_64-unknown-linux-ohos]\\nar = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\\"\\nlinker = \\"/path/to/x86_64-unknown-linux-ohos-clang.sh\\"","breadcrumbs":"Platform Support  *-linux-ohos  Building Rust programs","id":"1262","title":"Building Rust programs"},"1263":{"body":"Instead of using rustup, you can instead build a rust toolchain from source. Create a bootstrap.toml with the following contents: profile = \\"compiler\\"\\nchange-id = 115898 [build]\\nsanitizers = true\\nprofiler = true [target.aarch64-unknown-linux-ohos]\\ncc = \\"/path/to/aarch64-unknown-linux-ohos-clang.sh\\"\\ncxx = \\"/path/to/aarch64-unknown-linux-ohos-clang++.sh\\"\\nar = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\\"\\nranlib = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib\\"\\nlinker = \\"/path/to/aarch64-unknown-linux-ohos-clang.sh\\" [target.armv7-unknown-linux-ohos]\\ncc = \\"/path/to/armv7-unknown-linux-ohos-clang.sh\\"\\ncxx = \\"/path/to/armv7-unknown-linux-ohos-clang++.sh\\"\\nar = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\\"\\nranlib = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib\\"\\nlinker = \\"/path/to/armv7-unknown-linux-ohos-clang.sh\\" [target.x86_64-unknown-linux-ohos]\\ncc = \\"/path/to/x86_64-unknown-linux-ohos-clang.sh\\"\\ncxx = \\"/path/to/x86_64-unknown-linux-ohos-clang++.sh\\"\\nar = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\\"\\nranlib = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib\\"\\nlinker = \\"/path/to/x86_64-unknown-linux-ohos-clang.sh\\"","breadcrumbs":"Platform Support  *-linux-ohos  Building the target from source","id":"1263","title":"Building the target from source"},"1264":{"body":"Running the Rust testsuite is possible, but currently difficult due to the way the OpenHarmony emulator is set up (no networking).","breadcrumbs":"Platform Support  *-linux-ohos  Testing","id":"1264","title":"Testing"},"1265":{"body":"You can use the shell scripts above to compile C code for the target.","breadcrumbs":"Platform Support  *-linux-ohos  Cross-compilation toolchains and C code","id":"1265","title":"Cross-compilation toolchains and C code"},"1266":{"body":"Tier: 3 [GNU/Hurd] is the GNU Hurd is the GNU project\'s replacement for the Unix kernel.","breadcrumbs":"Platform Support  *-hurd-gnu  i686-unknown-hurd-gnu and x86_64-unknown-hurd-gnu","id":"1266","title":"i686-unknown-hurd-gnu and x86_64-unknown-hurd-gnu"},"1267":{"body":"@sthibaul","breadcrumbs":"Platform Support  *-hurd-gnu  Target maintainers","id":"1267","title":"Target maintainers"},"1268":{"body":"The target supports host tools. The GNU/Hurd target supports std and uses the standard ELF file format.","breadcrumbs":"Platform Support  *-hurd-gnu  Requirements","id":"1268","title":"Requirements"},"1269":{"body":"This target can be built by adding i686-unknown-hurd-gnu and x86_64-unknown-hurd-gnu as targets in the rustc list.","breadcrumbs":"Platform Support  *-hurd-gnu  Building the target","id":"1269","title":"Building the target"},"127":{"body":"You can also modify the lint level with a crate-wide attribute: $ cat lib.rs\\n#![warn(missing_docs)] pub fn foo() {}\\n$ rustc lib.rs --crate-type=lib\\nwarning: missing documentation for crate --> lib.rs:1:1 |\\n1 | / #![warn(missing_docs)]\\n2 | |\\n3 | | pub fn foo() {} | |_______________^ |\\nnote: lint level defined here --> lib.rs:1:9 |\\n1 | #![warn(missing_docs)] | ^^^^^^^^^^^^ warning: missing documentation for a function --> lib.rs:3:1 |\\n3 | pub fn foo() {} | ^^^^^^^^^^^^ warn, allow, deny, and forbid all work this way. There is no way to set a lint to force-warn using an attribute. You can also pass in multiple lints per attribute: #![warn(missing_docs, unused_variables)] pub fn foo() {} And use multiple attributes together: #![warn(missing_docs)]\\n#![deny(unused_variables)] pub fn foo() {} All lint attributes support an additional reason parameter, to give context why a certain attribute was added. This reason will be displayed as part of the lint message, if the lint is emitted at the defined level. use std::path::PathBuf;\\npub fn get_path() -> PathBuf { #[allow(unused_mut, reason = \\"this is only modified on some platforms\\")] let mut file_name = PathBuf::from(\\"git\\"); #[cfg(target_os = \\"windows\\")] file_name.set_extension(\\"exe\\"); file_name\\n}","breadcrumbs":"Lints  Lint Levels  Via an attribute","id":"127","title":"Via an attribute"},"1270":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar.","breadcrumbs":"Platform Support  *-hurd-gnu  Building Rust programs","id":"1270","title":"Building Rust programs"},"1271":{"body":"Tests can be run in the same way as a regular binary.","breadcrumbs":"Platform Support  *-hurd-gnu  Testing","id":"1271","title":"Testing"},"1272":{"body":"The target supports C code, the GNU toolchain calls the target i686-unknown-gnu and x86_64-unknown-gnu.","breadcrumbs":"Platform Support  *-hurd-gnu  Cross-compilation toolchains and C code","id":"1272","title":"Cross-compilation toolchains and C code"},"1273":{"body":"Tier: 3 Target for the TEEOS operating system. TEEOS is a mini os run in TrustZone, for trusted/security apps. The kernel of TEEOS is HongMeng/ChCore micro kernel. The libc for TEEOS is a part of musl. It\'s very small that there is no RwLock, no network, no stdin, and no file system for apps in TEEOS. Some abbreviation: Abbreviation The full text Description TEE Trusted Execution Environment ARM TrustZone divides the system into two worlds/modes -- the secure world/mode and the normal world/mode. TEE is in the secure world/mode. REE Rich Execution Environment The normal world. for example, Linux for Android phone is in REE side. TA Trusted Application The app run in TEE side system. CA Client Application The progress run in REE side system. TEEOS is open source in progress. MORE about","breadcrumbs":"Platform Support  aarch64-unknown-teeos  aarch64-unknown-teeos","id":"1273","title":"aarch64-unknown-teeos"},"1274":{"body":"@petrochenkov @Sword-Destiny","breadcrumbs":"Platform Support  aarch64-unknown-teeos  Target maintainers","id":"1274","title":"Target maintainers"},"1275":{"body":"We use OpenHarmony SDK for TEEOS. The OpenHarmony SDK doesn\'t currently support Rust compilation directly, so some setup is required. First, you must obtain the OpenHarmony SDK from this page . Select the version of OpenHarmony you are developing for and download the \\"Public SDK package for the standard system\\". Create the following shell scripts that wrap Clang from the OpenHarmony SDK: aarch64-unknown-teeos-clang.sh #!/bin/sh\\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang \\\\ -target aarch64-linux-gnu \\\\ \\"$@\\" aarch64-unknown-teeos-clang++.sh #!/bin/sh\\nexec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \\\\ -target aarch64-linux-gnu \\\\ \\"$@\\"","breadcrumbs":"Platform Support  aarch64-unknown-teeos  Setup","id":"1275","title":"Setup"},"1276":{"body":"To build a rust toolchain, create a bootstrap.toml with the following contents: profile = \\"compiler\\"\\nchange-id = 115898 [build]\\nsanitizers = true\\nprofiler = true\\ntarget = [\\"x86_64-unknown-linux-gnu\\", \\"aarch64-unknown-teeos\\"]\\nsubmodules = false\\ncompiler-docs = false\\nextended = true [install]\\nbindir = \\"bin\\"\\nlibdir = \\"lib\\" [target.aarch64-unknown-teeos]\\ncc = \\"/path/to/scripts/aarch64-unknown-teeos-clang.sh\\"\\ncxx = \\"/path/to/scripts/aarch64-unknown-teeos-clang.sh\\"\\nlinker = \\"/path/to/scripts/aarch64-unknown-teeos-clang.sh\\"\\nar = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar\\"\\nranlib = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib\\"\\nllvm-config = \\"/path/to/ohos-sdk/linux/native/llvm/bin/llvm-config\\" note: You need to insert \\"/usr/include/x86_64-linux-gnu/\\" into environment variable: $C_INCLUDE_PATH if some header files like bits/xxx.h not found.\\nnote: You can install gcc-aarch64-linux-gnu,g++-aarch64-linux-gnu if some files like crti.o not found.\\nnote: You may need to install libc6-dev-i386 libc6-dev if \\"gnu/stubs-32.h\\" not found.","breadcrumbs":"Platform Support  aarch64-unknown-teeos  Building the target","id":"1276","title":"Building the target"},"1277":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar. You will need to configure the linker to use in ~/.cargo/config: [target.aarch64-unknown-teeos]\\nlinker = \\"/path/to/aarch64-unknown-teeos-clang.sh\\" # or aarch64-linux-gnu-ld","breadcrumbs":"Platform Support  aarch64-unknown-teeos  Building Rust programs","id":"1277","title":"Building Rust programs"},"1278":{"body":"Running the Rust testsuite is not possible now. More information about how to test CA/TA. See here","breadcrumbs":"Platform Support  aarch64-unknown-teeos  Testing","id":"1278","title":"Testing"},"1279":{"body":"Series of microcontrollers from Atmel: ATmega8, ATmega328p etc. Tier: 3","breadcrumbs":"Platform Support  avr-none  avr-none","id":"1279","title":"avr-none"},"128":{"body":"rustc supports a flag, --cap-lints LEVEL that sets the \\"lint cap level.\\" This is the maximum level for all lints. So for example, if we take our code sample from the \\"deny\\" lint level above: fn main() { 100u8 << 10;\\n} And we compile it, capping lints to warn: $ rustc lib.rs --cap-lints warn\\nwarning: bitshift exceeds the type\'s number of bits --> lib.rs:2:5 |\\n2 | 100u8 << 10; | ^^^^^^^^^^^ | = note: `#[warn(exceeding_bitshifts)]` on by default warning: this expression will panic at run-time --> lib.rs:2:5 |\\n2 | 100u8 << 10; | ^^^^^^^^^^^ attempt to shift left with overflow It now only warns, rather than errors. We can go further and allow all lints: $ rustc lib.rs --cap-lints allow\\n$ This feature is used heavily by Cargo; it will pass --cap-lints allow when compiling your dependencies, so that if they have any warnings, they do not pollute the output of your build. However, note that --cap-lints allow does not override lints marked as force-warn.","breadcrumbs":"Lints  Lint Levels  Capping lints","id":"128","title":"Capping lints"},"1280":{"body":"@Patryk27","breadcrumbs":"Platform Support  avr-none  Target maintainers","id":"1280","title":"Target maintainers"},"1281":{"body":"This target is only cross-compiled; x86-64 Linux, x86-64 macOS and aarch64 macOS hosts are confirmed to work, but in principle any machine able to run rustc and avr-gcc should be good. Compiling for this target requires avr-gcc installed, because a couple of intrinsics (like 32-bit multiplication) rely on libgcc and can\'t be provided through compiler-builtins yet. This is a limitation that we hope to lift in the future . You\'ll also need to setup the .cargo/config file - see below for details.","breadcrumbs":"Platform Support  avr-none  Requirements","id":"1281","title":"Requirements"},"1282":{"body":"Rust comes with AVR support enabled, you don\'t have to rebuild the compiler.","breadcrumbs":"Platform Support  avr-none  Building the target","id":"1282","title":"Building the target"},"1283":{"body":"Install avr-gcc: # Ubuntu:\\n$ sudo apt-get install gcc-avr # Mac:\\n$ brew tap osx-cross/avr && brew install avr-gcc # NixOS (takes a couple of minutes, since it\'s not provided through Hydra):\\n$ nix shell nixpkgs#pkgsCross.avr.buildPackages.gcc11 ... setup .cargo/config for your project: [build]\\ntarget = \\"avr-none\\"\\nrustflags = [\\"-C\\", \\"target-cpu=atmega328p\\"] [unstable]\\nbuild-std = [\\"core\\"] ... and then simply run: $ cargo build --release The final binary will be placed into ./target/avr-none/release/your-project.elf. Note that since AVRs have rather small amounts of registers, ROM and RAM, it\'s recommended to always use --release to avoid running out of space. Also, please note that specifying -C target-cpu is required - here\'s a list of the possible variants: https://github.com/llvm/llvm-project/blob/093d4db2f3c874d4683fb01194b00dbb20e5c713/clang/lib/Basic/Targets/AVR.cpp#L32","breadcrumbs":"Platform Support  avr-none  Building Rust programs","id":"1283","title":"Building Rust programs"},"1284":{"body":"You can use simavr to emulate the resulting firmware on your machine: $ simavr -m atmega328p ./target/avr-none/release/your-project.elf Alternatively, if you want to write a couple of actual #[test]s, you can use avr-tester .","breadcrumbs":"Platform Support  avr-none  Testing","id":"1284","title":"Testing"},"1285":{"body":"Tier: 3 Targets for the ESP-IDF development framework running on RISC-V and Xtensa CPUs.","breadcrumbs":"Platform Support  *-espidf  *-espidf","id":"1285","title":"*-espidf"},"1286":{"body":"@ivmarkov @MabezDev @SergioGasquez","breadcrumbs":"Platform Support  *-espidf  Target maintainers","id":"1286","title":"Target maintainers"},"1287":{"body":"The target names follow this format: $ARCH-esp-espidf, where $ARCH specifies the target processor architecture. The following targets are currently defined: Target name Target CPU(s) Minimum ESP-IDF version riscv32imc-esp-espidf ESP32-C2 v5.0 riscv32imc-esp-espidf ESP32-C3 v4.4 riscv32imac-esp-espidf ESP32-C6 v5.1 riscv32imac-esp-espidf ESP32-H2 v5.1 riscv32imafc-esp-espidf ESP32-P4 v5.2 xtensa-esp32-espidf ESP32 v4.4 xtensa-esp32s2-espidf ESP32-S2 v4.4 xtensa-esp32s3-espidf ESP32-S3 v4.4 It is recommended to use the latest ESP-IDF stable release if possible.","breadcrumbs":"Platform Support  *-espidf  Requirements","id":"1287","title":"Requirements"},"1288":{"body":"The target can be built by enabling it for a rustc build. The build-std feature is required to build the standard library for ESP-IDF. ldproxy is also required for linking, it can be installed from crates.io. [build]\\ntarget = [\\"$ARCH-esp-espidf\\"] [target.$ARCH-esp-espidf]\\nlinker = \\"ldproxy\\" [unstable]\\nbuild-std = [\\"std\\", \\"panic_abort\\"] The esp-idf-sys crate will handle the compilation of ESP-IDF, including downloading the relevant toolchains for the build.","breadcrumbs":"Platform Support  *-espidf  Building the target","id":"1288","title":"Building the target"},"1289":{"body":"esp-idf-sys exposes the toolchain used in the compilation of ESP-IDF, see the crate documentation for build output propagation for more information.","breadcrumbs":"Platform Support  *-espidf  Cross-compilation toolchains and C code","id":"1289","title":"Cross-compilation toolchains and C code"},"129":{"body":"Rust allows setting lint levels (allow, warn, deny, forbid, force-warn) through various sources: Attributes : #[allow(...)], #![deny(...)], etc. Command-line options : --cap-lints, --force-warn, -A, -W, -D, -F Heres how these different lint controls interact: --force-warn forces a lint to warning level, and takes precedence over attributes and all other CLI flags. #[forbid(unused_variables)]\\nfn main() { let x = 42;\\n} Compiled with: $ rustc --force-warn unused_variables lib.rs warning: unused variable: `x` --> lib.rs:3:9 | 3 | let x = 42; | ^ help: if this is intentional, prefix it with an underscore: `_x` | = note: requested on the command line with `--force-warn unused-variables` warning: 1 warning emitted --cap-lints sets the maximum level of a lint, and takes precedence over attributes as well as the -D, -W, and -F CLI flags. #[deny(unused_variables)]\\nfn main() { let x = 42;\\n} Compiled with: $ rustc --cap-lints=warn lib.rs warning: unused variable: `x` --> test1.rs:3:9 | 3 | let x = 42; | ^ help: if this is intentional, prefix it with an underscore: `_x` | note: the lint level is defined here --> test1.rs:1:8 | 1 | #[deny(unused_variables)] | ^^^^^^^^^^^^^^^^ warning: 1 warning emitted CLI level flags take precedence over attributes. The order of the flags matter; flags on the right take precedence over earlier flags. fn main() { let x = 42;\\n} Compiled with: $ rustc -A unused_variables -D unused_variables lib.rs error: unused variable: `x` --> test1.rs:2:9 | 2 | let x = 42; | ^ help: if this is intentional, prefix it with an underscore: `_x` | = note: requested on the command line with `-D unused-variables` error: aborting due to 1 previous error Within the source, attributes at a lower-level in the syntax tree take precedence over attributes at a higher level, or from a previous attribute on the same entity as listed in left-to-right source order. #![deny(unused_variables)] #[allow(unused_variables)]\\nfn main() { let x = 42; // Allow wins\\n} The exception is once a lint is set to \\"forbid\\", it is an error to try to change its level except for deny, which is allowed inside a forbid context, but is ignored. In terms of priority, lint groups are treated as-if they are expanded to a list of all of the lints they contain. The exception is the warnings group which ignores attribute and CLI order and applies to all lints that would otherwise warn within the entity.","breadcrumbs":"Lints  Lint Levels  Priority of lint level sources","id":"129","title":"Priority of lint level sources"},"1290":{"body":"Tier: 2 Fuchsia is a modern open source operating system that\'s simple, secure, updatable, and performant.","breadcrumbs":"Platform Support  *-unknown-fuchsia  aarch64-unknown-fuchsia and x86_64-unknown-fuchsia","id":"1290","title":"aarch64-unknown-fuchsia and x86_64-unknown-fuchsia"},"1291":{"body":"@erickt @Nashenas88 The up-to-date list can be also found via the fuchsia marker team .","breadcrumbs":"Platform Support  *-unknown-fuchsia  Target maintainers","id":"1291","title":"Target maintainers"},"1292":{"body":"Requirements Walkthrough structure Compiling a Rust binary targeting Fuchsia Targeting Fuchsia with rustup and cargo Targeting Fuchsia with a compiler built from source Creating a Fuchsia package Creating a Fuchsia component Building a Fuchsia package Publishing a Fuchsia package Creating a Fuchsia package repository Publishing Fuchsia package to repository Running a Fuchsia component on an emulator Starting the Fuchsia emulator Watching emulator logs Serving a Fuchsia package Running a Fuchsia component .gitignore extensions Testing Running unit tests Running the compiler test suite Debugging zxdb Attaching zxdb Using zxdb Displaying source code in zxdb","breadcrumbs":"Platform Support  *-unknown-fuchsia  Table of contents","id":"1292","title":"Table of contents"},"1293":{"body":"This target is cross-compiled from a host environment. You will need a recent copy of the Fuchsia SDK , which provides the tools, libraries, and binaries required to build and link programs for Fuchsia. Development may also be done from the source tree . Fuchsia targets support std and follow the sysv64 calling convention on x86_64. Fuchsia binaries use the ELF file format.","breadcrumbs":"Platform Support  *-unknown-fuchsia  Requirements","id":"1293","title":"Requirements"},"1294":{"body":"This walkthrough will cover: Compiling a Rust binary targeting Fuchsia. Building a Fuchsia package. Publishing and running a Fuchsia package to a Fuchsia emulator. For the purposes of this walkthrough, we will only target x86_64-unknown-fuchsia.","breadcrumbs":"Platform Support  *-unknown-fuchsia  Walkthrough structure","id":"1294","title":"Walkthrough structure"},"1295":{"body":"Today, there are two main ways to build a Rust binary targeting Fuchsia using the Fuchsia SDK: Allow rustup to handle the installation of Fuchsia targets for you. Build a toolchain locally that can target Fuchsia.","breadcrumbs":"Platform Support  *-unknown-fuchsia  Compiling a Rust binary targeting Fuchsia","id":"1295","title":"Compiling a Rust binary targeting Fuchsia"},"1296":{"body":"The easiest way to build a Rust binary targeting Fuchsia is by allowing rustup to handle the installation of Fuchsia targets for you. This can be done by issuing the following commands: rustup target add x86_64-unknown-fuchsia\\nrustup target add aarch64-unknown-fuchsia After installing our Fuchsia targets, we can now compile a Rust binary that targets Fuchsia. To create our Rust project, we can use cargo as follows: From base working directory cargo new hello_fuchsia The rest of this walkthrough will take place from hello_fuchsia, so we can change into that directory now: cd hello_fuchsia Note: From this point onwards, all commands will be issued from the hello_fuchsia/ directory, and all hello_fuchsia/ prefixes will be removed from references for sake of brevity. We can edit our src/main.rs to include a test as follows: src/main.rs fn main() { println!(\\"Hello Fuchsia!\\");\\n} #[test]\\nfn it_works() { assert_eq!(2 + 2, 4);\\n} In addition to the standard workspace created, we will want to create a .cargo/config.toml file to link necessary libraries during compilation: .cargo/config.toml [target.x86_64-unknown-fuchsia] rustflags = [ \\"-Lnative=<SDK_PATH>/arch/x64/lib\\", \\"-Lnative=<SDK_PATH>/arch/x64/sysroot/lib\\"\\n] Note: Make sure to fill out <SDK_PATH> with the path to the downloaded Fuchsia SDK . These options configure the following: -Lnative=${SDK_PATH}/arch/${ARCH}/lib: Link against Fuchsia libraries from the SDK -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib: Link against Fuchsia sysroot libraries from the SDK In total, our new project will look like: Current directory structure hello_fuchsia/\\n src/\\n  main.rs\\n Cargo.toml\\n .cargo/  config.toml Finally, we can build our rust binary as: cargo build --target x86_64-unknown-fuchsia Now we have a Rust binary at target/x86_64-unknown-fuchsia/debug/hello_fuchsia, targeting our desired Fuchsia target. Current directory structure hello_fuchsia/\\n src/\\n  main.rs\\n target/\\n  x86_64-unknown-fuchsia/\\n  debug/\\n  hello_fuchsia\\n Cargo.toml\\n .cargo/  config.toml","breadcrumbs":"Platform Support  *-unknown-fuchsia  Targeting Fuchsia with rustup and cargo","id":"1296","title":"Targeting Fuchsia with rustup and cargo"},"1297":{"body":"An alternative to the first workflow is to target Fuchsia by using rustc built from source. Before building Rust for Fuchsia, you\'ll need a clang toolchain that supports Fuchsia as well. A recent version (14+) of clang should be sufficient to compile Rust for Fuchsia. x86-64 and AArch64 Fuchsia targets can be enabled using the following configuration in bootstrap.toml: [build]\\ntarget = [\\"<host_platform>\\", \\"aarch64-unknown-fuchsia\\", \\"x86_64-unknown-fuchsia\\"] [rust]\\nlld = true [llvm]\\ndownload-ci-llvm = false [target.x86_64-unknown-fuchsia]\\ncc = \\"clang\\"\\ncxx = \\"clang++\\" [target.aarch64-unknown-fuchsia]\\ncc = \\"clang\\"\\ncxx = \\"clang++\\" Though not strictly required, you may also want to use clang for your host target as well: [target.<host_platform>]\\ncc = \\"clang\\"\\ncxx = \\"clang++\\" By default, the Rust compiler installs itself to /usr/local on most UNIX systems. You may want to install it to another location (e.g. a local install directory) by setting a custom prefix in bootstrap.toml: [install]\\n# Make sure to use the absolute path to your install directory\\nprefix = \\"<RUST_SRC_PATH>/install\\" Next, the following environment variables must be configured. For example, using a script we name config-env.sh: # Configure this environment variable to be the path to the downloaded SDK\\nexport SDK_PATH=\\"<SDK path goes here>\\" export CFLAGS_aarch64_unknown_fuchsia=\\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\\"\\nexport CXXFLAGS_aarch64_unknown_fuchsia=\\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\\"\\nexport LDFLAGS_aarch64_unknown_fuchsia=\\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -L${SDK_PATH}/arch/arm64/lib\\"\\nexport CARGO_TARGET_AARCH64_UNKNOWN_FUCHSIA_RUSTFLAGS=\\"-C link-arg=--sysroot=${SDK_PATH}/arch/arm64/sysroot -Lnative=${SDK_PATH}/arch/arm64/sysroot/lib -Lnative=${SDK_PATH}/arch/arm64/lib\\"\\nexport CFLAGS_x86_64_unknown_fuchsia=\\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\\"\\nexport CXXFLAGS_x86_64_unknown_fuchsia=\\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\\"\\nexport LDFLAGS_x86_64_unknown_fuchsia=\\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -L${SDK_PATH}/arch/x64/lib\\"\\nexport CARGO_TARGET_X86_64_UNKNOWN_FUCHSIA_RUSTFLAGS=\\"-C link-arg=--sysroot=${SDK_PATH}/arch/x64/sysroot -Lnative=${SDK_PATH}/arch/x64/sysroot/lib -Lnative=${SDK_PATH}/arch/x64/lib\\" Finally, the Rust compiler can be built and installed: (source config-env.sh && ./x.py install) Once rustc is installed, we can create a new working directory to work from, hello_fuchsia along with hello_fuchsia/src: mkdir hello_fuchsia\\ncd hello_fuchsia\\nmkdir src Note: From this point onwards, all commands will be issued from the hello_fuchsia/ directory, and all hello_fuchsia/ prefixes will be removed from references for sake of brevity. There, we can create a new file named src/hello_fuchsia.rs: src/hello_fuchsia.rs fn main() { println!(\\"Hello Fuchsia!\\");\\n} #[test]\\nfn it_works() { assert_eq!(2 + 2, 4);\\n} Current directory structure hello_fuchsia/\\n src/  hello_fuchsia.rs Using your freshly installed rustc, you can compile a binary for Fuchsia using the following options: --target x86_64-unknown-fuchsia/--target aarch64-unknown-fuchsia: Targets the Fuchsia platform of your choice -Lnative ${SDK_PATH}/arch/${ARCH}/lib: Link against Fuchsia libraries from the SDK -Lnative ${SDK_PATH}/arch/${ARCH}/sysroot/lib: Link against Fuchsia sysroot libraries from the SDK Putting it all together: # Configure these for the Fuchsia target of your choice\\nTARGET_ARCH=\\"<x86_64-unknown-fuchsia|aarch64-unknown-fuchsia>\\"\\nARCH=\\"<x64|aarch64>\\" rustc \\\\ --target ${TARGET_ARCH} \\\\ -Lnative=${SDK_PATH}/arch/${ARCH}/lib \\\\ -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib \\\\ --out-dir bin src/hello_fuchsia.rs Current directory structure hello_fuchsia/\\n src/\\n  hello_fuchsia.rs\\n bin/  hello_fuchsia","breadcrumbs":"Platform Support  *-unknown-fuchsia  Targeting Fuchsia with a compiler built from source","id":"1297","title":"Targeting Fuchsia with a compiler built from source"},"1298":{"body":"Before moving on, double check your directory structure: Current directory structure hello_fuchsia/\\n src/ (if using rustc)\\n  hello_fuchsia.rs ...\\n bin/ ...\\n  hello_fuchsia ...\\n src/ (if using cargo)\\n  main.rs ...\\n target/ ...  x86_64-unknown-fuchsia/ ...  debug/ ...  hello_fuchsia ... With our Rust binary built, we can move to creating a Fuchsia package. On Fuchsia, a package is the unit of distribution for software. We\'ll need to create a new package directory where we will place files like our finished binary and any data it may need. To start, make the pkg, and pkg/meta directories: mkdir pkg\\nmkdir pkg/meta Current directory structure hello_fuchsia/\\n pkg/  meta/ Now, create the following files inside: pkg/meta/package { \\"name\\": \\"hello_fuchsia\\", \\"version\\": \\"0\\"\\n} The package file describes our package\'s name and version number. Every package must contain one. pkg/hello_fuchsia.manifest if using cargo bin/hello_fuchsia=target/x86_64-unknown-fuchsia/debug/hello_fuchsia\\nlib/ld.so.1=<SDK_PATH>/arch/x64/sysroot/dist/lib/ld.so.1\\nlib/libfdio.so=<SDK_PATH>/arch/x64/dist/libfdio.so\\nmeta/package=pkg/meta/package\\nmeta/hello_fuchsia.cm=pkg/meta/hello_fuchsia.cm pkg/hello_fuchsia.manifest if using rustc bin/hello_fuchsia=bin/hello_fuchsia\\nlib/ld.so.1=<SDK_PATH>/arch/x64/sysroot/dist/lib/ld.so.1\\nlib/libfdio.so=<SDK_PATH>/arch/x64/dist/libfdio.so\\nmeta/package=pkg/meta/package\\nmeta/hello_fuchsia.cm=pkg/meta/hello_fuchsia.cm Note: Relative manifest paths are resolved starting from the working directory of ffx. Make sure to fill out <SDK_PATH> with the path to the downloaded SDK. The .manifest file will be used to describe the contents of the package by relating their location when installed to their location on the file system. The bin/hello_fuchsia= entry will be different depending on how your Rust binary was built, so choose accordingly. Current directory structure hello_fuchsia/\\n pkg/  meta/   package  hello_fuchsia.manifest","breadcrumbs":"Platform Support  *-unknown-fuchsia  Creating a Fuchsia package","id":"1298","title":"Creating a Fuchsia package"},"1299":{"body":"On Fuchsia, components require a component manifest written in Fuchsia\'s markup language called CML. The Fuchsia devsite contains an overview of CML and a reference for the file format . Here\'s a basic one that can run our single binary: pkg/hello_fuchsia.cml { include: [ \\"syslog/client.shard.cml\\" ], program: { runner: \\"elf\\", binary: \\"bin/hello_fuchsia\\", },\\n} Current directory structure hello_fuchsia/\\n pkg/  meta/   package  hello_fuchsia.manifest  hello_fuchsia.cml Now we can compile that CML into a component manifest: ${SDK_PATH}/tools/${ARCH}/cmc compile \\\\ pkg/hello_fuchsia.cml \\\\ --includepath ${SDK_PATH}/pkg \\\\ -o pkg/meta/hello_fuchsia.cm Note: --includepath tells the compiler where to look for includes from our CML. In our case, we\'re only using syslog/client.shard.cml. Current directory structure hello_fuchsia/\\n pkg/  meta/   package   hello_fuchsia.cm  hello_fuchsia.manifest  hello_fuchsia.cml","breadcrumbs":"Platform Support  *-unknown-fuchsia  Creating a Fuchsia component","id":"1299","title":"Creating a Fuchsia component"},"13":{"body":"This flag takes a value of 2015, 2018,2021, or 2024. The default is 2015. More information about editions may be found in the edition guide .","breadcrumbs":"Command-line Arguments  --edition: specify the edition to use","id":"13","title":"--edition: specify the edition to use"},"130":{"body":"rustc has the concept of a \\"lint group\\", where you can toggle several warnings through one name. For example, the nonstandard-style lint sets non-camel-case-types, non-snake-case, and non-upper-case-globals all at once. So these are equivalent: $ rustc -D nonstandard-style\\n$ rustc -D non-camel-case-types -D non-snake-case -D non-upper-case-globals Here\'s a list of each lint group, and the lints that they are made up of: Group Description Lints warnings All lints that are set to issue warnings See warn-by-default for the default set of warnings deprecated-safe Lints for functions which were erroneously marked as safe in the past deprecated-safe-2024 future-incompatible Lints that detect code that has future-compatibility problems aarch64-softfloat-neon , ambiguous-associated-items , ambiguous-glob-imports , coherence-leak-check , conflicting-repr-hints , const-evaluatable-unchecked , elided-lifetimes-in-associated-constant , forbidden-lint-groups , ill-formed-attribute-input , invalid-macro-export-arguments , invalid-type-param-default , late-bound-lifetime-arguments , legacy-derive-helpers , macro-expanded-macro-exports-accessed-by-absolute-paths , out-of-scope-macro-calls , patterns-in-fns-without-body , proc-macro-derive-resolution-fallback , pub-use-of-private-extern-crate , repr-transparent-external-private-fields , self-constructor-from-outer-item , semicolon-in-expressions-from-macros , soft-unstable , uncovered-param-in-projection , uninhabited-static , unstable-name-collisions , unstable-syntax-pre-expansion , unsupported-calling-conventions keyword-idents Lints that detect identifiers which will be come keywords in later editions keyword-idents-2018 , keyword-idents-2024 let-underscore Lints that detect wildcard let bindings that are likely to be invalid let-underscore-drop , let-underscore-lock nonstandard-style Violation of standard naming conventions non-camel-case-types , non-snake-case , non-upper-case-globals refining-impl-trait Detects refinement of impl Trait return types by trait implementations refining-impl-trait-internal , refining-impl-trait-reachable rust-2018-compatibility Lints used to transition code from the 2015 edition to 2018 absolute-paths-not-starting-with-crate , anonymous-parameters , keyword-idents-2018 , tyvar-behind-raw-pointer rust-2018-idioms Lints to nudge you toward idiomatic features of Rust 2018 bare-trait-objects , elided-lifetimes-in-paths , ellipsis-inclusive-range-patterns , explicit-outlives-requirements , unused-extern-crates rust-2021-compatibility Lints used to transition code from the 2018 edition to 2021 array-into-iter , bare-trait-objects , ellipsis-inclusive-range-patterns , non-fmt-panics , rust-2021-incompatible-closure-captures , rust-2021-incompatible-or-patterns , rust-2021-prefixes-incompatible-syntax , rust-2021-prelude-collisions rust-2024-compatibility Lints used to transition code from the 2021 edition to 2024 boxed-slice-into-iter , dependency-on-unit-never-type-fallback , deprecated-safe-2024 , edition-2024-expr-fragment-specifier , if-let-rescope , impl-trait-overcaptures , keyword-idents-2024 , missing-unsafe-on-extern , never-type-fallback-flowing-into-unsafe , rust-2024-guarded-string-incompatible-syntax , rust-2024-incompatible-pat , rust-2024-prelude-collisions , static-mut-refs , tail-expr-drop-order , unsafe-attr-outside-unsafe , unsafe-op-in-unsafe-fn unknown-or-malformed-diagnostic-attributes detects unknown or malformed diagnostic attributes malformed-diagnostic-attributes , malformed-diagnostic-format-literals , misplaced-diagnostic-attributes , unknown-diagnostic-attributes unused Lints that detect things being declared but not used, or excess syntax dead-code , map-unit-fn , path-statements , redundant-semicolons , unreachable-code , unreachable-patterns , unused-allocation , unused-assignments , unused-attributes , unused-braces , unused-doc-comments , unused-extern-crates , unused-features , unused-imports , unused-labels , unused-macro-rules , unused-macros , unused-must-use , unused-mut , unused-parens , unused-unsafe , unused-variables Additionally, there\'s a bad-style lint group that\'s a deprecated alias for nonstandard-style. Finally, you can also see the table above by invoking rustc -W help. This will give you the exact values for the specific compiler you have installed.","breadcrumbs":"Lints  Lint Groups  Lint Groups","id":"130","title":"Lint Groups"},"1300":{"body":"Next, we\'ll build a package manifest as defined by our manifest: ${SDK_PATH}/tools/${ARCH}/ffx package build \\\\ --api-level $(${SDK_PATH}/tools/${ARCH}/ffx --machine json version | jq .tool_version.api_level) \\\\ --out pkg/hello_fuchsia_manifest \\\\ pkg/hello_fuchsia.manifest This will produce pkg/hello_fuchsia_manifest/ which is a package manifest we can publish directly to a repository. Current directory structure hello_fuchsia/\\n pkg/  meta/   package   hello_fuchsia.cm  hello_fuchsia_manifest/   ...  hello_fuchsia.manifest  hello_fuchsia.cml  hello_fuchsia_package_manifest We are now ready to publish the package.","breadcrumbs":"Platform Support  *-unknown-fuchsia  Building a Fuchsia package","id":"1300","title":"Building a Fuchsia package"},"1301":{"body":"With our package and component manifests setup, we can now publish our package. The first step will be to create a Fuchsia package repository to publish to.","breadcrumbs":"Platform Support  *-unknown-fuchsia  Publishing a Fuchsia package","id":"1301","title":"Publishing a Fuchsia package"},"1302":{"body":"We can set up our repository with: ${SDK_PATH}/tools/${ARCH}/ffx repository create pkg/repo Current directory structure hello_fuchsia/\\n pkg/  meta/   package   hello_fuchsia.cm  hello_fuchsia_manifest/   ...  repo/   ...  hello_fuchsia.manifest  hello_fuchsia.cml  hello_fuchsia_package_manifest","breadcrumbs":"Platform Support  *-unknown-fuchsia  Creating a Fuchsia package repository","id":"1302","title":"Creating a Fuchsia package repository"},"1303":{"body":"We can publish our new package to that repository with: ${SDK_PATH}/tools/${ARCH}/ffx repository publish \\\\ --package pkg/hello_fuchsia_package_manifest \\\\ pkg/repo","breadcrumbs":"Platform Support  *-unknown-fuchsia  Publishing Fuchsia package to repository","id":"1303","title":"Publishing Fuchsia package to repository"},"1304":{"body":"At this point, we are ready to run our Fuchsia component. For reference, our final directory structure will look like: Final directory structure hello_fuchsia/\\n src/ (if using rustc)\\n  hello_fuchsia.rs ...\\n bin/ ...\\n  hello_fuchsia ...\\n src/ (if using cargo)\\n  main.rs ...\\n target/ ...\\n  x86_64-unknown-fuchsia/ ...\\n  debug/ ...\\n  hello_fuchsia ...\\n pkg/  meta/   package   hello_fuchsia.cm  hello_fuchsia_manifest/   ...  repo/   ...  hello_fuchsia.manifest  hello_fuchsia.cml  hello_fuchsia_package_manifest","breadcrumbs":"Platform Support  *-unknown-fuchsia  Running a Fuchsia component on an emulator","id":"1304","title":"Running a Fuchsia component on an emulator"},"1305":{"body":"Start a Fuchsia emulator in a new terminal using: ${SDK_PATH}/tools/${ARCH}/ffx product-bundle get workstation_eng.qemu-${ARCH}\\n${SDK_PATH}/tools/${ARCH}/ffx emu start workstation_eng.qemu-${ARCH} --headless","breadcrumbs":"Platform Support  *-unknown-fuchsia  Starting the Fuchsia emulator","id":"1305","title":"Starting the Fuchsia emulator"},"1306":{"body":"Once the emulator is running, open a separate terminal to watch the emulator logs: In separate terminal ${SDK_PATH}/tools/${ARCH}/ffx log \\\\ --since now","breadcrumbs":"Platform Support  *-unknown-fuchsia  Watching emulator logs","id":"1306","title":"Watching emulator logs"},"1307":{"body":"Now, start a package repository server to serve our package to the emulator: ${SDK_PATH}/tools/${ARCH}/ffx repository server start \\\\ --background --repository hello-fuchsia --repo-path pkg-repo Once the repository server is up and running, register it with the target Fuchsia system running in the emulator: ${SDK_PATH}/tools/${ARCH}/ffx target repository register \\\\ --repository hello-fuchsia","breadcrumbs":"Platform Support  *-unknown-fuchsia  Serving a Fuchsia package","id":"1307","title":"Serving a Fuchsia package"},"1308":{"body":"Finally, run the component: ${SDK_PATH}/tools/${ARCH}/ffx component run \\\\ /core/ffx-laboratory:hello_fuchsia \\\\ fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm On reruns of the component, the --recreate argument may also need to be passed. ${SDK_PATH}/tools/${ARCH}/ffx component run \\\\ --recreate \\\\ /core/ffx-laboratory:hello_fuchsia \\\\ fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm","breadcrumbs":"Platform Support  *-unknown-fuchsia  Running a Fuchsia component","id":"1308","title":"Running a Fuchsia component"},"1309":{"body":"Optionally, we can create/extend our .gitignore file to ignore files and directories that are not helpful to track: pkg/repo\\npkg/meta/hello_fuchsia.cm\\npkg/hello_fuchsia_manifest\\npkg/hello_fuchsia_package_manifest","breadcrumbs":"Platform Support  *-unknown-fuchsia  .gitignore extensions","id":"1309","title":".gitignore extensions"},"131":{"body":"This section lists out all of the lints, grouped by their default lint levels. You can also see this list by running rustc -W help.","breadcrumbs":"Lints  Lint Listing  Lint Listing","id":"131","title":"Lint Listing"},"1310":{"body":"","breadcrumbs":"Platform Support  *-unknown-fuchsia  Testing","id":"1310","title":"Testing"},"1311":{"body":"Tests can be run in the same way as a regular binary. If using cargo, you can simply pass test --no-run to the cargo invocation and then repackage and rerun the Fuchsia package. From our previous example, this would look like cargo test --target x86_64-unknown-fuchsia --no-run, and moving the executable binary path found from the line Executable unittests src/main.rs (target/x86_64-unknown-fuchsia/debug/deps/hello_fuchsia-<HASH>) into pkg/hello_fuchsia.manifest. If using the compiled rustc, you can simply pass --test to the rustc invocation and then repackage and rerun the Fuchsia package. The test harness will run the applicable unit tests. Often when testing, you may want to pass additional command line arguments to your binary. Additional arguments can be set in the component manifest: pkg/hello_fuchsia.cml { include: [ \\"syslog/client.shard.cml\\" ], program: { runner: \\"elf\\", binary: \\"bin/hello_fuchsia\\", args: [\\"it_works\\"], },\\n} This will pass the argument it_works to the binary, filtering the tests to only those tests that match the pattern. There are many more configuration options available in CML including environment variables. More documentation is available on the Fuchsia devsite .","breadcrumbs":"Platform Support  *-unknown-fuchsia  Running unit tests","id":"1311","title":"Running unit tests"},"1312":{"body":"The commands in this section assume that they are being run from inside your local Rust source checkout: cd ${RUST_SRC_PATH} To run the Rust test suite on an emulated Fuchsia device, you\'ll also need to download a copy of the Fuchsia SDK. The current minimum supported SDK version is 20.20240412.3.1 . Fuchsia\'s test runner interacts with the Fuchsia emulator and is located at src/ci/docker/scripts/fuchsia-test-runner.py. First, add the following variables to your existing config-env.sh: # TEST_TOOLCHAIN_TMP_DIR can point anywhere, but it:\\n# - must be less than 108 characters, otherwise qemu can\'t handle the path\\n# - must be consistent across calls to this file (don\'t use `mktemp -d` here)\\nexport TEST_TOOLCHAIN_TMP_DIR=\\"/tmp/rust-tmp\\" # Keep existing contents of `config-env.sh` from earlier, including SDK_PATH We can then use the script to start our test environment with: ( \\\\ source config-env.sh && \\\\ src/ci/docker/scripts/fuchsia-test-runner.py start \\\\ --rust-build ${RUST_SRC_PATH}/build \\\\ --sdk ${SDK_PATH} \\\\ --target {x86_64-unknown-fuchsia|aarch64-unknown-fuchsia} \\\\ --verbose \\\\\\n) Where ${RUST_SRC_PATH}/build is the build-dir set in bootstrap.toml. Once our environment is started, we can run our tests using x.py as usual. The test runner script will run the compiled tests on an emulated Fuchsia device. To run the full tests/ui test suite: ( \\\\ source config-env.sh && \\\\ ./x.py \\\\ --config bootstrap.toml \\\\ --stage=2 \\\\ test tests/ui \\\\ --target x86_64-unknown-fuchsia \\\\ --run=always \\\\ --test-args --target-rustcflags \\\\ --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/sysroot/lib \\\\ --test-args --target-rustcflags \\\\ --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/lib \\\\ --test-args --target-rustcflags \\\\ --test-args -Clink-arg=--undefined-version \\\\ --test-args --remote-test-client \\\\ --test-args src/ci/docker/scripts/fuchsia-test-runner.py \\\\\\n) By default, x.py compiles test binaries with panic=unwind. If you built your Rust toolchain with -Cpanic=abort, you need to tell x.py to compile test binaries with panic=abort as well: --test-args --target-rustcflags \\\\ --test-args -Cpanic=abort \\\\ --test-args --target-rustcflags \\\\ --test-args -Zpanic_abort_tests \\\\ When finished testing, the test runner can be used to stop the test environment: src/ci/docker/scripts/fuchsia-test-runner.py stop","breadcrumbs":"Platform Support  *-unknown-fuchsia  Running the compiler test suite","id":"1312","title":"Running the compiler test suite"},"1313":{"body":"","breadcrumbs":"Platform Support  *-unknown-fuchsia  Debugging","id":"1313","title":"Debugging"},"1314":{"body":"Debugging components running on a Fuchsia emulator can be done using the console-mode debugger: zxdb . We will demonstrate attaching necessary symbol paths to debug our hello-fuchsia component.","breadcrumbs":"Platform Support  *-unknown-fuchsia  zxdb","id":"1314","title":"zxdb"},"1315":{"body":"In a separate terminal, issue the following command from our hello_fuchsia directory to launch zxdb: In separate terminal ${SDK_PATH}/tools/${ARCH}/ffx debug connect -- \\\\ --symbol-path target/x86_64-unknown-fuchsia/debug --symbol-path gets required symbol paths, which are necessary for stepping through your program. The \\" displaying source code in zxdb \\" section describes how you can display Rust and/or Fuchsia source code in your debugging session.","breadcrumbs":"Platform Support  *-unknown-fuchsia  Attaching zxdb","id":"1315","title":"Attaching zxdb"},"1316":{"body":"Once launched, you will be presented with the window: Connecting (use \\"disconnect\\" to cancel)...\\nConnected successfully.\\n To get started, try \\"status\\" or \\"help\\".\\n[zxdb] To attach to our program, we can run: [zxdb] attach hello_fuchsia Expected output Waiting for process matching \\"hello_fuchsia\\".\\nType \\"filter\\" to see the current filters. Next, we can create a breakpoint at main using \\"b main\\": [zxdb] b main Expected output Created Breakpoint 1 @ main Finally, we can re-run the \\"hello_fuchsia\\" component from our original terminal: ${SDK_PATH}/tools/${ARCH}/ffx component run \\\\ --recreate \\\\ fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm Once our component is running, our zxdb window will stop execution in our main as desired: Expected output Breakpoint 1 now matching 1 addrs for main\\n on bp 1 hello_fuchsia::main()  main.rs:2 1 fn main() {  2 println!(\\"Hello Fuchsia!\\"); 3 } 4\\n[zxdb] zxdb has similar commands to other debuggers like gdb . To list the available commands, run \\"help\\" in the zxdb window or visit the zxdb documentation . [zxdb] help Expected output Help! Type \\"help <command>\\" for command-specific help. Other help topics (see \\"help <topic>\\")\\n...","breadcrumbs":"Platform Support  *-unknown-fuchsia  Using zxdb","id":"1316","title":"Using zxdb"},"1317":{"body":"By default, the debugger will not be able to display source code while debugging. For our user code, we displayed source code by pointing our debugger to our debug binary via the --symbol-path arg. To display library source code in the debugger, you must provide paths to the source using --build-dir. For example, to display the Rust and Fuchsia source code: ${SDK_PATH}/tools/${ARCH}/ffx debug connect -- \\\\ --symbol-path target/x86_64-unknown-fuchsia/debug \\\\ --build-dir ${RUST_SRC_PATH}/rust \\\\ --build-dir ${FUCHSIA_SRC_PATH}/fuchsia/out/default --build-dir links against source code paths, which are not strictly necessary for debugging, but is a nice-to-have for displaying source code in zxdb. Linking to a Fuchsia checkout can help with debugging Fuchsia libraries, such as fdio .","breadcrumbs":"Platform Support  *-unknown-fuchsia  Displaying source code in zxdb","id":"1317","title":"Displaying source code in zxdb"},"1318":{"body":"Debugging the compiler test suite requires some special configuration: First, we have to properly configure zxdb so it will be able to find debug symbols and source information for our test. The test runner can do this for us with: src/ci/docker/scripts/fuchsia-test-runner.py debug \\\\ --rust-src ${RUST_SRC_PATH} \\\\ --fuchsia-src ${FUCHSIA_SRC_PATH} \\\\ --test ${TEST} where ${TEST} is relative to Rust\'s tests directory (e.g. ui/abi/...). This will start a zxdb session that is properly configured for the specific test being run. All three arguments are optional, so you can omit --fuchsia-src if you don\'t have it downloaded. Now is a good time to set any desired breakpoints, like b main. Next, we have to tell x.py not to optimize or strip debug symbols from our test suite binaries. We can do this by passing some new arguments to rustc through our x.py invocation. The full invocation is: ( \\\\ source config-env.sh && \\\\ ./x.py \\\\ --config bootstrap.toml \\\\ --stage=2 \\\\ test tests/${TEST} \\\\ --target x86_64-unknown-fuchsia \\\\ --run=always \\\\ --test-args --target-rustcflags \\\\ --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/sysroot/lib \\\\ --test-args --target-rustcflags \\\\ --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/lib \\\\ --test-args --target-rustcflags \\\\ --test-args -Clink-arg=--undefined-version \\\\ --test-args --target-rustcflags \\\\ --test-args -Cdebuginfo=2 \\\\ --test-args --target-rustcflags \\\\ --test-args -Copt-level=0 \\\\ --test-args --target-rustcflags \\\\ --test-args -Cstrip=none \\\\ --test-args --remote-test-client \\\\ --test-args src/ci/docker/scripts/fuchsia-test-runner.py \\\\\\n) If you built your Rust toolchain with panic=abort, make sure to include the previous flags so your test binaries are also compiled with panic=abort. Upon running this command, the test suite binary will be run and zxdb will attach and load any relevant debug symbols.","breadcrumbs":"Platform Support  *-unknown-fuchsia  Debugging the compiler test suite","id":"1318","title":"Debugging the compiler test suite"},"1319":{"body":"Tier: 3 Trusty is a secure Operating System that provides a Trusted Execution Environment (TEE) for Android.","breadcrumbs":"Platform Support  *-unknown-trusty  aarch64-unknown-trusty and armv7-unknown-trusty","id":"1319","title":"aarch64-unknown-trusty and armv7-unknown-trusty"},"132":{"body":"These lints are all set to the \'allow\' level by default. As such, they won\'t show up unless you set them to a higher lint level with a flag or attribute. absolute_paths_not_starting_with_crate ambiguous_negative_literals async-idents closure_returning_async_block deprecated_safe_2024 deref_into_dyn_supertrait disjoint-capture-migration edition_2024_expr_fragment_specifier elided-lifetime-in-path elided_lifetimes_in_paths explicit_outlives_requirements ffi_unwind_calls fuzzy_provenance_casts if_let_rescope impl_trait_overcaptures impl_trait_redundant_captures keyword-idents keyword_idents_2018 keyword_idents_2024 let_underscore_drop linker_messages lossy_provenance_casts macro_use_extern_crate meta_variable_misuse missing_copy_implementations missing_debug_implementations missing_docs missing_unsafe_on_extern multiple_supertrait_upcastable must_not_suspend non_ascii_idents non_exhaustive_omitted_patterns or-patterns-back-compat redundant_imports redundant_lifetimes rust_2021_incompatible_closure_captures rust_2021_incompatible_or_patterns rust_2021_prefixes_incompatible_syntax rust_2021_prelude_collisions rust_2024_guarded_string_incompatible_syntax rust_2024_incompatible_pat rust_2024_prelude_collisions single-use-lifetime single_use_lifetimes supertrait_item_shadowing_definition supertrait_item_shadowing_usage tail_expr_drop_order trivial_casts trivial_numeric_casts unit_bindings unnameable_types unqualified_local_imports unreachable_pub unsafe_attr_outside_unsafe unsafe_code unsafe_op_in_unsafe_fn unstable_features unused_crate_dependencies unused_extern_crates unused_import_braces unused_lifetimes unused_macro_rules unused_qualifications unused_results variant_size_differences","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Allowed-by-default Lints","id":"132","title":"Allowed-by-default Lints"},"1320":{"body":"@randomPoison @ahomescu","breadcrumbs":"Platform Support  *-unknown-trusty  Target maintainers","id":"1320","title":"Target maintainers"},"1321":{"body":"These targets are cross-compiled. They have no special requirements for the host. Trusty targets have partial support for the standard library: alloc is fully supported and std has limited support that excludes things like filesystem access, network I/O, and spawning processes/threads. File descriptors are supported for the purpose of IPC. Trusty uses the ELF file format.","breadcrumbs":"Platform Support  *-unknown-trusty  Requirements","id":"1321","title":"Requirements"},"1322":{"body":"The targets can be built by enabling them for a rustc build, for example: [build]\\nbuild-stage = 1\\ntarget = [\\"aarch64-unknown-trusty\\", \\"armv7-unknown-trusty\\"]","breadcrumbs":"Platform Support  *-unknown-trusty  Building the target","id":"1322","title":"Building the target"},"1323":{"body":"There is currently no supported way to build a Trusty app with Cargo. You can follow the Trusty build instructions to build the Trusty kernel along with any Rust apps that are setup in the project.","breadcrumbs":"Platform Support  *-unknown-trusty  Building Rust programs","id":"1323","title":"Building Rust programs"},"1324":{"body":"See the Trusty build instructions for information on how to build Rust code within the main Trusty project. The main project also includes infrastructure for testing Rust applications within a QEMU emulator.","breadcrumbs":"Platform Support  *-unknown-trusty  Testing","id":"1324","title":"Testing"},"1325":{"body":"See the Trusty build instructions for information on how C code is built within Trusty.","breadcrumbs":"Platform Support  *-unknown-trusty  Cross-compilation toolchains and C code","id":"1325","title":"Cross-compilation toolchains and C code"},"1326":{"body":"Tier: 3 SOLID embedded development platform by Kyoto Microcomputer Co., Ltd. The target names follow this format: $ARCH-kmc-solid_$KERNEL-$ABI, where $ARCH specifies the target processor architecture, $KERNEL the base kernel, and $ABI the target ABI (optional). The following targets are currently defined: Target name target_arch target_vendor target_os aarch64-kmc-solid_asp3 aarch64 kmc solid_asp3 armv7a-kmc-solid_asp3-eabi arm kmc solid_asp3 armv7a-kmc-solid_asp3-eabihf arm kmc solid_asp3","breadcrumbs":"Platform Support  *-kmc-solid_*  *-kmc-solid_*","id":"1326","title":"*-kmc-solid_*"},"1327":{"body":"@kawadakk","breadcrumbs":"Platform Support  *-kmc-solid_*  Target Maintainers","id":"1327","title":"Target Maintainers"},"1328":{"body":"This target is cross-compiled. A platform-provided C compiler toolchain is required, though it can be substituted by GNU Arm Embedded Toolchain for the purpose of building Rust and functional binaries.","breadcrumbs":"Platform Support  *-kmc-solid_*  Requirements","id":"1328","title":"Requirements"},"1329":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"aarch64-kmc-solid_asp3\\"] Make sure aarch64-kmc-elf-gcc is included in $PATH. Alternatively, you can use GNU Arm Embedded Toolchain by adding the following to bootstrap.toml: [target.aarch64-kmc-solid_asp3]\\ncc = \\"arm-none-eabi-gcc\\"","breadcrumbs":"Platform Support  *-kmc-solid_*  Building","id":"1329","title":"Building"},"133":{"body":"The absolute_paths_not_starting_with_crate lint detects fully qualified paths that start with a module name instead of crate, self, or an extern crate name","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  absolute-paths-not-starting-with-crate","id":"133","title":"absolute-paths-not-starting-with-crate"},"1330":{"body":"This target can be cross-compiled from any hosts.","breadcrumbs":"Platform Support  *-kmc-solid_*  Cross-compilation","id":"1330","title":"Cross-compilation"},"1331":{"body":"Currently there is no support to run the rustc test suite for this target.","breadcrumbs":"Platform Support  *-kmc-solid_*  Testing","id":"1331","title":"Testing"},"1332":{"body":"Building executables is not supported yet. If rustc has support for that target and the library artifacts are available, then Rust static libraries can be built for that target: $ rustc --target aarch64-kmc-solid_asp3 your-code.rs --crate-type staticlib\\n$ ls libyour_code.a On Rust Nightly it\'s possible to build without the target artifacts available: cargo build -Z build-std --target aarch64-kmc-solid_asp3","breadcrumbs":"Platform Support  *-kmc-solid_*  Building Rust programs","id":"1332","title":"Building Rust programs"},"1333":{"body":"Tier: 3 This target supports C-SKY CPUs with abi v2 and glibc. target std host notes csky-unknown-linux-gnuabiv2  C-SKY abiv2 Linux (little endian) csky-unknown-linux-gnuabiv2hf  C-SKY abiv2 Linux, hardfloat (little endian) Reference: CSKY ABI Manual csky-linux-gnuabiv2-toolchain csky-linux-gnuabiv2-qemu other links: https://c-sky.github.io/ https://gitlab.com/c-sky/","breadcrumbs":"Platform Support  csky-unknown-linux-gnuabiv2*  csky-unknown-linux-gnuabiv2","id":"1333","title":"csky-unknown-linux-gnuabiv2"},"1334":{"body":"@Dirreke","breadcrumbs":"Platform Support  csky-unknown-linux-gnuabiv2*  Target maintainers","id":"1334","title":"Target maintainers"},"1335":{"body":"","breadcrumbs":"Platform Support  csky-unknown-linux-gnuabiv2*  Requirements","id":"1335","title":"Requirements"},"1336":{"body":"","breadcrumbs":"Platform Support  csky-unknown-linux-gnuabiv2*  Building the target","id":"1336","title":"Building the target"},"1337":{"body":"Compiling rust for this target has been tested on x86_64 linux hosts. Other host types have not been tested, but may work, if you can find a suitable cross compilation toolchain for them. If you don\'t already have a suitable toolchain, you can download from here , and unpack it into a directory.","breadcrumbs":"Platform Support  csky-unknown-linux-gnuabiv2*  Get a C toolchain","id":"1337","title":"Get a C toolchain"},"1338":{"body":"The target can be built by enabling it for a rustc build, by placing the following in bootstrap.toml: [build]\\ntarget = [\\"x86_64-unknown-linux-gnu\\", \\"csky-unknown-linux-gnuabiv2\\", \\"csky-unknown-linux-gnuabiv2hf\\"]\\nstage = 2 [target.csky-unknown-linux-gnuabiv2]\\n# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN\\ncc = \\"${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc\\" [target.csky-unknown-linux-gnuabiv2hf]\\n# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN\\ncc = \\"${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc\\"","breadcrumbs":"Platform Support  csky-unknown-linux-gnuabiv2*  Configure rust","id":"1338","title":"Configure rust"},"1339":{"body":"# in rust dir\\n./x.py build --stage 2","breadcrumbs":"Platform Support  csky-unknown-linux-gnuabiv2*  Build","id":"1339","title":"Build"},"134":{"body":"#![deny(absolute_paths_not_starting_with_crate)] mod foo { pub fn bar() {}\\n} fn main() { ::foo::bar();\\n} This will produce: error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition --> lint_example.rs:8:5 |\\n8 | ::foo::bar(); | ^^^^^^^^^^ help: use `crate`: `crate::foo::bar` | = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018! = note: for more information, see issue #53130 <https://github.com/rust-lang/rust/issues/53130>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(absolute_paths_not_starting_with_crate)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"134","title":"Example"},"1340":{"body":"To test cross-compiled binaries on a x86_64 system, you can use the qemu-cskyv2. This avoids having a full emulated ARM system by doing dynamic binary translation and dynamic system call translation. It lets you run CSKY programs directly on your x86_64 kernel. It\'s very convenient! To use: Install qemu-cskyv2 (If you don\'t already have a qemu, you can download from here , and unpack it into a directory.) Link your built toolchain via: rustup toolchain link stage2 ${RUST}/build/x86_64-unknown-linux-gnu/stage2 Create a test program cargo new hello_world\\ncd hello_world Build and run CARGO_TARGET_CSKY_UNKNOWN_LINUX_GNUABIV2_RUNNER=${QEMU_PATH}/bin/qemu-cskyv2 -L ${TOOLCHAIN_PATH}/csky-linux-gnuabiv2/libc \\\\\\nCARGO_TARGET_CSKY_UNKNOWN_LINUX_GNUABIV2_LINKER=${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc \\\\\\nRUSTFLAGS=\\"-C target-feature=+crt-static\\" \\\\\\ncargo +stage2 run --target csky-unknown-linux-gnuabiv2 Attention: The dynamic-linked program may nor be run by qemu-cskyv2 but can be run on the target.","breadcrumbs":"Platform Support  csky-unknown-linux-gnuabiv2*  Building and Running Rust programs","id":"1340","title":"Building and Running Rust programs"},"1341":{"body":"Tier: 3 Target for cross-compiling Linux user-mode applications targeting the Hexagon DSP architecture. Target Descriptions hexagon-unknown-linux-musl Hexagon 32-bit Linux","breadcrumbs":"Platform Support  hexagon-unknown-linux-musl  hexagon-unknown-linux-musl","id":"1341","title":"hexagon-unknown-linux-musl"},"1342":{"body":"@androm3da","breadcrumbs":"Platform Support  hexagon-unknown-linux-musl  Target maintainers","id":"1342","title":"Target maintainers"},"1343":{"body":"The target is cross-compiled. This target supports std. By default, code generated with this target should run on Hexagon DSP hardware. -Ctarget-cpu=hexagonv73 adds support for instructions defined up to Hexagon V73. Binaries can be run using QEMU user emulation. On Debian-based systems, it should be sufficient to install the package qemu-user-static to be able to run simple static binaries: # apt install qemu-user-static\\n# qemu-hexagon-static ./hello In order to build linux programs with Rust, you will require a linker capable of targeting hexagon. You can use clang/lld from the hexagon toolchain using exclusively public open source repos . Also included in that toolchain is the C library that can be used when creating dynamically linked executables. # /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/bin/qemu-hexagon -L /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr/ ./hello","breadcrumbs":"Platform Support  hexagon-unknown-linux-musl  Requirements","id":"1343","title":"Requirements"},"1344":{"body":"Because it is Tier 3, rust does not yet ship pre-compiled artifacts for this target. Therefore, you can build Rust with support for the target by adding it to the target list in bootstrap.toml, a sample configuration is shown below. [build]\\ntarget = [\\"hexagon-unknown-linux-musl\\"] [target.hexagon-unknown-linux-musl] cc = \\"hexagon-unknown-linux-musl-clang\\"\\ncxx = \\"hexagon-unknown-linux-musl-clang++\\"\\nlinker = \\"hexagon-unknown-linux-musl-clang\\"\\nar = \\"hexagon-unknown-linux-musl-ar\\"\\nranlib = \\"hexagon-unknown-linux-musl-ranlib\\"\\nmusl-root = \\"/opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr\\"\\nllvm-libunwind = \'in-tree\'\\nqemu-rootfs = \\"/opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr\\"","breadcrumbs":"Platform Support  hexagon-unknown-linux-musl  Building the target","id":"1344","title":"Building the target"},"1345":{"body":"Currently there is no support to run the rustc test suite for this target.","breadcrumbs":"Platform Support  hexagon-unknown-linux-musl  Testing","id":"1345","title":"Testing"},"1346":{"body":"Download and install the hexagon open source toolchain from https://github.com/quic/toolchain_for_hexagon/releases The following .cargo/config is needed inside any project directory to build for the Hexagon Linux target: [build]\\ntarget = \\"hexagon-unknown-linux-musl\\" [target.hexagon-unknown-linux-musl]\\nlinker = \\"hexagon-unknown-linux-musl-clang\\"\\nar = \\"hexagon-unknown-linux-musl-ar\\"\\nrunner = \\"qemu-hexagon -L /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr\\" Edit the \\"runner\\" in .cargo/config to point to the path to your toolchain\'s C library. ...\\nrunner = \\"qemu-hexagon -L /path/to/my/inst/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr\\"\\n... Build/run your rust program with qemu-hexagon in your PATH: export PATH=/path/to/my/inst/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/bin/:$PATH\\ncargo run -Zbuild-std -Zbuild-std-features=llvm-libunwind","breadcrumbs":"Platform Support  hexagon-unknown-linux-musl  Building Rust programs","id":"1346","title":"Building Rust programs"},"1347":{"body":"Tier: 3 Rust for baremetal Hexagon DSPs. Target Descriptions hexagon-unknown-none-elf Hexagon 32-bit (freestanding, hardfloat)","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  hexagon-unknown-none-elf","id":"1347","title":"hexagon-unknown-none-elf"},"1348":{"body":"@androm3da","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  Target maintainers","id":"1348","title":"Target maintainers"},"1349":{"body":"This target is cross-compiled. There is no support for std. There is no default allocator, but it\'s possible to use alloc by supplying an allocator. By default, code generated with this target should run on Hexagon DSP hardware. -Ctarget-cpu=hexagonv73 adds support for instructions defined up to Hexagon V73. Functions marked extern \\"C\\" use the Hexagon architecture calling convention . This target generates PIC ELF binaries.","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  Requirements","id":"1349","title":"Requirements"},"135":{"body":"Rust editions allow the language to evolve without breaking backwards compatibility. This lint catches code that uses absolute paths in the style of the 2015 edition. In the 2015 edition, absolute paths (those starting with ::) refer to either the crate root or an external crate. In the 2018 edition it was changed so that they only refer to external crates. The path prefix crate:: should be used instead to reference items from the crate root. If you switch the compiler from the 2015 to 2018 edition without updating the code, then it will fail to compile if the old style paths are used. You can manually change the paths to use the crate:: prefix to transition to the 2018 edition. This lint solves the problem automatically. It is \\"allow\\" by default because the code is perfectly valid in the 2015 edition. The cargo fix tool with the --edition flag will switch this lint to \\"warn\\" and automatically apply the suggested fix from the compiler. This provides a completely automated way to update old code to the 2018 edition.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"135","title":"Explanation"},"1350":{"body":"You can build Rust with support for the target by adding it to the target list in bootstrap.toml: [build]\\nbuild-stage = 1\\nhost = [\\"<target for your host>\\"]\\ntarget = [\\"<target for your host>\\", \\"hexagon-unknown-none-elf\\"] [target.hexagon-unknown-none-elf] cc = \\"hexagon-unknown-none-elf-clang\\"\\ncxx = \\"hexagon-unknown-none-elf-clang++\\"\\nlinker = \\"hexagon-unknown-none-elf-clang\\"\\nranlib = \\"hexagon-unknown-none-elf-ranlib\\"\\nar = \\"hexagon-unknown-none-elf-ar\\"\\nllvm-libunwind = \'in-tree\' Replace <target for your host> with x86_64-unknown-linux-gnu or whatever else is appropriate for your host machine.","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  Building the target","id":"1350","title":"Building the target"},"1351":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar.","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  Building Rust programs","id":"1351","title":"Building Rust programs"},"1352":{"body":"Since hexagon-unknown-none-elf supports a variety of different environments and does not support std, this target does not support running the Rust test suite.","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  Testing","id":"1352","title":"Testing"},"1353":{"body":"This target has been tested using qemu-system-hexagon. A common use case for hexagon-unknown-none-elf is building libraries that link against C code and can be used in emulation or on a device with a Hexagon DSP. The Hexagon SDK has libraries which are useful to link against when running on a device.","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  Cross-compilation toolchains and C code","id":"1353","title":"Cross-compilation toolchains and C code"},"1354":{"body":"The script below will build an executable against \\"hexagon standalone OS\\" which is suitable for emulation or bare-metal on-device testing. First, run cargo new --bin demo1_hexagon then add the source below as src/main.rs. This program demonstrates the console output via semihosting. #![no_std]\\n#![no_main] extern \\"C\\" { fn putchar(ch: i32); fn _exit(code: i32) -> !;\\n} #[no_mangle]\\nextern \\"C\\" fn main() -> i32 { let message = \\"Hello, this is Rust!\\"; for b in message.bytes() { unsafe { putchar(b as i32); } } 0\\n} #[panic_handler]\\nfn panic(_panic: &core::panic::PanicInfo) -> ! { unsafe { _exit(1); }\\n} Next, save the script below as build.sh and edit it to suit your environment. hex_toolchain below refers to the hexagon toolchain using exclusively public open source repos . cc below refers to clang. You can use clang from your distribution, as long as it\'s at least clang-17. Or you can use hexagon-unknown-none-elf-clang from one of the hexagon open source toolchain releases . # Hexagon SDK, required for target libraries:\\nhex_sdk_root=/local/mnt/workspace/Qualcomm/Hexagon_SDK/5.3.0.0\\nhex_sdk_toolchain=${hex_sdk_root}/tools/HEXAGON_Tools/8.6.06 sdk_libs=${hex_sdk_toolchain}/Tools/target/hexagon/lib\\nq6_arch=v65\\ng0_lib_path=${sdk_libs}/${q6_arch}/G0\\npic_lib_path=${sdk_libs}/${q6_arch}/G0/pic build_cfg=release\\ncargo build --target=hexagon-unknown-none-elf -Zbuild-std --release # Builds an executable against \\"hexagon standalone OS\\" suitable for emulation:\\n${cc} --target=hexagon-unknown-none-elf -o testit \\\\ -fuse-ld=lld \\\\ -m${q6_arch} \\\\ -nodefaultlibs \\\\ -nostartfiles \\\\ ${g0_lib_path}/crt0_standalone.o \\\\ ${g0_lib_path}/crt0.o \\\\ ${g0_lib_path}/init.o \\\\ -L${sdk_libs}/${q6_arch}/ \\\\ -L${sdk_libs}/ \\\\ wrap.c \\\\ target/hexagon-unknown-none-elf/${build_cfg}/libdemo1_hexagon.rlib \\\\ target/hexagon-unknown-none-elf/${build_cfg}/deps/libcore-*.rlib \\\\ target/hexagon-unknown-none-elf/${build_cfg}/deps/libcompiler_builtins-*.rlib \\\\ -Wl,--start-group \\\\ -Wl,--defsym,_SDA_BASE_=0,--defsym,__sbss_start=0,--defsym,__sbss_end=0 \\\\ ${g0_lib_path}/libstandalone.a \\\\ ${g0_lib_path}/libc.a \\\\ -lgcc \\\\ -lc_eh \\\\ -Wl,--end-group \\\\ ${g0_lib_path}/fini.o \\\\ ${hex_toolchain}/x86_64-linux-gnu/bin/qemu-system-hexagon -monitor none -display none -kernel ./testit","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  Standalone OS","id":"1354","title":"Standalone OS"},"1355":{"body":"First, run cargo new --lib demo2_hexagon then add the source below as src/lib.rs. This program demonstrates inline assembly and console output via semihosting. #![no_std]\\n#![no_main]\\n#![feature(lang_items)]\\n#![feature(asm_experimental_arch)] use core::arch::asm; extern \\"C\\" { fn putchar(ch: i32); fn _exit(code: i32) -> !;\\n} fn hexagon_specific() { let mut buffer = [0_u8; 128]; unsafe { let mut x = &buffer; asm!( \\"{{\\\\n\\\\t\\", \\" v0=vmem({addr}+#0)\\\\n\\\\t\\", \\" {tmp} = and({tmp}, #1)\\\\n\\\\t\\", \\"}}\\\\n\\\\t\\", addr = in(reg) x, tmp = out(reg) _, ); }\\n} #[no_mangle]\\nextern \\"C\\" fn hello() -> i32 { let message = \\"Hello, this is Rust!\\\\n\\"; for b in message.bytes() { unsafe { putchar(b as i32); } } hexagon_specific(); 0\\n} #[panic_handler]\\nfn panic(_panic: &core::panic::PanicInfo) -> ! { unsafe { _exit(1); }\\n} #[lang = \\"eh_personality\\"]\\nfn rust_eh_personality() {} Next, create a C program as an entry point, save the content below as wrap.c: int hello(); int main() { hello();\\n} Then, save the script below as build.sh and edit it to suit your environment. The script below will build a shared object against the QuRT RTOS which is suitable for emulation or on-device testing when loaded via the fastrpc-shell. # Hexagon SDK, required for target libraries:\\nhex_sdk_root=/local/mnt/workspace/Qualcomm/Hexagon_SDK/5.3.0.0\\nhex_sdk_toolchain=${hex_sdk_root}/tools/HEXAGON_Tools/8.6.06 sdk_libs=${hex_sdk_toolchain}/Tools/target/hexagon/lib\\nq6_arch=v65\\ng0_lib_path=${sdk_libs}/${q6_arch}/G0\\npic_lib_path=${sdk_libs}/${q6_arch}/G0/pic\\nrunelf=${hex_sdk_root}/rtos/qurt/computev65/sdksim_bin/runelf.pbn\\nrmohs=${hex_sdk_root}/libs/run_main_on_hexagon/ship/hexagon_toolv86_${q6_arch}/run_main_on_hexagon_sim # Builds a library suitable for loading into \\"run_main_on_hexagon_sim\\" for\\n# emulation or frpc shell on real target:\\n${cc} --target=hexagon-unknown-none-elf -o testit.so \\\\ -fuse-ld=lld \\\\ -fPIC -shared \\\\ -nostdlib \\\\ -Wl,-Bsymbolic \\\\ -Wl,--wrap=malloc \\\\ -Wl,--wrap=calloc \\\\ -Wl,--wrap=free \\\\ -Wl,--wrap=realloc \\\\ -Wl,--wrap=memalign \\\\ -m${q6_arch} \\\\ wrap.c \\\\ target/hexagon-unknown-none-elf/${build_cfg}/libdemo2_hexagon.rlib \\\\ target/hexagon-unknown-none-elf/${build_cfg}/deps/libcore-*.rlib \\\\ target/hexagon-unknown-none-elf/${build_cfg}/deps/libcompiler_builtins-*.rlib \\\\ -Wl,-soname=testit \\\\ ${pic_lib_path}/libc.so # -Bsymbolic above for memory alloc funcs is necessary to access the heap on\\n# target, but otherwise not required. # multi-stage loader: runelf => run_main_on_hexagon_sim => testit.so{`main`}\\n${hex_toolchain}/x86_64-linux-gnu/bin/qemu-system-hexagon \\\\ -monitor none \\\\ -display none \\\\ -kernel ${runelf} \\\\ -append \\"${rmohs} -- ./testit.so\\"","breadcrumbs":"Platform Support  hexagon-unknown-none-elf  QuRT OS","id":"1355","title":"QuRT OS"},"1356":{"body":"Tier: 2/3 illumos , is a Unix operating system which provides next-generation features for downstream distributions, including advanced system debugging, next generation filesystem, networking, and virtualization options.","breadcrumbs":"Platform Support  illumos  aarch64-unknown-illumos and x86_64-unknown-illumos","id":"1356","title":"aarch64-unknown-illumos and x86_64-unknown-illumos"},"1357":{"body":"@jclulow @pfmooney","breadcrumbs":"Platform Support  illumos  Target maintainers","id":"1357","title":"Target maintainers"},"1358":{"body":"The target supports host tools. The illumos target supports std and uses the standard ELF file format. x86_64-unknown-illumos is a tier 2 target with host tools. aarch64-unknown-illumos is a tier 3 target.","breadcrumbs":"Platform Support  illumos  Requirements","id":"1358","title":"Requirements"},"1359":{"body":"These targets can be built by adding aarch64-unknown-illumos and x86_64-unknown-illumos as targets in the rustc list.","breadcrumbs":"Platform Support  illumos  Building the target","id":"1359","title":"Building the target"},"136":{"body":"The ambiguous_negative_literals lint checks for cases that are confusing between a negative literal and a negation that\'s not part of the literal.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  ambiguous-negative-literals","id":"136","title":"ambiguous-negative-literals"},"1360":{"body":"Rust ships pre-compiled artifacts for the x86_64-unknown-illumos target. Rust does not ship pre-compiled artifacts for aarch64-unknown-illumos, it requires building the target either as shown above or using -Zbuild-std.","breadcrumbs":"Platform Support  illumos  Building Rust programs","id":"1360","title":"Building Rust programs"},"1361":{"body":"Tests can be run in the same way as a regular binary.","breadcrumbs":"Platform Support  illumos  Testing","id":"1361","title":"Testing"},"1362":{"body":"The target supports C code. The illumos project makes available prebuilt sysroot artefacts which can be used for cross compilation. The official Rust binaries are cross-compiled using these artefacts.","breadcrumbs":"Platform Support  illumos  Cross-compilation toolchains and C code","id":"1362","title":"Cross-compilation toolchains and C code"},"1363":{"body":"Tier: 2 (with Host Tools) LoongArch Linux targets. LoongArch is a RISC ISA developed by Loongson Technology Corporation Limited. Target Description loongarch64-unknown-linux-gnu LoongArch64 Linux, LP64D ABI (kernel 5.19, glibc 2.36), LSX required loongarch64-unknown-linux-musl LoongArch64 Linux, LP64D ABI (kernel 5.19, musl 1.2.5), LSX required These support both native and cross builds, and have full support for std. Reference material: LoongArch ISA manuals Application Binary Interface for the LoongArch Architecture","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  loongarch*-unknown-linux-*","id":"1363","title":"loongarch*-unknown-linux-*"},"1364":{"body":"@heiher @xen0n","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  Target maintainers","id":"1364","title":"Target maintainers"},"1365":{"body":"","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  Requirements","id":"1365","title":"Requirements"},"1366":{"body":"The minimum supported Linux version is 5.19. Some Linux distributions, mostly commercial ones, may provide forked Linux kernels that has a version number less than 5.19 for their LoongArch ports. Such kernels may still get patched to be compatible with the upstream Linux 5.19 UAPI, therefore supporting the targets described in this document, but this is not always the case. The rustup installer contains a check for this, and will abort if incompatibility is detected.","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  OS Version","id":"1366","title":"OS Version"},"1367":{"body":"The targets require a reasonably up-to-date LoongArch toolchain on the host. Currently the following components are used by the Rust CI to build the target, and the versions can be seen as the minimum requirement: GNU Binutils 2.42 GCC 14.x glibc 2.36 linux-headers 5.19 Of these, glibc and linux-headers are at their respective earliest versions with mainline LoongArch support, so it is impossible to use older versions of these. Older versions of Binutils and GCC will not work either, due to lack of support for newer LoongArch ELF relocation types, among other features. Recent LLVM/Clang toolchains may be able to build the targets, but are not currently being actively tested.","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  Host toolchain","id":"1367","title":"Host toolchain"},"1368":{"body":"These targets require the double-precision floating-point and LSX (LoongArch SIMD Extension) features.","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  CPU features","id":"1368","title":"CPU features"},"1369":{"body":"These targets are distributed through rustup, and otherwise require no special configuration. If you need to build your own Rust for some reason though, the targets can be simply enabled in bootstrap.toml. For example: [build]\\ntarget = [\\"loongarch64-unknown-linux-gnu\\"] Make sure the LoongArch toolchain binaries are reachable from $PATH. Alternatively, you can explicitly configure the paths in bootstrap.toml: [target.loongarch64-unknown-linux-gnu]\\n# Adjust the paths to point at your toolchain\\n# Suppose the toolchain is placed at /TOOLCHAIN_PATH, and the cross prefix is\\n# \\"loongarch64-unknown-linux-gnu-\\":\\ncc = \\"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc\\"\\ncxx = \\"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-g++\\"\\nar = \\"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-ar\\"\\nranlib = \\"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-ranlib\\"\\nlinker = \\"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc\\"","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  Building","id":"1369","title":"Building"},"137":{"body":"# #![deny(ambiguous_negative_literals)]\\n# #![allow(unused)]\\n-1i32.abs(); // equals -1, while `(-1i32).abs()` equals 1 This will produce: error: `-` has lower precedence than method calls, which might be unexpected --> lint_example.rs:4:1 |\\n4 | -1i32.abs(); // equals -1, while `(-1i32).abs()` equals 1 | ^^^^^^^^^^^ | = note: e.g. `-4.abs()` equals `-4`; while `(-4).abs()` equals `4`\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(ambiguous_negative_literals)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: add parentheses around the `-` and the literal to call the method on a negative literal |\\n4 | (-1i32).abs(); // equals -1, while `(-1i32).abs()` equals 1 | + +\\nhelp: add parentheses around the literal and the method call to keep the current behavior |\\n4 | -(1i32.abs()); // equals -1, while `(-1i32).abs()` equals 1 | + +","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"137","title":"Example"},"1370":{"body":"This target can be cross-compiled on a x86_64-unknown-linux-gnu host. Other hosts are also likely to work, but not actively tested. You can test the cross build directly on the host, thanks to QEMU linux-user emulation. An example is given below: # Suppose the cross toolchain is placed at $TOOLCHAIN_PATH, with a cross prefix\\n# of \\"loongarch64-unknown-linux-gnu-\\".\\nexport CC_loongarch64_unknown_linux_gnu=\\"$TOOLCHAIN_PATH\\"/bin/loongarch64-unknown-linux-gnu-gcc\\nexport CXX_loongarch64_unknown_linux_gnu=\\"$TOOLCHAIN_PATH\\"/bin/loongarch64-unknown-linux-gnu-g++\\nexport AR_loongarch64_unknown_linux_gnu=\\"$TOOLCHAIN_PATH\\"/bin/loongarch64-unknown-linux-gnu-gcc-ar\\nexport CARGO_TARGET_LOONGARCH64_UNKNOWN_LINUX_GNU_LINKER=\\"$TOOLCHAIN_PATH\\"/bin/loongarch64-unknown-linux-gnu-gcc # Point qemu-loongarch64 to the LoongArch sysroot.\\n# Suppose the sysroot is located at \\"sysroot\\" below the toolchain root:\\nexport CARGO_TARGET_LOONGARCH64_UNKNOWN_LINUX_GNU_RUNNER=\\"qemu-loongarch64 -L $TOOLCHAIN_PATH/sysroot\\"\\n# Or alternatively, if binfmt_misc is set up for running LoongArch binaries\\n# transparently:\\nexport QEMU_LD_PREFIX=\\"$TOOLCHAIN_PATH\\"/sysroot cargo run --target loongarch64-unknown-linux-gnu --release","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  Cross-compilation","id":"1370","title":"Cross-compilation"},"1371":{"body":"There are no special requirements for testing and running the targets. For testing cross builds on the host, please refer to the \\"Cross-compilation\\" section above.","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  Testing","id":"1371","title":"Testing"},"1372":{"body":"As the targets are available through rustup, it is very easy to build Rust programs for these targets: same as with other architectures. Note that you will need a LoongArch C/C++ toolchain for linking, or if you want to compile C code along with Rust (such as for Rust crates with C dependencies). rustup target add loongarch64-unknown-linux-gnu\\ncargo build --target loongarch64-unknown-linux-gnu Availability of pre-built artifacts through rustup are as follows: loongarch64-unknown-linux-gnu: since Rust 1.71; loongarch64-unknown-linux-musl: since Rust 1.81.","breadcrumbs":"Platform Support  loongarch*-unknown-linux-*  Building Rust programs","id":"1372","title":"Building Rust programs"},"1373":{"body":"Freestanding/bare-metal LoongArch binaries in ELF format: firmware, kernels, etc. Target Description Tier loongarch32-unknown-none LoongArch 32-bit, ILP32D ABI (freestanding, hard-float) Tier 3 loongarch32-unknown-none-softfloat LoongArch 32-bit, ILP32S ABI (freestanding, soft-float) Tier 3 loongarch64-unknown-none LoongArch 64-bit, LP64D ABI (freestanding, hard-float) Tier 2 loongarch64-unknown-none-softfloat LoongArch 64-bit, LP64S ABI (freestanding, soft-float) Tier 2","breadcrumbs":"Platform Support  loongarch*-unknown-none*  loongarch*-unknown-none*","id":"1373","title":"loongarch*-unknown-none*"},"1374":{"body":"@heiher @xen0n","breadcrumbs":"Platform Support  loongarch*-unknown-none*  Target maintainers","id":"1374","title":"Target maintainers"},"1375":{"body":"This target is cross-compiled. There is no support for std. There is no default allocator, but it\'s possible to use alloc by supplying an allocator. The *-softfloat target does not assume existence of FPU or any other LoongArch ISA extension, and does not make use of any non-GPR register. This allows the generated code to run in environments, such as kernels, which may need to avoid the use of such registers or which may have special considerations about the use of such registers (e.g. saving and restoring them to avoid breaking userspace code using the same registers). You can change code generation to use additional CPU features via the -C target-feature= codegen options to rustc, or via the #[target_feature] mechanism within Rust code. By default, code generated with the soft-float target should run on any LoongArch hardware, with the hard-float target additionally requiring an FPU; enabling additional target features may raise this baseline. Code generated with the targets will use the medium code model by default. You can change this using the -C code-model= option to rustc. On loongarch*-unknown-none*, extern \\"C\\" uses the architecture\'s standard calling convention . The targets generate binaries in the ELF format. Any alternate formats or special considerations for binary layout will require linker options or linker scripts.","breadcrumbs":"Platform Support  loongarch*-unknown-none*  Requirements","id":"1375","title":"Requirements"},"1376":{"body":"You can build Rust with support for the targets by adding them to the target list in bootstrap.toml: [build]\\nbuild-stage = 1\\ntarget = [ \\"loongarch32-unknown-none\\", \\"loongarch32-unknown-none-softfloat\\", \\"loongarch64-unknown-none\\", \\"loongarch64-unknown-none-softfloat\\",\\n]","breadcrumbs":"Platform Support  loongarch*-unknown-none*  Building the target","id":"1376","title":"Building the target"},"1377":{"body":"As the targets support a variety of different environments and do not support std, they do not support running the Rust test suite.","breadcrumbs":"Platform Support  loongarch*-unknown-none*  Testing","id":"1377","title":"Testing"},"1378":{"body":"","breadcrumbs":"Platform Support  loongarch*-unknown-none*  Building Rust programs","id":"1378","title":"Building Rust programs"},"1379":{"body":"The loongarch32-unknown-none* targets are Tier 3, so you must build the Rust compiler from source to use them. # target flag may be used with any cargo or rustc command\\ncargo build --target loongarch32-unknown-none\\ncargo build --target loongarch32-unknown-none-softfloat","breadcrumbs":"Platform Support  loongarch*-unknown-none*  loongarch32-unknown-none*","id":"1379","title":"loongarch32-unknown-none*"},"138":{"body":"Method calls take precedence over unary precedence. Setting the precedence explicitly makes the code clearer and avoid potential bugs.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"138","title":"Explanation"},"1380":{"body":"Starting with Rust 1.74, precompiled artifacts are provided via rustup: # install cross-compile toolchain\\nrustup target add loongarch64-unknown-none\\nrustup target add loongarch64-unknown-none-softfloat\\n# target flag may be used with any cargo or rustc command\\ncargo build --target loongarch64-unknown-none\\ncargo build --target loongarch64-unknown-none-softfloat","breadcrumbs":"Platform Support  loongarch*-unknown-none*  loongarch64-unknown-none*","id":"1380","title":"loongarch64-unknown-none*"},"1381":{"body":"For cross builds, you will need an appropriate LoongArch C/C++ toolchain for linking, or if you want to compile C code along with Rust (such as for Rust crates with C dependencies). Rust may be able to use an loongarch{32,64}-unknown-linux-{gnu,musl}- toolchain with appropriate standalone flags to build for this toolchain (depending on the assumptions of that toolchain, see below), or you may wish to use a separate loongarch{32,64}-unknown-none toolchain. On some LoongArch hosts that use ELF binaries, you may be able to use the host C toolchain, if it does not introduce assumptions about the host environment that don\'t match the expectations of a standalone environment. Otherwise, you may need a separate toolchain for standalone/freestanding development, just as when cross-compiling from a non-LoongArch platform.","breadcrumbs":"Platform Support  loongarch*-unknown-none*  Cross-compilation toolchains and C code","id":"1381","title":"Cross-compilation toolchains and C code"},"1382":{"body":"Tier: 3 Targets for the LynxOS-178 operating system. LynxOS-178 is a commercial RTOS designed for safety-critical real-time systems. It is developed by Lynx Software Technologies as part of the MOSA.ic product suite. Target triples available: x86_64-lynx-lynxos178","breadcrumbs":"Platform Support  *-lynxos178-*  *-lynxos178-*","id":"1382","title":"*-lynxos178-*"},"1383":{"body":"@rfatykhov-lynx","breadcrumbs":"Platform Support  *-lynxos178-*  Target maintainers","id":"1383","title":"Target maintainers"},"1384":{"body":"To build Rust programs for LynxOS-178, you must first have LYNX MOSA.ic installed on the build machine. This target supports only cross-compilation, from the same hosts supported by the Lynx CDK. Currently only no_std programs are supported. Work to support std is in progress.","breadcrumbs":"Platform Support  *-lynxos178-*  Requirements","id":"1384","title":"Requirements"},"1385":{"body":"You can build Rust with support for x86_64-lynx-lynxos178 by adding that to the target list in config.toml, and then running ./x build --target x86_64-lynx-lynxos178 compiler.","breadcrumbs":"Platform Support  *-lynxos178-*  Building the target","id":"1385","title":"Building the target"},"1386":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will need to build Rust with the target enabled (see \\"Building the target\\" above). Before executing cargo, you must configure the environment to build LynxOS-178 binaries by running source setup.sh from the los178 directory. If your program/crates contain procedural macros, Rust must be able to build binaries for the host as well. The host gcc is hidden by sourcing setup.sh. To deal with this, add the following to your project\'s .cargo/config.toml: [target.x86_64-unknown-linux-gnu]\\nlinker = \\"lynx-host-gcc\\" (If necessary substitute your host target triple for x86_64-unknown-linux-gnu.) To point cargo at the correct rustc binary, set the RUSTC environment variable. The core library should be usable. You can try by building it as part of your project: cargo +nightly build -Z build-std=core --target x86_64-lynx-lynxos178","breadcrumbs":"Platform Support  *-lynxos178-*  Building Rust programs","id":"1386","title":"Building Rust programs"},"1387":{"body":"Binaries built with rust can be provided to a LynxOS-178 instance on its file system, where they can be executed. Rust binaries tend to be large, so it may be necessary to strip them first. It is possible to run the Rust testsuite by providing a test runner that takes the test binary and executes it under LynxOS-178. Most (all?) tests won\'t run without std support though, which is not yet supported.","breadcrumbs":"Platform Support  *-lynxos178-*  Testing","id":"1387","title":"Testing"},"1388":{"body":"LYNX MOSA.ic comes with all the tools required to cross-compile C code for LynxOS-178.","breadcrumbs":"Platform Support  *-lynxos178-*  Cross-compilation toolchains and C code","id":"1388","title":"Cross-compilation toolchains and C code"},"1389":{"body":"Tier: 3 Motorola 680x0 Linux","breadcrumbs":"Platform Support  m68k-unknown-linux-gnu  m68k-unknown-linux-gnu","id":"1389","title":"m68k-unknown-linux-gnu"},"139":{"body":"The lint async-idents has been renamed to keyword-idents .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  async-idents","id":"139","title":"async-idents"},"1390":{"body":"@glaubitz @ricky26","breadcrumbs":"Platform Support  m68k-unknown-linux-gnu  Target Maintainers","id":"1390","title":"Target Maintainers"},"1391":{"body":"This target requires a Linux/m68k build environment for cross-compilation which is available on Debian and Debian-based systems, openSUSE and other distributions. On Debian, it should be sufficient to install a g++ cross-compiler for the m68k architecture which will automatically pull in additional dependencies such as the glibc cross development package: # apt install g++-m68k-linux-gnu Binaries can be run using QEMU user emulation. On Debian-based systems, it should be sufficient to install the package qemu-user-static to be able to run simple static binaries: # apt install qemu-user-static To run more complex programs, it will be necessary to set up a Debian/m68k chroot with the help of the command debootstrap: # apt install debootstrap debian-ports-archive-keyring\\n# debootstrap --keyring=/usr/share/keyrings/debian-ports-archive-keyring.gpg --arch=m68k unstable debian-68k http://ftp.ports.debian.org/debian-ports This chroot can then seamlessly entered using the normal chroot command thanks to QEMU user emulation: # chroot /path/to/debian-68k To get started with native builds, which are currently untested, a native Debian/m68k system can be installed either on real hardware such as 68k-based Commodore Amiga or Atari systems or emulated environments such as QEMU version 4.2 or newer or ARAnyM. ISO images for installation are provided by the Debian Ports team and can be obtained from the Debian CD image server available at: https://cdimage.debian.org/cdimage/ports/current Documentation for Debian/m68k is available on the Debian Wiki at: https://wiki.debian.org/M68k Support is available either through the debian-68k mailing list: https://lists.debian.org/debian-68k/ or the #debian-68k IRC channel on OFTC network.","breadcrumbs":"Platform Support  m68k-unknown-linux-gnu  Requirements","id":"1391","title":"Requirements"},"1392":{"body":"The codegen for this target should be built by default. However, core and std are currently missing but are being worked on and should become available in the near future.","breadcrumbs":"Platform Support  m68k-unknown-linux-gnu  Building","id":"1392","title":"Building"},"1393":{"body":"This target can be cross-compiled from a standard Debian or Debian-based, openSUSE or any other distribution which has a basic m68k cross-toolchain available.","breadcrumbs":"Platform Support  m68k-unknown-linux-gnu  Cross-compilation","id":"1393","title":"Cross-compilation"},"1394":{"body":"Currently there is no support to run the rustc test suite for this target.","breadcrumbs":"Platform Support  m68k-unknown-linux-gnu  Testing","id":"1394","title":"Testing"},"1395":{"body":"Rust programs can be built for that target: rustc --target m68k-unknown-linux-gnu your-code.rs Very simple programs can be run using the qemu-m68k-static program: $ qemu-m68k-static your-code For more complex applications, a chroot or native (emulated) Debian/m68k system are required for testing.","breadcrumbs":"Platform Support  m68k-unknown-linux-gnu  Building Rust programs","id":"1395","title":"Building Rust programs"},"1396":{"body":"Tier: 3 Bare metal Motorola 680x0","breadcrumbs":"Platform Support  m68k-unknown-none-elf  m68k-unknown-none-elf","id":"1396","title":"m68k-unknown-none-elf"},"1397":{"body":"@knickish","breadcrumbs":"Platform Support  m68k-unknown-none-elf  Target Maintainers","id":"1397","title":"Target Maintainers"},"1398":{"body":"This target requires an m68k build environment for cross-compilation which is available on Debian, Debian-based systems, openSUSE, and other distributions. On Debian-based systems, it should be sufficient to install a g++ cross-compiler for the m68k architecture which will automatically pull in additional dependencies such as the glibc cross development package: apt install g++-m68k-linux-gnu Binaries can be run using QEMU user emulation. On Debian-based systems, it should be sufficient to install the package qemu-user-static to be able to run simple static binaries: # apt install qemu-user-static To run more complex programs, it will be necessary to set up a Debian/m68k chroot with the help of the command debootstrap: # apt install debootstrap debian-ports-archive-keyring\\n# debootstrap --keyring=/usr/share/keyrings/debian-ports-archive-keyring.gpg --arch=m68k unstable debian-68k http://ftp.ports.debian.org/debian-ports This chroot can then seamlessly entered using the normal chroot command thanks to QEMU user emulation: # chroot /path/to/debian-68k To get started with native builds, which are currently untested, a native Debian/m68k system can be installed either on real hardware such as 68k-based Commodore Amiga or Atari systems or emulated environments such as QEMU version 4.2 or newer or ARAnyM. ISO images for installation are provided by the Debian Ports team and can be obtained from the Debian CD image server available at: https://cdimage.debian.org/cdimage/ports/current Documentation for Debian/m68k is available on the Debian Wiki at: https://wiki.debian.org/M68k Support is available either through the debian-68k mailing list: https://lists.debian.org/debian-68k/ or the #debian-68k IRC channel on OFTC network.","breadcrumbs":"Platform Support  m68k-unknown-none-elf  Requirements","id":"1398","title":"Requirements"},"1399":{"body":"At least llvm version 19.1.5 is required to build core and alloc for this target, and currently the gnu linker is required, as lld has no support for the m68k architecture","breadcrumbs":"Platform Support  m68k-unknown-none-elf  Building","id":"1399","title":"Building"},"14":{"body":"This flag controls the types of output files generated by the compiler. It accepts a comma-separated list of values, and may be specified multiple times. The valid emit kinds are: asm  Generates a file with the crate\'s assembly code. The default output filename is CRATE_NAME.s. dep-info  Generates a file with Makefile syntax that indicates all the source files that were loaded to generate the crate. The default output filename is CRATE_NAME.d. link  Generates the crates specified by --crate-type. The default output filenames depend on the crate type and platform. This is the default if --emit is not specified. llvm-bc  Generates a binary file containing the LLVM bitcode . The default output filename is CRATE_NAME.bc. llvm-ir  Generates a file containing LLVM IR . The default output filename is CRATE_NAME.ll. metadata  Generates a file containing metadata about the crate. The default output filename is libCRATE_NAME.rmeta. mir  Generates a file containing rustc\'s mid-level intermediate representation. The default output filename is CRATE_NAME.mir. obj  Generates a native object file. The default output filename is CRATE_NAME.o. The output filename can be set with the -o flag . A suffix may be added to the filename with the -C extra-filename flag . Output files are written to the current directory unless the --out-dir flag is used.","breadcrumbs":"Command-line Arguments  --emit: specifies the types of output files to generate","id":"14","title":"--emit: specifies the types of output files to generate"},"140":{"body":"The closure_returning_async_block lint detects cases where users write a closure that returns an async block.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  closure-returning-async-block","id":"140","title":"closure-returning-async-block"},"1400":{"body":"This target can be cross-compiled from a standard Debian or Debian-based, openSUSE or any other distribution which has a basic m68k cross-toolchain available.","breadcrumbs":"Platform Support  m68k-unknown-none-elf  Cross-compilation","id":"1400","title":"Cross-compilation"},"1401":{"body":"Currently there is no support to run the rustc test suite for this target.","breadcrumbs":"Platform Support  m68k-unknown-none-elf  Testing","id":"1401","title":"Testing"},"1402":{"body":"Recommended .cargo/config.toml: [unstable]\\nbuild-std = [\\"panic_abort\\", \\"core\\", \\"alloc\\"] [target.m68k-unknown-none-elf]\\n# as we\'re building for ELF, the m68k-linux linker should be adequate\\nlinker = \\"m68k-linux-gnu-ld\\" # the mold linker also supports m68k, remove the above line and uncomment the\\n# following ones to use that instead\\n# linker = \\"clang\\"\\n# rustflags = [\\"-C\\", \\"link-arg=-fuse-ld=/path/to/mold/binary\\"] Rust programs can be built for this target using: cargo build --target m68k-unknown-none-elf Very simple programs can be run using the qemu-m68k-static program: qemu-m68k-static your-code For more complex applications, a chroot or native m68k system is required for testing.","breadcrumbs":"Platform Support  m68k-unknown-none-elf  Building Rust programs","id":"1402","title":"Building Rust programs"},"1403":{"body":"Tier: 3","breadcrumbs":"Platform Support  mips64-openwrt-linux-musl  mips64-openwrt-linux-musl","id":"1403","title":"mips64-openwrt-linux-musl"},"1404":{"body":"@Itus-Shield","breadcrumbs":"Platform Support  mips64-openwrt-linux-musl  Target maintainers","id":"1404","title":"Target maintainers"},"1405":{"body":"This target is cross-compiled. There is no support for std. There is no default allocator, but it\'s possible to use alloc by supplying an allocator. By default, Rust code generated for this target uses -msoft-float and is dynamically linked. This target generated binaries in the ELF format.","breadcrumbs":"Platform Support  mips64-openwrt-linux-musl  Requirements","id":"1405","title":"Requirements"},"1406":{"body":"This target is built exclusively within the OpenWrt build system via the rust-lang HOST package","breadcrumbs":"Platform Support  mips64-openwrt-linux-musl  Building the target","id":"1406","title":"Building the target"},"1407":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above).","breadcrumbs":"Platform Support  mips64-openwrt-linux-musl  Building Rust programs","id":"1407","title":"Building Rust programs"},"1408":{"body":"As mips64-openwrt-linux-musl supports a variety of different environments and does not support std, this target does not support running the Rust testsuite at this time.","breadcrumbs":"Platform Support  mips64-openwrt-linux-musl  Testing","id":"1408","title":"Testing"},"1409":{"body":"Tier: 3 Target for 64-bit big endian MIPS Linux programs using musl libc and the N64 ABI.","breadcrumbs":"Platform Support  mips64-unknown-linux-muslabi64  mips64-unknown-linux-muslabi64","id":"1409","title":"mips64-unknown-linux-muslabi64"},"141":{"body":"#![warn(closure_returning_async_block)]\\nlet c = |x: &str| async {}; This will produce: warning: closure returning async block can be made into an async closure --> lint_example.rs:3:9 |\\n3 | let c = |x: &str| async {}; | ^^^^^^^^^ ----- this async block can be removed, and the closure can be turned into an async closure |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![warn(closure_returning_async_block)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: turn this into an async closure |\\n3 - let c = |x: &str| async {};\\n3 + let c = async |x: &str| {}; |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"141","title":"Example"},"1410":{"body":"@Gelbpunkt","breadcrumbs":"Platform Support  mips64-unknown-linux-muslabi64  Target maintainers","id":"1410","title":"Target maintainers"},"1411":{"body":"Building the target itself requires a 64-bit big endian MIPS compiler that is supported by cc-rs.","breadcrumbs":"Platform Support  mips64-unknown-linux-muslabi64  Requirements","id":"1411","title":"Requirements"},"1412":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"mips64-unknown-linux-muslabi64\\"] Make sure your C compiler is included in $PATH, then add it to the bootstrap.toml: [target.mips64-unknown-linux-muslabi64]\\ncc = \\"mips64-linux-musl-gcc\\"\\ncxx = \\"mips64-linux-musl-g++\\"\\nar = \\"mips64-linux-musl-ar\\"\\nlinker = \\"mips64-linux-musl-gcc\\"","breadcrumbs":"Platform Support  mips64-unknown-linux-muslabi64  Building the target","id":"1412","title":"Building the target"},"1413":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will first need to build Rust with the target enabled (see \\"Building the target\\" above).","breadcrumbs":"Platform Support  mips64-unknown-linux-muslabi64  Building Rust programs","id":"1413","title":"Building Rust programs"},"1414":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  mips64-unknown-linux-muslabi64  Cross-compilation","id":"1414","title":"Cross-compilation"},"1415":{"body":"This target can be tested as normal with x.py on a 64-bit big endian MIPS host or via QEMU emulation.","breadcrumbs":"Platform Support  mips64-unknown-linux-muslabi64  Testing","id":"1415","title":"Testing"},"1416":{"body":"Tier: 3 Sony PlayStation 1 (psx)","breadcrumbs":"Platform Support  mipsel-sony-psx  mipsel-sony-psx","id":"1416","title":"mipsel-sony-psx"},"1417":{"body":"@ayrtonm","breadcrumbs":"Platform Support  mipsel-sony-psx  Designated Developer","id":"1417","title":"Designated Developer"},"1418":{"body":"This target is cross-compiled. It has no special requirements for the host.","breadcrumbs":"Platform Support  mipsel-sony-psx  Requirements","id":"1418","title":"Requirements"},"1419":{"body":"The target can be built by enabling it for a rustc build: [build]\\nbuild-stage = 1\\ntarget = [\\"mipsel-sony-psx\\"]","breadcrumbs":"Platform Support  mipsel-sony-psx  Building","id":"1419","title":"Building"},"142":{"body":"Using an async closure is preferable over a closure that returns an async block, since async closures are less restrictive in how its captures are allowed to be used. For example, this code does not work with a closure returning an async block: async fn callback(x: &str) {} let captured_str = String::new();\\nlet c = move || async { callback(&captured_str).await;\\n}; But it does work with async closures: async fn callback(x: &str) {} let captured_str = String::new();\\nlet c = async move || { callback(&captured_str).await;\\n};","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"142","title":"Explanation"},"1420":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  mipsel-sony-psx  Cross-compilation","id":"1420","title":"Cross-compilation"},"1421":{"body":"Currently there is no support to run the rustc test suite for this target.","breadcrumbs":"Platform Support  mipsel-sony-psx  Testing","id":"1421","title":"Testing"},"1422":{"body":"Since it is Tier 3, rust doesn\'t ship pre-compiled artifacts for this target. Just use the build-std nightly cargo feature to build the core and alloc libraries: cargo build -Zbuild-std=core,alloc --target mipsel-sony-psx The command above generates an ELF. To generate binaries in the PSEXE format that emulators run, you can use cargo-psx : cargo psx build or use -Clink-arg=--oformat=binary to produce a flat binary.","breadcrumbs":"Platform Support  mipsel-sony-psx  Building Rust programs","id":"1422","title":"Building Rust programs"},"1423":{"body":"Tier: 3 Little-endian 32 bit MIPS for Linux with `glibc.","breadcrumbs":"Platform Support  mipsel-unknown-linux-gnu  mipsel-unknown-linux-gnu","id":"1423","title":"mipsel-unknown-linux-gnu"},"1424":{"body":"@LukasWoodtli","breadcrumbs":"Platform Support  mipsel-unknown-linux-gnu  Target maintainers","id":"1424","title":"Target maintainers"},"1425":{"body":"The target supports std on Linux. Host tools are supported but not tested.","breadcrumbs":"Platform Support  mipsel-unknown-linux-gnu  Requirements","id":"1425","title":"Requirements"},"1426":{"body":"For cross compilation the GNU C compiler for the mipsel architecture needs to be installed. On Ubuntu install the packets: gcc-mipsel-linux-gnu and g++-mipsel-linux-gnu. Add mipsel-unknown-linux-gnu as target list in config.toml.","breadcrumbs":"Platform Support  mipsel-unknown-linux-gnu  Building the target","id":"1426","title":"Building the target"},"1427":{"body":"Rust does not ship pre-compiled artifacts for this target. To compile for this target, you will need to build Rust with the target enabled (see \\"Building the target\\" above).","breadcrumbs":"Platform Support  mipsel-unknown-linux-gnu  Building Rust programs","id":"1427","title":"Building Rust programs"},"1428":{"body":"Tier: 3 MIPS32r2 baremetal softfloat, Big Endian or Little Endian. mips-mti-none-elf mipsel-mti-none-elf","breadcrumbs":"Platform Support  mips*-mti-none-elf  mips*-mti-none-elf","id":"1428","title":"mips*-mti-none-elf"},"1429":{"body":"@wzssyqa","breadcrumbs":"Platform Support  mips*-mti-none-elf  Target maintainers","id":"1429","title":"Target maintainers"},"143":{"body":"The deprecated_safe_2024 lint detects unsafe functions being used as safe functions.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  deprecated-safe-2024","id":"143","title":"deprecated-safe-2024"},"1430":{"body":"These 2 targets, aka mips-mti-none-elf and mipsel-mti-none-elf, are for baremetal development of MIPS32r2. The lld is used instead of Gnu-ld.","breadcrumbs":"Platform Support  mips*-mti-none-elf  Background","id":"1430","title":"Background"},"1431":{"body":"The target only supports cross compilation and no host tools. The target supports alloc with a default allocator while only support no-std development. The vendor name mti follows the naming of gcc to indicate MIPS32r2.","breadcrumbs":"Platform Support  mips*-mti-none-elf  Requirements","id":"1431","title":"Requirements"},"1432":{"body":"Compatible C code can be built for this target on any compiler that has a MIPS32r2 target. On clang and ld.lld linker, it can be generated using the -march=mips/-march=mipsel, -mabi=32 with llvm features flag features=+mips32r2,+soft-float,+noabicalls.","breadcrumbs":"Platform Support  mips*-mti-none-elf  Cross-compilation toolchains and C code","id":"1432","title":"Cross-compilation toolchains and C code"},"1433":{"body":"Tier: 3 MIPS Release 6 , or simply MIPS R6, is the latest iteration of the MIPS instruction set architecture (ISA). MIPS R6 is experimental in nature, as there is not yet real hardware. However, Qemu emulation is available and we have two Linux distros maintained for development and evaluation purposes. This documentation describes the Rust support for MIPS R6 targets under mipsisa*r6*-unknown-linux-gnu*. The target name follow this format: <machine>-<vendor>-<os><abi_suffix>, where <machine> specifies the CPU family/model, <vendor> specifies the vendor and <os> the operating system name. The <abi_suffix> denotes the base ABI (32/n32/64/o64). ABI suffix Description abi64 Uses the 64-bit (64) ABI abin32 Uses the n32 ABI N/A Uses the (assumed) 32-bit (32) ABI","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  mipsisa*r6*-unknown-linux-gnu*","id":"1433","title":"mipsisa*r6*-unknown-linux-gnu*"},"1434":{"body":"@chenx97 @709924470 @Cyanoxygen @Fearyncess","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Target Maintainers","id":"1434","title":"Target Maintainers"},"1435":{"body":"","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Requirements","id":"1435","title":"Requirements"},"1436":{"body":"A GNU toolchain for one of the MIPS R6 target is required. AOSC OS provides working native and cross-compiling build environments. You may also supply your own a toolchain consisting of recent versions of GCC and Binutils.","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  C/C++ Toolchain","id":"1436","title":"C/C++ Toolchain"},"1437":{"body":"A minimum set of libraries is required to perform dynamic linking: GNU glibc OpenSSL Zlib Linux API Headers This set of libraries should be installed to make up minimal target sysroot. For AOSC OS, You may install such a sysroot with the following commands: cd /tmp # linux+api, glibc, and file system structure are included in the toolchain.\\nsudo apt install gcc+cross-mips64r6el binutils+cross-mips64r6el # Download and extract required libraries.\\nwget https://repo.aosc.io/debs/pool/stable/main/z/zlib_1.2.13-0_mips64r6el.deb -O zlib.deb\\nwget https://repo.aosc.io/debs/pool/stable/main/o/openssl_1.1.1q-1_mips64r6el.deb -O openssl.deb # Extract them to your desired location.\\nfor i in zlib openssl ; do sudo dpkg-deb -vx $i.deb /var/ab/cross-root/mips64r6el\\ndone # Workaround a possible ld bug when using -Wl,-Bdynamic.\\nsudo sed -i \'s|/usr|=/usr|g\' /var/ab/cross-root/mips64r6el/usr/lib/libc.so For other distros, you may build them manually.","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Target libraries","id":"1437","title":"Target libraries"},"1438":{"body":"The following procedure outlines the build process for the MIPS64 R6 target with 64-bit (64) ABI (mipsisa64r6el-unknown-linux-gnuabi64).","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Building","id":"1438","title":"Building"},"1439":{"body":"An LLVM bug makes rustc crash if debug or debug info generation is enabled. You need to edit bootstrap.toml to disable this: [rust]\\ndebug = false\\ndebug-info-level = 0","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Prerequisite: Disable debuginfo","id":"1439","title":"Prerequisite: Disable debuginfo"},"144":{"body":"#![deny(deprecated_safe)]\\n// edition 2021\\nuse std::env;\\nfn enable_backtrace() { env::set_var(\\"RUST_BACKTRACE\\", \\"1\\");\\n} This will produce: error: call to deprecated safe function `std::env::set_var` is unsafe and requires unsafe block --> lint_example.rs:6:5 |\\n6 | env::set_var(\\"RUST_BACKTRACE\\", \\"1\\"); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function | = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/newly-unsafe-functions.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(deprecated_safe)] | ^^^^^^^^^^^^^^^ = note: `#[deny(deprecated_safe_2024)]` implied by `#[deny(deprecated_safe)]`\\nhelp: you can wrap the call in an `unsafe` block if you can guarantee that the environment access only happens in single-threaded code |\\n6 + // TODO: Audit that the environment access only happens in single-threaded code.\\n7 ~ unsafe { env::set_var(\\"RUST_BACKTRACE\\", \\"1\\") }; |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"144","title":"Example"},"1440":{"body":"The crate rustix may try to link itself against MIPS R2 assembly, resulting in linkage error. To avoid this, you may force rustix to use its fallback libc backend by setting relevant RUSTFLAGS: export RUSTFLAGS=\\"--cfg rustix_use_libc\\" This will trigger warnings during build, as -D warnings is enabled by default. Disable -D warnings by editing bootstrap.toml to append the following: [rust]\\ndeny-warnings = false","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Prerequisite: Enable rustix\'s libc backend","id":"1440","title":"Prerequisite: Enable rustix\'s libc backend"},"1441":{"body":"As a Tier 3 target, openssl_sys lacks the vendored OpenSSL library for this target. You will need to provide a prebuilt OpenSSL library to link cargo. Since we have a pre-configured sysroot, we can point to it directly: export MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_NO_VENDOR=y\\nexport MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_DIR=\\"/var/ab/cross-root/mips64r6el/usr\\" On Debian, you may need to provide library path and include path separately: export MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_NO_VENDOR=y\\nexport MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_LIB_DIR=\\"/usr/lib/mipsisa64r6el-linux-gnuabi64/\\"\\nexport MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_INCLUDE_DIR=\\"/usr/include\\"","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Prerequisite: Supplying OpenSSL","id":"1441","title":"Prerequisite: Supplying OpenSSL"},"1442":{"body":"[build]\\ntarget = [\\"mipsisa64r6el-unknown-linux-gnuabi64\\"] Make sure that mipsisa64r6el-unknown-linux-gnuabi64-gcc is available from your executable search path ($PATH). Alternatively, you can specify the directories to all necessary toolchain executables in bootstrap.toml: [target.mipsisa64r6el-unknown-linux-gnuabi64]\\n# Adjust the paths below to point to your toolchain installation prefix.\\ncc = \\"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc\\"\\ncxx = \\"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-g++\\"\\nar = \\"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc-ar\\"\\nranlib = \\"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-ranlib\\"\\nlinker = \\"/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc\\" Or, you can specify your cross compiler toolchain with an environment variable: export CROSS_COMPILE=\\"/opt/abcross/mips64r6el/bin/mipsisa64r6el-aosc-linux-gnuabi64-\\" Finally, launch the build script: ./x.py build","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Launching x.py","id":"1442","title":"Launching x.py"},"1443":{"body":"Avoid setting cargo-native-static to false, as this will result in a redundant artifact error while building clippy: duplicate artifacts found when compiling a tool, this typically means that something was recompiled because a transitive dependency has different features activated than in a previous build: the following dependencies have different features: syn 2.0.8 (registry+https://github.com/rust-lang/crates.io-index)\\n`clippy-driver` additionally enabled features {\\"full\\"} at ...\\n`cargo` additionally enabled features {} at ... to fix this you will probably want to edit the local src/tools/rustc-workspace-hack/Cargo.toml crate, as that will update the dependency graph to ensure that these crates all share the same feature set\\nthread \'main\' panicked at \'tools should not compile multiple copies of the same crate\', tool.rs:250:13\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Tips","id":"1443","title":"Tips"},"1444":{"body":"To build Rust programs for MIPS R6 targets, for instance, the mipsisa64r6el-unknown-linux-gnuabi64 target: cargo build --target mipsisa64r6el-unknown-linux-gnuabi64","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Building Rust programs","id":"1444","title":"Building Rust programs"},"1445":{"body":"To test a cross-compiled binary on your build system, install the Qemu user emulator that support the MIPS R6 architecture (qemu-user-mipsel or qemu-user-mips64el). GCC runtime libraries (libgcc_s) for the target architecture should be present in target sysroot to run the program. env \\\\ CARGO_TARGET_MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_LINKER=\\"/opt/abcross/mips64r6el/bin/mipsisa64r6el-aosc-linux-gnuabi64-gcc\\" \\\\ CARGO_TARGET_MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_RUNNER=\\"qemu-mips64el-static -L /var/ab/cross-root/mips64r6el\\" \\\\ cargo run --release \\\\ --target mipsisa64r6el-unknown-linux-gnuabi64","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Testing","id":"1445","title":"Testing"},"1446":{"body":"Until we finalize a fix, please make sure the aforementioned workarounds for rustix crate and LLVM are always applied. This can be achieved by setting the relevant environment variables, and editing Cargo.toml before building.","breadcrumbs":"Platform Support  mipsisa*r6*-unknown-linux-gnu*  Tips for building Rust programs for MIPS R6","id":"1446","title":"Tips for building Rust programs for MIPS R6"},"1447":{"body":"Tier: 2 This is the target meant for deploying code for Nvidia accelerators based on their CUDA platform.","breadcrumbs":"Platform Support  nvptx64-nvidia-cuda  nvptx64-nvidia-cuda","id":"1447","title":"nvptx64-nvidia-cuda"},"1448":{"body":"@RDambrosio016 @kjetilkjeka","breadcrumbs":"Platform Support  nvptx64-nvidia-cuda  Target maintainers","id":"1448","title":"Target maintainers"},"1449":{"body":"This target is no_std and will typically be built with crate-type cdylib and -C linker-flavor=llbc, which generates PTX. The necessary components for this workflow are: rustup toolchain add nightly rustup component add llvm-tools --toolchain nightly rustup component add llvm-bitcode-linker --toolchain nightly There are two options for using the core library: rustup component add rust-src --toolchain nightly and build using -Z build-std=core. rustup target add nvptx64-nvidia-cuda --toolchain nightly","breadcrumbs":"Platform Support  nvptx64-nvidia-cuda  Requirements","id":"1449","title":"Requirements"},"145":{"body":"Rust editions allow the language to evolve without breaking backward compatibility. This lint catches code that uses unsafe functions that were declared as safe (non-unsafe) in editions prior to Rust 2024. If you switch the compiler to Rust 2024 without updating the code, then it will fail to compile if you are using a function previously marked as safe. You can audit the code to see if it suffices the preconditions of the unsafe code, and if it does, you can wrap it in an unsafe block. If you can\'t fulfill the preconditions, you probably need to switch to a different way of doing what you want to achieve. This lint can automatically wrap the calls in unsafe blocks, but this obviously cannot verify that the preconditions of the unsafe functions are fulfilled, so that is still up to the user. The lint is currently \\"allow\\" by default, but that might change in the future.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"145","title":"Explanation"},"1450":{"body":"It is generally necessary to specify the target, such as -C target-cpu=sm_89, because the default is very old. This implies two target features: sm_89 and ptx78 (and all preceding features within sm_* and ptx*). Rust will default to using the oldest PTX version that supports the target processor (see this table ), which maximizes driver compatibility. One can use -C target-feature=+ptx80 to choose a later PTX version without changing the target (the default in this case, ptx78, requires CUDA driver version 11.8, while ptx80 would require driver version 12.0). Later PTX versions may allow more efficient code generation. Although Rust follows LLVM in representing ptx* and sm_* as target features, they should be thought of as having crate granularity, set via (either via -Ctarget-cpu and optionally -Ctarget-feature). While the compiler accepts #[target_feature(enable = \\"ptx80\\", enable = \\"sm_89\\")], it is not supported, may not behave as intended, and may become erroneous in the future.","breadcrumbs":"Platform Support  nvptx64-nvidia-cuda  Target and features","id":"1450","title":"Target and features"},"1451":{"body":"A no_std crate containing one or more functions with extern \\"ptx-kernel\\" can be compiled to PTX using a command like the following. $ RUSTFLAGS=\'-Ctarget-cpu=sm_89\' cargo +nightly rustc --target=nvptx64-nvidia-cuda -Zbuild-std=core --crate-type=cdylib -- -Clinker-flavor=llbc -Zunstable-options Intrinsics in core::arch::nvptx may use #[cfg(target_feature = \\"...\\")], thus it\'s necessary to use -Zbuild-std=core with appropriate RUSTFLAGS. The following components are needed for this workflow: $ rustup component add rust-src --toolchain nightly\\n$ rustup component add llvm-tools --toolchain nightly\\n$ rustup component add llvm-bitcode-linker --toolchain nightly","breadcrumbs":"Platform Support  nvptx64-nvidia-cuda  Building Rust kernels","id":"1451","title":"Building Rust kernels"},"1452":{"body":"powerpc-unknown-openbsd is not maintained by OpenBSD developers and there are currently no active rustc maintainers.","breadcrumbs":"Platform Support  powerpc-unknown-openbsd  Designated maintainers","id":"1452","title":"Designated maintainers"},"1453":{"body":"Tier: 3 powerpc-unknown-linux-gnuspe is a target for Linux on 32-bit PowerPC processors that implement the Signal Processing Engine (SPE), such as e500, and uses a different ABI than standard powerpc-unknown-linux-gnu. When building for other 32-bit PowerPC processors, use powerpc-unknown-linux-gnu instead. See also Debian Wiki for details on this platform, and ABI reference for details on SPE ABI. Note that support for PowerPC SPE by GCC was removed in GCC 9 , so recent GCC cannot be used as linker/compiler for this target.","breadcrumbs":"Platform Support  powerpc-unknown-linux-gnuspe  powerpc-unknown-linux-gnuspe","id":"1453","title":"powerpc-unknown-linux-gnuspe"},"1454":{"body":"There are currently no formally documented target maintainers.","breadcrumbs":"Platform Support  powerpc-unknown-linux-gnuspe  Target maintainers","id":"1454","title":"Target maintainers"},"1455":{"body":"Tier: 3 This target is very similar to already existing ones like powerpc-unknown-linux-musl and powerpc-unknown-linux-gnuspe. This one has PowerPC SPE support for musl. Unfortunately, the last supported gcc version with PowerPC SPE is 8.4.0. See also platform support documentation of powerpc-unknown-linux-gnuspe for information about PowerPC SPE.","breadcrumbs":"Platform Support  powerpc-unknown-linux-muslspe  powerpc-unknown-linux-muslspe","id":"1455","title":"powerpc-unknown-linux-muslspe"},"1456":{"body":"@BKPepe","breadcrumbs":"Platform Support  powerpc-unknown-linux-muslspe  Target maintainers","id":"1456","title":"Target maintainers"},"1457":{"body":"This target is cross-compiled. There is no support for std. There is no default allocator, but it\'s possible to use alloc by supplying an allocator. This target generated binaries in the ELF format.","breadcrumbs":"Platform Support  powerpc-unknown-linux-muslspe  Requirements","id":"1457","title":"Requirements"},"1458":{"body":"This target was tested and used within the OpenWrt build system for CZ.NIC Turris 1.x routers using Freescale P2020.","breadcrumbs":"Platform Support  powerpc-unknown-linux-muslspe  Building the target","id":"1458","title":"Building the target"},"1459":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar.","breadcrumbs":"Platform Support  powerpc-unknown-linux-muslspe  Building Rust programs","id":"1459","title":"Building Rust programs"},"146":{"body":"The deref_into_dyn_supertrait lint is emitted whenever there is a Deref implementation for dyn SubTrait with a dyn SuperTrait type as the Output type. These implementations are \\"shadowed\\" by trait upcasting (stabilized since 1.86.0). The deref functions is no longer called implicitly, which might change behavior compared to previous rustc versions.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  deref-into-dyn-supertrait","id":"146","title":"deref-into-dyn-supertrait"},"1460":{"body":"This is a cross-compiled target and there is no support to run rustc test suite.","breadcrumbs":"Platform Support  powerpc-unknown-linux-muslspe  Testing","id":"1460","title":"Testing"},"1461":{"body":"Tier: 3 Rust for AIX operating system, currently only 64-bit PowerPC is supported.","breadcrumbs":"Platform Support  powerpc64-ibm-aix  powerpc64-ibm-aix","id":"1461","title":"powerpc64-ibm-aix"},"1462":{"body":"@daltenty @gilamn5tr","breadcrumbs":"Platform Support  powerpc64-ibm-aix  Target maintainers","id":"1462","title":"Target maintainers"},"1463":{"body":"This target supports host tools, std and alloc. This target cannot be cross-compiled as for now, mainly because of the unavailability of system linker on other platforms. Binary built for this target is expected to run on Power7 or newer CPU, and AIX 7.2 or newer version. Binary format of this platform is XCOFF . Archive file format is \'AIX big format\' .","breadcrumbs":"Platform Support  powerpc64-ibm-aix  Requirements","id":"1463","title":"Requirements"},"1464":{"body":"This target supports running test suites natively, but it\'s not available to cross-compile and execute in emulator.","breadcrumbs":"Platform Support  powerpc64-ibm-aix  Testing","id":"1464","title":"Testing"},"1465":{"body":"This target supports C code. C code compiled by XL, Open XL and Clang are compatible with Rust. Typical triple of AIX on 64-bit PowerPC of these compilers are also powerpc64-ibm-aix.","breadcrumbs":"Platform Support  powerpc64-ibm-aix  Interoperability with C code","id":"1465","title":"Interoperability with C code"},"1466":{"body":"Tier: 3 Target for 64-bit big endian PowerPC Linux programs using musl libc. This target uses the ELF v2 ABI.","breadcrumbs":"Platform Support  powerpc64-unknown-linux-musl  powerpc64-unknown-linux-musl","id":"1466","title":"powerpc64-unknown-linux-musl"},"1467":{"body":"@Gelbpunkt @famfo @neuschaefer","breadcrumbs":"Platform Support  powerpc64-unknown-linux-musl  Target maintainers","id":"1467","title":"Target maintainers"},"1468":{"body":"Building the target itself requires a 64-bit big endian PowerPC compiler that is supported by cc-rs.","breadcrumbs":"Platform Support  powerpc64-unknown-linux-musl  Requirements","id":"1468","title":"Requirements"},"1469":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"powerpc64-unknown-linux-musl\\"] Make sure your C compiler is included in $PATH, then add it to the bootstrap.toml: [target.powerpc64-unknown-linux-musl]\\ncc = \\"powerpc64-linux-musl-gcc\\"\\ncxx = \\"powerpc64-linux-musl-g++\\"\\nar = \\"powerpc64-linux-musl-ar\\"\\nlinker = \\"powerpc64-linux-musl-gcc\\"","breadcrumbs":"Platform Support  powerpc64-unknown-linux-musl  Building the target","id":"1469","title":"Building the target"},"147":{"body":"#![deny(deref_into_dyn_supertrait)]\\n#![allow(dead_code)] use core::ops::Deref; trait A {}\\ntrait B: A {}\\nimpl<\'a> Deref for dyn \'a + B { type Target = dyn A; fn deref(&self) -> &Self::Target { todo!() }\\n} fn take_a(_: &dyn A) { } fn take_b(b: &dyn B) { take_a(b);\\n} This will produce: error: this `Deref` implementation is covered by an implicit supertrait coercion --> lint_example.rs:9:1 | 9 | impl<\'a> Deref for dyn \'a + B { | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `dyn B` implements `Deref<Target = dyn A>` which conflicts with supertrait `A`\\n10 | type Target = dyn A; | ----------- target type is a supertrait of `dyn B` |\\nnote: the lint level is defined here --> lint_example.rs:1:9 | 1 | #![deny(deref_into_dyn_supertrait)] | ^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"147","title":"Example"},"1470":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will first need to build Rust with the target enabled (see \\"Building the target\\" above).","breadcrumbs":"Platform Support  powerpc64-unknown-linux-musl  Building Rust programs","id":"1470","title":"Building Rust programs"},"1471":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  powerpc64-unknown-linux-musl  Cross-compilation","id":"1471","title":"Cross-compilation"},"1472":{"body":"This target can be tested as normal with x.py on a 64-bit big endian PowerPC host or via QEMU emulation.","breadcrumbs":"Platform Support  powerpc64-unknown-linux-musl  Testing","id":"1472","title":"Testing"},"1473":{"body":"Tier: 2 Target for 64-bit little endian PowerPC Linux programs","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-gnu  powerpc64le-unknown-linux-gnu","id":"1473","title":"powerpc64le-unknown-linux-gnu"},"1474":{"body":"@daltenty @gilamn5tr","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-gnu  Target maintainers","id":"1474","title":"Target maintainers"},"1475":{"body":"Building the target itself requires a 64-bit little endian PowerPC compiler that is supported by cc-rs.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-gnu  Requirements","id":"1475","title":"Requirements"},"1476":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"powerpc64le-unknown-linux-gnu\\"] Make sure your C compiler is included in $PATH, then add it to the config.toml: [target.powerpc64le-unknown-linux-gnu]\\ncc = \\"powerpc64le-linux-gnu-gcc\\"\\ncxx = \\"powerpc64le-linux-gnu-g++\\"\\nar = \\"powerpc64le-linux-gnu-ar\\"\\nlinker = \\"powerpc64le-linux-gnu-gcc\\"","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-gnu  Building the target","id":"1476","title":"Building the target"},"1477":{"body":"This target is distributed through rustup, and requires no special configuration.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-gnu  Building Rust programs","id":"1477","title":"Building Rust programs"},"1478":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-gnu  Cross-compilation","id":"1478","title":"Cross-compilation"},"1479":{"body":"This target can be tested as normal with x.py on a 64-bit little endian PowerPC host or via QEMU emulation.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-gnu  Testing","id":"1479","title":"Testing"},"148":{"body":"The trait upcasting coercion added a new coercion rule, taking priority over certain other coercion rules, which causes some behavior change compared to older rustc versions. deref can be still called explicitly, it just isn\'t called as part of a deref coercion (since trait upcasting coercion takes priority).","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"148","title":"Explanation"},"1480":{"body":"Tier: 2 Target for 64-bit little endian PowerPC Linux programs using musl libc.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-musl  powerpc64le-unknown-linux-musl","id":"1480","title":"powerpc64le-unknown-linux-musl"},"1481":{"body":"@Gelbpunkt @famfo @neuschaefer","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-musl  Target maintainers","id":"1481","title":"Target maintainers"},"1482":{"body":"Building the target itself requires a 64-bit little endian PowerPC compiler that is supported by cc-rs.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-musl  Requirements","id":"1482","title":"Requirements"},"1483":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"powerpc64le-unknown-linux-musl\\"] Make sure your C compiler is included in $PATH, then add it to the bootstrap.toml: [target.powerpc64le-unknown-linux-musl]\\ncc = \\"powerpc64le-linux-musl-gcc\\"\\ncxx = \\"powerpc64le-linux-musl-g++\\"\\nar = \\"powerpc64le-linux-musl-ar\\"\\nlinker = \\"powerpc64le-linux-musl-gcc\\"","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-musl  Building the target","id":"1483","title":"Building the target"},"1484":{"body":"This target are distributed through rustup, and otherwise require no special configuration.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-musl  Building Rust programs","id":"1484","title":"Building Rust programs"},"1485":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-musl  Cross-compilation","id":"1485","title":"Cross-compilation"},"1486":{"body":"This target can be tested as normal with x.py on a 64-bit little endian PowerPC host or via QEMU emulation.","breadcrumbs":"Platform Support  powerpc64le-unknown-linux-musl  Testing","id":"1486","title":"Testing"},"1487":{"body":"Tier: 3 Bare-metal target for RISC-V CPUs with the RV32E, RV32EM and RV32EMC ISAs.","breadcrumbs":"Platform Support  riscv32e*-unknown-none-elf  riscv32{e,em,emc}-unknown-none-elf","id":"1487","title":"riscv32{e,em,emc}-unknown-none-elf"},"1488":{"body":"@hegza","breadcrumbs":"Platform Support  riscv32e*-unknown-none-elf  Target maintainers","id":"1488","title":"Target maintainers"},"1489":{"body":"The target is cross-compiled, and uses static linking. No external toolchain is required and the default rust-lld linker works, but you must specify a linker script.","breadcrumbs":"Platform Support  riscv32e*-unknown-none-elf  Requirements","id":"1489","title":"Requirements"},"149":{"body":"The lint disjoint-capture-migration has been renamed to rust-2021-incompatible-closure-captures .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  disjoint-capture-migration","id":"149","title":"disjoint-capture-migration"},"1490":{"body":"This target is included in Rust and can be installed via rustup.","breadcrumbs":"Platform Support  riscv32e*-unknown-none-elf  Building the target","id":"1490","title":"Building the target"},"1491":{"body":"This is a cross-compiled no-std target, which must be run either in a simulator or by programming them onto suitable hardware. It is not possible to run the Rust test-suite on this target.","breadcrumbs":"Platform Support  riscv32e*-unknown-none-elf  Testing","id":"1491","title":"Testing"},"1492":{"body":"This target supports C code. If interlinking with C or C++, you may need to use riscv32-unknown-elf-gcc as a linker instead of rust-lld.","breadcrumbs":"Platform Support  riscv32e*-unknown-none-elf  Cross-compilation toolchains and C code","id":"1492","title":"Cross-compilation toolchains and C code"},"1493":{"body":"Tier: 2 Bare-metal target for RISC-V CPUs with the RV32I, RV32IM, RV32IMC, RV32IMAFC and RV32IMAC ISAs. Tier: 3 Bare-metal target for RISC-V CPUs with the RV32IMA ISA.","breadcrumbs":"Platform Support  riscv32i*-unknown-none-elf  riscv32{i,im,ima,imc,imac,imafc}-unknown-none-elf","id":"1493","title":"riscv32{i,im,ima,imc,imac,imafc}-unknown-none-elf"},"1494":{"body":"Rust Embedded Working Group, RISC-V team","breadcrumbs":"Platform Support  riscv32i*-unknown-none-elf  Target maintainers","id":"1494","title":"Target maintainers"},"1495":{"body":"The target is cross-compiled, and uses static linking. No external toolchain is required and the default rust-lld linker works, but you must specify a linker script. The riscv-rt crate provides a suitable one. The riscv-rust-quickstart repository gives an example of an RV32 project.","breadcrumbs":"Platform Support  riscv32i*-unknown-none-elf  Requirements","id":"1495","title":"Requirements"},"1496":{"body":"This target is included in Rust and can be installed via rustup.","breadcrumbs":"Platform Support  riscv32i*-unknown-none-elf  Building the target","id":"1496","title":"Building the target"},"1497":{"body":"This is a cross-compiled no-std target, which must be run either in a simulator or by programming them onto suitable hardware. It is not possible to run the Rust test-suite on this target.","breadcrumbs":"Platform Support  riscv32i*-unknown-none-elf  Testing","id":"1497","title":"Testing"},"1498":{"body":"This target supports C code. If interlinking with C or C++, you may need to use riscv32-unknown-elf-gcc as a linker instead of rust-lld.","breadcrumbs":"Platform Support  riscv32i*-unknown-none-elf  Cross-compilation toolchains and C code","id":"1498","title":"Cross-compilation toolchains and C code"},"1499":{"body":"Tier: 3 RISC Zero\'s Zero Knowledge Virtual Machine (zkVM) implementing the RV32IM instruction set.","breadcrumbs":"Platform Support  riscv32im-risc0-zkvm-elf  riscv32im-risc0-zkvm-elf","id":"1499","title":"riscv32im-risc0-zkvm-elf"},"15":{"body":"Each emit type can optionally be followed by = to specify an explicit output path that only applies to the output of that type. For example: --emit=link,dep-info=/path/to/dep-info.d Emit the crate itself as normal, and also emit dependency info to the specified path. --emit=llvm-ir=-,mir Emit MIR to the default filename (based on crate name), and emit LLVM IR to stdout.","breadcrumbs":"Command-line Arguments  Custom paths for individual emit kinds","id":"15","title":"Custom paths for individual emit kinds"},"150":{"body":"The edition_2024_expr_fragment_specifier lint detects the use of expr fragments in macros during migration to the 2024 edition. The expr fragment specifier will accept more expressions in the 2024 edition. To maintain the behavior from the 2021 edition and earlier, use the expr_2021 fragment specifier.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  edition-2024-expr-fragment-specifier","id":"150","title":"edition-2024-expr-fragment-specifier"},"1500":{"body":"@flaub @jbruestle","breadcrumbs":"Platform Support  riscv32im-risc0-zkvm-elf  Target maintainers","id":"1500","title":"Target maintainers"},"1501":{"body":"This target is an execution environment to produce a proof of execution of a RISC-V ELF binary and any output that the developer of the binary wishes to display publicly. In order to do this, the target will execute the ELF to generate a receipt containing the output of the computation along with a cryptographic seal. This receipt can be verified to ensure the integrity of the computation and its result. This target is implemented as software only; it has no hardware implementation. We have a cargo extension called cargo-risczero that allow users to generate project templates, install tools for improved user experience, build the binary using a docker environment and test programs.","breadcrumbs":"Platform Support  riscv32im-risc0-zkvm-elf  Background","id":"1501","title":"Background"},"1502":{"body":"The target only supports cross compilation and no host tools. The target supports alloc with a default allocator and has experimental support for std. The target expects the binaries to be in ELF. The target\'s execution environment is single threaded, non-preemptive, and does not support any privileged instructions, nor unaligned accesses. At the time of writing the VM has 192 MB of memory and text/data, heap, and stack need to be with in the address range 0x400 - 0x0C000000. The binaries themselves expect no operating system and can be thought of as running on bare-metal. The target does not use #[target_feature(...)] or -C target-feature= values. Calling extern \\"C\\" on the target uses the C calling convention outlined in the RISC-V specification .","breadcrumbs":"Platform Support  riscv32im-risc0-zkvm-elf  Requirements","id":"1502","title":"Requirements"},"1503":{"body":"Programs for the zkVM could be built by adding it to the target list in bootstrap.toml. However, we recommend building programs in our starter template generated by the cargo-risczero utility and the risc0-build crate. This crate calls rustc with -C \\"link-arg=-Ttext= so that it maps the text in the appropriate location as well as generating variables that represent the ELF and a unique ID associated with the ELF. The starter template provides developers with system calls that are useful to zero knowledge computing such as writing to the public output, hashing using sha256, and multiply big integers.","breadcrumbs":"Platform Support  riscv32im-risc0-zkvm-elf  Building for the zkVM","id":"1503","title":"Building for the zkVM"},"1504":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above). We do not recommend using build-std as we have run into issues building core in the past on our starter template. An alternate solution is to download the risc0 tool chain by running cargo risczero install.","breadcrumbs":"Platform Support  riscv32im-risc0-zkvm-elf  Building Rust programs","id":"1504","title":"Building Rust programs"},"1505":{"body":"Note: the target is implemented as a software emulator called the zkVM and there is no hardware implementation of the target. The most practical way to test the target program is to use our starter template that can be generated by using the cargo risczero new command. The template generates a sample \\"host\\" and \\"guest\\" code. The guest code compiled to the target (which is RV32IM) whereas the \\"host\\" code is compiled to run on the programmer\'s machine running either a Linux distribution or macOS. The host program is responsible for running the guest binary on the zkVM and retrieving its public output. The target currently does not support running the Rust test suite.","breadcrumbs":"Platform Support  riscv32im-risc0-zkvm-elf  Testing","id":"1505","title":"Testing"},"1506":{"body":"Compatible C code can be built for this target on any compiler that has a RV32IM target. On clang and ld.lld linker, it can be generated using the -march=rv32im, -mabi=ilp32 with llvm features flag features=+m and llvm target riscv32-unknown-none.","breadcrumbs":"Platform Support  riscv32im-risc0-zkvm-elf  Cross-compilation toolchains and C code","id":"1506","title":"Cross-compilation toolchains and C code"},"1507":{"body":"Tier: 3 Xous microkernel, message-based operating system that powers devices such as Precursor and Betrusted. The operating system is written entirely in Rust, so no additional software is required to compile programs for Xous.","breadcrumbs":"Platform Support  riscv32imac-unknown-xous-elf  riscv32imac-unknown-xous-elf","id":"1507","title":"riscv32imac-unknown-xous-elf"},"1508":{"body":"@xobs","breadcrumbs":"Platform Support  riscv32imac-unknown-xous-elf  Target maintainers","id":"1508","title":"Target maintainers"},"1509":{"body":"Building the target itself requires a RISC-V compiler that is supported by cc-rs. For example, you can use the prebuilt xPack toolchain. Cross-compiling programs does not require any additional software beyond the toolchain. Prebuilt versions of the toolchain are available from Betrusted .","breadcrumbs":"Platform Support  riscv32imac-unknown-xous-elf  Requirements","id":"1509","title":"Requirements"},"151":{"body":"#![deny(edition_2024_expr_fragment_specifier)]\\nmacro_rules! m { ($e:expr) => { $e }\\n} fn main() { m!(1);\\n} This will produce: error: the `expr` fragment specifier will accept more expressions in the 2024 edition --> lint_example.rs:3:7 |\\n3 | ($e:expr) => { | ^^^^ | = warning: this changes meaning in Rust 2024 = note: for more information, see Migration Guide <https://doc.rust-lang.org/edition-guide/rust-2024/macro-fragment-specifiers.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(edition_2024_expr_fragment_specifier)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: to keep the existing behavior, use the `expr_2021` fragment specifier |\\n3 | ($e:expr_2021) => { | +++++","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"151","title":"Example"},"1510":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"riscv32imac-unknown-xous-elf\\"] Make sure your C compiler is included in $PATH, then add it to the bootstrap.toml: [target.riscv32imac-unknown-xous-elf]\\ncc = \\"riscv-none-elf-gcc\\"\\nar = \\"riscv-none-elf-ar\\"","breadcrumbs":"Platform Support  riscv32imac-unknown-xous-elf  Building the target","id":"1510","title":"Building the target"},"1511":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will need to do one of the following: Build Rust with the target enabled (see \\"Building the target\\" above) Build your own copy of core by using build-std or similar Download a prebuilt toolchain from Betrusted","breadcrumbs":"Platform Support  riscv32imac-unknown-xous-elf  Building Rust programs","id":"1511","title":"Building Rust programs"},"1512":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  riscv32imac-unknown-xous-elf  Cross-compilation","id":"1512","title":"Cross-compilation"},"1513":{"body":"Currently there is no support to run the rustc test suite for this target.","breadcrumbs":"Platform Support  riscv32imac-unknown-xous-elf  Testing","id":"1513","title":"Testing"},"1514":{"body":"Tier: 2 (with Host Tools) RISC-V targets using the RV64I base instruction set with the G collection of extensions, as well as the C extension.","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-gnu  riscv64gc-unknown-linux-gnu","id":"1514","title":"riscv64gc-unknown-linux-gnu"},"1515":{"body":"@kito-cheng @michaelmaitland @robin-randhawa-sifive @topperc","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-gnu  Target maintainers","id":"1515","title":"Target maintainers"},"1516":{"body":"This target requires: Linux Kernel version 4.20 or later glibc 2.17 or later","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-gnu  Requirements","id":"1516","title":"Requirements"},"1517":{"body":"These targets are distributed through rustup, and otherwise require no special configuration. If you need to build your own Rust for some reason though, the targets can be enabled in bootstrap.toml. For example: [build]\\ntarget = [\\"riscv64gc-unknown-linux-gnu\\"]","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-gnu  Building the target","id":"1517","title":"Building the target"},"1518":{"body":"On a RISC-V host, the riscv64gc-unknown-linux-gnu target should be automatically installed and used by default. On a non-RISC-V host, add the target: rustup target add riscv64gc-unknown-linux-gnu Then cross compile crates with: cargo build --target riscv64gc-unknown-linux-gnu","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-gnu  Building Rust programs","id":"1518","title":"Building Rust programs"},"1519":{"body":"There are no special requirements for testing and running the targets. For testing cross builds on the host, please refer to the \\"Cross-compilation toolchains and C code\\" section below.","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-gnu  Testing","id":"1519","title":"Testing"},"152":{"body":"Rust editions allow the language to evolve without breaking backwards compatibility. This lint catches code that uses macro matcher fragment specifiers that have changed meaning in the 2024 edition. If you switch to the new edition without updating the code, your macros may behave differently. In the 2024 edition, the expr fragment specifier expr will also match const { ... } blocks. This means if a macro had a pattern that matched $e:expr and another that matches const { $e: expr }, for example, that under the 2024 edition the first pattern would match while in the 2021 and earlier editions the second pattern would match. To keep the old behavior, use the expr_2021 fragment specifier. This lint detects macros whose behavior might change due to the changing meaning of the expr fragment specifier. It is \\"allow\\" by default because the code is perfectly valid in older editions. The cargo fix tool with the --edition flag will switch this lint to \\"warn\\" and automatically apply the suggested fix from the compiler. This provides a completely automated way to update old code for a new edition. Using cargo fix --edition with this lint will ensure that your code retains the same behavior. This may not be the desired, as macro authors often will want their macros to use the latest grammar for matching expressions. Be sure to carefully review changes introduced by this lint to ensure the macros implement the desired behavior.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"152","title":"Explanation"},"1520":{"body":"A RISC-V toolchain can be obtained for Windows/Mac/Linux from the riscv-gnu-toolchain repository. Binaries are available via embecosm , and may also be available from your OS\'s package manager. On Ubuntu, a RISC-V toolchain can be installed with: apt install gcc-riscv64-linux-gnu g++-riscv64-linux-gnu libc6-dev-riscv64-cross Depending on your system, you may need to configure the target to use the GNU GCC linker. To use it, add the following to your .cargo/config.toml: [target.riscv64gc-unknown-linux-gnu]\\nlinker = \\"riscv64-linux-gnu-gcc\\" If your riscv64-linux-gnu-* toolchain is not in your PATH you may need to configure additional settings: [target.riscv64gc-unknown-linux-gnu]\\n# Adjust the paths to point at your toolchain\\ncc = \\"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-gcc\\"\\ncxx = \\"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-g++\\"\\nar = \\"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-ar\\"\\nranlib = \\"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-ranlib\\"\\nlinker = \\"/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-gcc\\" To test cross compiled binaries on a non-RISCV-V host, you can use qemu . On Ubuntu, a RISC-V emulator can be obtained with: apt install qemu-system-riscv64 Then, in .cargo/config.toml set the runner: [target.riscv64gc-unknown-linux-gnu]\\nrunner = \\"qemu-riscv64-static -L /usr/riscv64-linux-gnu -cpu rv64\\" On Mac and Linux, it\'s also possible to use lima to emulate RISC-V in a similar way to how WSL2 works on Windows: limactl start template://riscv\\nlimactl shell riscv Using Docker (with BuildKit) the riscv64/ubuntu image can be used to build or run riscv64gc-unknown-linux-gnu binaries. docker run --platform linux/riscv64 -ti --rm --mount \\"type=bind,src=$(pwd),dst=/checkout\\" riscv64/ubuntu bash","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-gnu  Cross-compilation toolchains and C code","id":"1520","title":"Cross-compilation toolchains and C code"},"1521":{"body":"Tier: 2 Target for RISC-V Linux programs using musl libc.","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-musl  riscv64gc-unknown-linux-musl","id":"1521","title":"riscv64gc-unknown-linux-musl"},"1522":{"body":"@Amanieu @kraj","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-musl  Target maintainers","id":"1522","title":"Target maintainers"},"1523":{"body":"Building the target itself requires a RISC-V compiler that is supported by cc-rs.","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-musl  Requirements","id":"1523","title":"Requirements"},"1524":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"riscv64gc-unknown-linux-musl\\"] Make sure your C compiler is included in $PATH, then add it to the bootstrap.toml: [target.riscv64gc-unknown-linux-musl]\\ncc = \\"riscv64-linux-gnu-gcc\\"\\ncxx = \\"riscv64-linux-gnu-g++\\"\\nar = \\"riscv64-linux-gnu-ar\\"\\nlinker = \\"riscv64-linux-gnu-gcc\\"","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-musl  Building the target","id":"1524","title":"Building the target"},"1525":{"body":"This target are distributed through rustup, and otherwise require no special configuration.","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-musl  Building Rust programs","id":"1525","title":"Building Rust programs"},"1526":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-musl  Cross-compilation","id":"1526","title":"Cross-compilation"},"1527":{"body":"This target can be tested as normal with x.py on a RISC-V host or via QEMU emulation.","breadcrumbs":"Platform Support  riscv64gc-unknown-linux-musl  Testing","id":"1527","title":"Testing"},"1528":{"body":"Tier: 3 RISC-V target using the ratified RVA23 Profile . This target will enable all mandary features of rva23u64 by default.","breadcrumbs":"Platform Support  riscv64a23-unknown-linux-gnu  riscv64a23-unknown-linux-gnu","id":"1528","title":"riscv64a23-unknown-linux-gnu"},"1529":{"body":"@ZhongyaoChen @CaiWeiran","breadcrumbs":"Platform Support  riscv64a23-unknown-linux-gnu  Target maintainers","id":"1529","title":"Target maintainers"},"153":{"body":"The lint elided-lifetime-in-path has been renamed to elided-lifetimes-in-paths .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  elided-lifetime-in-path","id":"153","title":"elided-lifetime-in-path"},"1530":{"body":"This target can be sucessfully build on the following platform: ubuntu 24.04 (Linux Kernel version 6.8.0, glibc 2.39). Other platforms may work, but are not tested. Please contanct if you encounter any issues.","breadcrumbs":"Platform Support  riscv64a23-unknown-linux-gnu  Requirements","id":"1530","title":"Requirements"},"1531":{"body":"Tier-3 target is not distributed through rustup. You need to build your own Rust, the target can be build with: ./x build --target riscv64a23-unknown-linux-gnu","breadcrumbs":"Platform Support  riscv64a23-unknown-linux-gnu  Building the target","id":"1531","title":"Building the target"},"1532":{"body":"Add the toolchain: rustup toolchain link rva23-toolchain {path-to-rust}/build/host/stage2 Then cross compile crates with: RUSTFLAGS=\\"-C linker=riscv64-linux-gnu-gcc\\" cargo +rva23-toolchain build --target=riscv64a23-unknown-linux-gnu","breadcrumbs":"Platform Support  riscv64a23-unknown-linux-gnu  Building Rust programs","id":"1532","title":"Building Rust programs"},"1533":{"body":"Tier: 2 (with Host Tools) IBM z/Architecture (s390x) targets (including IBM Z and LinuxONE) running Linux.","breadcrumbs":"Platform Support  s390x-unknown-linux-gnu  s390x-unknown-linux-gnu","id":"1533","title":"s390x-unknown-linux-gnu"},"1534":{"body":"@uweigand @cuviper","breadcrumbs":"Platform Support  s390x-unknown-linux-gnu  Target maintainers","id":"1534","title":"Target maintainers"},"1535":{"body":"This target requires: Linux Kernel version 3.2 or later glibc 2.17 or later Code generated by the target uses the z/Architecture ISA assuming a minimum architecture level of z10 (Eighth Edition of the z/Architecture Principles of Operation), and is compliant with the s390x ELF ABI. Reference material: z/Architecture Principles of Operation z/Architecture ELF Application Binary Interface","breadcrumbs":"Platform Support  s390x-unknown-linux-gnu  Requirements","id":"1535","title":"Requirements"},"1536":{"body":"This target is distributed through rustup, and otherwise requires no special configuration. If you need to build your own Rust for some reason though, the target can be enabled in bootstrap.toml. For example: [build]\\ntarget = [\\"s390x-unknown-linux-gnu\\"]","breadcrumbs":"Platform Support  s390x-unknown-linux-gnu  Building the target","id":"1536","title":"Building the target"},"1537":{"body":"On a s390x Linux host, the s390x-unknown-linux-gnu target should be automatically installed and used by default. On a non-s390x host, add the target: rustup target add s390x-unknown-linux-gnu Then cross compile crates with: cargo build --target s390x-unknown-linux-gnu","breadcrumbs":"Platform Support  s390x-unknown-linux-gnu  Building Rust programs","id":"1537","title":"Building Rust programs"},"1538":{"body":"There are no special requirements for testing and running the target. For testing cross builds on the host, please refer to the \\"Cross-compilation toolchains and C code\\" section below. If you want to do native testing but do not have your own s390x machine, there are several options how to get access to one: The IBM LinuxONE Community Cloud provides a self-service portal where you can create s390x virtual machine instances. These are intended for temporary use (limited to 120 days). The IBM LinuxONE Open Source Cloud provides permanent access to s390x machines. This requires approval by IBM, which will normally be granted if you\'re planning to use the machine to work on an open-source project that is relevant to the IBM Z ecosystem - the Rust compiler would certainly qualify.","breadcrumbs":"Platform Support  s390x-unknown-linux-gnu  Testing","id":"1538","title":"Testing"},"1539":{"body":"Rust code built using the target is compatible with C code compiled with GCC or Clang using the s390x-unknown-linux-gnu target triple (via either native or cross-compilation). On Ubuntu, a s390x cross-toolchain can be installed with: apt install gcc-s390x-linux-gnu g++-s390x-linux-gnu libc6-dev-s390x-cross Depending on your system, you may need to configure the target to use the GNU GCC linker. To use it, add the following to your .cargo/config.toml: [target.s390x-unknown-linux-gnu]\\nlinker = \\"s390x-linux-gnu-gcc\\" If your s390x-linux-gnu-* toolchain is not in your PATH you may need to configure additional settings: [target.s390x-unknown-linux-gnu]\\n# Adjust the paths to point at your toolchain\\ncc = \\"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-gcc\\"\\ncxx = \\"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-g++\\"\\nar = \\"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-ar\\"\\nranlib = \\"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-ranlib\\"\\nlinker = \\"/TOOLCHAIN_PATH/bin/s390x-linux-gnu-gcc\\" To test cross compiled binaries on a non-s390x host, you can use qemu . On Ubuntu, a s390x emulator can be obtained with: apt install qemu-system-s390x Then, in .cargo/config.toml set the runner: [target.s390x-unknown-linux-gnu]\\nrunner = \\"qemu-s390x-static -L /usr/s390x-linux-gnu\\"","breadcrumbs":"Platform Support  s390x-unknown-linux-gnu  Cross-compilation toolchains and C code","id":"1539","title":"Cross-compilation toolchains and C code"},"154":{"body":"The elided_lifetimes_in_paths lint detects the use of hidden lifetime parameters.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  elided-lifetimes-in-paths","id":"154","title":"elided-lifetimes-in-paths"},"1540":{"body":"Tier: 3 IBM z/Architecture (s390x) targets (including IBM Z and LinuxONE) running Linux.","breadcrumbs":"Platform Support  s390x-unknown-linux-musl  s390x-unknown-linux-musl","id":"1540","title":"s390x-unknown-linux-musl"},"1541":{"body":"@uweigand","breadcrumbs":"Platform Support  s390x-unknown-linux-musl  Target maintainers","id":"1541","title":"Target maintainers"},"1542":{"body":"This target requires: Linux Kernel version 3.2 or later musl 1.2.3 or later Code generated by the target uses the z/Architecture ISA assuming a minimum architecture level of z10 (Eighth Edition of the z/Architecture Principles of Operation), and is compliant with the s390x ELF ABI. Reference material: z/Architecture Principles of Operation z/Architecture ELF Application Binary Interface","breadcrumbs":"Platform Support  s390x-unknown-linux-musl  Requirements","id":"1542","title":"Requirements"},"1543":{"body":"Because it is Tier 3, Rust does not yet ship pre-compiled artifacts for this target. Therefore, you can build Rust with support for the target by adding it to the target list in bootstrap.toml, a sample configuration is shown below. [build]\\ntarget = [\\"s390x-unknown-linux-musl\\"]","breadcrumbs":"Platform Support  s390x-unknown-linux-musl  Building the target","id":"1543","title":"Building the target"},"1544":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will first need to build Rust with the target enabled (see \\"Building the target\\" above).","breadcrumbs":"Platform Support  s390x-unknown-linux-musl  Building Rust programs","id":"1544","title":"Building Rust programs"},"1545":{"body":"There are no special requirements for testing and running the target. For testing cross builds on the host, please refer to the \\"Cross-compilation toolchains and C code\\" section below.","breadcrumbs":"Platform Support  s390x-unknown-linux-musl  Testing","id":"1545","title":"Testing"},"1546":{"body":"Rust code built using the target is compatible with C code compiled with GCC or Clang using the s390x-unknown-linux-musl target triple (via either native or cross-compilation). Depending on your system, you may need to configure the target to use the GNU GCC linker. To use it, add the following to your .cargo/config.toml: [target.s390x-unknown-linux-musl]\\nlinker = \\"s390x-linux-musl-gcc\\" If your s390x-linux-musl-* toolchain is not in your PATH you may need to configure additional settings: [target.s390x-unknown-linux-musl]\\n# Adjust the paths to point at your toolchain\\ncc = \\"/TOOLCHAIN_PATH/bin/s390x-linux-musl-gcc\\"\\ncxx = \\"/TOOLCHAIN_PATH/bin/s390x-linux-musl-g++\\"\\nar = \\"/TOOLCHAIN_PATH/bin/s390x-linux-musl-ar\\"\\nranlib = \\"/TOOLCHAIN_PATH/bin/s390x-linux-musl-ranlib\\"\\nlinker = \\"/TOOLCHAIN_PATH/bin/s390x-linux-musl-gcc\\" To test cross compiled binaries on a non-s390x host, you can use qemu .","breadcrumbs":"Platform Support  s390x-unknown-linux-musl  Cross-compilation toolchains and C code","id":"1546","title":"Cross-compilation toolchains and C code"},"1547":{"body":"Tier: 3 Rust for bare-metal 32-bit SPARC V7 and V8 systems, e.g. the Gaisler LEON3. Target Descriptions sparc-unknown-none-elf SPARC V7 32-bit (freestanding, hardfloat)","breadcrumbs":"Platform Support  sparc-unknown-none-elf  sparc-unknown-none-elf","id":"1547","title":"sparc-unknown-none-elf"},"1548":{"body":"@jonathanpallant","breadcrumbs":"Platform Support  sparc-unknown-none-elf  Target maintainers","id":"1548","title":"Target maintainers"},"1549":{"body":"This target is cross-compiled. There is no support for std. There is no default allocator, but it\'s possible to use alloc by supplying an allocator. By default, code generated with this target should run on any SPARC hardware; enabling additional target features may raise this baseline. -Ctarget-cpu=v8 adds the extra SPARC V8 instructions. -Ctarget-cpu=leon3 adds the SPARC V8 instructions and sets up scheduling to suit the Gaisler Leon3. Functions marked extern \\"C\\" use the standard SPARC architecture calling convention . This target generates ELF binaries. Any alternate formats or special considerations for binary layout will require linker options or linker scripts.","breadcrumbs":"Platform Support  sparc-unknown-none-elf  Requirements","id":"1549","title":"Requirements"},"155":{"body":"#![deny(elided_lifetimes_in_paths)]\\n#![deny(warnings)]\\nstruct Foo<\'a> { x: &\'a u32\\n} fn foo(x: &Foo) {\\n} This will produce: error: hidden lifetime parameters in types are deprecated --> lint_example.rs:8:12 |\\n8 | fn foo(x: &Foo) { | ^^^ expected lifetime parameter |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(elided_lifetimes_in_paths)] | ^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: indicate the anonymous lifetime |\\n8 | fn foo(x: &Foo<\'_>) { | ++++","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"155","title":"Example"},"1550":{"body":"You can build Rust with support for the target by adding it to the target list in bootstrap.toml: [build]\\nbuild-stage = 1\\nhost = [\\"<target for your host>\\"]\\ntarget = [\\"<target for your host>\\", \\"sparc-unknown-none-elf\\"] Replace <target for your host> with x86_64-unknown-linux-gnu or whatever else is appropriate for your host machine.","breadcrumbs":"Platform Support  sparc-unknown-none-elf  Building the target","id":"1550","title":"Building the target"},"1551":{"body":"To build with this target, pass it to the --target argument, like: cargo build --target sparc-unknown-none-elf This target uses GCC as a linker, and so you will need an appropriate GCC compatible sparc-unknown-none toolchain. The default linker binary is sparc-elf-gcc, but you can override this in your project configuration, as follows: .cargo/config.toml: [target.sparc-unknown-none-elf]\\nlinker = \\"sparc-custom-elf-gcc\\"","breadcrumbs":"Platform Support  sparc-unknown-none-elf  Building Rust programs","id":"1551","title":"Building Rust programs"},"1552":{"body":"As sparc-unknown-none-elf supports a variety of different environments and does not support std, this target does not support running the Rust test suite.","breadcrumbs":"Platform Support  sparc-unknown-none-elf  Testing","id":"1552","title":"Testing"},"1553":{"body":"This target was initially tested using BCC2 from Gaisler, along with the TSIM Leon3 processor simulator. Both BCC2 GCC and BCC2 Clang have been shown to work. To work with these tools, your project configuration should contain something like: .cargo/config.toml: [target.sparc-unknown-none-elf]\\nlinker = \\"sparc-gaisler-elf-gcc\\"\\nrunner = \\"tsim-leon3\\" [build]\\ntarget = [\\"sparc-unknown-none-elf\\"]\\nrustflags = \\"-Ctarget-cpu=leon3\\" With this configuration, running cargo run will compile your code for the SPARC V8 compatible Gaisler Leon3 processor and then start the tsim-leon3 simulator. The libcore was pre-compiled as part of the rustc compilation process using the SPARC V7 baseline, but if you are using a nightly toolchain you can use the -Z build-std=core option to rebuild libcore from source. This may be useful if you want to compile it for SPARC V8 and take advantage of the extra instructions. .cargo/config.toml: [target.sparc-unknown-none-elf]\\nlinker = \\"sparc-gaisler-elf-gcc\\"\\nrunner = \\"tsim-leon3\\" [build]\\ntarget = [\\"sparc-unknown-none-elf\\"]\\nrustflags = \\"-Ctarget-cpu=leon3\\" [unstable]\\nbuild-std = [\\"core\\"] Either way, once the simulator is running, simply enter the command run to start the code executing in the simulator. The default C toolchain libraries are linked in, so with the Gaisler BCC2 toolchain, and using its default Leon3 BSP, you can use call the C putchar function and friends to output to the simulator console. The default linker script is also appropriate for the Leon3 simulator, so no linker script is required. Here\'s a complete example using the above config file: #![no_std]\\n#![no_main] extern \\"C\\" { fn putchar(ch: i32); fn _exit(code: i32) -> !;\\n} #[no_mangle]\\nextern \\"C\\" fn main() -> i32 { let message = \\"Hello, this is Rust!\\"; for b in message.bytes() { unsafe { putchar(b as i32); } } 0\\n} #[panic_handler]\\nfn panic(_panic: &core::panic::PanicInfo) -> ! { unsafe { _exit(1); }\\n} $ cargo run --target=sparc-unknown-none-elf Compiling sparc-demo-rust v0.1.0 (/work/sparc-demo-rust) Finished dev [unoptimized + debuginfo] target(s) in 3.44s Running `tsim-leon3 target/sparc-unknown-none-elf/debug/sparc-demo-rust` TSIM3 LEON3 SPARC simulator, version 3.1.9 (evaluation version) Copyright (C) 2023, Frontgrade Gaisler - all rights reserved. This software may only be used with a valid license. For latest updates, go to https://www.gaisler.com/ Comments or bug-reports to support@gaisler.com This TSIM evaluation version will expire 2023-11-28 Number of CPUs: 2\\nsystem frequency: 50.000 MHz\\nicache: 1 * 4 KiB, 16 bytes/line (4 KiB total)\\ndcache: 1 * 4 KiB, 16 bytes/line (4 KiB total)\\nAllocated 8192 KiB SRAM memory, in 1 bank at 0x40000000\\nAllocated 32 MiB SDRAM memory, in 1 bank at 0x60000000\\nAllocated 8192 KiB ROM memory at 0x00000000\\nsection: .text, addr: 0x40000000, size: 20528 bytes\\nsection: .rodata, addr: 0x40005030, size: 128 bytes\\nsection: .data, addr: 0x400050b0, size: 1176 bytes\\nread 347 symbols tsim> run Initializing and starting from 0x40000000\\nHello, this is Rust! Program exited normally on CPU 0.\\ntsim>","breadcrumbs":"Platform Support  sparc-unknown-none-elf  Cross-compilation toolchains and C code","id":"1553","title":"Cross-compilation toolchains and C code"},"1554":{"body":"","breadcrumbs":"Platform Support  solaris  sparcv9-sun-solaris","id":"1554","title":"sparcv9-sun-solaris"},"1555":{"body":"Tier: 2 Rust for Solaris operating system.","breadcrumbs":"Platform Support  solaris  x86_64-pc-solaris","id":"1555","title":"x86_64-pc-solaris"},"1556":{"body":"@psumbera @kulikjak","breadcrumbs":"Platform Support  solaris  Target maintainers","id":"1556","title":"Target maintainers"},"1557":{"body":"The sparcv9-sun-solaris and x86_64-pc-solaris targets are Tier 2 with host tools. Binary built for these targets are expected to run on sparcv9 or x86_64, and Solaris 11.4.","breadcrumbs":"Platform Support  solaris  Requirements","id":"1557","title":"Requirements"},"1558":{"body":"For testing you can download Oracle Solaris 11.4 CBE release from: https://www.oracle.com/uk/solaris/solaris11/downloads/solaris-downloads.html Solaris CBE release is also available for GitHub CI: https://github.com/vmactions/solaris-vm Latest Solaris 11.4 SRU can be tested at Compile farm project: https://portal.cfarm.net/machines/list/ (cfarm215, cfarm215) There are no official Rust binaries for Solaris available for Rustup yet. But you can eventually download unofficial from: https://github.com/psumbera/solaris-rust","breadcrumbs":"Platform Support  solaris  Testing","id":"1558","title":"Testing"},"1559":{"body":"Tier: 3 The QNX Neutrino (nto) Real-time operating system. Known as QNX OS from version 8 onwards. This support has been implemented jointly by Elektrobit Automotive GmbH and QNX .","breadcrumbs":"Platform Support  *-nto-qnx-*  nto-qnx","id":"1559","title":"nto-qnx"},"156":{"body":"Elided lifetime parameters can make it difficult to see at a glance that borrowing is occurring. This lint ensures that lifetime parameters are always explicitly stated, even if it is the \'_ placeholder lifetime . This lint is \\"allow\\" by default because it has some known issues, and may require a significant transition for old code.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"156","title":"Explanation"},"1560":{"body":"@flba-eb @gh-tr @jonathanpallant @japaric","breadcrumbs":"Platform Support  *-nto-qnx-*  Target maintainers","id":"1560","title":"Target maintainers"},"1561":{"body":"Currently, the following QNX versions and compilation targets are supported: Target Tuple QNX Version Target Architecture Full support no_std support aarch64-unknown-nto-qnx800 QNX OS 8.0 AArch64 ?  x86_64-pc-nto-qnx800 QNX OS 8.0 x86_64 ?  aarch64-unknown-nto-qnx710 QNX Neutrino 7.1 with io-pkt AArch64   x86_64-pc-nto-qnx710 QNX Neutrino 7.1 with io-pkt x86_64   aarch64-unknown-nto-qnx710_iosock QNX Neutrino 7.1 with io-sock AArch64 ?  x86_64-pc-nto-qnx710_iosock QNX Neutrino 7.1 with io-sock x86_64 ?  aarch64-unknown-nto-qnx700 QNX Neutrino 7.0 AArch64 ?  i686-pc-nto-qnx700 QNX Neutrino 7.0 x86  On QNX Neutrino 7.0 and 7.1, io-pkt is used as network stack by default. QNX Neutrino 7.1 includes the optional network stack io-sock. QNX OS 8.0 always uses io-sock. QNX OS 8.0 support is currently work in progress. Adding other architectures that are supported by QNX is possible. In the table above, \'full support\' indicates support for building Rust applications with the full standard library. A \'?\' means that support is in-progress. \'no_std support\' is for building #![no_std] applications where only core and alloc are available. For building or using the Rust toolchain for QNX, the QNX Software Development Platform (SDP) must be installed and initialized. Initialization is usually done by sourcing qnxsdp-env.sh (this will be installed as part of the SDP, see also installation instruction provided with the SDP). Afterwards qcc (QNX C/C++ compiler) should be available (in the $PATH variable). qcc will be called e.g. for linking executables. When linking no_std applications, they must link against libc.so (see example). This is required because applications always link against the crt library and crt depends on libc.so. This is done automatically when using the standard library.","breadcrumbs":"Platform Support  *-nto-qnx-*  Requirements","id":"1561","title":"Requirements"},"1562":{"body":"While not recommended by default, some QNX kernel setups may require the RELRO to be disabled with -C relro_level=off, e.g. by adding it to the .cargo/config.toml file: [target.aarch64-unknown-nto-qnx700]\\nrustflags = [\\"-C\\", \\"relro_level=off\\"] If your QNX kernel does not allow it, and relro is not disabled, running compiled binary would fail with syntax error: ... unexpected or similar. This is due to kernel trying to interpret compiled binary with /bin/sh, and obviously failing. To verify that this is really the case, run your binary with the DL_DEBUG=all env var, and look for this output. If you see it, you should disable relro as described above. Resolution scope for Executable->/bin/sh: Executable->/bin/sh libc.so.4->/usr/lib/ldqnx-64.so.2","breadcrumbs":"Platform Support  *-nto-qnx-*  Disabling RELocation Read-Only (RELRO)","id":"1562","title":"Disabling RELocation Read-Only (RELRO)"},"1563":{"body":"Small no_std example is shown below. Applications using the standard library work as well. #![no_std]\\n#![no_main]\\n#![feature(lang_items)] // We must always link against libc, even if no external functions are used\\n// \\"extern C\\" - Block can be empty but must be present\\n#[link(name = \\"c\\")]\\nextern \\"C\\" { pub fn printf(format: *const core::ffi::c_char, ...) -> core::ffi::c_int;\\n} #[no_mangle]\\npub extern \\"C\\" fn main(_argc: core::ffi::c_int, _argv: *const *const u8) -> core::ffi::c_int { const HELLO: &\'static str = \\"Hello World, the answer is %d\\\\n\\\\0\\"; unsafe { printf(HELLO.as_ptr() as *const _, 42); } 0\\n} use core::panic::PanicInfo; #[panic_handler]\\nfn panic(_panic: &PanicInfo<\'_>) -> ! { loop {}\\n} #[lang = \\"eh_personality\\"]\\n#[no_mangle]\\npub extern \\"C\\" fn rust_eh_personality() {} The QNX support in Rust has been tested with QNX Neutrino 7.0 and 7.1. Support for QNX OS 8.0 is a work in progress. There are no further known requirements.","breadcrumbs":"Platform Support  *-nto-qnx-*  Small example application","id":"1563","title":"Small example application"},"1564":{"body":"For conditional compilation, following QNX specific attributes are defined: target_os = \\"nto\\" target_env = \\"nto71\\" (for QNX Neutrino 7.1 with \\"classic\\" network stack \\"io_pkt\\") target_env = \\"nto71_iosock\\" (for QNX Neutrino 7.1 with network stack \\"io_sock\\") target_env = \\"nto70\\" (for QNX Neutrino 7.0) target_env = \\"nto80\\" (for QNX OS 8.0)","breadcrumbs":"Platform Support  *-nto-qnx-*  Conditional compilation","id":"1564","title":"Conditional compilation"},"1565":{"body":"Create a bootstrap.toml Example content: profile = \\"compiler\\"\\nchange-id = 999999 Compile the Rust toolchain for an x86_64-unknown-linux-gnu host Compiling the Rust toolchain requires the same environment variables used for compiling C binaries. Refer to the QNX developer manual . To compile for QNX, environment variables must be set to use the correct tools and compiler switches: CC_<target>=qcc CFLAGS_<target>=<nto_cflag> CXX_<target>=qcc AR_<target>=<nto_ar> With: <target> target triplet using underscores instead of hyphens, e.g. aarch64_unknown_nto_qnx710 <nto_cflag> -Vgcc_ntox86_cxx for x86 (32 bit) -Vgcc_ntox86_64_cxx for x86_64 (64 bit) -Vgcc_ntoaarch64le_cxx for Aarch64 (64 bit) <nto_ar> ntox86-ar for x86 (32 bit) ntox86_64-ar for x86_64 (64 bit) ntoaarch64-ar for Aarch64 (64 bit) Example to build the Rust toolchain including a standard library for x86_64-linux-gnu and Aarch64-QNX-7.1: export build_env=\' CC_aarch64_unknown_nto_qnx710=qcc CFLAGS_aarch64_unknown_nto_qnx710=-Vgcc_ntoaarch64le_cxx CXX_aarch64_unknown_nto_qnx710=qcc AR_aarch64_unknown_nto_qnx710=ntoaarch64-ar \' env $build_env \\\\ ./x.py build \\\\ --target x86_64-unknown-linux-gnu,aarch64-unknown-nto-qnx710 \\\\ rustc library/core library/alloc library/std","breadcrumbs":"Platform Support  *-nto-qnx-*  Building the target","id":"1565","title":"Building the target"},"1566":{"body":"The test suites of the Rust compiler and standard library can be executed much like other Rust targets. The environment for testing should match the one used during compiler compilation (refer to build_env and qcc/PATH above) with the addition of the TEST_DEVICE_ADDR environment variable. The TEST_DEVICE_ADDR variable controls the remote runner and should point to the target, despite localhost being shown in the following example. Note that some tests are failing which is why they are currently excluded by the target maintainers which can be seen in the following example. To run all tests on a x86_64 QNX Neutrino 7.1 target: export TEST_DEVICE_ADDR=\\"localhost:12345\\" # must address the test target, can be a SSH tunnel\\nexport build_env=<see above> # Disable tests that only work on the host or don\'t make sense for this target.\\n# See also:\\n# - src/ci/docker/host-x86_64/i686-gnu/Dockerfile\\n# - https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Running.20tests.20on.20remote.20target\\n# - .github/workflows/ci.yml\\nexport exclude_tests=\' --exclude src/bootstrap --exclude src/tools/error_index_generator --exclude src/tools/linkchecker --exclude tests/ui-fulldeps --exclude rustc --exclude rustdoc\' env $build_env \\\\ ./x.py test \\\\ $exclude_tests \\\\ --stage 1 \\\\ --target x86_64-pc-nto-qnx710","breadcrumbs":"Platform Support  *-nto-qnx-*  Running the Rust test suite","id":"1566","title":"Running the Rust test suite"},"1567":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you must either build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar.","breadcrumbs":"Platform Support  *-nto-qnx-*  Building Rust programs","id":"1567","title":"Building Rust programs"},"1568":{"body":"Compiled executables can run directly on QNX.","breadcrumbs":"Platform Support  *-nto-qnx-*  Testing","id":"1568","title":"Testing"},"1569":{"body":"The target needs sufficient resources to execute all tests. The commands below assume that a QEMU image is used. Ensure that the temporary directory used by remote-test-server has enough free space and inodes. 5GB of free space and 40000 inodes are known to be sufficient (the test will create more than 32k files). To create a QEMU image in an empty directory, run this command inside the directory: mkqnximage --type=qemu --ssh-ident=$HOME/.ssh/id_ed25519.pub --data-size=5000 --data-inodes=40000 /data should have enough free resources. Set the TMPDIR environment variable accordingly when running remote-test-server, e.g.: TMPDIR=/data/tmp/rust remote-test-server --bind 0.0.0.0:12345 Ensure the TCP stack can handle enough parallel connections (default is 200, should be 300 or higher). After creating an image (see above), edit the file output/build/startup.sh: Search for io-pkt-v6-hc Add the parameter -ptcpip threads_max=300, e.g.: io-pkt-v6-hc -U 33:33 -d e1000 -ptcpip threads_max=300 Update the image by running mkqnximage again with the same parameters as above for creating it. Running and stopping the virtual machine To start the virtual machine, run inside the directory of the VM: mkqnximage --run=-h To stop the virtual machine, run inside the directory of the VM: mkqnximage --stop Ensure local networking Ensure that \'localhost\' is getting resolved to 127.0.0.1. If you can\'t ping the localhost, some tests may fail. Ensure it\'s appended to /etc/hosts (if first ping command fails). Commands have to be executed inside the virtual machine! $ ping localhost\\nping: Cannot resolve \\"localhost\\" (Host name lookup failure) $ echo \\"127.0.0.1 localhost\\" >> /etc/hosts $ ping localhost\\nPING localhost (127.0.0.1): 56 data bytes\\n64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=1 ms","breadcrumbs":"Platform Support  *-nto-qnx-*  Rust std library test suite","id":"1569","title":"Rust std library test suite"},"157":{"body":"The explicit_outlives_requirements lint detects unnecessary lifetime bounds that can be inferred.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  explicit-outlives-requirements","id":"157","title":"explicit-outlives-requirements"},"1570":{"body":"Compiling C code requires the same environment variables to be set as compiling the Rust toolchain (see above), to ensure qcc is used with proper arguments. To ensure compatibility, do not specify any further arguments that for example change calling conventions or memory layout.","breadcrumbs":"Platform Support  *-nto-qnx-*  Cross-compilation toolchains and C code","id":"1570","title":"Cross-compilation toolchains and C code"},"1571":{"body":"Tier: 3 Targets for the Unikraft Unikernel Development Kit (with musl). Target triplets available so far: x86_64-unikraft-linux-musl","breadcrumbs":"Platform Support  *-unikraft-linux-musl  *-unikraft-linux-musl","id":"1571","title":"*-unikraft-linux-musl"},"1572":{"body":"@mkroening","breadcrumbs":"Platform Support  *-unikraft-linux-musl  Target maintainers","id":"1572","title":"Target maintainers"},"1573":{"body":"These targets only support cross-compilation. The targets do support std. Unikraft pretends to behave exactly like Linux. How much of that functionality is available depends on the individual unikernel configuration. For example, the basic Unikraft + musl config does not support poll or networking out of the box. That functionality requires enabling LIBPOSIX_EVENT or lwIP respectively. The Unikraft targets follow Linux\'s extern \\"C\\" calling convention. For these targets, rustc does not perform the final linking step. Instead, the Unikraft build system will produce the final Unikernel image for the selected platform (e.g., KVM, Linux user space, and Xen).","breadcrumbs":"Platform Support  *-unikraft-linux-musl  Requirements","id":"1573","title":"Requirements"},"1574":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml: [build]\\nbuild-stage = 1\\ntarget = [\\"x86_64-unikraft-linux-musl\\"]","breadcrumbs":"Platform Support  *-unikraft-linux-musl  Building the targets","id":"1574","title":"Building the targets"},"1575":{"body":"Rust does not yet ship pre-compiled artifacts for these targets. To compile for these targets, you will either need to build Rust with the targets enabled (see Building the targets above), or build your own copy of core by using build-std or similar. Linking requires a KraftKit shim. See unikraft/kraftkit#612 for more information.","breadcrumbs":"Platform Support  *-unikraft-linux-musl  Building Rust programs","id":"1575","title":"Building Rust programs"},"1576":{"body":"The targets do support running binaries in the form of unikernel images. How the unikernel image is run depends on the specific platform (e.g., KVM, Linux user space, and Xen). The targets do not support running the Rust test suite.","breadcrumbs":"Platform Support  *-unikraft-linux-musl  Testing","id":"1576","title":"Testing"},"1577":{"body":"The targets do support C code. To build compatible C code, you have to use the same compiler and flags as does the Unikraft build system for your specific configuration. The easiest way to achieve that, is to build the C code with the Unikraft build system when building your unikernel image.","breadcrumbs":"Platform Support  *-unikraft-linux-musl  Cross-compilation toolchains and C code","id":"1577","title":"Cross-compilation toolchains and C code"},"1578":{"body":"Tier: 3 The Hermit unikernel target allows compiling your applications into self-contained, specialized unikernel images that can be run in small virtual machines. Target triplets available so far: x86_64-unknown-hermit aarch64-unknown-hermit aarch64_be-unknown-hermit riscv64gc-unknown-hermit","breadcrumbs":"Platform Support  *-unknown-hermit  *-unknown-hermit","id":"1578","title":"*-unknown-hermit"},"1579":{"body":"@stlankes @mkroening","breadcrumbs":"Platform Support  *-unknown-hermit  Target maintainers","id":"1579","title":"Target maintainers"},"158":{"body":"# #![allow(unused)]\\n#![deny(explicit_outlives_requirements)]\\n#![deny(warnings)] struct SharedRef<\'a, T>\\nwhere T: \'a,\\n{ data: &\'a T,\\n} This will produce: error: outlives requirements can be inferred --> lint_example.rs:6:24 |\\n6 | struct SharedRef<\'a, T> | ________________________^\\n7 | | where\\n8 | | T: \'a, | |__________^ help: remove this bound |\\nnote: the lint level is defined here --> lint_example.rs:2:9 |\\n2 | #![deny(explicit_outlives_requirements)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"158","title":"Example"},"1580":{"body":"These targets only support cross-compilation. The targets do support std. When building binaries for this target, the Hermit unikernel is built from scratch. The application developer themselves specializes the target and sets corresponding expectations. The Hermit targets follow Linux\'s extern \\"C\\" calling convention. Hermit binaries have the ELF format.","breadcrumbs":"Platform Support  *-unknown-hermit  Requirements","id":"1580","title":"Requirements"},"1581":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml. To run the Hermit build scripts, you also have to enable your host target. The build scripts rely on llvm-tools and binaries are linked using rust-lld, so those have to be enabled as well. [build]\\nbuild-stage = 1\\ntarget = [ \\"<HOST_TARGET>\\", \\"x86_64-unknown-hermit\\", \\"aarch64-unknown-hermit\\", \\"aarch64_be-unknown-hermit\\", \\"riscv64gc-unknown-hermit\\",\\n] [rust]\\nlld = true\\nllvm-tools = true","breadcrumbs":"Platform Support  *-unknown-hermit  Building the target","id":"1581","title":"Building the target"},"1582":{"body":"Rust does not yet ship pre-compiled artifacts for these targets. To compile for these targets, you will either need to build Rust with the targets enabled (see Building the targets above), or build your own copy of core by using build-std or similar. As all Hermit programs are unikernels, building a Rust program also requires including the operating system code. A guide for doing so is provided in our starter hermit-rs-template .","breadcrumbs":"Platform Support  *-unknown-hermit  Building Rust programs","id":"1582","title":"Building Rust programs"},"1583":{"body":"The targets support running binaries in the form of self-contained unikernel images. These images can be chainloaded by Hermit\'s loader or hypervisor ( Uhyve ). QEMU can be used to boot Hermit binaries using the loader on any architecture. The targets do not support running the Rust test suite.","breadcrumbs":"Platform Support  *-unknown-hermit  Testing","id":"1583","title":"Testing"},"1584":{"body":"The targets do not yet support C code and Rust code at the same time.","breadcrumbs":"Platform Support  *-unknown-hermit  Cross-compilation toolchains and C code","id":"1584","title":"Cross-compilation toolchains and C code"},"1585":{"body":"Tier: 2/3 FreeBSD multi-platform 4.4BSD-based UNIX-like operating system.","breadcrumbs":"Platform Support  *-unknown-freebsd  *-unknown-freebsd","id":"1585","title":"*-unknown-freebsd"},"1586":{"body":"@asomers @MikaelUrankar","breadcrumbs":"Platform Support  *-unknown-freebsd  Target maintainers","id":"1586","title":"Target maintainers"},"1587":{"body":"The x86_64-unknown-freebsd target is Tier 2 with host tools. i686-unknown-freebsd is Tier 2 without host tools. Other targets are Tier 3. See platform-support.md for the full list. We commit that rustc will run on all currently supported releases of FreeBSD . EoL releases may be supported for a time, too. The same guarantees apply for the standard library and the libc crate. Specific release support matrix, as of Rust 1.82.0: FreeBSD Release rustc std libc 10 < 1.78.0 ? ? 11 < 1.78.0 < 1.78.0 current 12+ current current current extern \\"C\\" uses the official calling convention of the respective architectures. FreeBSD OS binaries use the ELF file format.","breadcrumbs":"Platform Support  *-unknown-freebsd  Requirements","id":"1587","title":"Requirements"},"1588":{"body":"The x86_64-unknown-freebsd and i686-unknown-freebsd artifacts are distributed by the rust project and may be installed with rustup. Other targets are built by the ports system and may be installed with pkg(7) or ports(7) . By default the i686-unknown-freebsd target uses SSE2 instructions. To build code that does not require SSE2, build lang/rust from ports and disable the SSE2 option at build time. That will produce non-compliant behavior. See issue #114479 .","breadcrumbs":"Platform Support  *-unknown-freebsd  Building Rust programs","id":"1588","title":"Building Rust programs"},"1589":{"body":"The Rust test suite can be run natively. It can also be run from the FreeBSD ports tree with the make test command from within the lang/rust directory.","breadcrumbs":"Platform Support  *-unknown-freebsd  Testing","id":"1589","title":"Testing"},"159":{"body":"If a struct contains a reference, such as &\'a T, the compiler requires that T outlives the lifetime \'a. This historically required writing an explicit lifetime bound to indicate this requirement. However, this can be overly explicit, causing clutter and unnecessary complexity. The language was changed to automatically infer the bound if it is not specified. Specifically, if the struct contains a reference, directly or indirectly, to T with lifetime \'x, then it will infer that T: \'x is a requirement. This lint is \\"allow\\" by default because it can be noisy for existing code that already had these requirements. This is a stylistic choice, as it is still valid to explicitly state the bound. It also has some false positives that can cause confusion. See RFC 2093 for more details.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"159","title":"Explanation"},"1590":{"body":"Tier: 3","breadcrumbs":"Platform Support  *-unknown-managarm-mlibc  *-unknown-managarm-mlibc","id":"1590","title":"*-unknown-managarm-mlibc"},"1591":{"body":"@no92 @64 @Dennisbonke","breadcrumbs":"Platform Support  *-unknown-managarm-mlibc  Target Maintainers","id":"1591","title":"Target Maintainers"},"1592":{"body":"This target is cross-compiled. There is currently no support for std yet. It generates binaries in the ELF format. Currently, we support the x86_64, aarch64 and riscv64gc architectures.The examples below $ARCH should be substituted for one of the supported architectures.","breadcrumbs":"Platform Support  *-unknown-managarm-mlibc  Requirements","id":"1592","title":"Requirements"},"1593":{"body":"Managarm has upstream support in LLVM since the release of 21.1.0. Set up your bootstrap.toml like this: change-id = 142379 [llvm]\\ntargets = \\"X86;AArch64;RISCV\\"\\ndownload-ci-llvm = false [build]\\ntarget = [\\"$ARCH-unknown-managarm-mlibc\\", \\"x86_64-unknown-linux-gnu\\"] [target.x86_64-unknown-linux-gnu]\\nllvm-config = \\"/path/to/your/llvm/bin/llvm-config\\" [target.$ARCH-unknown-managarm-mlibc]\\nllvm-config = \\"/path/to/your/llvm/bin/llvm-config\\"","breadcrumbs":"Platform Support  *-unknown-managarm-mlibc  Building the target","id":"1593","title":"Building the target"},"1594":{"body":"Build a $ARCH-managarm-gcc using our gcc fork . [build]\\nrustc = \\"/path/to/the/rust-prefix/bin/rustc\\"\\ntarget = \\"$ARCH-unknown-managarm-mlibc\\" [target.$ARCH-unknown-managarm-mlibc]\\nlinker = \\"/path/to/the/managarm-gcc/bin/$ARCH-managarm-gcc\\"","breadcrumbs":"Platform Support  *-unknown-managarm-mlibc  Building Rust programs","id":"1594","title":"Building Rust programs"},"1595":{"body":"This target does not support running the Rust testsuite yet.","breadcrumbs":"Platform Support  *-unknown-managarm-mlibc  Testing","id":"1595","title":"Testing"},"1596":{"body":"Tier: 3 Motor OS is a new operating system for virtualized environments.","breadcrumbs":"Platform Support  *-unknown-motor  x86_64-unknown-motor","id":"1596","title":"x86_64-unknown-motor"},"1597":{"body":"@lasiotus","breadcrumbs":"Platform Support  *-unknown-motor  Target maintainers","id":"1597","title":"Target maintainers"},"1598":{"body":"This target is cross-compiled. There are no special requirements for the host. Motor OS uses the ELF file format.","breadcrumbs":"Platform Support  *-unknown-motor  Requirements","id":"1598","title":"Requirements"},"1599":{"body":"Motor OS target toolchain can be built using x.py : The bootstrap file: [build]\\nhost = [\\"x86_64-unknown-linux-gnu\\"]\\ntarget = [\\"x86_64-unknown-linux-gnu\\", \\"x86_64-unknown-motor\\"] The build command: ./x.py build --stage 2 clippy library","breadcrumbs":"Platform Support  *-unknown-motor  Building the target toolchain","id":"1599","title":"Building the target toolchain"},"16":{"body":"When using --emit or -o , output can be sent to stdout by specifying - as the path (e.g. -o -). Binary output types can only be written to stdout if it is not a tty. Text output types (asm, dep-info, llvm-ir and mir) can be written to stdout regardless of whether it is a tty or not. Only one type of output can be written to stdout. Attempting to write multiple types to stdout at the same time will result in an error.","breadcrumbs":"Command-line Arguments  Emitting to stdout","id":"16","title":"Emitting to stdout"},"160":{"body":"The ffi_unwind_calls lint detects calls to foreign functions or function pointers with C-unwind or other FFI-unwind ABIs.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  ffi-unwind-calls","id":"160","title":"ffi-unwind-calls"},"1600":{"body":"See the Hello Motor OS example.","breadcrumbs":"Platform Support  *-unknown-motor  Building Rust programs","id":"1600","title":"Building Rust programs"},"1601":{"body":"Cross-compiled Rust binaries and test artifacts can be executed in Motor OS VMs, as described in the build doc and the Hello Motor OS example.","breadcrumbs":"Platform Support  *-unknown-motor  Testing","id":"1601","title":"Testing"},"1602":{"body":"C code can be compiled as part of Rust cargo projects. However, there is no libc support.","breadcrumbs":"Platform Support  *-unknown-motor  Cross-compilation toolchains and C code","id":"1602","title":"Cross-compilation toolchains and C code"},"1603":{"body":"NetBSD multi-platform 4.4BSD-based UNIX-like operating system. The target names follow this format: $ARCH-unknown-netbsd{-$SUFFIX}, where $ARCH specifies the target processor architecture and -$SUFFIX (optional) might indicate the ABI. The following targets are currently defined running NetBSD: Target tier Target name NetBSD Platform 2 (with host tools) x86_64-unknown-netbsd amd64 / x86_64 systems 3 armv7-unknown-netbsd-eabihf 32-bit ARMv7 systems with hard-float 3 armv6-unknown-netbsd-eabihf 32-bit ARMv6 systems with hard-float 3 aarch64-unknown-netbsd 64-bit ARM systems, little-endian 3 aarch64_be-unknown-netbsd 64-bit ARM systems, big-endian 3 i586-unknown-netbsd 32-bit i386, restricted to Pentium 3 i686-unknown-netbsd 32-bit i386 with SSE 3 mipsel-unknown-netbsd 32-bit mips, requires mips32 cpu support 3 powerpc-unknown-netbsd Various 32-bit PowerPC systems, e.g. MacPPC 3 riscv64gc-unknown-netbsd 64-bit RISC-V 3 sparc64-unknown-netbsd Sun UltraSPARC systems All use the \\"native\\" stdc++ library which goes along with the natively supplied GNU C++ compiler for the given OS version. Many of the bootstraps are built for NetBSD 9.x, although some exceptions exist (some are built for NetBSD 8.x but also work on newer OS versions).","breadcrumbs":"Platform Support  *-unknown-netbsd*  *-unknown-netbsd","id":"1603","title":"*-unknown-netbsd"},"1604":{"body":"@he32 @0323pin Further contacts: NetBSD/pkgsrc-wip\'s rust maintainer (see MAINTAINER variable). This package is part of \\"pkgsrc work-in-progress\\" and is used for deployment and testing of new versions of rust. Note that we have the convention of having multiple rust versions active in pkgsrc-wip at any one time, so the version number is part of the directory name, and from time to time old versions are culled so this is not a fully \\"stable\\" link. NetBSD\'s pkgsrc lang/rust for the \\"proper\\" package in pkgsrc. NetBSD\'s pkgsrc lang/rust-bin which re-uses the bootstrap kit as a binary distribution and therefore avoids the rather protracted native build time of rust itself Fallback to pkgsrc-users@NetBSD.org, or fault reporting via NetBSD\'s bug reporting system.","breadcrumbs":"Platform Support  *-unknown-netbsd*  Target Maintainers","id":"1604","title":"Target Maintainers"},"1605":{"body":"The x86_64-unknown-netbsd artifacts is being distributed by the rust project. The other targets are built by the target maintainers (see above), and the targets are initially cross-compiled, but many if not most of them are also built natively as part of testing.","breadcrumbs":"Platform Support  *-unknown-netbsd*  Requirements","id":"1605","title":"Requirements"},"1606":{"body":"The default build mode for the packages is a native build.","breadcrumbs":"Platform Support  *-unknown-netbsd*  Building","id":"1606","title":"Building"},"1607":{"body":"These targets can be cross-compiled, and we do that via the pkgsrc package(s). Cross-compilation typically requires the \\"tools\\" and \\"dest\\" trees resulting from a normal cross-build of NetBSD itself, ref. our main build script, build.sh. See e.g. do-cross.mk Makefile for the Makefile used to cross-build all the above NetBSD targets (except for the amd64 target). The major option for the rust build is whether to build rust with the LLVM rust carries in its distribution, or use the LLVM package installed from pkgsrc. The PKG_OPTIONS.rust option is rust-internal-llvm, ref. the rust package\'s options.mk make fragment . It defaults to being set for a few of the above platforms, for various reasons (see comments), but is otherwise unset and therefore indicates use of the pkgsrc LLVM.","breadcrumbs":"Platform Support  *-unknown-netbsd*  Cross-compilation","id":"1607","title":"Cross-compilation"},"1608":{"body":"The Rust testsuite could presumably be run natively. For the systems where the maintainer can build natively, the rust compiler itself is re-built natively. This involves the rust compiler being re-built with the newly self-built rust compiler, so exercises the result quite extensively. Additionally, for some systems we build librsvg, and for the more capable systems we build and test firefox (amd64, i386, aarch64).","breadcrumbs":"Platform Support  *-unknown-netbsd*  Testing","id":"1608","title":"Testing"},"1609":{"body":"Rust ships pre-compiled artifacts for the x86_64-unknown-netbsd target. For the other systems mentioned above, using the pkgsrc route is probably the easiest, possibly via the rust-bin package to save time, see the RUST_TYPE variable from the rust.mk Makefile fragment. The pkgsrc rust package has a few files to assist with building pkgsrc packages written in rust, ref. the rust.mk and cargo.mk Makefile fragments in the lang/rust package.","breadcrumbs":"Platform Support  *-unknown-netbsd*  Building Rust programs","id":"1609","title":"Building Rust programs"},"161":{"body":"#![warn(ffi_unwind_calls)] unsafe extern \\"C-unwind\\" { fn foo();\\n} fn bar() { unsafe { foo(); } let ptr: unsafe extern \\"C-unwind\\" fn() = foo; unsafe { ptr(); }\\n} This will produce: warning: call to foreign function with FFI-unwind ABI --> lint_example.rs:9:14 |\\n9 | unsafe { foo(); } | ^^^^^ call to foreign function with FFI-unwind ABI |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![warn(ffi_unwind_calls)] | ^^^^^^^^^^^^^^^^ warning: call to function pointer with FFI-unwind ABI --> lint_example.rs:11:14 |\\n11 | unsafe { ptr(); } | ^^^^^ call to function pointer with FFI-unwind ABI","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"161","title":"Example"},"1610":{"body":"Tier: 3 OpenBSD multi-platform 4.4BSD-based UNIX-like operating system. The target names follow this format: $ARCH-unknown-openbsd, where $ARCH specifies the target processor architecture. The following targets are currently defined: Target name C++ library OpenBSD Platform aarch64-unknown-openbsd libc++ 64-bit ARM systems i686-unknown-openbsd libc++ Standard PC and clones based on the Intel i386 architecture and compatible processors powerpc64-unknown-openbsd libc++ IBM POWER-based PowerNV systems riscv64gc-unknown-openbsd libc++ 64-bit RISC-V systems sparc64-unknown-openbsd estdc++ Sun UltraSPARC and Fujitsu SPARC64 systems x86_64-unknown-openbsd libc++ AMD64-based systems Note that all OS versions are major even if using X.Y notation (6.8 and 6.9 are different major versions) and could be binary incompatibles (with breaking changes).","breadcrumbs":"Platform Support  *-unknown-openbsd  *-unknown-openbsd","id":"1610","title":"*-unknown-openbsd"},"1611":{"body":"@semarie Further contacts: lang/rust maintainer (see MAINTAINER variable) Fallback to ports@openbsd.org, OpenBSD third parties public mailing-list (with openbsd developers readers)","breadcrumbs":"Platform Support  *-unknown-openbsd  Target Maintainers","id":"1611","title":"Target Maintainers"},"1612":{"body":"These targets are natively compiled and could be cross-compiled. C compiler toolchain is required for the purpose of building Rust and functional binaries.","breadcrumbs":"Platform Support  *-unknown-openbsd  Requirements","id":"1612","title":"Requirements"},"1613":{"body":"The target can be built by enabling it for a rustc build. [build]\\ntarget = [\\"$ARCH-unknown-openbsd\\"] [target.$ARCH-unknown-openbsd]\\ncc = \\"$ARCH-openbsd-cc\\"","breadcrumbs":"Platform Support  *-unknown-openbsd  Building","id":"1613","title":"Building"},"1614":{"body":"These targets can be cross-compiled, but LLVM might not build out-of-box.","breadcrumbs":"Platform Support  *-unknown-openbsd  Cross-compilation","id":"1614","title":"Cross-compilation"},"1615":{"body":"The Rust testsuite could be run natively.","breadcrumbs":"Platform Support  *-unknown-openbsd  Testing","id":"1615","title":"Testing"},"1616":{"body":"Rust does not yet ship pre-compiled artifacts for these targets.","breadcrumbs":"Platform Support  *-unknown-openbsd  Building Rust programs","id":"1616","title":"Building Rust programs"},"1617":{"body":"Tier: 2/3 Targets for the Redox OS operating system. Target triplets available so far: x86_64-unknown-redox (tier 2) aarch64-unknown-redox (tier 3) i586-unknown-redox (tier 3)","breadcrumbs":"Platform Support  *-unknown-redox  *-unknown-redox","id":"1617","title":"*-unknown-redox"},"1618":{"body":"@jackpot51","breadcrumbs":"Platform Support  *-unknown-redox  Target maintainers","id":"1618","title":"Target maintainers"},"1619":{"body":"These targets are natively compiled and can be cross-compiled. Std is fully supported. The targets are only expected to work with the latest version of Redox OS as the ABI is not yet stable. extern \\"C\\" uses the official calling convention of the respective architectures. Redox OS binaries use ELF as file format.","breadcrumbs":"Platform Support  *-unknown-redox  Requirements","id":"1619","title":"Requirements"},"162":{"body":"For crates containing such calls, if they are compiled with -C panic=unwind then the produced library cannot be linked with crates compiled with -C panic=abort. For crates that desire this ability it is therefore necessary to avoid such calls.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"162","title":"Explanation"},"1620":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml. In addition a copy of relibc needs to be present in the linker search path. [build]\\nbuild-stage = 1\\ntarget = [ \\"<HOST_TARGET>\\", \\"x86_64-unknown-redox\\", \\"aarch64-unknown-redox\\", \\"i586-unknown-redox\\",\\n]","breadcrumbs":"Platform Support  *-unknown-redox  Building the target","id":"1620","title":"Building the target"},"1621":{"body":"Rust does not yet ship pre-compiled artifacts for Redox OS except for x86_64-unknown-redox. The easiest way to build and test programs for Redox OS is using redoxer which sets up the required compiler toolchain for building as well as runs programs inside a Redox OS VM using QEMU.","breadcrumbs":"Platform Support  *-unknown-redox  Building Rust programs and testing","id":"1621","title":"Building Rust programs and testing"},"1622":{"body":"The target supports C code. Pre-compiled C toolchains can be found at https://static.redox-os.org/toolchain/ .","breadcrumbs":"Platform Support  *-unknown-redox  Cross-compilation toolchains and C code","id":"1622","title":"Cross-compilation toolchains and C code"},"1623":{"body":"Tier: 2 Unified Extensible Firmware Interface (UEFI) targets for application, driver, and core UEFI binaries. Available targets: aarch64-unknown-uefi i686-unknown-uefi x86_64-unknown-uefi","breadcrumbs":"Platform Support  *-unknown-uefi  *-unknown-uefi","id":"1623","title":"*-unknown-uefi"},"1624":{"body":"@dvdhrm @nicholasbishop (for aarch64-unknown-uefi only) @rust-lang/arm-maintainers ( rust@arm.com )","breadcrumbs":"Platform Support  *-unknown-uefi  Target maintainers","id":"1624","title":"Target maintainers"},"1625":{"body":"All UEFI targets can be used as no-std environments via cross-compilation. Support for std is present, but incomplete and extremely new. alloc is supported if an allocator is provided by the user or if using std. No host tools are supported. The UEFI environment resembles the environment for Microsoft Windows, with some minor differences. Therefore, cross-compiling for UEFI works with the same tools as cross-compiling for Windows. The target binaries are PE32+ encoded, the calling convention is different for each architecture, but matches what Windows uses (if the architecture is supported by Windows). The special efiapi Rust calling-convention chooses the right ABI for the target platform (extern \\"C\\" is incorrect on Intel targets at least). The specification has an elaborate section on the different supported calling-conventions, if more details are desired. MMX, SSE, and other FP-units are disabled by default, to allow for compilation of core UEFI code that runs before they are set up. This can be overridden for individual compilations via rustc command-line flags. Not all firmwares correctly configure those units, though, so careful inspection is required. As native to PE32+, binaries are position-dependent, but can be relocated at runtime if their desired location is unavailable. The code must be statically linked. Dynamic linking is not supported. Code is shared via UEFI interfaces, rather than dynamic linking. Additionally, UEFI forbids running code on anything but the boot CPU/thread, nor is interrupt-usage allowed (apart from the timer interrupt). Device drivers are required to use polling methods. UEFI uses a single address-space to run all code in. Multiple applications can be loaded simultaneously and are dispatched via cooperative multitasking on a single stack. By default, the UEFI targets use the link-flavor of the LLVM linker lld to link binaries into the final PE32+ file suffixed with *.efi. The PE subsystem is set to EFI_APPLICATION, but can be modified by passing /subsystem:<...> to the linker. Similarly, the entry-point is set to efi_main but can be changed via /entry:<...>. The panic-strategy is set to abort, The UEFI specification is available online for free: UEFI Specification Directory","breadcrumbs":"Platform Support  *-unknown-uefi  Requirements","id":"1625","title":"Requirements"},"1626":{"body":"Rust can be built for the UEFI targets by enabling them in the rustc build configuration. Note that you can only build the standard libraries. The compiler and host tools currently cannot be compiled for UEFI targets. A sample configuration would be: [build]\\nbuild-stage = 1\\ntarget = [\\"x86_64-unknown-uefi\\"]","breadcrumbs":"Platform Support  *-unknown-uefi  Building rust for UEFI targets","id":"1626","title":"Building rust for UEFI targets"},"1627":{"body":"Starting with Rust 1.67, precompiled artifacts are provided via rustup. For example, to use x86_64-unknown-uefi: # install cross-compile toolchain\\nrustup target add x86_64-unknown-uefi\\n# target flag may be used with any cargo or rustc command\\ncargo build --target x86_64-unknown-uefi","breadcrumbs":"Platform Support  *-unknown-uefi  Building Rust programs","id":"1627","title":"Building Rust programs"},"1628":{"body":"There are three types of UEFI executables: application, boot service driver, and runtime driver. All of Rust\'s UEFI targets default to producing applications. To build a driver instead, pass a subsystem linker flag with a value of efi_boot_service_driver or efi_runtime_driver. Example: # In .cargo/config.toml:\\n[build]\\nrustflags = [\\"-C\\", \\"link-args=/subsystem:efi_runtime_driver\\"]","breadcrumbs":"Platform Support  *-unknown-uefi  Building a driver","id":"1628","title":"Building a driver"},"1629":{"body":"UEFI applications can be copied into the ESP on any UEFI system and executed via the firmware boot menu. The qemu suite allows emulating UEFI systems and executing UEFI applications as well. See its documentation for details. The uefi-run rust tool is a simple wrapper around qemu that can spawn UEFI applications in qemu. You can install it via cargo install uefi-run and execute qemu applications as uefi-run ./application.efi.","breadcrumbs":"Platform Support  *-unknown-uefi  Testing","id":"1629","title":"Testing"},"163":{"body":"The fuzzy_provenance_casts lint detects an as cast between an integer and a pointer.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  fuzzy-provenance-casts","id":"163","title":"fuzzy-provenance-casts"},"1630":{"body":"There are 3 common ways to compile native C code for UEFI targets: Use the official SDK by Intel: Tianocore/EDK2 . This supports a multitude of platforms, comes with the full specification transposed into C, lots of examples and build-system integrations. This is also the only officially supported platform by Intel, and is used by many major firmware implementations. Any code compiled via the SDK is compatible to rust binaries compiled for the UEFI targets. You can link them directly into your rust binaries, or call into each other via UEFI protocols. Use the GNU-EFI suite. This approach is used by many UEFI applications in the Linux/OSS ecosystem. The GCC compiler is used to compile ELF binaries, and linked with a pre-loader that converts the ELF binary to PE32+ at runtime . You can combine such binaries with the rust UEFI targets only via UEFI protocols. Linking both into the same executable will fail, since one is an ELF executable, and one a PE32+. If linking to GNU-EFI executables is desired, you must compile your rust code natively for the same GNU target as GNU-EFI and use their pre-loader. This requires careful consideration about which calling-convention to use when calling into native UEFI protocols, or calling into linked GNU-EFI code (similar to how these differences need to be accounted for when writing GNU-EFI C code). Use native Windows targets. This means compiling your C code for the Windows platform as if it was the UEFI platform. This works for static libraries, but needs adjustments when linking into an UEFI executable. You can, however, link such static libraries seamlessly into rust code compiled for UEFI targets. Be wary of any includes that are not specifically suitable for UEFI targets (especially the C standard library includes are not always compatible). Freestanding compilations are recommended to avoid incompatibilities.","breadcrumbs":"Platform Support  *-unknown-uefi  Cross-compilation toolchains and C code","id":"1630","title":"Cross-compilation toolchains and C code"},"1631":{"body":"The rust language has a long history of supporting UEFI targets. Many crates have been developed to provide access to UEFI protocols and make UEFI programming more ergonomic in rust. The following list is a short overview (in alphabetical ordering): efi : Ergonomic Rust bindings for writing UEFI applications . Provides rustified access to UEFI protocols, implements allocators and a safe environment to write UEFI applications. r-efi : UEFI Reference Specification Protocol Constants and Definitions . A pure transpose of the UEFI specification into rust. This provides the raw definitions from the specification, without any extended helpers or rustification . It serves as baseline to implement any more elaborate rust UEFI layers. uefi-rs : Safe and easy-to-use wrapper for building UEFI apps . An elaborate library providing safe abstractions for UEFI protocols and features. It implements allocators and provides an execution environment to UEFI applications written in rust. uefi-run : Run UEFI applications . A small wrapper around qemu to spawn UEFI applications in an emulated x86_64 machine.","breadcrumbs":"Platform Support  *-unknown-uefi  Ecosystem","id":"1631","title":"Ecosystem"},"1632":{"body":"The following code is a valid UEFI application returning immediately upon execution with an exit code of 0. A panic handler is provided. This is executed by rust on panic. For simplicity, we simply end up in an infinite loop. This example can be compiled as binary crate via cargo: cargo build --target x86_64-unknown-uefi #![no_main]\\n#![no_std] #[panic_handler]\\nfn panic_handler(_info: &core::panic::PanicInfo) -> ! { loop {}\\n} #[export_name = \\"efi_main\\"]\\npub extern \\"C\\" fn main(_h: *mut core::ffi::c_void, _st: *mut core::ffi::c_void) -> usize { 0\\n}","breadcrumbs":"Platform Support  *-unknown-uefi  Example: Freestanding","id":"1632","title":"Example: Freestanding"},"1633":{"body":"This is an example UEFI application that prints \\"Hello World!\\", then waits for key input before it exits. It serves as base example how to write UEFI applications without any helper modules other than the standalone UEFI protocol definitions provided by the r-efi crate. This extends the \\"Freestanding\\" example and builds upon its setup. See there for instruction how to compile this as binary crate. Note that UEFI uses UTF-16 strings. Since rust literals are UTF-8, we have to use an open-coded, zero-terminated, UTF-16 array as argument to output_string(). Similarly to the panic handler, real applications should rather use UTF-16 modules. #![no_main]\\n#![no_std] use r_efi::efi; #[panic_handler]\\nfn panic_handler(_info: &core::panic::PanicInfo) -> ! { loop {}\\n} #[export_name = \\"efi_main\\"]\\npub extern \\"C\\" fn main(_h: efi::Handle, st: *mut efi::SystemTable) -> efi::Status { let s = [ 0x0048u16, 0x0065u16, 0x006cu16, 0x006cu16, 0x006fu16, // \\"Hello\\" 0x0020u16, // \\" \\" 0x0057u16, 0x006fu16, 0x0072u16, 0x006cu16, 0x0064u16, // \\"World\\" 0x0021u16, // \\"!\\" 0x000au16, // \\"\\\\n\\" 0x0000u16, // NUL ]; // Print \\"Hello World!\\". let r = unsafe { ((*(*st).con_out).output_string)((*st).con_out, s.as_ptr() as *mut efi::Char16) }; if r.is_error() { return r; } // Wait for key input, by waiting on the `wait_for_key` event hook. let r = unsafe { let mut x: usize = 0; ((*(*st).boot_services).wait_for_event)(1, &mut (*(*st).con_in).wait_for_key, &mut x) }; if r.is_error() { return r; } efi::Status::SUCCESS\\n}","breadcrumbs":"Platform Support  *-unknown-uefi  Example: Hello World","id":"1633","title":"Example: Hello World"},"1634":{"body":"This section contains information on how to use std on UEFI.","breadcrumbs":"Platform Support  *-unknown-uefi  Rust std for UEFI","id":"1634","title":"Rust std for UEFI"},"1635":{"body":"The building std part is pretty much the same as the official docs . The linker that should be used is rust-lld. Here is a sample bootstrap.toml: [rust]\\nlld = true Then just build using x.py: ./x.py build --target x86_64-unknown-uefi --stage 1 Alternatively, it is possible to use the build-std feature. However, you must use a toolchain which has the UEFI std patches. Then just build the project using the following command: cargo build --target x86_64-unknown-uefi -Zbuild-std=std,panic_abort","breadcrumbs":"Platform Support  *-unknown-uefi  Build std","id":"1635","title":"Build std"},"1636":{"body":"alloc Implemented using EFI_BOOT_SERVICES.AllocatePool() and EFI_BOOT_SERVICES.FreePool(). Passes all the tests. Currently uses EfiLoaderData as the EFI_ALLOCATE_POOL->PoolType. cmath Provided by compiler-builtins. env Just some global constants. locks The provided locks should work on all standard single-threaded UEFI implementations. os_str While the strings in UEFI should be valid UCS-2, in practice, many implementations just do not care and use UTF-16 strings. Thus, the current implementation supports full UTF-16 strings. stdio Uses Simple Text Input Protocol and Simple Text Output Protocol. Note: UEFI uses CRLF for new line. This means Enter key is registered as CR instead of LF. args Uses EFI_LOADED_IMAGE_PROTOCOL->LoadOptions","breadcrumbs":"Platform Support  *-unknown-uefi  Implemented features","id":"1636","title":"Implemented features"},"1637":{"body":"The following code features a valid UEFI application, including stdio and alloc (OsString and Vec): This example can be compiled as binary crate via cargo using the toolchain compiled from the above source (named custom): cargo +custom build --target x86_64-unknown-uefi #![feature(uefi_std)] use r_efi::{efi, protocols::simple_text_output};\\nuse std::{ ffi::OsString, os::uefi::{env, ffi::OsStrExt}\\n}; pub fn main() { println!(\\"Starting Rust Application...\\"); // Use System Table Directly let st = env::system_table().as_ptr() as *mut efi::SystemTable; let mut s: Vec<u16> = OsString::from(\\"Hello World!\\\\n\\").encode_wide().collect(); s.push(0); let r = unsafe { let con_out: *mut simple_text_output::Protocol = (*st).con_out; let output_string: extern \\"efiapi\\" fn(_: *mut simple_text_output::Protocol, *mut u16) -> efi::Status = (*con_out).output_string; output_string(con_out, s.as_ptr() as *mut efi::Char16) }; assert!(!r.is_error())\\n}","breadcrumbs":"Platform Support  *-unknown-uefi  Example: Hello World With std","id":"1637","title":"Example: Hello World With std"},"1638":{"body":"The current implementation of std makes BootServices unavailable once ExitBootServices is called. Refer to Runtime Drivers for more information regarding how to handle switching from using physical addresses to using virtual addresses. Note: It should be noted that it is up to the user to drop all allocated memory before ExitBootServices is called.","breadcrumbs":"Platform Support  *-unknown-uefi  BootServices","id":"1638","title":"BootServices"},"1639":{"body":"Windows MSVC targets. Tier 1 with host tools: aarch64-pc-windows-msvc: Windows on ARM64. i686-pc-windows-msvc: Windows on 32-bit x86. x86_64-pc-windows-msvc: Windows on 64-bit x86.","breadcrumbs":"Platform Support  *-unknown-windows-msvc  *-pc-windows-msvc","id":"1639","title":"*-pc-windows-msvc"},"164":{"body":"#![feature(strict_provenance_lints)]\\n#![warn(fuzzy_provenance_casts)] fn main() { let _dangling = 16_usize as *const u8;\\n} This will produce: warning: strict provenance disallows casting integer `usize` to pointer `*const u8` --> lint_example.rs:5:21 |\\n5 | let _dangling = 16_usize as *const u8; | ^^^^^^^^^^^^^^^^^^^^^ | = help: if you can\'t comply with strict provenance and don\'t have a pointer with the correct provenance you can use `std::ptr::with_exposed_provenance()` instead\\nnote: the lint level is defined here --> lint_example.rs:2:9 |\\n2 | #![warn(fuzzy_provenance_casts)] | ^^^^^^^^^^^^^^^^^^^^^^\\nhelp: use `.with_addr()` to adjust a valid pointer in the same allocation, to this address |\\n5 - let _dangling = 16_usize as *const u8;\\n5 + let _dangling = (...).with_addr(16_usize); |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"164","title":"Example"},"1640":{"body":"@ChrisDenton @dpaoliello @lambdageek @sivadeilra @wesleywiser","breadcrumbs":"Platform Support  *-unknown-windows-msvc  Target maintainers","id":"1640","title":"Target maintainers"},"1641":{"body":"","breadcrumbs":"Platform Support  *-unknown-windows-msvc  Requirements","id":"1641","title":"Requirements"},"1642":{"body":"Windows 10 or higher is required for client installs, Windows Server 2016 or higher is required for server installs.","breadcrumbs":"Platform Support  *-unknown-windows-msvc  OS version","id":"1642","title":"OS version"},"1643":{"body":"The minimum supported Visual Studio version is 2017 but this support is not actively tested in CI. It is highly recommended to use the latest version of VS (currently VS 2022).","breadcrumbs":"Platform Support  *-unknown-windows-msvc  Host tooling","id":"1643","title":"Host tooling"},"1644":{"body":"These targets fully implement the Rust standard library. The extern \\"C\\" calling convention conforms to Microsoft\'s default calling convention for the given architecture: __cdecl on i686, x64 on x86_64 and ARM64 on aarch64. The *-windows-msvc targets produce PE/COFF binaries with CodeView debuginfo, the native formats used on Windows.","breadcrumbs":"Platform Support  *-unknown-windows-msvc  Platform details","id":"1644","title":"Platform details"},"1645":{"body":"These targets are distributed via rustup and can be installed via rustup component add [--toolchain {name}] {target}. For example, adding the 32-bit x86 target to the nightly toolchain: rustup component add --toolchain nightly i686-pc-windows-msvc or adding the ARM64 target to the active toolchain: rustup component add aarch64-pc-windows-msvc","breadcrumbs":"Platform Support  *-unknown-windows-msvc  Building Rust programs","id":"1645","title":"Building Rust programs"},"1646":{"body":"There are no special requirements for testing and running this target.","breadcrumbs":"Platform Support  *-unknown-windows-msvc  Testing","id":"1646","title":"Testing"},"1647":{"body":"Architectural cross-compilation from one Windows host to a different Windows platform is natively supported by the MSVC toolchain provided the appropriate components are selected when using the VS Installer. Cross-compilation from a non-Windows host to a *-windows-msvc target may be possible but is not supported.","breadcrumbs":"Platform Support  *-unknown-windows-msvc  Cross-compilation toolchains and C code","id":"1647","title":"Cross-compilation toolchains and C code"},"1648":{"body":"Tier: 3 Windows targets for Universal Windows Platform (UWP) applications, using MSVC toolchain.","breadcrumbs":"Platform Support  *-uwp-windows-msvc  x86_64-uwp-windows-msvc, i686-uwp-windows-msvc, thumbv7a-uwp-windows-msvc and aarch64-uwp-windows-msvc","id":"1648","title":"x86_64-uwp-windows-msvc, i686-uwp-windows-msvc, thumbv7a-uwp-windows-msvc and aarch64-uwp-windows-msvc"},"1649":{"body":"@bdbai","breadcrumbs":"Platform Support  *-uwp-windows-msvc  Target maintainers","id":"1649","title":"Target maintainers"},"165":{"body":"This lint is part of the strict provenance effort, see issue #95228 . Casting an integer to a pointer is considered bad style, as a pointer contains, besides the address also a provenance , indicating what memory the pointer is allowed to read/write. Casting an integer, which doesn\'t have provenance, to a pointer requires the compiler to assign (guess) provenance. The compiler assigns \\"all exposed valid\\" (see the docs of ptr::with_exposed_provenance for more information about this \\"exposing\\"). This penalizes the optimiser and is not well suited for dynamic analysis/dynamic program verification (e.g. Miri or CHERI platforms). It is much better to use ptr::with_addr instead to specify the provenance you want. If using this function is not possible because the code relies on exposed provenance then there is as an escape hatch ptr::with_exposed_provenance .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"165","title":"Explanation"},"1650":{"body":"These targets are cross-compiled with std support. The host requirement and binary format are the same as the corresponding non-UWP targets (i.e. x86_64-pc-windows-msvc, i686-pc-windows-msvc, thumbv7a-pc-windows-msvc and aarch64-pc-windows-msvc).","breadcrumbs":"Platform Support  *-uwp-windows-msvc  Requirements","id":"1650","title":"Requirements"},"1651":{"body":"The targets can be built by enabling them for a rustc build, for example: [build]\\nbuild-stage = 1\\ntarget = [\\"x86_64-uwp-windows-msvc\\", \\"aarch64-uwp-windows-msvc\\"]","breadcrumbs":"Platform Support  *-uwp-windows-msvc  Building the targets","id":"1651","title":"Building the targets"},"1652":{"body":"Rust does not yet ship pre-compiled artifacts for these targets. To compile for these targets, you will either need to build Rust with the targets enabled (see \\"Building the targets\\" above), or build your own copy of std by using build-std or similar. Example of building a Rust project for x64 UWP using build-std: cargo build -Z build-std=std,panic_abort --target x86_64-uwp-windows-msvc","breadcrumbs":"Platform Support  *-uwp-windows-msvc  Building Rust programs","id":"1652","title":"Building Rust programs"},"1653":{"body":"Currently there is no support to run the rustc test suite for this target.","breadcrumbs":"Platform Support  *-uwp-windows-msvc  Testing","id":"1653","title":"Testing"},"1654":{"body":"In general, the toolchain target should match the corresponding non-UWP targets. Beware that not all Win32 APIs behave the same way in UWP, and some are restricted in AppContainer or even not available at all. If the C code being compiled happens to use any of restricted or unavailable APIs, consider using allowed alternatives or disable certain feature sets to avoid using them.","breadcrumbs":"Platform Support  *-uwp-windows-msvc  Cross-compilation toolchains and C code","id":"1654","title":"Cross-compilation toolchains and C code"},"1655":{"body":"Tier: 3 Targets for the VxWorks operating system. Target triplets available: x86_64-wrs-vxworks aarch64-wrs-vxworks i686-wrs-vxworks armv7-wrs-vxworks-eabihf powerpc-wrs-vxworks powerpc64-wrs-vxworks powerpc-wrs-vxworks-spe riscv32-wrs-vxworks riscv64-wrs-vxworks","breadcrumbs":"Platform Support  *-wrs-vxworks  *-wrs-vxworks","id":"1655","title":"*-wrs-vxworks"},"1656":{"body":"@biabbas @hax0kartik","breadcrumbs":"Platform Support  *-wrs-vxworks  Target maintainers","id":"1656","title":"Target maintainers"},"1657":{"body":"","breadcrumbs":"Platform Support  *-wrs-vxworks  Requirements","id":"1657","title":"Requirements"},"1658":{"body":"The minimum supported version is VxWorks 7.","breadcrumbs":"Platform Support  *-wrs-vxworks  OS version","id":"1658","title":"OS version"},"1659":{"body":"Rust for each target can be cross-compiled with its specific target vsb configuration. Std support is added but not yet fully tested.","breadcrumbs":"Platform Support  *-wrs-vxworks  Building","id":"1659","title":"Building"},"166":{"body":"The if_let_rescope lint detects cases where a temporary value with significant drop is generated on the right hand side of if let and suggests a rewrite into match when possible.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  if-let-rescope","id":"166","title":"if-let-rescope"},"1660":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml. In addition the workbench and wr-cc have to configured and activated. [build]\\nbuild-stage = 1\\ntarget = [ \\"<HOST_TARGET>\\", \\"x86_64-wrs-vxworks\\", \\"aarch64-wrs-vxworks\\", \\"i686-wrs-vxworks\\", \\"armv7-wrs-vxworks-eabihf\\", \\"powerpc-wrs-vxworks\\", \\"powerpc64-wrs-vxworks\\", \\"powerpc-wrs-vxworks-spe\\",\\n]","breadcrumbs":"Platform Support  *-wrs-vxworks  Building the target","id":"1660","title":"Building the target"},"1661":{"body":"Rust does not yet ship pre-compiled artifacts for VxWorks. The easiest way to build and test programs for VxWorks is to use the shipped rustc and cargo in VxWorks workbench, following the official windriver guidelines.","breadcrumbs":"Platform Support  *-wrs-vxworks  Building Rust programs","id":"1661","title":"Building Rust programs"},"1662":{"body":"The target supports C code. Pre-compiled C toolchains can be found in provided VxWorks workbench.","breadcrumbs":"Platform Support  *-wrs-vxworks  Cross-compilation toolchains and C code","id":"1662","title":"Cross-compilation toolchains and C code"},"1663":{"body":"Tier: 2 The wasm32-wasip1 target is a WebAssembly compilation target which assumes that the WASIp1 (aka \\"WASI preview1\\") set of \\"syscalls\\" are available for use in the standard library. This target explicitly supports interop with non-Rust code such as C and C++. The WASIp1 set of syscalls is standard insofar as it was written down once by a set of folks and has not changed since then. Additionally the WASIp1 syscalls have been adapted and adopted into a number of runtimes and embeddings. It is not standard in the sense that there are no formal semantics for each syscall and APIs are no longer receiving any maintenance (e.g. no new APIs, no new documentation, etc). After WASIp1 was originally developed in 2019 the WASI standard effort has since been \\"rebased\\" on top of the Component Model . This was a large change to the WASI specification and was released as 0.2.0 (\\"WASIp2\\" colloquially) in January 2024. Current standardization efforts are focused on the Component Model-based definition of WASI. At this point the wasm32-wasip1 Rust target is intended for historical compatibility with WASIp1 set of syscalls. Today the wasm32-wasip1 target will generate core WebAssembly modules which will import functions from the wasi_snapshot_preview1 module for OS-related functionality (e.g. printing). Note : Prior to March 2024 this target was known as wasm32-wasi with some historical context found in old MCPs: Rename wasm32-wasi target to wasm32-wasip1 Smooth the renaming transition of wasm32-wasi","breadcrumbs":"Platform Support  wasm32-wasip1  wasm32-wasip1","id":"1663","title":"wasm32-wasip1"},"1664":{"body":"When this target was added to the compiler platform-specific documentation here was not maintained at that time. This means that the list below is not exhaustive and there are more interested parties in this target. That being said since when this document was last updated those interested in maintaining this target are: @alexcrichton @loganek","breadcrumbs":"Platform Support  wasm32-wasip1  Target maintainers","id":"1664","title":"Target maintainers"},"1665":{"body":"This target is cross-compiled. The target includes support for std itself, but not all of the standard library works. For example spawning a thread will always return an error (see the wasm32-wasip1-threads target for example). Another example is that spawning a process will always return an error. Operations such as opening a file, however, will be implemented by calling WASI-defined APIs. The WASI targets for Rust are explicitly intended to interoperate with other languages compiled to WebAssembly, for example C/C++. Any ABI differences or mismatches are considered bugs that need to be fixed. By default the WASI targets in Rust ship in rustup with a precompiled copy of wasi-libc meaning that a WebAssembly-targeting-Clang is not required to use the WASI targets from Rust. If there is no actual interoperation with C then rustup target add wasm32-wasip1 is all that\'s needed to get started with WASI. Note that this behavior can be controlled with -Clinker and -Clink-self-contained, however. By specifying clang as a linker and disabling the link-self-contained option an external version of libc.a can be used instead.","breadcrumbs":"Platform Support  wasm32-wasip1  Requirements","id":"1665","title":"Requirements"},"1666":{"body":"To build this target first acquire a copy of wasi-sdk . At this time version 22 is the minimum needed. Next configure the WASI_SDK_PATH environment variable to point to where this is installed. For example: export WASI_SDK_PATH=/path/to/wasi-sdk-22.0 Next be sure to enable LLD when building Rust from source as LLVM\'s wasm-ld driver for LLD is required when linking WebAssembly code together. Rust\'s build system will automatically pick up any necessary binaries and programs from WASI_SDK_PATH.","breadcrumbs":"Platform Support  wasm32-wasip1  Building the target","id":"1666","title":"Building the target"},"1667":{"body":"The wasm32-wasip1 target is shipped with rustup so users can install the target with: rustup target add wasm32-wasip1 Rust programs can be built for that target: rustc --target wasm32-wasip1 your-code.rs","breadcrumbs":"Platform Support  wasm32-wasip1  Building Rust programs","id":"1667","title":"Building Rust programs"},"1668":{"body":"This target can be cross-compiled from any hosts.","breadcrumbs":"Platform Support  wasm32-wasip1  Cross-compilation","id":"1668","title":"Cross-compilation"},"1669":{"body":"This target is tested in rust-lang/rust CI on all merges. A subset of tests are run in the test-various builder such as the UI tests and libcore tests. This can be tested locally, for example, with: ./x.py test --target wasm32-wasip1 tests/ui","breadcrumbs":"Platform Support  wasm32-wasip1  Testing","id":"1669","title":"Testing"},"167":{"body":"#![warn(if_let_rescope)]\\n#![allow(unused_variables)] struct Droppy;\\nimpl Drop for Droppy { fn drop(&mut self) { // Custom destructor, including this `drop` implementation, is considered // significant. // Rust does not check whether this destructor emits side-effects that can // lead to observable change in program semantics, when the drop order changes. // Rust biases to be on the safe side, so that you can apply discretion whether // this change indeed breaches any contract or specification that your code needs // to honour. println!(\\"dropped\\"); }\\n}\\nimpl Droppy { fn get(&self) -> Option<u8> { None }\\n} fn main() { if let Some(value) = Droppy.get() { // do something } else { // do something else }\\n} This will produce: warning: `if let` assigns a shorter lifetime since Edition 2024 --> lint_example.rs:24:8 |\\n24 | if let Some(value) = Droppy.get() { | ^^^^^^^^^^^^^^^^^^------^^^^^^ | | | this value has a significant drop implementation which may observe a major change in drop order and requires your discretion | = warning: this changes meaning in Rust 2024 = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html>\\nnote: value invokes this custom destructor --> lint_example.rs:5:1 | 5 | impl Drop for Droppy { | ^^^^^^^^^^^^^^^^^^^^\\nhelp: the value is now dropped here in Edition 2024 --> lint_example.rs:26:5 |\\n26 | } else { | ^\\nnote: the lint level is defined here --> lint_example.rs:1:9 | 1 | #![warn(if_let_rescope)] | ^^^^^^^^^^^^^^\\nhelp: a `match` with a single arm can preserve the drop order up to Edition 2021 |\\n24 ~ match Droppy.get() { Some(value) => {\\n25 | // do something\\n26 ~ } _ => {\\n27 | // do something else\\n28 ~ }} |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"167","title":"Example"},"1670":{"body":"It\'s recommended to conditionally compile code for this target with: #[cfg(all(target_os = \\"wasi\\", target_env = \\"p1\\"))] Note that the target_env = \\"p1\\" condition first appeared in Rust 1.80. Prior to Rust 1.80 the target_env condition was not set.","breadcrumbs":"Platform Support  wasm32-wasip1  Conditionally compiling code","id":"1670","title":"Conditionally compiling code"},"1671":{"body":"The default set of WebAssembly features enabled for compilation is currently the same as wasm32-unknown-unknown . See the documentation there for more information.","breadcrumbs":"Platform Support  wasm32-wasip1  Enabled WebAssembly features","id":"1671","title":"Enabled WebAssembly features"},"1672":{"body":"This target is compiled with -Cpanic=abort by default. For information on using -Cpanic=unwind see the documentation about unwinding for wasm32-unknown-unknown .","breadcrumbs":"Platform Support  wasm32-wasip1  Unwinding","id":"1672","title":"Unwinding"},"1673":{"body":"Tier: 2 The wasm32-wasip1-threads target is a new and still (as of July 2023) an experimental target. This target is an extension to wasm32-wasip1 target, originally known as wasm32-wasi. It extends the original target with a standardized set of syscalls that are intended to empower WebAssembly binaries with native multi threading capabilities. Note : Prior to March 2024 this target was known as wasm32-wasi-preview1-threads, and even longer before that it was known as wasm32-wasi-threads.","breadcrumbs":"Platform Support  wasm32-wasip1-threads  wasm32-wasip1-threads","id":"1673","title":"wasm32-wasip1-threads"},"1674":{"body":"@g0djan @alexcrichton @abrown @loganek","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Target maintainers","id":"1674","title":"Target maintainers"},"1675":{"body":"This target is cross-compiled. The target supports std fully. The Rust target definition here is interesting in a few ways. We want to serve two use cases here with this target: First, we want Rust usage of the target to be as hassle-free as possible, ideally avoiding the need to configure and install a local wasm32-wasip1-threads toolchain. Second, one of the primary use cases of LLVM\'s new wasm backend and the wasm support in LLD is that any compiled language can interoperate with any other. The wasm32-wasip1-threads target is the first with a viable C standard library and sysroot common definition, so we want Rust and C/C++ code to interoperate when compiled to wasm32-unknown-unknown. You\'ll note, however, that the two goals above are somewhat at odds with one another. To attempt to solve both use cases in one go we define a target that (ab)uses the crt-static target feature to indicate which one you\'re in.","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Requirements","id":"1675","title":"Requirements"},"1676":{"body":"By default the crt-static target feature is enabled, and when enabled this means that the bundled version of libc.a found in liblibc.rlib is used. This isn\'t intended really for interoperation with a C because it may be the case that Rust\'s bundled C library is incompatible with a foreign-compiled C library. In this use case, though, we use rust-lld and some copied crt startup object files to ensure that you can download the wasi target for Rust and you\'re off to the races, no further configuration necessary. All in all, by default, no external dependencies are required. You can compile wasm32-wasip1-threads binaries straight out of the box. You can\'t, however, reliably interoperate with C code in this mode (yet).","breadcrumbs":"Platform Support  wasm32-wasip1-threads  No interop with C required","id":"1676","title":"No interop with C required"},"1677":{"body":"For the second goal we repurpose the target-feature flag, meaning that you\'ll need to do a few things to have C/Rust code interoperate. All Rust code needs to be compiled with -C target-feature=-crt-static, indicating that the bundled C standard library in the Rust sysroot will not be used. If you\'re using rustc to build a linked artifact then you\'ll need to specify -C linker to a clang binary that supports wasm32-wasip1-threads and is configured with the wasm32-wasip1-threads sysroot. This will cause Rust code to be linked against the libc.a that the specified clang provides. If you\'re building a staticlib and integrating Rust code elsewhere, then compiling with -C target-feature=-crt-static is all you need to do. All in all, by default, no external dependencies are required. You can compile wasm32-wasip1-threads binaries straight out of the box. You can\'t, however, reliably interoperate with C code in this mode (yet). Also note that at this time the wasm32-wasip1-threads target assumes the presence of other merged wasm proposals such as (with their LLVM feature flags): Bulk memory - +bulk-memory Mutable imported globals - +mutable-globals Atomics - +atomics LLVM 16 is required for this target. The reason is related to linker flags: prior to LLVM 16, --import-memory and --export-memory were not allowed together. The reason both are needed is an artifact of how WASI currently does things; see https://github.com/WebAssembly/WASI/issues/502 for more details. The target intends to match the corresponding Clang target for its \\"C\\" ABI. Note : due to the relatively early-days nature of this target when working with this target you may encounter LLVM bugs. If an assertion hit or a bug is found it\'s recommended to open an issue either with rust-lang/rust or ideally with LLVM itself.","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Interop with C required","id":"1677","title":"Interop with C required"},"1678":{"body":"The runtime should support the same set of APIs as any other supported wasi target for interacting with the host environment through the WASI standard. The runtime also should have implementation of wasi-threads proposal . This target is not a stable target. This means that there are a few engines which implement the wasi-threads feature and if they do they\'re likely behind a flag, for example: Wasmtime - --wasi threads WAMR - needs to be built with WAMR_BUILD_LIB_WASI_THREADS=1","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Platform requirements","id":"1678","title":"Platform requirements"},"1679":{"body":"Users need to install or built wasi-sdk since release 20.0 https://github.com/WebAssembly/wasi-sdk/releases/tag/wasi-sdk-20 and specify path to wasi-root bootstrap.toml [target.wasm32-wasip1-threads]\\nwasi-root = \\".../wasi-libc/sysroot\\" After that users can build this by adding it to the target list in bootstrap.toml, or with -Zbuild-std.","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Building the target","id":"1679","title":"Building the target"},"168":{"body":"With Edition 2024, temporaries generated while evaluating if lets will be dropped before the else block. This lint captures a possible change in runtime behaviour due to a change in sequence of calls to significant Drop::drop destructors. A significant Drop::drop destructor here refers to an explicit, arbitrary implementation of the Drop trait on the type with exceptions including Vec, Box, Rc, BTreeMap and HashMap that are marked by the compiler otherwise so long that the generic types have no significant destructor recursively. In other words, a type has a significant drop destructor when it has a Drop implementation or its destructor invokes a significant destructor on a type. Since we cannot completely reason about the change by just inspecting the existence of a significant destructor, this lint remains only a suggestion and is set to allow by default. Whenever possible, a rewrite into an equivalent match expression that observe the same order of calls to such destructors is proposed by this lint. Authors may take their own discretion whether the rewrite suggestion shall be accepted, or rejected to continue the use of the if let expression.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"168","title":"Explanation"},"1680":{"body":"From Rust Nightly 1.71.1 (2023-08-03) on the artifacts are shipped pre-compiled: rustup target add wasm32-wasip1-threads --toolchain nightly Rust programs can be built for that target: rustc --target wasm32-wasip1-threads your-code.rs","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Building Rust programs","id":"1680","title":"Building Rust programs"},"1681":{"body":"This target can be cross-compiled from any hosts.","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Cross-compilation","id":"1681","title":"Cross-compilation"},"1682":{"body":"Currently testing is not well supported for wasm32-wasip1-threads and the Rust project doesn\'t run any tests for this target. However the UI testsuite can be run manually following this instructions: Ensure wamr , wasmtime or another engine that supports wasi-threads is installed and can be found in the $PATH env variable. Clone master branch. Apply such a change with an engine from the step 1. Run ./x.py test --target wasm32-wasip1-threads tests/ui and save the list of failed tests. Checkout branch with your changes. Apply such a change with an engine from the step 1. Run ./x.py test --target wasm32-wasip1-threads tests/ui and save the list of failed tests. For both lists of failed tests run cat list | sort > sorted_list and compare it with diff sorted_list1 sorted_list2.","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Testing","id":"1682","title":"Testing"},"1683":{"body":"It\'s recommended to conditionally compile code for this target with: #[cfg(all(target_os = \\"wasi\\", target_env = \\"p1\\", target_feature = \\"atomics\\"))] Prior to Rust 1.80 the target_env = \\"p1\\" key was not set. Currently the target_feature = \\"atomics\\" is Nightly-only. Note that the precise #[cfg] necessary to detect this target may change as the target becomes more stable.","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Conditionally compiling code","id":"1683","title":"Conditionally compiling code"},"1684":{"body":"The default set of WebAssembly features enabled for compilation includes two more features in addition to that which wasm32-unknown-unknown enables: bulk-memory atomics For more information about features see the documentation for wasm32-unknown-unknown , but note that the mvp CPU in LLVM does not support this target as it\'s required that bulk-memory, atomics, and mutable-globals are all enabled.","breadcrumbs":"Platform Support  wasm32-wasip1-threads  Enabled WebAssembly features","id":"1684","title":"Enabled WebAssembly features"},"1685":{"body":"Tier: 2 The wasm32-wasip2 target is a new and still (as of January 2024) an experimental target. This target is an extension to wasm32-wasip1 target, originally known as wasm32-wasi. It is the next evolution in the development of wasi (the WebAssembly System Interface ) that uses the WebAssembly component model to allow for a standardized set of syscalls that are intended to empower WebAssembly binaries with native host capabilities.","breadcrumbs":"Platform Support  wasm32-wasip2  wasm32-wasip2","id":"1685","title":"wasm32-wasip2"},"1686":{"body":"@alexcrichton @rylev","breadcrumbs":"Platform Support  wasm32-wasip2  Target maintainers","id":"1686","title":"Target maintainers"},"1687":{"body":"This target is cross-compiled. The target supports std fully.","breadcrumbs":"Platform Support  wasm32-wasip2  Requirements","id":"1687","title":"Requirements"},"1688":{"body":"The WebAssembly runtime should support the wasi preview 2 API set. Runtimes also are required to support components since this target outputs a component as opposed to a core wasm module. As of the time of this writing Wasmtime 17 and above is able to run this target natively with no extra flags.","breadcrumbs":"Platform Support  wasm32-wasip2  Platform requirements","id":"1688","title":"Platform requirements"},"1689":{"body":"To build this target first acquire a copy of wasi-sdk . At this time version 22 is the minimum needed. Next configure the WASI_SDK_PATH environment variable to point to where this is installed. For example: export WASI_SDK_PATH=/path/to/wasi-sdk-22.0 Next be sure to enable LLD when building Rust from source as LLVM\'s wasm-ld driver for LLD is required when linking WebAssembly code together. Rust\'s build system will automatically pick up any necessary binaries and programs from WASI_SDK_PATH.","breadcrumbs":"Platform Support  wasm32-wasip2  Building the target","id":"1689","title":"Building the target"},"169":{"body":"The impl_trait_overcaptures lint warns against cases where lifetime capture behavior will differ in edition 2024. In the 2024 edition, impl Traits will capture all lifetimes in scope, rather than just the lifetimes that are mentioned in the bounds of the type. Often these sets are equal, but if not, it means that the impl Trait may cause erroneous borrow-checker errors.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  impl-trait-overcaptures","id":"169","title":"impl-trait-overcaptures"},"1690":{"body":"This target is not tested in CI at this time. Locally it can be tested with a wasmtime binary in PATH like so: ./x.py test --target wasm32-wasip2 tests/ui","breadcrumbs":"Platform Support  wasm32-wasip2  Testing","id":"1690","title":"Testing"},"1691":{"body":"It\'s recommended to conditionally compile code for this target with: #[cfg(all(target_os = \\"wasi\\", target_env = \\"p2\\"))]","breadcrumbs":"Platform Support  wasm32-wasip2  Conditionally compiling code","id":"1691","title":"Conditionally compiling code"},"1692":{"body":"The default set of WebAssembly features enabled for compilation is currently the same as wasm32-unknown-unknown . See the documentation there for more information.","breadcrumbs":"Platform Support  wasm32-wasip2  Enabled WebAssembly features","id":"1692","title":"Enabled WebAssembly features"},"1693":{"body":"This target is compiled with -Cpanic=abort by default. For information on using -Cpanic=unwind see the documentation about unwinding for wasm32-unknown-unknown .","breadcrumbs":"Platform Support  wasm32-wasip2  Unwinding","id":"1693","title":"Unwinding"},"1694":{"body":"Tier: 3 The wasm32-wasip3 target is the next stage of evolution of the wasm32-wasip2 target. The wasm32-wasip3 target enables the Rust standard library to use WASIp3 APIs to implement various pieces of functionality. WASIp3 brings native async support over WASIp2, which integrates well with Rust\'s async ecosystem. Note : As of 2025-10-01 WASIp3 has not yet been approved by the WASI subgroup of the WebAssembly Community Group. Development is expected to conclude in late 2025 or early 2026. Until then the Rust standard library won\'t actually use WASIp3 APIs on the wasm32-wasip3 target as they are not yet stable and would reduce the stability of this target. Once WASIp3 is approved, however, the standard library will update to use WASIp3 natively. Note : This target does not yet build as of 2025-10-01 due to and update needed in the libc crate. Using it will require a [patch] for now. Note : Until the standard library is fully migrated to use the wasip3 crate then components produced for wasm32-wasip3 may import WASIp2 APIs. This is considered a transitionary phase until fully support of libstd is implemented.","breadcrumbs":"Platform Support  wasm32-wasip3  wasm32-wasip3","id":"1694","title":"wasm32-wasip3"},"1695":{"body":"@alexcrichton","breadcrumbs":"Platform Support  wasm32-wasip3  Target maintainers","id":"1695","title":"Target maintainers"},"1696":{"body":"This target is cross-compiled. The target supports std fully.","breadcrumbs":"Platform Support  wasm32-wasip3  Requirements","id":"1696","title":"Requirements"},"1697":{"body":"The WebAssembly runtime should support both WASIp2 and WASIp3. Runtimes also are required to support components since this target outputs a component as opposed to a core wasm module. Two example runtimes for WASIp3 are Wasmtime and Jco .","breadcrumbs":"Platform Support  wasm32-wasip3  Platform requirements","id":"1697","title":"Platform requirements"},"1698":{"body":"To build this target first acquire a copy of wasi-sdk . At this time version 22 is the minimum needed. Next configure the WASI_SDK_PATH environment variable to point to where this is installed. For example: export WASI_SDK_PATH=/path/to/wasi-sdk-22.0 Next be sure to enable LLD when building Rust from source as LLVM\'s wasm-ld driver for LLD is required when linking WebAssembly code together. Rust\'s build system will automatically pick up any necessary binaries and programs from WASI_SDK_PATH.","breadcrumbs":"Platform Support  wasm32-wasip3  Building the target","id":"1698","title":"Building the target"},"1699":{"body":"This target is not tested in CI at this time. Locally it can be tested with a wasmtime binary in PATH like so: ./x.py test --target wasm32-wasip3 tests/ui","breadcrumbs":"Platform Support  wasm32-wasip3  Testing","id":"1699","title":"Testing"},"17":{"body":"This flag will allow you to set print options .","breadcrumbs":"Command-line Arguments  --print: print compiler information","id":"17","title":"--print: print compiler information"},"170":{"body":"# #![deny(impl_trait_overcaptures)]\\n# use std::fmt::Display;\\nlet mut x = vec![];\\nx.push(1); fn test(x: &Vec<i32>) -> impl Display { x[0]\\n} let element = test(&x);\\nx.push(2);\\nprintln!(\\"{element}\\"); This will produce: error: `impl std::fmt::Display` will capture more lifetimes than possibly intended in edition 2024 --> lint_example.rs:7:26 |\\n7 | fn test(x: &Vec<i32>) -> impl Display { | ^^^^^^^^^^^^ | = warning: this changes meaning in Rust 2024 = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/rpit-lifetime-capture.html>\\nnote: specifically, this lifetime is in scope but not mentioned in the type\'s bounds --> lint_example.rs:7:12 |\\n7 | fn test(x: &Vec<i32>) -> impl Display { | ^ = note: all lifetimes in scope will be captured by `impl Trait`s in edition 2024\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(impl_trait_overcaptures)] | ^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: use the precise capturing `use<...>` syntax to make the captures explicit |\\n7 | fn test(x: &Vec<i32>) -> impl Display + use<> { | +++++++","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"170","title":"Example"},"1700":{"body":"It\'s recommended to conditionally compile code for this target with: #[cfg(all(target_os = \\"wasi\\", target_env = \\"p3\\"))]","breadcrumbs":"Platform Support  wasm32-wasip3  Conditionally compiling code","id":"1700","title":"Conditionally compiling code"},"1701":{"body":"The default set of WebAssembly features enabled for compilation is currently the same as wasm32-unknown-unknown . See the documentation there for more information.","breadcrumbs":"Platform Support  wasm32-wasip3  Enabled WebAssembly features","id":"1701","title":"Enabled WebAssembly features"},"1702":{"body":"Tier: 3 WebAssembly targets that use the WebAssembly Linux Interface (WALI) with 32-bit memory. The latest status of the WALI specification and support are documented within the repo. WALI offers seamless targetability of traditional Linux applications to Wasm by exposing Linux syscalls strategically into the sandbox. Numerous applications and build system work unmodified over WALI, including complex low-level system libraries -- a list of applications are included in the research paper linked in the main repo. From the wider Wasm ecosystem perspective, implementing WALI within engines allows layering of high-level security policies (e.g. WASI) above it, arming the latter\'s implementations with sandboxing and portability.","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  wasm32-wali-linux-*","id":"1702","title":"wasm32-wali-linux-*"},"1703":{"body":"@arjunr2","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Target maintainers","id":"1703","title":"Target maintainers"},"1704":{"body":"","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Requirements","id":"1704","title":"Requirements"},"1705":{"body":"This target is cross-compiled and requires an installation of the WALI compiler/sysroot . This produces standard wasm32 binaries with the WALI interface methods as module imports that need to be implemented by a supported engine (see the \\"Execution\\" section below). wali targets minimally require the following LLVM feature flags: Bulk memory - +bulk-memory Mutable imported globals - +mutable-globals Sign-extending operations - +sign-ext Threading/Atomics - +atomics Note : Users can expect that new enabled-by-default Wasm features for LLVM are transitively incorporatable into this target -- see wasm32-unknown-unknown for detailed information on WebAssembly features. Note : The WALI ABI is similar to default Clang wasm32 ABIs but not identical . The primary difference is 64-bit long types as opposed to 32-bit for wasm32. This is required to maintain minimum source code changes for 64-bit host platforms currently supported. This may change in the future as the spec evolves.","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Compilation","id":"1705","title":"Compilation"},"1706":{"body":"Running generated WALI binaries also requires a supported compliant engine implementation -- a working implementation in the WebAssembly Micro-Runtime (WAMR) is included in the repo. Note : WALI is still somewhat experimental and bugs may exist in the Rust support, WALI toolchain, or the LLVM compiler. The former can be filed in Rust repos while the latter two in the WALI repo.","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Execution","id":"1706","title":"Execution"},"1707":{"body":"You can build Rust with support for the target by adding it to the target list in config.toml, and pointing to the toolchain artifacts from the previous section (\\"Requirements->Compilation\\"). A sample config.toml for the musl environment will look like this, where <WALI-root> is the absolute path to the root directory of the WALI repo : [build]\\ntarget = [\\"wasm32-wali-linux-musl\\"] [target.wasm32-wali-linux-musl]\\nmusl-root = \\"<WALI>/wali-musl/sysroot\\"\\nllvm-config = \\"<WALI>/llvm-project/build/bin/llvm-config\\"\\ncc = \\"<WALI>/llvm-project/build/bin/clang-18\\"\\ncxx = \\"<WALI>/llvm-project/build/bin/clang-18\\"\\nar = \\"<WALI>/llvm-project/build/bin/llvm-ar\\"\\nranlib = \\"<WALI>/llvm-project/build/bin/llvm-ranlib\\"\\nllvm-libunwind = \\"system\\"\\ncrt-static = true The llvm-config settings are only temporary, and the changes will eventually be upstreamed into LLVM","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Building the target","id":"1707","title":"Building the target"},"1708":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar. Rust program builds can use this target normally. Currently, linking WALI programs may require pointing the linker to the llvm build in the Cargo config (until LLVM is upstreamed). A config.toml for Cargo will look like the following: [target.wasm32-wali-linux-musl]\\nlinker = \\"<WALI>/llvm-project/build/bin/lld\\" Note that the following cfg directives are set for wasm32-wali-linux-*: cfg(target_arch = \\"wasm32\\") cfg(target_family = {\\"wasm\\", \\"unix\\"}) cfg(target_r = \\"wasm\\") cfg(target_os = \\"linux\\") cfg(target_env = *)","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Building Rust programs","id":"1708","title":"Building Rust programs"},"1709":{"body":"Hardware or platform-specific support, besides syscall is mostly unsupported in WALI for ISA portability (these tend to be uncommon).","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Restrictions","id":"1709","title":"Restrictions"},"171":{"body":"In edition < 2024, the returned impl Display doesn\'t capture the lifetime from the &Vec<i32>, so the vector can be mutably borrowed while the impl Display is live. To fix this, we can explicitly state that the impl Display doesn\'t capture any lifetimes, using impl Display + use<>.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"171","title":"Explanation"},"1710":{"body":"Currently testing is not supported for wali targets and the Rust project doesn\'t run any tests for this target. However, standard ISA-agnostic tests for Linux should be thereotically reusable for WALI targets and minor changes. Testing integration will be continually incorporated as support evolves.","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Testing","id":"1710","title":"Testing"},"1711":{"body":"Most fully featured C code is compilable with the WALI toolchain -- examples can be seen in the repo.","breadcrumbs":"Platform Support  wasm32-wali-linux-musl  Cross-compilation toolchains and C code","id":"1711","title":"Cross-compilation toolchains and C code"},"1712":{"body":"Tier: 2 The wasm32-unknown-emscripten target is a WebAssembly compilation target which uses the Emscripten compiler toolchain. Emscripten is a C/C++ toolchain designed to make it as easy as possible to port C/C++ code written for Linux to run on the web or in other JavaScript runtimes such as Node. It thus provides POSIX-compatible (musl) libc and libstd implementations and many Linux APIs, access to the OpenGL and SDL APIs, and the ability to run arbitrary JavaScript code, all based on web APIs using JS glue code. With the wasm32-unknown-emscripten target, Rust code can interoperate with Emscripten\'s ecosystem, C/C++ and JS code, and web APIs. One existing user of this target is the pyodide project which provides a Python runtime in WebAssembly using Emscripten and compiles Python extension modules written in Rust to the wasm32-unknown-emscripten target. If you want to generate a standalone WebAssembly binary that does not require access to the web APIs or the Rust standard library, the wasm32-unknown-unknown target may be better suited for you. However, wasm32-unknown-unknown does not (easily) support interop with C/C++ code. Please refer to the wasm-bindgen crate in case you want to interoperate with JavaScript with this target. Like Emscripten, the WASI targets wasm32-wasip1 and wasm32-wasip2 also provide access to the host environment, support interop with C/C++ (and other languages), and support most of the Rust standard library. While the WASI targets are portable across different hosts (web and non-web), WASI has no standard way of accessing web APIs, whereas Emscripten has the ability to run arbitrary JS from WASM and access many web APIs. If you are only targeting the web and need to access web APIs, the wasm32-unknown-emscripten target may be preferable.","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  wasm32-unknown-emscripten","id":"1712","title":"wasm32-unknown-emscripten"},"1713":{"body":"@hoodmane @juntyr","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Target maintainers","id":"1713","title":"Target maintainers"},"1714":{"body":"This target is cross-compiled. The Emscripten compiler toolchain emcc must be installed to link WASM binaries for this target. You can install emcc using: git clone https://github.com/emscripten-core/emsdk.git --depth 1\\n./emsdk/emsdk install 3.1.68\\n./emsdk/emsdk activate 3.1.68\\nsource ./emsdk/emsdk_env.sh Please refer to https://emscripten.org/docs/getting_started/downloads.html for further details and instructions.","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Requirements","id":"1714","title":"Requirements"},"1715":{"body":"Building this target can be done by: Configure the wasm32-unknown-emscripten target to get built. Ensure the WebAssembly target backend is not disabled in LLVM. These are all controlled through bootstrap.toml options. It should be possible to build this target on any platform. A minimal example configuration would be: [llvm]\\ntargets = \\"WebAssembly\\" [build]\\nbuild-stage = 1\\ntarget = [\\"wasm32-unknown-emscripten\\"]","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Building the target","id":"1715","title":"Building the target"},"1716":{"body":"Rust programs can be compiled by adding this target via rustup: $ rustup target add wasm32-unknown-emscripten and then compiling with the target: $ rustc foo.rs --target wasm32-unknown-emscripten\\n$ file foo.wasm","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Building Rust programs","id":"1716","title":"Building Rust programs"},"1717":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Cross-compilation","id":"1717","title":"Cross-compilation"},"1718":{"body":"The Emscripten compiler toolchain does not follow a semantic versioning scheme that clearly indicates when breaking changes to the ABI can be made. Additionally, Emscripten offers many different ABIs even for a single version of Emscripten depending on the linker flags used, e.g. -fexceptions and -sWASM_BIGINT. If the ABIs mismatch, your code may exhibit undefined behaviour. To ensure that the ABIs of your Rust code, of the Rust standard library, and of other code compiled for Emscripten all match, you should rebuild the Rust standard library with your local Emscripten version and settings using: cargo +nightly -Zbuild-std build If you still want to use the pre-compiled std from rustup, you should ensure that your local Emscripten matches the version used by Rust and be careful about any -C link-args that you compiled your Rust code with.","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Emscripten ABI Compatibility","id":"1718","title":"Emscripten ABI Compatibility"},"1719":{"body":"This target is not extensively tested in CI for the rust-lang/rust repository. It can be tested locally, for example, with: EMCC_CFLAGS=\\"-s MAXIMUM_MEMORY=2GB\\" ./x.py test --target wasm32-unknown-emscripten --skip src/tools/linkchecker To run these tests, both emcc and node need to be in your $PATH. You can install node, for example, using nvm by following the instructions at https://github.com/nvm-sh/nvm#install--update-script . If you need to test WebAssembly compatibility in general , it is recommended to test the wasm32-wasip1 target instead.","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Testing","id":"1719","title":"Testing"},"172":{"body":"The impl_trait_redundant_captures lint warns against cases where use of the precise capturing use<...> syntax is not needed. In the 2024 edition, impl Traits will capture all lifetimes in scope. If precise-capturing use<...> syntax is used, and the set of parameters that are captures are equal to the set of parameters in scope, then the syntax is redundant, and can be removed.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  impl-trait-redundant-captures","id":"172","title":"impl-trait-redundant-captures"},"1720":{"body":"It\'s recommended to conditionally compile code for this target with: #[cfg(target_os = \\"emscripten\\")] It may sometimes be necessary to conditionally compile code for WASM targets which do not use emscripten, which can be achieved with: #[cfg(all(target_family = \\"wasm\\", not(target_os = \\"emscripten)))]","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Conditionally compiling code","id":"1720","title":"Conditionally compiling code"},"1721":{"body":"WebAssembly is an evolving standard which adds new features such as new instructions over time. This target\'s default set of supported WebAssembly features will additionally change over time. The wasm32-unknown-emscripten target inherits the default settings of LLVM which typically, but not necessarily, matches the default settings of Emscripten as well. At link time, emcc configures the linker to use Emscripten\'s settings. Please refer to the wasm32-unknown-unknown target\'s documentation on which WebAssembly features Rust enables by default, how features can be disabled, and how Rust code can be conditionally compiled based on which features are enabled. Note that Rust code compiled for wasm32-unknown-emscripten currently enables -fexceptions (JS exceptions) by default unless the Rust code is compiled with -Cpanic=abort. -fwasm-exceptions (WASM exceptions) is not yet currently supported, see https://github.com/rust-lang/rust/issues/112195 . Please refer to the Emscripten ABI compatibility section to ensure that the features that are enabled do not cause an ABI mismatch between your Rust code, the pre-compiled Rust standard library, and other code compiled for Emscripten.","breadcrumbs":"Platform Support  wasm32-unknown-emscripten  Enabled WebAssembly features","id":"1721","title":"Enabled WebAssembly features"},"1722":{"body":"Tier: 2 The wasm32-unknown-unknown target is a WebAssembly compilation target which does not import any functions from the host for the standard library. This is the \\"minimal\\" WebAssembly in the sense of making the fewest assumptions about the host environment. This target is often used when compiling to the web or JavaScript environments as there is no standard for what functions can be imported on the web. This target can also be useful for creating minimal or bare-bones WebAssembly binaries. The wasm32-unknown-unknown target has support for the Rust standard library but many parts of the standard library do not work and return errors. For example println! does nothing, std::fs always return errors, and std::thread::spawn will panic. There is no means by which this can be overridden. For a WebAssembly target that more fully supports the standard library see the wasm32-wasip1 or wasm32-wasip2 targets. The wasm32-unknown-unknown target has full support for the core and alloc crates. It additionally supports the HashMap type in the std crate, although hash maps are not randomized like they are on other platforms. One existing user of this target (please feel free to edit and expand this list too) is the wasm-bindgen project which facilitates Rust code interoperating with JavaScript code. Note, though, that not all uses of wasm32-unknown-unknown are using JavaScript and the web.","breadcrumbs":"Platform Support  wasm32-unknown-unknown  wasm32-unknown-unknown","id":"1722","title":"wasm32-unknown-unknown"},"1723":{"body":"When this target was added to the compiler, platform-specific documentation here was not maintained at that time. This means that the list below is not exhaustive, and there are more interested parties in this target. That being said, those interested in maintaining this target are: @alexcrichton","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Target maintainers","id":"1723","title":"Target maintainers"},"1724":{"body":"This target is cross-compiled. The target includes support for std itself, but as mentioned above many pieces of functionality that require an operating system do not work and will return errors. This target currently has no equivalent in C/C++. There is no C/C++ toolchain for this target. While interop is theoretically possible it\'s recommended to instead use one of: wasm32-unknown-emscripten - for web-based use cases the Emscripten toolchain is typically chosen for running C/C++. wasm32-wasip1 - the wasi-sdk toolchain is used to compile C/C++ on this target and can interop with Rust code. WASI works on the web so far as there\'s no blocker, but an implementation of WASI APIs must be either chosen or reimplemented. This target has no build requirements beyond what\'s in-tree in the Rust repository. Linking binaries requires LLD to be enabled for the wasm-ld driver. This target uses the dlmalloc crate as the default global allocator.","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Requirements","id":"1724","title":"Requirements"},"1725":{"body":"Building this target can be done by: Configure the wasm32-unknown-unknown target to get built. Configure LLD to be built. Ensure the WebAssembly target backend is not disabled in LLVM. These are all controlled through bootstrap.toml options. It should be possible to build this target on any platform.","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Building the target","id":"1725","title":"Building the target"},"1726":{"body":"Rust programs can be compiled by adding this target via rustup: $ rustup target add wasm32-unknown-unknown and then compiling with the target: $ rustc foo.rs --target wasm32-unknown-unknown\\n$ file foo.wasm","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Building Rust programs","id":"1726","title":"Building Rust programs"},"1727":{"body":"This target can be cross-compiled from any host.","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Cross-compilation","id":"1727","title":"Cross-compilation"},"1728":{"body":"This target is not tested in CI for the rust-lang/rust repository. Many tests must be disabled to run on this target and failures are non-obvious because println! doesn\'t work in the standard library. It\'s recommended to test the wasm32-wasip1 target instead for WebAssembly compatibility.","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Testing","id":"1728","title":"Testing"},"1729":{"body":"It\'s recommended to conditionally compile code for this target with: #[cfg(all(target_family = \\"wasm\\", target_os = \\"unknown\\"))] Note that there is no way to tell via #[cfg] whether code will be running on the web or not.","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Conditionally compiling code","id":"1729","title":"Conditionally compiling code"},"173":{"body":"# #![deny(impl_trait_redundant_captures)]\\nfn test<\'a>(x: &\'a i32) -> impl Sized + use<\'a> { x } This will produce: error: all possible in-scope parameters are already captured, so `use<...>` syntax is redundant --> lint_example.rs:3:28 |\\n3 | fn test<\'a>(x: &\'a i32) -> impl Sized + use<\'a> { x } | ^^^^^^^^^^^^^------- | | | help: remove the `use<...>` syntax |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(impl_trait_redundant_captures)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"173","title":"Example"},"1730":{"body":"WebAssembly is an evolving standard which adds new features such as new instructions over time. This target\'s default set of supported WebAssembly features will additionally change over time. The wasm32-unknown-unknown target inherits the default settings of LLVM which typically matches the default settings of Emscripten as well. Changes to WebAssembly go through a proposals process but reaching the final stage (stage 5) does not automatically mean that the feature will be enabled in LLVM and Rust by default. At this time the general guidance is that features must be present in most engines for a \\"good chunk of time\\" before they\'re enabled in LLVM by default. There is currently no exact number of months or engines that are required to enable features by default. As of the time of this writing the proposals that are enabled by default (the generic CPU in LLVM terminology) are: multivalue mutable-globals reference-types sign-ext nontrapping-fptoint (Rust 1.87.0+, LLVM 20+) bulk-memory (Rust 1.87.0+, LLVM 20+) If you\'re compiling WebAssembly code for an engine that does not support a feature in LLVM\'s default feature set then the feature must be disabled at compile time. There are two approaches to choose from: If you are targeting a feature set no smaller than the W3C WebAssembly Core 1.0 recommendation -- which is equivalent to the WebAssembly MVP plus the mutable-globals feature -- and you are building no_std, then you can simply use the wasm32v1-none target instead of wasm32-unknown-unknown, which uses only those minimal features and includes a core and alloc library built with only those minimal features. Otherwise -- if you need std, or if you need to target the ultra-minimal \\"MVP\\" feature set, excluding mutable-globals -- you will need to manually specify -Ctarget-cpu=mvp and also rebuild the stdlib using that target to ensure no features are used in the stdlib. This in turn requires use of a nightly compiler. Compiling all code for the initial release of WebAssembly looks like: $ export RUSTFLAGS=-Ctarget-cpu=mvp\\n$ cargo +nightly build -Zbuild-std=panic_abort,std --target wasm32-unknown-unknown Here the mvp \\"cpu\\" is a placeholder in LLVM for disabling all supported features by default. Cargo\'s -Zbuild-std feature, a Nightly Rust feature, is then used to recompile the standard library in addition to your own code. This will produce a binary that uses only the original WebAssembly features by default and no proposals since its inception. To enable individual features on either this target or wasm32v1-none, pass arguments of the form -Ctarget-feature=+foo. Available features for Rust code itself are documented in the reference and can also be found through: $ rustc -Ctarget-feature=help --target wasm32-unknown-unknown You\'ll need to consult your WebAssembly engine\'s documentation to learn more about the supported WebAssembly features the engine has. Note that it is still possible for Rust crates and libraries to enable WebAssembly features on a per-function level. This means that the build command above may not be sufficient to disable all WebAssembly features. If the final binary still has SIMD instructions, for example, the function in question will need to be found and the crate in question will likely contain something like: #[target_feature(enable = \\"simd128\\")]\\nfn foo() { // ...\\n} In this situation there is no compiler flag to disable emission of SIMD instructions and the crate must instead be modified to not include this function at compile time either by default or through a Cargo feature. For crate authors it\'s recommended to avoid #[target_feature(enable = \\"...\\")] except where necessary and instead use: #[cfg(target_feature = \\"simd128\\")]\\nfn foo() { // ...\\n} That is to say instead of enabling target features it\'s recommended to conditionally compile code instead. This is notably different to the way native platforms such as x86_64 work, and this is due to the fact that WebAssembly binaries must only contain code the engine understands. Native binaries work so long as the CPU doesn\'t execute unknown code dynamically at runtime.","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Enabled WebAssembly features","id":"1730","title":"Enabled WebAssembly features"},"1731":{"body":"By default the wasm32-unknown-unknown target is compiled with -Cpanic=abort. Historically this was due to the fact that there was no way to catch panics in wasm, but since mid-2025 the WebAssembly exception-handling proposal reached stabilization. LLVM has support for this proposal as well and when this is all combined together it\'s possible to enable -Cpanic=unwind on wasm targets. Compiling wasm targets with -Cpanic=unwind is not as easy as just passing -Cpanic=unwind, however: $ rustc foo.rs -Cpanic=unwind --target wasm32-unknown-unknown\\nerror: the crate `panic_unwind` does not have the panic strategy `unwind` Notably the precompiled standard library that is shipped through Rustup is compiled with -Cpanic=abort, not -Cpanic=unwind. While this is the case you\'re going to be required to use Cargo\'s -Zbuild-std feature to build with unwinding support: $ RUSTFLAGS=\'-Cpanic=unwind\' cargo +nightly build --target wasm32-unknown-unknown -Zbuild-std Note, however, that as of 2025-10-03 LLVM is still using the \\"legacy exception instructions\\" by default, not the officially standard version of the exception-handling proposal: $ wasm-tools validate target/wasm32-unknown-unknown/debug/foo.wasm\\nerror: <sysroot>/library/std/src/sys/backtrace.rs:161:5\\nfunction `std::sys::backtrace::__rust_begin_short_backtrace` failed to validate Caused by: 0: func 2 failed to validate 1: legacy_exceptions feature required for try instruction (at offset 0x880) Fixing this requires passing -Cllvm-args=-wasm-use-legacy-eh=false to the Rust compiler as well: $ RUSTFLAGS=\'-Cpanic=unwind -Cllvm-args=-wasm-use-legacy-eh=false\' cargo +nightly build --target wasm32-unknown-unknown -Zbuild-std\\n$ wasm-tools validate target/wasm32-unknown-unknown/debug/foo.wasm At this time there are no concrete plans for adding new targets to the Rust compiler which have -Cpanic=unwind enabled-by-default. The most likely route to having this enabled is that in a few years when the exception-handling target feature is enabled by default in LLVM (due to browsers/runtime support propagating widely enough) the targets will switch to using -Cpanic=unwind by default. This is not for certain, however, and will likely be accompanied with either an MCP or an RFC about changing all wasm targets in the same manner. In the meantime using -Cpanic=unwind will require using -Zbuild-std and passing the appropriate flags to rustc.","breadcrumbs":"Platform Support  wasm32-unknown-unknown  Unwinding","id":"1731","title":"Unwinding"},"1732":{"body":"Tier: 2 The wasm32v1-none target is a WebAssembly compilation target that: Imports nothing from its host environment Enables no proposals / features past the W3C WebAssembly Core 1.0 spec The target is very similar to wasm32-unknown-unknown and similarly uses LLVM\'s wasm32-unknown-unknown backend target. It contains only three minor differences: Setting the target-cpu to mvp rather than the default generic. Requesting mvp disables all WebAssembly proposals / LLVM target feature flags. Enabling the Import/Export of Mutable Globals proposal (i.e. the +mutable-globals LLVM target feature flag) Not compiling the std library at all, rather than compiling it with stubs.","breadcrumbs":"Platform Support  wasm32v1-none  wasm32v1-none","id":"1732","title":"wasm32v1-none"},"1733":{"body":"@alexcrichton @graydon","breadcrumbs":"Platform Support  wasm32v1-none  Target maintainers","id":"1733","title":"Target maintainers"},"1734":{"body":"This target is cross-compiled. It does not support std, only core and alloc. Since it imports nothing from its environment, any std parts that use OS facilities would be stubbed out with functions-that-fail anyways, and the experience of working with the stub std in the wasm32-unknown-unknown target was deemed not something worth repeating here. Everything else about this target\'s requirements, building, usage and testing is the same as what\'s described in the wasm32-unknown-unknown document , just using the target string wasm32v1-none in place of wasm32-unknown-unknown.","breadcrumbs":"Platform Support  wasm32v1-none  Requirements","id":"1734","title":"Requirements"},"1735":{"body":"It\'s recommended to conditionally compile code for this target with: #[cfg(all(target_family = \\"wasm\\", target_os = \\"none\\"))] Note that there is no way to tell via #[cfg] whether code will be running on the web or not.","breadcrumbs":"Platform Support  wasm32v1-none  Conditionally compiling code","id":"1735","title":"Conditionally compiling code"},"1736":{"body":"As noted above, no WebAssembly proposals past 1.0 are enabled on this target by default. Indeed, the entire point of this target is to have a way to compile for a stable \\"no post-1.0 proposals\\" subset of WebAssembly on stable Rust . The W3C WebAssembly Core 1.0 spec was adopted as a W3C recommendation in December 2019, and includes exactly one \\"post-MVP\\" proposal: the Import/Export of Mutable Globals proposal. All subsequent proposals are disabled on this target by default, though they can be individually enabled by passing LLVM target-feature flags. For reference sake, the set of proposals that LLVM supports at the time of writing, that this target does not enable by default , are listed here along with their LLVM target-feature flags: Post-1.0 proposals (integrated into the WebAssembly core 2.0 spec): Bulk memory - +bulk-memory Sign-extending operations - +sign-ext Non-trapping fp-to-int operations - +nontrapping-fptoint Multi-value - +multivalue Reference Types - +reference-types Fixed-width SIMD - +simd128 Post-2.0 proposals: Threads (supported by atomics) - +atomics Exception handling - +exception-handling Extended Constant Expressions - +extended-const Half Precision - +half-precision Multiple memories - +multimemory Relaxed SIMD - +relaxed-simd Tail call - +tail-call Additional proposals in the future are, of course, also not enabled by default.","breadcrumbs":"Platform Support  wasm32v1-none  Enabled WebAssembly features","id":"1736","title":"Enabled WebAssembly features"},"1737":{"body":"As noted in the wasm32-unknown-unknown document , it is possible to compile with --target wasm32-unknown-unknown and disable all WebAssembly proposals \\"by hand\\", by passing -Ctarget-cpu=mvp. Furthermore one can enable proposals one by one by passing LLVM target feature flags, such as -Ctarget-feature=+mutable-globals. Is it therefore reasonable to wonder what the difference is between building with this: $ rustc --target wasm32-unknown-unknown -Ctarget-cpu=mvp -Ctarget-feature=+mutable-globals and building with this: $ rustc --target wasm32v1-none The difference is in how the core and alloc crates are compiled for distribution with the toolchain, and whether it works on stable Rust toolchains or requires nightly ones. Again referring back to the wasm32-unknown-unknown document , note that to disable all post-MVP proposals on that target one actually has to compile with this: $ export RUSTFLAGS=\\"-Ctarget-cpu=mvp -Ctarget-feature=+mutable-globals\\"\\n$ cargo +nightly build -Zbuild-std=panic_abort,std --target wasm32-unknown-unknown Which not only rebuilds std, core and alloc (which is somewhat costly and annoying) but more importantly requires the use of nightly Rust toolchains (for the -Zbuild-std flag). This is very undesirable for the target audience, which consists of people targeting WebAssembly implementations that prioritize stability, simplicity and/or security over feature support. This wasm32v1-none target exists as an alternative option that works on stable Rust toolchains, without rebuilding the stdlib.","breadcrumbs":"Platform Support  wasm32v1-none  Rationale relative to wasm32-unknown-unknown","id":"1737","title":"Rationale relative to wasm32-unknown-unknown"},"1738":{"body":"This target is compiled with -Cpanic=abort by default. Using -Cpanic=unwind would require using the WebAssembly exception-handling proposal stabilized mid-2025, and if that\'s desired then you most likely don\'t want to use this target and instead want to use wasm32-unknown-unknown instead. It\'s unlikely that this target will ever support unwinding with the precompiled artifacts shipped through rustup. For documentation about using -Zbuild-std to enable using -Cpanic=unwind see the documentation of wasm32-unknown-unknown .","breadcrumbs":"Platform Support  wasm32v1-none  Unwinding","id":"1738","title":"Unwinding"},"1739":{"body":"Tier: 3 WebAssembly target which uses 64-bit memories, relying on the memory64 WebAssembly proposal.","breadcrumbs":"Platform Support  wasm64-unknown-unknown  wasm64-unknown-unknown","id":"1739","title":"wasm64-unknown-unknown"},"174":{"body":"To fix this, remove the use<\'a>, since the lifetime is already captured since it is in scope.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"174","title":"Explanation"},"1740":{"body":"@alexcrichton","breadcrumbs":"Platform Support  wasm64-unknown-unknown  Target maintainers","id":"1740","title":"Target maintainers"},"1741":{"body":"This target is cross-compiled. The target supports std in the same manner as the wasm32-unknown-unknown target which is to say that it comes with the standard library but many I/O functions such as std::fs and std::net will simply return error. Additionally I/O operations like println! don\'t actually do anything and the prints aren\'t routed anywhere. This is the same as the wasm32-unknown-unknown target. This target comes by default with an allocator, currently dlmalloc which is ported to rust . The difference of this target with wasm32-unknown-unknown is that it\'s compiled for 64-bit memories instead of 32-bit memories. This means that usize is 8-bytes large as well as pointers. The tradeoff, though, is that the maximum memory size is now the full 64-bit address space instead of the 4GB as limited by the 32-bit address space for wasm32-unknown-unknown. This target is not a stable target. The memory64 WebAssembly proposal is still in-progress and not standardized. This means that there are not many engines which implement the memory64 feature and if they do they\'re likely behind a flag, for example: Nodejs - --experimental-wasm-memory64 Wasmtime - --wasm memory64 Also note that at this time the wasm64-unknown-unknown target assumes the presence of other merged wasm proposals such as (with their LLVM feature flags): Bulk memory - +bulk-memory Mutable imported globals - +mutable-globals Sign-extending operations - +sign-ext Non-trapping fp-to-int operations - +nontrapping-fptoint The wasm64-unknown-unknown target intends to match the default Clang targets for its \\"C\\" ABI, which is likely to be the same as Clang\'s wasm32-unknown-unknown largely. Note : due to the relatively early-days nature of this target when working with this target you may encounter LLVM bugs. If an assertion hit or a bug is found it\'s recommended to open an issue either with rust-lang/rust or ideally with LLVM itself. This target does not support panic=unwind at this time.","breadcrumbs":"Platform Support  wasm64-unknown-unknown  Requirements","id":"1741","title":"Requirements"},"1742":{"body":"You can build Rust with support for the target by adding it to the target list in bootstrap.toml, and the target also requires lld to be built to work. [build]\\ntarget = [\\"wasm64-unknown-unknown\\"] [rust]\\nlld = true","breadcrumbs":"Platform Support  wasm64-unknown-unknown  Building the target","id":"1742","title":"Building the target"},"1743":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of std by using build-std or similar. Note that the following cfg directives are set for wasm64-unknown-unknown: cfg(target_arch = \\"wasm64\\") cfg(target_family = \\"wasm\\")","breadcrumbs":"Platform Support  wasm64-unknown-unknown  Building Rust programs","id":"1743","title":"Building Rust programs"},"1744":{"body":"Currently testing is not well supported for wasm64-unknown-unknown and the Rust project doesn\'t run any tests for this target. Testing support sort of works but without println! it\'s not the most exciting tests to run.","breadcrumbs":"Platform Support  wasm64-unknown-unknown  Testing","id":"1744","title":"Testing"},"1745":{"body":"Compiling Rust code with C code for wasm64-unknown-unknown is theoretically possible, but there are no known toolchains to do this at this time. At the time of this writing there is no known \\"libc\\" for wasm that works with wasm64-unknown-unknown, which means that mixing C & Rust with this target effectively cannot be done.","breadcrumbs":"Platform Support  wasm64-unknown-unknown  Cross-compilation toolchains and C code","id":"1745","title":"Cross-compilation toolchains and C code"},"1746":{"body":" This documentation page is a stub, you can help improving it by sending a PR.  Tier: 1/2 (with host tools) Target triples available: i686-pc-windows-gnu: Tier 2 x86_64-pc-windows-gnu: Tier 1","breadcrumbs":"Platform Support  windows-gnu  *-windows-gnu","id":"1746","title":"*-windows-gnu"},"1747":{"body":" These targets do not have any maintainers and are not properly maintained.  If you are using this target, consider signing up to become a target maintainer. See the target tier policy for details. Without maintainers, these targets may be demoted in the future.","breadcrumbs":"Platform Support  windows-gnu  Target maintainers","id":"1747","title":"Target maintainers"},"1748":{"body":"These targets support std and host tools. Unlike their MSVC counterparts, windows-gnu targets support cross-compilation and are free of all MSVC licensing implications. They follow Windows calling convention for extern \\"C\\". Like with any other Windows target, created binaries are in PE format.","breadcrumbs":"Platform Support  windows-gnu  Requirements","id":"1748","title":"Requirements"},"1749":{"body":"Rust does ship a pre-compiled std library for those targets. That means one can easily compile and cross-compile for those targets from other hosts if C proper toolchain is installed.","breadcrumbs":"Platform Support  windows-gnu  Building Rust programs","id":"1749","title":"Building Rust programs"},"175":{"body":"The lint keyword-idents has been renamed to keyword-idents-2018 .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  keyword-idents","id":"175","title":"keyword-idents"},"1750":{"body":"Tier: 2 (with host tools) Windows targets similar to *-windows-gnu but using UCRT as the runtime and various LLVM tools/libraries instead of GCC/Binutils. Target triples available so far: aarch64-pc-windows-gnullvm i686-pc-windows-gnullvm x86_64-pc-windows-gnullvm","breadcrumbs":"Platform Support  windows-gnullvm  *-windows-gnullvm","id":"1750","title":"*-windows-gnullvm"},"1751":{"body":"@mati865 @thomcc","breadcrumbs":"Platform Support  windows-gnullvm  Target maintainers","id":"1751","title":"Target maintainers"},"1752":{"body":"The easiest way to obtain these targets is cross-compilation, but native build from x86_64-pc-windows-gnu is possible with few hacks which I don\'t recommend. Std support is expected to be on par with *-windows-gnu. Binaries for this target should be at least on par with *-windows-gnu in terms of requirements and functionality. Those targets follow Windows calling convention for extern \\"C\\". Like with any other Windows target, created binaries are in PE format.","breadcrumbs":"Platform Support  windows-gnullvm  Requirements","id":"1752","title":"Requirements"},"1753":{"body":"These targets can be easily cross-compiled using llvm-mingw toolchain or MSYS2 CLANG* environments. Just fill [target.*] sections for both build and resulting compiler and set installation prefix in bootstrap.toml. Then run ./x.py install. In my case I had ran ./x.py install --host x86_64-pc-windows-gnullvm --target x86_64-pc-windows-gnullvm inside MSYS2 MINGW64 shell so x86_64-pc-windows-gnu was my build toolchain. Native bootstrapping is doable in two ways: cross-compile gnullvm host toolchain and use it as build toolchain for the next build, copy libunwind libraries and rename them to mimic libgcc like here: https://github.com/msys2/MINGW-packages/blob/68e640756df2df6df6afa60f025e3f936e7b977c/mingw-w64-rust/PKGBUILD#L108-L109, stage0 compiler will be mostly broken but good enough to build the next stage. The second option might stop working anytime, so it\'s not recommended.","breadcrumbs":"Platform Support  windows-gnullvm  Building the target","id":"1753","title":"Building the target"},"1754":{"body":"Rust does ship a pre-compiled std library for those targets. That means one can easily cross-compile for those targets from other hosts if C proper toolchain is installed. Alternatively full toolchain can be built as described in the previous section.","breadcrumbs":"Platform Support  windows-gnullvm  Building Rust programs","id":"1754","title":"Building Rust programs"},"1755":{"body":"Created binaries work fine on Windows or Wine using native hardware. Testing AArch64 on x86_64 is problematic though and requires spending some time with QEMU. Most of x86_64 testsuite does pass when cross-compiling, with exception for rustdoc and ui-fulldeps that fail with and error regarding a missing library, they do pass in native builds though. The only failing test is std\'s process::tests::test_proc_thread_attributes for unknown reason.","breadcrumbs":"Platform Support  windows-gnullvm  Testing","id":"1755","title":"Testing"},"1756":{"body":"Compatible C code can be built with Clang\'s aarch64-pc-windows-gnu, i686-pc-windows-gnullvm and x86_64-pc-windows-gnu targets as long as LLVM-based C toolchains are used. Those include: llvm-mingw MSYS2 with CLANG* environment","breadcrumbs":"Platform Support  windows-gnullvm  Cross-compilation toolchains and C code","id":"1756","title":"Cross-compilation toolchains and C code"},"1757":{"body":"Tier: 3 Windows targets continuing support of Windows 7. Target triples: i686-win7-windows-gnu x86_64-win7-windows-gnu","breadcrumbs":"Platform Support  *-win7-windows-gnu  *-win7-windows-gnu","id":"1757","title":"*-win7-windows-gnu"},"1758":{"body":"@tbu-","breadcrumbs":"Platform Support  *-win7-windows-gnu  Target maintainers","id":"1758","title":"Target maintainers"},"1759":{"body":"This target supports all of core, alloc, std and test. Host tools may also work, though those are not currently tested. Those targets follow Windows calling convention for extern \\"C\\". Like any other Windows target, the created binaries are in PE format.","breadcrumbs":"Platform Support  *-win7-windows-gnu  Requirements","id":"1759","title":"Requirements"},"176":{"body":"The keyword_idents_2018 lint detects edition keywords being used as an identifier.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  keyword-idents-2018","id":"176","title":"keyword-idents-2018"},"1760":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml: [build]\\nbuild-stage = 1\\ntarget = [\\"x86_64-win7-windows-gnu\\"]","breadcrumbs":"Platform Support  *-win7-windows-gnu  Building the target","id":"1760","title":"Building the target"},"1761":{"body":"Rust does not ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy by using build-std or similar.","breadcrumbs":"Platform Support  *-win7-windows-gnu  Building Rust programs","id":"1761","title":"Building Rust programs"},"1762":{"body":"Created binaries work fine on Windows or Wine using native hardware. Remote testing is possible using the remote-test-server described here .","breadcrumbs":"Platform Support  *-win7-windows-gnu  Testing","id":"1762","title":"Testing"},"1763":{"body":"Compatible C code can be built with gcc\'s {i686,x86_64}-w64-mingw32-gcc.","breadcrumbs":"Platform Support  *-win7-windows-gnu  Cross-compilation toolchains and C code","id":"1763","title":"Cross-compilation toolchains and C code"},"1764":{"body":"Tier: 3 Windows targets continuing support of Windows 7. Target triples: i686-win7-windows-msvc x86_64-win7-windows-msvc","breadcrumbs":"Platform Support  *-win7-windows-msvc  *-win7-windows-msvc","id":"1764","title":"*-win7-windows-msvc"},"1765":{"body":"@roblabla","breadcrumbs":"Platform Support  *-win7-windows-msvc  Target maintainers","id":"1765","title":"Target maintainers"},"1766":{"body":"This target supports all of core, alloc, std and test. This is automatically tested every night on private infrastructure hosted by the maintainer. Host tools may also work, though those are not currently tested. Those targets follow Windows calling convention for extern \\"C\\". Like any other Windows target, the created binaries are in PE format.","breadcrumbs":"Platform Support  *-win7-windows-msvc  Requirements","id":"1766","title":"Requirements"},"1767":{"body":"You can build Rust with support for the targets by adding it to the target list in bootstrap.toml: [build]\\nbuild-stage = 1\\ntarget = [\\"x86_64-win7-windows-msvc\\"]","breadcrumbs":"Platform Support  *-win7-windows-msvc  Building the target","id":"1767","title":"Building the target"},"1768":{"body":"Rust does not ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy by using build-std or similar.","breadcrumbs":"Platform Support  *-win7-windows-msvc  Building Rust programs","id":"1768","title":"Building Rust programs"},"1769":{"body":"Created binaries work fine on Windows or Wine using native hardware. Remote testing is possible using the remote-test-server described here .","breadcrumbs":"Platform Support  *-win7-windows-msvc  Testing","id":"1769","title":"Testing"},"177":{"body":"#![deny(keyword_idents_2018)]\\n// edition 2015\\nfn dyn() {} This will produce: error: `dyn` is a keyword in the 2018 edition --> lint_example.rs:4:4 |\\n4 | fn dyn() {} | ^^^ help: you can use a raw identifier to stay compatible: `r#dyn` | = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018! = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(keyword_idents_2018)] | ^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"177","title":"Example"},"1770":{"body":"Compatible C code can be built with either MSVC\'s cl.exe or LLVM\'s clang-cl. Cross-compilation is possible using clang-cl/lld-link. It also requires the Windows SDK, which can be acquired using xwin . Install clang-cl and lld-link on your machine, and make sure they are in your $PATH. Install xwin: cargo install xwin Use xwin to install the Windows SDK: xwin splat --output winsdk Create an xwin-lld-link script with the following content: #!/usr/bin/env bash\\nset -e\\nXWIN=/path/to/winsdk\\nlld-link \\"$@\\" /libpath:$XWIN/crt/lib/x86_64 /libpath:$XWIN/sdk/lib/um/x86_64 /libpath:$XWIN/sdk/lib/ucrt/x86_64 Create an xwin-clang-cl script with the following content: #!/usr/bin/env bash\\nset -e\\nXWIN=/path/to/winsdk\\nclang-cl /imsvc \\"$XWIN/crt/include\\" /imsvc \\"$XWIN/sdk/include/ucrt\\" /imsvc \\"$XWIN/sdk/include/um\\" /imsvc \\"$XWIN/sdk/include/shared\\" --target=\\"x86_64-pc-windows-msvc\\" \\"$@\\" In your bootstrap.toml, add the following lines: [target.x86_64-win7-windows-msvc]\\nlinker = \\"path/to/xwin-lld-link\\"\\ncc = \\"path/to/xwin-clang-cl\\" You should now be able to cross-compile the Rust std, and any rust program.","breadcrumbs":"Platform Support  *-win7-windows-msvc  Cross-compilation toolchains and C code","id":"1770","title":"Cross-compilation toolchains and C code"},"1771":{"body":"Tier: 2 Secure enclaves using Intel Software Guard Extensions (SGX) based on the ABI defined by Fortanix for the Enclave Development Platform (EDP) .","breadcrumbs":"Platform Support  x86_64-fortanix-unknown-sgx  x86_64-fortanix-unknown-sgx","id":"1771","title":"x86_64-fortanix-unknown-sgx"},"1772":{"body":"@jethrogb @raoulstrackx @aditijannu Further contacts: The EDP team at Fortanix.","breadcrumbs":"Platform Support  x86_64-fortanix-unknown-sgx  Target maintainers","id":"1772","title":"Target maintainers"},"1773":{"body":"The target supports std with a default allocator. Only cross compilation is supported. Binaries support all CPUs that include Intel SGX. Only 64-bit mode is supported. Not all std features are supported, see Using Rust\'s std for details. The extern \\"C\\" calling convention is the System V AMD64 ABI. The supported ABI is the fortanix-sgx-abi . The compiler output is ELF, but the native format for the platform is the SGX stream (SGXS) format. A converter like ftxsgx-elf2sgxs is needed. Programs in SGXS format adhering to the Fortanix SGX ABI can be run with any compatible runner, such as ftxsgx-runner . See the EDP installation guide for recommendations on how to setup a development and runtime environment.","breadcrumbs":"Platform Support  x86_64-fortanix-unknown-sgx  Requirements","id":"1773","title":"Requirements"},"1774":{"body":"As a tier 2 target, the target is built by the Rust project. You can configure bootstrap like so: [build]\\nbuild-stage = 1\\ntarget = [\\"x86_64-fortanix-unknown-sgx\\"]","breadcrumbs":"Platform Support  x86_64-fortanix-unknown-sgx  Building the target","id":"1774","title":"Building the target"},"1775":{"body":"Standard build flows using cargo or rustc should work.","breadcrumbs":"Platform Support  x86_64-fortanix-unknown-sgx  Building Rust programs","id":"1775","title":"Building Rust programs"},"1776":{"body":"The Rust test suite as well as custom unit and integration tests will run on hardware that has Intel SGX enabled if a cargo runner is configured correctly, see the requirements section.","breadcrumbs":"Platform Support  x86_64-fortanix-unknown-sgx  Testing","id":"1776","title":"Testing"},"1777":{"body":"C code is not generally supported, as there is no libc. C code compiled for x86-64 in freestanding mode using the System V AMD64 ABI may work. The rs-libc crate contains a subset of libc that\'s known to work with this target.","breadcrumbs":"Platform Support  x86_64-fortanix-unknown-sgx  Cross-compilation toolchains and C code","id":"1777","title":"Cross-compilation toolchains and C code"},"1778":{"body":"Tier: 3 Windows targets supporting Cygwin. The *-cygwin targets are not intended as native target for applications, a developer writing Windows applications should use the *-pc-windows-* targets instead, which are native Windows. Cygwin is only intended as an emulation layer for Unix-only programs which do not support the native Windows targets.","breadcrumbs":"Platform Support  x86_64-pc-cygwin  x86_64-pc-cygwin","id":"1778","title":"x86_64-pc-cygwin"},"1779":{"body":"@Berrysoft","breadcrumbs":"Platform Support  x86_64-pc-cygwin  Target maintainers","id":"1779","title":"Target maintainers"},"178":{"body":"Rust editions allow the language to evolve without breaking backwards compatibility. This lint catches code that uses new keywords that are added to the language that are used as identifiers (such as a variable name, function name, etc.). If you switch the compiler to a new edition without updating the code, then it will fail to compile if you are using a new keyword as an identifier. You can manually change the identifiers to a non-keyword, or use a raw identifier , for example r#dyn, to transition to a new edition. This lint solves the problem automatically. It is \\"allow\\" by default because the code is perfectly valid in older editions. The cargo fix tool with the --edition flag will switch this lint to \\"warn\\" and automatically apply the suggested fix from the compiler (which is to use a raw identifier). This provides a completely automated way to update old code for a new edition.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"178","title":"Explanation"},"1780":{"body":"This target is cross compiled. It needs x86_64-pc-cygwin-gcc as linker. The target_os of the target is cygwin, and it is unix.","breadcrumbs":"Platform Support  x86_64-pc-cygwin  Requirements","id":"1780","title":"Requirements"},"1781":{"body":"For cross-compilation you want LLVM at least 20.1.0-rc1. No native builds on Cygwin now. The tracking issue for host tools on Cygwin is #137819 .","breadcrumbs":"Platform Support  x86_64-pc-cygwin  Building the target","id":"1781","title":"Building the target"},"1782":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar.","breadcrumbs":"Platform Support  x86_64-pc-cygwin  Building Rust programs","id":"1782","title":"Building Rust programs"},"1783":{"body":"Created binaries work fine on Windows with Cygwin.","breadcrumbs":"Platform Support  x86_64-pc-cygwin  Testing","id":"1783","title":"Testing"},"1784":{"body":"Compatible C code can be built with GCC shipped with Cygwin. Clang is untested.","breadcrumbs":"Platform Support  x86_64-pc-cygwin  Cross-compilation toolchains and C code","id":"1784","title":"Cross-compilation toolchains and C code"},"1785":{"body":"Tier: 3 Freestanding x86-64 linux binary with no dependency on libc.","breadcrumbs":"Platform Support  x86_64-unknown-linux-none  x86_64-unknown-linux-none","id":"1785","title":"x86_64-unknown-linux-none"},"1786":{"body":"@morr0ne","breadcrumbs":"Platform Support  x86_64-unknown-linux-none  Target maintainers","id":"1786","title":"Target maintainers"},"1787":{"body":"This target is cross compiled and can be built from any host. This target has no support for host tools, std, or alloc. One of the primary motivations of the target is to write a dynamic linker and libc in Rust. For that, the target defaults to position-independent code and position-independent executables (PIE) by default. PIE binaries need relocation at runtime. This is usually done by the dynamic linker or libc. You can use -Crelocation-model=static to create a position-dependent binary that does not need relocation at runtime.","breadcrumbs":"Platform Support  x86_64-unknown-linux-none  Requirements","id":"1787","title":"Requirements"},"1788":{"body":"The target can be built by enabling it for a rustc build: [build]\\nbuild-stage = 1\\ntarget = [\\"x86_64-unknown-linux-none\\"]","breadcrumbs":"Platform Support  x86_64-unknown-linux-none  Building the target","id":"1788","title":"Building the target"},"1789":{"body":"Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \\"Building the target\\" above), or build your own copy of core by using build-std or similar.","breadcrumbs":"Platform Support  x86_64-unknown-linux-none  Building Rust programs","id":"1789","title":"Building Rust programs"},"179":{"body":"The keyword_idents_2024 lint detects edition keywords being used as an identifier.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  keyword-idents-2024","id":"179","title":"keyword-idents-2024"},"1790":{"body":"Created binaries will run on linux without any external requirements","breadcrumbs":"Platform Support  x86_64-unknown-linux-none  Testing","id":"1790","title":"Testing"},"1791":{"body":"Support for C code is currently untested","breadcrumbs":"Platform Support  x86_64-unknown-linux-none  Cross-compilation toolchains and C code","id":"1791","title":"Cross-compilation toolchains and C code"},"1792":{"body":"Tier: 2 Freestanding/bare-metal x86-64 binaries in ELF format: firmware, kernels, etc.","breadcrumbs":"Platform Support  x86_64-unknown-none  x86_64-unknown-none","id":"1792","title":"x86_64-unknown-none"},"1793":{"body":"@haraldh @mikeleany","breadcrumbs":"Platform Support  x86_64-unknown-none  Target maintainers","id":"1793","title":"Target maintainers"},"1794":{"body":"This target is cross-compiled. There is no support for std. There is no default allocator, but it\'s possible to use alloc by supplying an allocator. By default, Rust code generated for this target does not use any vector or floating-point registers (e.g. SSE, AVX). This allows the generated code to run in environments, such as kernels, which may need to avoid the use of such registers or which may have special considerations about the use of such registers (e.g. saving and restoring them to avoid breaking userspace code using the same registers). You can change code generation to use additional CPU features via the -C target-feature= codegen options to rustc, or via the #[target_feature] mechanism within Rust code. By default, code generated with this target should run on any x86_64 hardware; enabling additional target features may raise this baseline. Code generated with this target will use the kernel code model by default. You can change this using the -C code-model= option to rustc. On x86_64-unknown-none, extern \\"C\\" uses the standard System V calling convention , without red zones. This target generates binaries in the ELF format. Any alternate formats or special considerations for binary layout will require linker options or linker scripts.","breadcrumbs":"Platform Support  x86_64-unknown-none  Requirements","id":"1794","title":"Requirements"},"1795":{"body":"You can build Rust with support for the target by adding it to the target list in bootstrap.toml: [build]\\nbuild-stage = 1\\ntarget = [\\"x86_64-unknown-none\\"]","breadcrumbs":"Platform Support  x86_64-unknown-none  Building the target","id":"1795","title":"Building the target"},"1796":{"body":"Starting with Rust 1.62, precompiled artifacts are provided via rustup: # install cross-compile toolchain\\nrustup target add x86_64-unknown-none\\n# target flag may be used with any cargo or rustc command\\ncargo build --target x86_64-unknown-none","breadcrumbs":"Platform Support  x86_64-unknown-none  Building Rust programs","id":"1796","title":"Building Rust programs"},"1797":{"body":"As x86_64-unknown-none supports a variety of different environments and does not support std, this target does not support running the Rust test suite.","breadcrumbs":"Platform Support  x86_64-unknown-none  Testing","id":"1797","title":"Testing"},"1798":{"body":"If you want to compile C code along with Rust (such as for Rust crates with C dependencies), you will need an appropriate x86_64 toolchain. Rust may be able to use an x86_64-linux-gnu- toolchain with appropriate standalone flags to build for this toolchain (depending on the assumptions of that toolchain, see below), or you may wish to use a separate x86_64-unknown-none (or x86_64-elf-) toolchain. On some x86_64 hosts that use ELF binaries, you may be able to use the host C toolchain, if it does not introduce assumptions about the host environment that don\'t match the expectations of a standalone environment. Otherwise, you may need a separate toolchain for standalone/freestanding development, just as when cross-compiling from a non-x86_64 platform.","breadcrumbs":"Platform Support  x86_64-unknown-none  Cross-compilation toolchains and C code","id":"1798","title":"Cross-compilation toolchains and C code"},"1799":{"body":"Tier: 3 Targets for Xtensa CPUs.","breadcrumbs":"Platform Support  xtensa-*-none-elf  xtensa-*-none-elf","id":"1799","title":"xtensa-*-none-elf"},"18":{"body":"A synonym for -C debuginfo=2 .","breadcrumbs":"Command-line Arguments  -g: include debug information","id":"18","title":"-g: include debug information"},"180":{"body":"#![deny(keyword_idents_2024)]\\n// edition 2015\\nfn gen() {} This will produce: error: `gen` is a keyword in the 2024 edition --> lint_example.rs:4:4 |\\n4 | fn gen() {} | ^^^ help: you can use a raw identifier to stay compatible: `r#gen` | = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2024! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/gen-keyword.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(keyword_idents_2024)] | ^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"180","title":"Example"},"1800":{"body":"@MabezDev @SergioGasquez","breadcrumbs":"Platform Support  xtensa-*-none-elf  Target maintainers","id":"1800","title":"Target maintainers"},"1801":{"body":"The target names follow this format: xtensa-$CPU, where $CPU specifies the target chip. The following targets are currently defined: Target name Target CPU(s) xtensa-esp32-none-elf ESP32 xtensa-esp32s2-none-elf ESP32-S2 xtensa-esp32s3-none-elf ESP32-S3 Xtensa targets that support std are documented in the ESP-IDF platform support document","breadcrumbs":"Platform Support  xtensa-*-none-elf  Requirements","id":"1801","title":"Requirements"},"1802":{"body":"The targets can be built by installing the Xtensa enabled Rust channel . See instructions in the RISC-V and Xtensa Targets section of The Rust on ESP Book .","breadcrumbs":"Platform Support  xtensa-*-none-elf  Building the targets","id":"1802","title":"Building the targets"},"1803":{"body":"Tier: 3 Targets for the Apache NuttX . Apache NuttX is a real-time operating system (RTOS) with an emphasis on standards compliance and small footprint. It is scalable from 8-bit to 64-bit microcontroller environments. The primary governing standards in NuttX are POSIX and ANSI standards. NuttX adopts additional standard APIs from Unix and other common RTOSs, such as VxWorks. These APIs are used for functionality not available under the POSIX and ANSI standards. However, some APIs, like fork(), are not appropriate for deeply-embedded environments and are not implemented in NuttX. For brevity, many parts of the documentation will refer to Apache NuttX as simply NuttX.","breadcrumbs":"Platform Support  *-nuttx-*  *-nuttx-elf","id":"1803","title":"*-nuttx-elf"},"1804":{"body":"@no1wudi","breadcrumbs":"Platform Support  *-nuttx-*  Target maintainers","id":"1804","title":"Target maintainers"},"1805":{"body":"The target name follow this format: ARCH[-VENDOR]-nuttx-ABI, where ARCH is the target architecture, VENDOR is the vendor name, and ABI is the ABI used. The following target names are defined: aarch64-unknown-nuttx armv7a-nuttx-eabi armv7a-nuttx-eabihf thumbv6m-nuttx-eabi thumbv7a-nuttx-eabi thumbv7a-nuttx-eabihf thumbv7m-nuttx-eabi thumbv7em-nuttx-eabi thumbv7em-nuttx-eabihf thumbv8m.base-nuttx-eabi thumbv8m.main-nuttx-eabi thumbv8m.main-nuttx-eabihf riscv32imc-unknown-nuttx-elf riscv32imac-unknown-nuttx-elf riscv32imafc-unknown-nuttx-elf riscv64imac-unknown-nuttx-elf riscv64gc-unknown-nuttx-elf","breadcrumbs":"Platform Support  *-nuttx-*  Requirements","id":"1805","title":"Requirements"},"1806":{"body":"The target can be built by enabling it in the rustc build: [build]\\ntarget = \\"riscv32imc-unknown-nuttx-elf\\" [target.\'riscv32imc-unknown-nuttx-elf\']\\nlinker = \\"riscv-none-elf-gcc\\" The toolchain for the target can be found in NuttX\'s quick start guide .","breadcrumbs":"Platform Support  *-nuttx-*  Building the target","id":"1806","title":"Building the target"},"1807":{"body":"This is a cross-compiled no-std target, which must be run either in a simulator or by programming them onto suitable hardware. It is not possible to run the Rust test-suite on this target.","breadcrumbs":"Platform Support  *-nuttx-*  Testing","id":"1807","title":"Testing"},"1808":{"body":"This target supports C code. If interlinking with C or C++, you may need to use riscv-none-elf-gcc or arm-none-eabi-gcc as a linker instead of rust-lld.","breadcrumbs":"Platform Support  *-nuttx-*  Cross-compilation toolchains and C code","id":"1808","title":"Cross-compilation toolchains and C code"},"181":{"body":"Rust editions allow the language to evolve without breaking backwards compatibility. This lint catches code that uses new keywords that are added to the language that are used as identifiers (such as a variable name, function name, etc.). If you switch the compiler to a new edition without updating the code, then it will fail to compile if you are using a new keyword as an identifier. You can manually change the identifiers to a non-keyword, or use a raw identifier , for example r#gen, to transition to a new edition. This lint solves the problem automatically. It is \\"allow\\" by default because the code is perfectly valid in older editions. The cargo fix tool with the --edition flag will switch this lint to \\"warn\\" and automatically apply the suggested fix from the compiler (which is to use a raw identifier). This provides a completely automated way to update old code for a new edition.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"181","title":"Explanation"},"182":{"body":"The let_underscore_drop lint checks for statements which don\'t bind an expression which has a non-trivial Drop implementation to anything, causing the expression to be dropped immediately instead of at end of scope.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  let-underscore-drop","id":"182","title":"let-underscore-drop"},"183":{"body":"struct SomeStruct;\\nimpl Drop for SomeStruct { fn drop(&mut self) { println!(\\"Dropping SomeStruct\\"); }\\n} fn main() { #[warn(let_underscore_drop)] // SomeStruct is dropped immediately instead of at end of scope, // so \\"Dropping SomeStruct\\" is printed before \\"end of main\\". // The order of prints would be reversed if SomeStruct was bound to // a name (such as \\"_foo\\"). let _ = SomeStruct; println!(\\"end of main\\");\\n} This will produce: warning: non-binding let on a type that has a destructor --> lint_example.rs:14:5 |\\n14 | let _ = SomeStruct; | ^^^^^^^^^^^^^^^^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:9:11 | 9 | #[warn(let_underscore_drop)] | ^^^^^^^^^^^^^^^^^^^\\nhelp: consider binding to an unused variable to avoid immediately dropping the value |\\n14 | let _unused = SomeStruct; | ++++++\\nhelp: consider immediately dropping the value |\\n14 - let _ = SomeStruct;\\n14 + drop(SomeStruct); |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"183","title":"Example"},"184":{"body":"Statements which assign an expression to an underscore causes the expression to immediately drop instead of extending the expression\'s lifetime to the end of the scope. This is usually unintended, especially for types like MutexGuard, which are typically used to lock a mutex for the duration of an entire scope. If you want to extend the expression\'s lifetime to the end of the scope, assign an underscore-prefixed name (such as _foo) to the expression. If you do actually want to drop the expression immediately, then calling std::mem::drop on the expression is clearer and helps convey intent.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"184","title":"Explanation"},"185":{"body":"The linker_messages lint forwards warnings from the linker.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  linker-messages","id":"185","title":"linker-messages"},"186":{"body":"#[warn(linker_messages)]\\nextern \\"C\\" { fn foo();\\n}\\nfn main () { unsafe { foo(); } } On Linux, using gcc -Wl,--warn-unresolved-symbols as a linker, this will produce warning: linker stderr: rust-lld: undefined symbol: foo >>> referenced by rust_out.69edbd30df4ae57d-cgu.0 >>> rust_out.rust_out.69edbd30df4ae57d-cgu.0.rcgu.o:(rust_out::main::h3a90094b06757803) |\\nnote: the lint level is defined here --> warn.rs:1:9 |\\n1 | #![warn(linker_messages)] | ^^^^^^^^^^^^^^^\\nwarning: 1 warning emitted","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"186","title":"Example"},"187":{"body":"Linkers emit platform-specific and program-specific warnings that cannot be predicted in advance by the Rust compiler. Such messages are ignored by default for now. While linker warnings could be very useful they have been ignored for many years by essentially all users, so we need to do a bit more work than just surfacing their text to produce a clear and actionable warning of similar quality to our other diagnostics. See this tracking issue for more details: https://github.com/rust-lang/rust/issues/136096 .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"187","title":"Explanation"},"188":{"body":"The lossy_provenance_casts lint detects an as cast between a pointer and an integer.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  lossy-provenance-casts","id":"188","title":"lossy-provenance-casts"},"189":{"body":"#![feature(strict_provenance_lints)]\\n#![warn(lossy_provenance_casts)] fn main() { let x: u8 = 37; let _addr: usize = &x as *const u8 as usize;\\n} This will produce: warning: under strict provenance it is considered bad style to cast pointer `*const u8` to integer `usize` --> lint_example.rs:6:24 |\\n6 | let _addr: usize = &x as *const u8 as usize; | ^^^^^^^^^^^^^^^^^^^^^^^^ | = help: if you can\'t comply with strict provenance and need to expose the pointer provenance you can use `.expose_provenance()` instead\\nnote: the lint level is defined here --> lint_example.rs:2:9 |\\n2 | #![warn(lossy_provenance_casts)] | ^^^^^^^^^^^^^^^^^^^^^^\\nhelp: use `.addr()` to obtain the address of a pointer |\\n6 - let _addr: usize = &x as *const u8 as usize;\\n6 + let _addr: usize = (&x as *const u8).addr(); |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"189","title":"Example"},"19":{"body":"A synonym for -C opt-level=3 .","breadcrumbs":"Command-line Arguments  -O: optimize your code","id":"19","title":"-O: optimize your code"},"190":{"body":"This lint is part of the strict provenance effort, see issue #95228 . Casting a pointer to an integer is a lossy operation, because beyond just an address a pointer may be associated with a particular provenance . This information is used by the optimiser and for dynamic analysis/dynamic program verification (e.g. Miri or CHERI platforms). Since this cast is lossy, it is considered good style to use the ptr::addr method instead, which has a similar effect, but doesn\'t \\"expose\\" the pointer provenance. This improves optimisation potential. See the docs of ptr::addr and ptr::expose_provenance for more information about exposing pointer provenance. If your code can\'t comply with strict provenance and needs to expose the provenance, then there is ptr::expose_provenance as an escape hatch, which preserves the behaviour of as usize casts while being explicit about the semantics.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"190","title":"Explanation"},"191":{"body":"The macro_use_extern_crate lint detects the use of the macro_use attribute .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  macro-use-extern-crate","id":"191","title":"macro-use-extern-crate"},"192":{"body":"#![deny(macro_use_extern_crate)] #[macro_use]\\nextern crate serde_json; fn main() { let _ = json!{{}};\\n} This will produce: error: applying the `#[macro_use]` attribute to an `extern crate` item is deprecated --> src/main.rs:3:1 |\\n3 | #[macro_use] | ^^^^^^^^^^^^ | = help: remove it and import macros at use sites with a `use` item instead\\nnote: the lint level is defined here --> src/main.rs:1:9 |\\n1 | #![deny(macro_use_extern_crate)] | ^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"192","title":"Example"},"193":{"body":"The macro_use attribute on an extern crate item causes macros in that external crate to be brought into the prelude of the crate, making the macros in scope everywhere. As part of the efforts to simplify handling of dependencies in the 2018 edition , the use of extern crate is being phased out. To bring macros from extern crates into scope, it is recommended to use a use import . This lint is \\"allow\\" by default because this is a stylistic choice that has not been settled, see issue #52043 for more information.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"193","title":"Explanation"},"194":{"body":"The meta_variable_misuse lint detects possible meta-variable misuse in macro definitions.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  meta-variable-misuse","id":"194","title":"meta-variable-misuse"},"195":{"body":"#![deny(meta_variable_misuse)] macro_rules! foo { () => {}; ($( $i:ident = $($j:ident),+ );*) => { $( $( $i = $k; )+ )* };\\n} fn main() { foo!();\\n} This will produce: error: unknown macro variable `k` --> lint_example.rs:5:55 |\\n5 | ($( $i:ident = $($j:ident),+ );*) => { $( $( $i = $k; )+ )* }; | ^^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(meta_variable_misuse)] | ^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"195","title":"Example"},"196":{"body":"There are quite a few different ways a macro_rules macro can be improperly defined. Many of these errors were previously only detected when the macro was expanded or not at all. This lint is an attempt to catch some of these problems when the macro is defined . This lint is \\"allow\\" by default because it may have false positives and other issues. See issue #61053 for more details.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"196","title":"Explanation"},"197":{"body":"The missing_copy_implementations lint detects potentially-forgotten implementations of Copy for public types.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  missing-copy-implementations","id":"197","title":"missing-copy-implementations"},"198":{"body":"#![deny(missing_copy_implementations)]\\npub struct Foo { pub field: i32\\n}\\n# fn main() {} This will produce: error: type could implement `Copy`; consider adding `impl Copy` --> lint_example.rs:2:1 |\\n2 | / pub struct Foo {\\n3 | | pub field: i32\\n4 | | } | |_^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(missing_copy_implementations)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"198","title":"Example"},"199":{"body":"Historically (before 1.0), types were automatically marked as Copy if possible. This was changed so that it required an explicit opt-in by implementing the Copy trait. As part of this change, a lint was added to alert if a copyable type was not marked Copy. This lint is \\"allow\\" by default because this code isn\'t bad; it is common to write newtypes like this specifically so that a Copy type is no longer Copy. Copy types can result in unintended copies of large data which can impact performance.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"199","title":"Explanation"},"2":{"body":"Here\'s a list of command-line arguments to rustc and what they do.","breadcrumbs":"Command-line Arguments  Command-line Arguments","id":"2","title":"Command-line Arguments"},"20":{"body":"This flag controls the output filename.","breadcrumbs":"Command-line Arguments  -o: filename of the output","id":"20","title":"-o: filename of the output"},"200":{"body":"The missing_debug_implementations lint detects missing implementations of fmt::Debug for public types.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  missing-debug-implementations","id":"200","title":"missing-debug-implementations"},"201":{"body":"#![deny(missing_debug_implementations)]\\npub struct Foo;\\n# fn main() {} This will produce: error: type does not implement `Debug`; consider adding `#[derive(Debug)]` or a manual implementation --> lint_example.rs:2:1 |\\n2 | pub struct Foo; | ^^^^^^^^^^^^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(missing_debug_implementations)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"201","title":"Example"},"202":{"body":"Having a Debug implementation on all types can assist with debugging, as it provides a convenient way to format and display a value. Using the #[derive(Debug)] attribute will automatically generate a typical implementation, or a custom implementation can be added by manually implementing the Debug trait. This lint is \\"allow\\" by default because adding Debug to all types can have a negative impact on compile time and code size. It also requires boilerplate to be added to every type, which can be an impediment.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"202","title":"Explanation"},"203":{"body":"The missing_docs lint detects missing documentation for public items.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  missing-docs","id":"203","title":"missing-docs"},"204":{"body":"#![deny(missing_docs)]\\npub fn foo() {} This will produce: error: missing documentation for the crate --> lint_example.rs:1:1 |\\n1 | / #![deny(missing_docs)]\\n2 | | fn main() {\\n3 | | pub fn foo() {}\\n4 | | } | |_^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(missing_docs)] | ^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"204","title":"Example"},"205":{"body":"This lint is intended to ensure that a library is well-documented. Items without documentation can be difficult for users to understand how to use properly. This lint is \\"allow\\" by default because it can be noisy, and not all projects may want to enforce everything to be documented.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"205","title":"Explanation"},"206":{"body":"The missing_unsafe_on_extern lint detects missing unsafe keyword on extern declarations.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  missing-unsafe-on-extern","id":"206","title":"missing-unsafe-on-extern"},"207":{"body":"#![warn(missing_unsafe_on_extern)]\\n#![allow(dead_code)] extern \\"C\\" { fn foo(_: i32);\\n} fn main() {} This will produce: warning: extern blocks should be unsafe --> lint_example.rs:4:1 |\\n4 | extern \\"C\\" { | ^ | | | _help: needs `unsafe` before the extern keyword: `unsafe` | |\\n5 | | fn foo(_: i32);\\n6 | | } | |_^ | = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-extern.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![warn(missing_unsafe_on_extern)] | ^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"207","title":"Example"},"208":{"body":"Declaring extern items, even without ever using them, can cause Undefined Behavior. We should consider all sources of Undefined Behavior to be unsafe. This is a future-incompatible lint to transition this to a hard error in the future.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"208","title":"Explanation"},"209":{"body":"The multiple_supertrait_upcastable lint detects when a dyn-compatible trait has multiple supertraits.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  multiple-supertrait-upcastable","id":"209","title":"multiple-supertrait-upcastable"},"21":{"body":"The outputted crate will be written to this directory. This flag is ignored if the -o flag is used.","breadcrumbs":"Command-line Arguments  --out-dir: directory to write the output in","id":"21","title":"--out-dir: directory to write the output in"},"210":{"body":"#![feature(multiple_supertrait_upcastable)]\\ntrait A {}\\ntrait B {} #[warn(multiple_supertrait_upcastable)]\\ntrait C: A + B {} This will produce: warning: `C` is dyn-compatible and has multiple supertraits --> lint_example.rs:7:1 |\\n7 | trait C: A + B {} | ^^^^^^^^^^^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:6:8 |\\n6 | #[warn(multiple_supertrait_upcastable)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"210","title":"Example"},"211":{"body":"To support upcasting with multiple supertraits, we need to store multiple vtables and this can result in extra space overhead, even if no code actually uses upcasting. This lint allows users to identify when such scenarios occur and to decide whether the additional overhead is justified.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"211","title":"Explanation"},"212":{"body":"The must_not_suspend lint guards against values that shouldn\'t be held across suspend points (.await)","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  must-not-suspend","id":"212","title":"must-not-suspend"},"213":{"body":"#![feature(must_not_suspend)]\\n#![warn(must_not_suspend)] #[must_not_suspend]\\nstruct SyncThing {} async fn yield_now() {} pub async fn uhoh() { let guard = SyncThing {}; yield_now().await; let _guard = guard;\\n} This will produce: warning: `SyncThing` held across a suspend point, but should not be --> lint_example.rs:11:9 |\\n11 | let guard = SyncThing {}; | ^^^^^\\n12 | yield_now().await; | ----- the value is held across this suspend point |\\nhelp: consider using a block (`{ ... }`) to shrink the value\'s scope, ending before the suspend point --> lint_example.rs:11:9 |\\n11 | let guard = SyncThing {}; | ^^^^^\\nnote: the lint level is defined here --> lint_example.rs:2:9 | 2 | #![warn(must_not_suspend)] | ^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"213","title":"Example"},"214":{"body":"The must_not_suspend lint detects values that are marked with the #[must_not_suspend] attribute being held across suspend points. A \\"suspend\\" point is usually a .await in an async function. This attribute can be used to mark values that are semantically incorrect across suspends (like certain types of timers), values that have async alternatives, and values that regularly cause problems with the Send-ness of async fn\'s returned futures (like MutexGuard\'s)","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"214","title":"Explanation"},"215":{"body":"The non_ascii_idents lint detects non-ASCII identifiers.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  non-ascii-idents","id":"215","title":"non-ascii-idents"},"216":{"body":"# #![allow(unused)]\\n#![deny(non_ascii_idents)]\\nfn main() { let f = 1;\\n} This will produce: error: identifier contains non-ASCII characters --> lint_example.rs:4:9 |\\n4 | let f = 1; | ^^^ |\\nnote: the lint level is defined here --> lint_example.rs:2:9 |\\n2 | #![deny(non_ascii_idents)] | ^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"216","title":"Example"},"217":{"body":"This lint allows projects that wish to retain the limit of only using ASCII characters to switch this lint to \\"forbid\\" (for example to ease collaboration or for security reasons). See RFC 2457 for more details.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"217","title":"Explanation"},"218":{"body":"The non_exhaustive_omitted_patterns lint aims to help consumers of a #[non_exhaustive] struct or enum who want to match all of its fields/variants explicitly. The #[non_exhaustive] annotation forces matches to use wildcards, so exhaustiveness checking cannot be used to ensure that all fields/variants are matched explicitly. To remedy this, this allow-by-default lint warns the user when a match mentions some but not all of the fields/variants of a #[non_exhaustive] struct or enum.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  non-exhaustive-omitted-patterns","id":"218","title":"non-exhaustive-omitted-patterns"},"219":{"body":"// crate A\\n#[non_exhaustive]\\npub enum Bar { A, B, // added variant in non breaking change\\n} // in crate B\\n#![feature(non_exhaustive_omitted_patterns_lint)]\\n#[warn(non_exhaustive_omitted_patterns)]\\nmatch Bar::A { Bar::A => {}, _ => {},\\n} This will produce: warning: some variants are not matched explicitly --> $DIR/reachable-patterns.rs:70:9 |\\nLL | match Bar::A { | ^ pattern `Bar::B` not covered | note: the lint level is defined here --> $DIR/reachable-patterns.rs:69:16 |\\nLL | #[warn(non_exhaustive_omitted_patterns)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ = help: ensure that all variants are matched explicitly by adding the suggested match arms = note: the matched value is of type `Bar` and the `non_exhaustive_omitted_patterns` attribute was found Warning: setting this to deny will make upstream non-breaking changes (adding fields or variants to a #[non_exhaustive] struct or enum) break your crate. This goes against expected semver behavior.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"219","title":"Example"},"22":{"body":"Each error of rustc\'s comes with an error code; this will print out a longer explanation of a given error.","breadcrumbs":"Command-line Arguments  --explain: provide a detailed explanation of an error message","id":"22","title":"--explain: provide a detailed explanation of an error message"},"220":{"body":"Structs and enums tagged with #[non_exhaustive] force the user to add a (potentially redundant) wildcard when pattern-matching, to allow for future addition of fields or variants. The non_exhaustive_omitted_patterns lint detects when such a wildcard happens to actually catch some fields/variants. In other words, when the match without the wildcard would not be exhaustive. This lets the user be informed if new fields/variants were added.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"220","title":"Explanation"},"221":{"body":"The lint or-patterns-back-compat has been renamed to rust-2021-incompatible-or-patterns .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  or-patterns-back-compat","id":"221","title":"or-patterns-back-compat"},"222":{"body":"The redundant_imports lint detects imports that are redundant due to being imported already; either through a previous import, or being present in the prelude.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  redundant-imports","id":"222","title":"redundant-imports"},"223":{"body":"#![deny(redundant_imports)]\\nuse std::option::Option::None;\\nfn foo() -> Option<i32> { None } This will produce: error: the item `None` is imported redundantly --> lint_example.rs:3:5 | 3 | use std::option::Option::None; | ^^^^^^^^^^^^^^^^^^^^^^^^^ | ::: C:\\\\a\\\\rust\\\\rust\\\\library\\\\std\\\\src\\\\prelude\\\\mod.rs:161:13 |\\n161 | pub use core::prelude::rust_2024::*; | ------------------------ the item `None` is already defined here |\\nnote: the lint level is defined here --> lint_example.rs:1:9 | 1 | #![deny(redundant_imports)] | ^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"223","title":"Example"},"224":{"body":"Redundant imports are unnecessary and can be removed to simplify code. If you intended to re-export the item to make it available outside of the module, add a visibility modifier like pub.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"224","title":"Explanation"},"225":{"body":"The redundant_lifetimes lint detects lifetime parameters that are redundant because they are equal to another named lifetime.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  redundant-lifetimes","id":"225","title":"redundant-lifetimes"},"226":{"body":"#[deny(redundant_lifetimes)] // `\'a = \'static`, so all usages of `\'a` can be replaced with `\'static`\\npub fn bar<\'a: \'static>() {} // `\'a = \'b`, so all usages of `\'b` can be replaced with `\'a`\\npub fn bar<\'a: \'b, \'b: \'a>() {} This will produce: error: unnecessary lifetime parameter `\'a` --> lint_example.rs:5:12 |\\n5 | pub fn bar<\'a: \'static>() {} | ^^ | = note: you can use the `\'static` lifetime directly, in place of `\'a`\\nnote: the lint level is defined here --> lint_example.rs:2:8 |\\n2 | #[deny(redundant_lifetimes)] | ^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"226","title":"Example"},"227":{"body":"Unused lifetime parameters may signal a mistake or unfinished code. Consider removing the parameter.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"227","title":"Explanation"},"228":{"body":"The rust_2021_incompatible_closure_captures lint detects variables that aren\'t completely captured in Rust 2021, such that the Drop order of their fields may differ between Rust 2018 and 2021. It can also detect when a variable implements a trait like Send, but one of its fields does not, and the field is captured by a closure and used with the assumption that said field implements the same trait as the root variable.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  rust-2021-incompatible-closure-captures","id":"228","title":"rust-2021-incompatible-closure-captures"},"229":{"body":"#![deny(rust_2021_incompatible_closure_captures)]\\n# #![allow(unused)] struct FancyInteger(i32); impl Drop for FancyInteger { fn drop(&mut self) { println!(\\"Just dropped {}\\", self.0); }\\n} struct Point { x: FancyInteger, y: FancyInteger } fn main() { let p = Point { x: FancyInteger(10), y: FancyInteger(20) }; let c = || { let x = p.x; }; c(); // ... More code ...\\n} This will produce: error: changes to closure capture in Rust 2021 will affect drop order --> lint_example.rs:17:11 |\\n17 | let c = || { | ^^\\n18 | let x = p.x; | --- in Rust 2018, this closure captures all of `p`, but in Rust 2021, it will only capture `p.x`\\n...\\n24 | } | - in Rust 2018, `p` is dropped here, but in Rust 2021, only `p.x` will be dropped here as part of the closure | = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 | 1 | #![deny(rust_2021_incompatible_closure_captures)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: add a dummy let to cause `p` to be fully captured |\\n17 ~ let c = || {\\n18 + let _ = &p; |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example of drop reorder","id":"229","title":"Example of drop reorder"},"23":{"body":"When compiling this crate, rustc will ignore your main function and instead produce a test harness. See the Tests chapter for more information about tests.","breadcrumbs":"Command-line Arguments  --test: build a test harness","id":"23","title":"--test: build a test harness"},"230":{"body":"In the above example, p.y will be dropped at the end of f instead of with c in Rust 2021.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"230","title":"Explanation"},"231":{"body":"#![deny(rust_2021_incompatible_closure_captures)]\\nuse std::thread; struct Pointer(*mut i32);\\nunsafe impl Send for Pointer {} fn main() { let mut f = 10; let fptr = Pointer(&mut f as *mut i32); thread::spawn(move || unsafe { *fptr.0 = 20; });\\n} This will produce: error: changes to closure capture in Rust 2021 will affect which traits the closure implements --> lint_example.rs:10:19 |\\n10 | thread::spawn(move || unsafe { | ^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0` does not implement `Send`\\n11 | *fptr.0 = 20; | ------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0` | = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 | 1 | #![deny(rust_2021_incompatible_closure_captures)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: add a dummy let to cause `fptr` to be fully captured |\\n10 ~ thread::spawn(move || { let _ = &fptr; unsafe {\\n11 | *fptr.0 = 20;\\n12 ~ } }); |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example of auto-trait","id":"231","title":"Example of auto-trait"},"232":{"body":"In the above example, only fptr.0 is captured in Rust 2021. The field is of type *mut i32, which doesn\'t implement Send, making the code invalid as the field cannot be sent between threads safely.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"232","title":"Explanation"},"233":{"body":"The rust_2021_incompatible_or_patterns lint detects usage of old versions of or-patterns.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  rust-2021-incompatible-or-patterns","id":"233","title":"rust-2021-incompatible-or-patterns"},"234":{"body":"#![deny(rust_2021_incompatible_or_patterns)] macro_rules! match_any { ( $expr:expr , $( $( $pat:pat )|+ => $expr_arm:expr ),+ ) => { match $expr { $( $( $pat => $expr_arm, )+ )+ } };\\n} fn main() { let result: Result<i64, i32> = Err(42); let int: i64 = match_any!(result, Ok(i) | Err(i) => i.into()); assert_eq!(int, 42);\\n} This will produce: error: the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro --> lint_example.rs:4:26 |\\n4 | ( $expr:expr , $( $( $pat:pat )|+ => $expr_arm:expr ),+ ) => { | ^^^^^^^^ help: use pat_param to preserve semantics: `$pat:pat_param` | = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2021/or-patterns-macro-rules.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(rust_2021_incompatible_or_patterns)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"234","title":"Example"},"235":{"body":"In Rust 2021, the pat matcher will match additional patterns, which include the | character.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"235","title":"Explanation"},"236":{"body":"The rust_2021_prefixes_incompatible_syntax lint detects identifiers that will be parsed as a prefix instead in Rust 2021.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  rust-2021-prefixes-incompatible-syntax","id":"236","title":"rust-2021-prefixes-incompatible-syntax"},"237":{"body":"#![deny(rust_2021_prefixes_incompatible_syntax)] macro_rules! m { (z $x:expr) => ();\\n} m!(z\\"hey\\"); This will produce: error: prefix `z` is unknown --> lint_example.rs:8:4 |\\n8 | m!(z\\"hey\\"); | ^ unknown prefix | = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2021/reserving-syntax.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(rust_2021_prefixes_incompatible_syntax)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: insert whitespace here to avoid this being parsed as a prefix in Rust 2021 |\\n8 | m!(z \\"hey\\"); | +","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"237","title":"Example"},"238":{"body":"In Rust 2015 and 2018, z\\"hey\\" is two tokens: the identifier z followed by the string literal \\"hey\\". In Rust 2021, the z is considered a prefix for \\"hey\\". This lint suggests to add whitespace between the z and \\"hey\\" tokens to keep them separated in Rust 2021.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"238","title":"Explanation"},"239":{"body":"The rust_2021_prelude_collisions lint detects the usage of trait methods which are ambiguous with traits added to the prelude in future editions.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  rust-2021-prelude-collisions","id":"239","title":"rust-2021-prelude-collisions"},"24":{"body":"This controls which target to produce.","breadcrumbs":"Command-line Arguments  --target: select a target triple to build","id":"24","title":"--target: select a target triple to build"},"240":{"body":"#![deny(rust_2021_prelude_collisions)] trait Foo { fn try_into(self) -> Result<String, !>;\\n} impl Foo for &str { fn try_into(self) -> Result<String, !> { Ok(String::from(self)) }\\n} fn main() { let x: String = \\"3\\".try_into().unwrap(); // ^^^^^^^^ // This call to try_into matches both Foo::try_into and TryInto::try_into as // `TryInto` has been added to the Rust prelude in 2021 edition. println!(\\"{x}\\");\\n} This will produce: error: trait method `try_into` will become ambiguous in Rust 2021 --> lint_example.rs:14:21 |\\n14 | let x: String = \\"3\\".try_into().unwrap(); | ^^^^^^^^^^^^^^ help: disambiguate the associated function: `Foo::try_into(&*\\"3\\")` | = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2021/prelude.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 | 1 | #![deny(rust_2021_prelude_collisions)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"240","title":"Example"},"241":{"body":"In Rust 2021, one of the important introductions is the prelude changes , which add TryFrom, TryInto, and FromIterator into the standard library\'s prelude. Since this results in an ambiguity as to which method/function to call when an existing try_into method is called via dot-call syntax or a try_from/from_iter associated function is called directly on a type.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"241","title":"Explanation"},"242":{"body":"The rust_2024_guarded_string_incompatible_syntax lint detects # tokens that will be parsed as part of a guarded string literal in Rust 2024.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  rust-2024-guarded-string-incompatible-syntax","id":"242","title":"rust-2024-guarded-string-incompatible-syntax"},"243":{"body":"#![deny(rust_2024_guarded_string_incompatible_syntax)] macro_rules! m { (# $x:expr #) => (); (# $x:expr) => ();\\n} m!(#\\"hey\\"#);\\nm!(#\\"hello\\"); This will produce: error: will be parsed as a guarded string in Rust 2024 --> lint_example.rs:9:4 |\\n9 | m!(#\\"hey\\"#); | ^^^^^^^ | = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/reserved-syntax.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(rust_2024_guarded_string_incompatible_syntax)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: insert whitespace here to avoid this being parsed as a guarded string in Rust 2024 |\\n9 | m!(# \\"hey\\"#); | + error: will be parsed as a guarded string in Rust 2024 --> lint_example.rs:10:4 |\\n10 | m!(#\\"hello\\"); | ^^^^^^^^ | = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/reserved-syntax.html>\\nhelp: insert whitespace here to avoid this being parsed as a guarded string in Rust 2024 |\\n10 | m!(# \\"hello\\"); | +","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"243","title":"Example"},"244":{"body":"Prior to Rust 2024, #\\"hey\\"# is three tokens: the first # followed by the string literal \\"hey\\" then the final #. In Rust 2024, the whole sequence is considered a single token. This lint suggests to add whitespace between the leading # and the string to keep them separated in Rust 2024.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"244","title":"Explanation"},"245":{"body":"The rust_2024_incompatible_pat lint detects patterns whose meaning will change in the Rust 2024 edition.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  rust-2024-incompatible-pat","id":"245","title":"rust-2024-incompatible-pat"},"246":{"body":"#![warn(rust_2024_incompatible_pat)] if let Some(&a) = &Some(&0u8) { let _: u8 = a;\\n}\\nif let Some(mut _a) = &mut Some(0u8) { _a = 7u8;\\n} This will produce: warning: cannot explicitly dereference within an implicitly-borrowing pattern in Rust 2024 --> lint_example.rs:4:13 |\\n4 | if let Some(&a) = &Some(&0u8) { | ^ reference pattern not allowed when implicitly borrowing | = warning: this changes meaning in Rust 2024 = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html>\\nnote: matching on a reference type with a non-reference pattern implicitly borrows the contents --> lint_example.rs:4:8 |\\n4 | if let Some(&a) = &Some(&0u8) { | ^^^^^^^^ this non-reference pattern matches on a reference type `&_`\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![warn(rust_2024_incompatible_pat)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: match on the reference with a reference pattern to avoid implicitly borrowing |\\n4 | if let &Some(&a) = &Some(&0u8) { | + warning: cannot mutably bind by value within an implicitly-borrowing pattern in Rust 2024 --> lint_example.rs:7:13 |\\n7 | if let Some(mut _a) = &mut Some(0u8) { | ^^^ `mut` binding modifier not allowed when implicitly borrowing | = warning: this changes meaning in Rust 2024 = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html>\\nnote: matching on a reference type with a non-reference pattern implicitly borrows the contents --> lint_example.rs:7:8 |\\n7 | if let Some(mut _a) = &mut Some(0u8) { | ^^^^^^^^^^^^ this non-reference pattern matches on a reference type `&mut _`\\nhelp: match on the reference with a reference pattern to avoid implicitly borrowing |\\n7 | if let &mut Some(mut _a) = &mut Some(0u8) { | ++++","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"246","title":"Example"},"247":{"body":"In Rust 2024 and above, the mut keyword does not reset the pattern binding mode, and nor do & or &mut patterns. The lint will suggest code that has the same meaning in all editions.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"247","title":"Explanation"},"248":{"body":"The rust_2024_prelude_collisions lint detects the usage of trait methods which are ambiguous with traits added to the prelude in future editions.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  rust-2024-prelude-collisions","id":"248","title":"rust-2024-prelude-collisions"},"249":{"body":"#![deny(rust_2024_prelude_collisions)]\\ntrait Meow { fn poll(&self) {}\\n}\\nimpl<T> Meow for T {} fn main() { core::pin::pin!(async {}).poll(); // ^^^^^^ // This call to try_into matches both Future::poll and Meow::poll as // `Future` has been added to the Rust prelude in 2024 edition.\\n} This will produce: error: trait method `poll` will become ambiguous in Rust 2024 --> lint_example.rs:8:5 |\\n8 | core::pin::pin!(async {}).poll(); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `Meow::poll(&core::pin::pin!(async {}))` | = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/prelude.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(rust_2024_prelude_collisions)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"249","title":"Example"},"25":{"body":"This flag will set which lints should be set to the warn level . Note: The order of these lint level arguments is taken into account, see lint level via compiler flag for more information.","breadcrumbs":"Command-line Arguments  -W: set lint warnings","id":"25","title":"-W: set lint warnings"},"250":{"body":"Rust 2024, introduces two new additions to the standard library\'s prelude: Future and IntoFuture. This results in an ambiguity as to which method/function to call when an existing poll/into_future method is called via dot-call syntax or a poll/into_future associated function is called directly on a type.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"250","title":"Explanation"},"251":{"body":"The lint single-use-lifetime has been renamed to single-use-lifetimes .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  single-use-lifetime","id":"251","title":"single-use-lifetime"},"252":{"body":"The single_use_lifetimes lint detects lifetimes that are only used once.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  single-use-lifetimes","id":"252","title":"single-use-lifetimes"},"253":{"body":"#![deny(single_use_lifetimes)] fn foo<\'a>(x: &\'a u32) {} This will produce: error: lifetime parameter `\'a` only used once --> lint_example.rs:4:8 |\\n4 | fn foo<\'a>(x: &\'a u32) {} | ^^ -- ...is used only here | | | this lifetime... |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(single_use_lifetimes)] | ^^^^^^^^^^^^^^^^^^^^\\nhelp: elide the single-use lifetime |\\n4 - fn foo<\'a>(x: &\'a u32) {}\\n4 + fn foo(x: &u32) {} |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"253","title":"Example"},"254":{"body":"Specifying an explicit lifetime like \'a in a function or impl should only be used to link together two things. Otherwise, you should just use \'_ to indicate that the lifetime is not linked to anything, or elide the lifetime altogether if possible. This lint is \\"allow\\" by default because it was introduced at a time when \'_ and elided lifetimes were first being introduced, and this lint would be too noisy. Also, there are some known false positives that it produces. See RFC 2115 for historical context, and issue #44752 for more details.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"254","title":"Explanation"},"255":{"body":"The supertrait_item_shadowing_definition lint detects when the definition of an item that is provided by both a subtrait and supertrait is shadowed, preferring the subtrait.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  supertrait-item-shadowing-definition","id":"255","title":"supertrait-item-shadowing-definition"},"256":{"body":"#![feature(supertrait_item_shadowing)]\\n#![deny(supertrait_item_shadowing_definition)] trait Upstream { fn hello(&self) {}\\n}\\nimpl<T> Upstream for T {} trait Downstream: Upstream { fn hello(&self) {}\\n}\\nimpl<T> Downstream for T {} This will produce: error: trait item `hello` from `Downstream` shadows identically named item from supertrait --> lint_example.rs:11:5 |\\n11 | fn hello(&self) {} | ^^^^^^^^^^^^^^^ |\\nnote: item from `Upstream` is shadowed by a subtrait item --> lint_example.rs:6:5 | 6 | fn hello(&self) {} | ^^^^^^^^^^^^^^^\\nnote: the lint level is defined here --> lint_example.rs:2:9 | 2 | #![deny(supertrait_item_shadowing_definition)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"256","title":"Example"},"257":{"body":"RFC 3624 specified a heuristic in which a supertrait item would be shadowed by a subtrait item when ambiguity occurs during item selection. In order to mitigate side-effects of this happening silently, this lint detects these cases when users want to deny them or fix their trait definitions.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"257","title":"Explanation"},"258":{"body":"The supertrait_item_shadowing_usage lint detects when the usage of an item that is provided by both a subtrait and supertrait is shadowed, preferring the subtrait.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  supertrait-item-shadowing-usage","id":"258","title":"supertrait-item-shadowing-usage"},"259":{"body":"#![feature(supertrait_item_shadowing)]\\n#![deny(supertrait_item_shadowing_usage)] trait Upstream { fn hello(&self) {}\\n}\\nimpl<T> Upstream for T {} trait Downstream: Upstream { fn hello(&self) {}\\n}\\nimpl<T> Downstream for T {} struct MyType;\\nMyType.hello(); This will produce: error: trait item `hello` from `Downstream` shadows identically named item from supertrait --> lint_example.rs:16:8 |\\n16 | MyType.hello(); | ^^^^^ |\\nnote: item from `Downstream` shadows a supertrait item --> lint_example.rs:11:5 |\\n11 | fn hello(&self) {} | ^^^^^^^^^^^^^^^\\nnote: item from `Upstream` is shadowed by a subtrait item --> lint_example.rs:6:5 | 6 | fn hello(&self) {} | ^^^^^^^^^^^^^^^\\nnote: the lint level is defined here --> lint_example.rs:2:9 | 2 | #![deny(supertrait_item_shadowing_usage)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"259","title":"Example"},"26":{"body":"This flag sets the given lint to the forced warn level and the level cannot be overridden, even ignoring the lint caps .","breadcrumbs":"Command-line Arguments  --force-warn: force a lint to warn","id":"26","title":"--force-warn: force a lint to warn"},"260":{"body":"RFC 3624 specified a heuristic in which a supertrait item would be shadowed by a subtrait item when ambiguity occurs during item selection. In order to mitigate side-effects of this happening silently, this lint detects these cases when users want to deny them or fix the call sites.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"260","title":"Explanation"},"261":{"body":"The tail_expr_drop_order lint looks for those values generated at the tail expression location, that runs a custom Drop destructor. Some of them may be dropped earlier in Edition 2024 that they used to in Edition 2021 and prior. This lint detects those cases and provides you information on those values and their custom destructor implementations. Your discretion on this information is required.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  tail-expr-drop-order","id":"261","title":"tail-expr-drop-order"},"262":{"body":"#![warn(tail_expr_drop_order)]\\nstruct Droppy(i32);\\nimpl Droppy { fn get(&self) -> i32 { self.0 }\\n}\\nimpl Drop for Droppy { fn drop(&mut self) { // This is a custom destructor and it induces side-effects that is observable // especially when the drop order at a tail expression changes. println!(\\"loud drop {}\\", self.0); }\\n}\\nfn edition_2021() -> i32 { let another_droppy = Droppy(0); Droppy(1).get()\\n}\\nfn main() { edition_2021();\\n} This will produce: warning: relative drop order changing in Rust 2024 --> lint_example.rs:17:5 |\\n16 | let another_droppy = Droppy(0); | -------------- | | | `another_droppy` calls a custom destructor | `another_droppy` will be dropped later as of Edition 2024\\n17 | Droppy(1).get() | ^^^^^^^^^ | | | this value will be stored in a temporary; let us call it `#1` | up until Edition 2021 `#1` is dropped last but will be dropped earlier in Edition 2024\\n18 | } | - now the temporary value is dropped here, before the local variables in the block or statement | = warning: this changes meaning in Rust 2024 = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/temporary-tail-expr-scope.html>\\nnote: `#1` invokes this custom destructor --> lint_example.rs:8:1 | 8 | impl Drop for Droppy { | ^^^^^^^^^^^^^^^^^^^^\\nnote: `another_droppy` invokes this custom destructor --> lint_example.rs:8:1 | 8 | impl Drop for Droppy { | ^^^^^^^^^^^^^^^^^^^^ = note: most of the time, changing drop order is harmless; inspect the `impl Drop`s for side effects like releasing locks or sending messages\\nnote: the lint level is defined here --> lint_example.rs:1:9 | 1 | #![warn(tail_expr_drop_order)] | ^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"262","title":"Example"},"263":{"body":"In tail expression of blocks or function bodies, values of type with significant Drop implementation has an ill-specified drop order before Edition 2024 so that they are dropped only after dropping local variables. Edition 2024 introduces a new rule with drop orders for them, so that they are dropped first before dropping local variables. A significant Drop::drop destructor here refers to an explicit, arbitrary implementation of the Drop trait on the type, with exceptions including Vec, Box, Rc, BTreeMap and HashMap that are marked by the compiler otherwise so long that the generic types have no significant destructor recursively. In other words, a type has a significant drop destructor when it has a Drop implementation or its destructor invokes a significant destructor on a type. Since we cannot completely reason about the change by just inspecting the existence of a significant destructor, this lint remains only a suggestion and is set to allow by default. This lint only points out the issue with Droppy, which will be dropped before another_droppy does in Edition 2024. No fix will be proposed by this lint. However, the most probable fix is to hoist Droppy into its own local variable binding. struct Droppy(i32);\\nimpl Droppy { fn get(&self) -> i32 { self.0 }\\n}\\nfn edition_2024() -> i32 { let value = Droppy(0); let another_droppy = Droppy(1); value.get()\\n}","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"263","title":"Explanation"},"264":{"body":"The trivial_casts lint detects trivial casts which could be replaced with coercion, which may require a temporary variable.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  trivial-casts","id":"264","title":"trivial-casts"},"265":{"body":"#![deny(trivial_casts)]\\nlet x: &u32 = &42;\\nlet y = x as *const u32; This will produce: error: trivial cast: `&u32` as `*const u32` --> lint_example.rs:4:9 |\\n4 | let y = x as *const u32; | ^^^^^^^^^^^^^^^ | = help: cast can be replaced by coercion; this might require a temporary variable\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(trivial_casts)] | ^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"265","title":"Example"},"266":{"body":"A trivial cast is a cast e as T where e has type U and U is a subtype of T. This type of cast is usually unnecessary, as it can be usually be inferred. This lint is \\"allow\\" by default because there are situations, such as with FFI interfaces or complex type aliases, where it triggers incorrectly, or in situations where it will be more difficult to clearly express the intent. It may be possible that this will become a warning in the future, possibly with an explicit syntax for coercions providing a convenient way to work around the current issues. See RFC 401 (coercions) , RFC 803 (type ascription) and RFC 3307 (remove type ascription) for historical context.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"266","title":"Explanation"},"267":{"body":"The trivial_numeric_casts lint detects trivial numeric casts of types which could be removed.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  trivial-numeric-casts","id":"267","title":"trivial-numeric-casts"},"268":{"body":"#![deny(trivial_numeric_casts)]\\nlet x = 42_i32 as i32; This will produce: error: trivial numeric cast: `i32` as `i32` --> lint_example.rs:3:9 |\\n3 | let x = 42_i32 as i32; | ^^^^^^^^^^^^^ | = help: cast can be replaced by coercion; this might require a temporary variable\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(trivial_numeric_casts)] | ^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"268","title":"Example"},"269":{"body":"A trivial numeric cast is a cast of a numeric type to the same numeric type. This type of cast is usually unnecessary. This lint is \\"allow\\" by default because there are situations, such as with FFI interfaces or complex type aliases, where it triggers incorrectly, or in situations where it will be more difficult to clearly express the intent. It may be possible that this will become a warning in the future, possibly with an explicit syntax for coercions providing a convenient way to work around the current issues. See RFC 401 (coercions) , RFC 803 (type ascription) and RFC 3307 (remove type ascription) for historical context.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"269","title":"Explanation"},"27":{"body":"This flag will set which lints should be set to the allow level . Note: The order of these lint level arguments is taken into account, see lint level via compiler flag for more information.","breadcrumbs":"Command-line Arguments  -A: set lint allowed","id":"27","title":"-A: set lint allowed"},"270":{"body":"The unit_bindings lint detects cases where bindings are useless because they have the unit type () as their inferred type. The lint is suppressed if the user explicitly annotates the let binding with the unit type (), or if the let binding uses an underscore wildcard pattern, i.e. let _ = expr, or if the binding is produced from macro expansions.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unit-bindings","id":"270","title":"unit-bindings"},"271":{"body":"#![deny(unit_bindings)] fn foo() { println!(\\"do work\\");\\n} pub fn main() { let x = foo(); // useless binding\\n} This will produce: error: binding has unit type `()` --> lint_example.rs:8:5 |\\n8 | let x = foo(); // useless binding | ^^^^-^^^^^^^^^ | | | this pattern is inferred to be the unit type `()` |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unit_bindings)] | ^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"271","title":"Example"},"272":{"body":"Creating a local binding with the unit type () does not do much and can be a sign of a user error, such as in this example: fn main() { let mut x = [1, 2, 3]; x[0] = 5; let y = x.sort(); // useless binding as `sort` returns `()` and not the sorted array. println!(\\"{:?}\\", y); // prints \\"()\\"\\n}","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"272","title":"Explanation"},"273":{"body":"The unnameable_types lint detects types for which you can get objects of that type, but cannot name the type itself.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unnameable-types","id":"273","title":"unnameable-types"},"274":{"body":"# #![allow(unused)]\\n#![deny(unnameable_types)]\\nmod m { pub struct S;\\n} pub fn get_unnameable() -> m::S { m::S }\\n# fn main() {} This will produce: error: struct `S` is reachable but cannot be named --> lint_example.rs:4:5 |\\n4 | pub struct S; | ^^^^^^^^^^^^ reachable at visibility `pub`, but can only be named at visibility `pub(crate)` |\\nnote: the lint level is defined here --> lint_example.rs:2:9 |\\n2 | #![deny(unnameable_types)] | ^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"274","title":"Example"},"275":{"body":"It is often expected that if you can obtain an object of type T, then you can name the type T as well; this lint attempts to enforce this rule. The recommended action is to either reexport the type properly to make it nameable, or document that users are not supposed to be able to name it for one reason or another. Besides types, this lint applies to traits because traits can also leak through signatures, and you may obtain objects of their dyn Trait or impl Trait types.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"275","title":"Explanation"},"276":{"body":"The unqualified_local_imports lint checks for use items that import a local item using a path that does not start with self::, super::, or crate::.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unqualified-local-imports","id":"276","title":"unqualified-local-imports"},"277":{"body":"#![feature(unqualified_local_imports)]\\n#![warn(unqualified_local_imports)] mod localmod { pub struct S;\\n} use localmod::S;\\n# // We have to actually use `S`, or else the `unused` warnings suppress the lint we care about.\\n# pub fn main() {\\n# let _x = S;\\n# } This will produce: warning: `use` of a local item without leading `self::`, `super::`, or `crate::` --> lint_example.rs:8:5 |\\n8 | use localmod::S; | ^^^^^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:2:9 |\\n2 | #![warn(unqualified_local_imports)] | ^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"277","title":"Example"},"278":{"body":"This lint is meant to be used with the (unstable) rustfmt setting group_imports = \\"StdExternalCrate\\". That setting makes rustfmt group self::, super::, and crate:: imports separately from those referring to other crates. However, rustfmt cannot know whether use c::S; refers to a local module c or an external crate c, so it always gets categorized as an import from another crate. To ensure consistent grouping of imports from the local crate, all local imports must start with self::, super::, or crate::. This lint can be used to enforce that style.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"278","title":"Explanation"},"279":{"body":"The unreachable_pub lint triggers for pub items not reachable from other crates - that means neither directly accessible, nor reexported (with pub use), nor leaked through things like return types (which the unnameable_types lint can detect if desired).","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unreachable-pub","id":"279","title":"unreachable-pub"},"28":{"body":"This flag will set which lints should be set to the deny level . Note: The order of these lint level arguments is taken into account, see lint level via compiler flag for more information.","breadcrumbs":"Command-line Arguments  -D: set lint denied","id":"28","title":"-D: set lint denied"},"280":{"body":"#![deny(unreachable_pub)]\\nmod foo { pub mod bar { }\\n} This will produce: error: unreachable `pub` item --> lint_example.rs:4:5 |\\n4 | pub mod bar { | ---^^^^^^^^ | | | help: consider restricting its visibility: `pub(crate)` | = help: or consider exporting it for use by other crates\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unreachable_pub)] | ^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"280","title":"Example"},"281":{"body":"The pub keyword both expresses an intent for an item to be publicly available, and also signals to the compiler to make the item publicly accessible. The intent can only be satisfied, however, if all items which contain this item are also publicly accessible. Thus, this lint serves to identify situations where the intent does not match the reality. If you wish the item to be accessible elsewhere within the crate, but not outside it, the pub(crate) visibility is recommended to be used instead. This more clearly expresses the intent that the item is only visible within its own crate. This lint is \\"allow\\" by default because it will trigger for a large amount of existing Rust code. Eventually it is desired for this to become warn-by-default.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"281","title":"Explanation"},"282":{"body":"The unsafe_attr_outside_unsafe lint detects a missing unsafe keyword on attributes considered unsafe.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unsafe-attr-outside-unsafe","id":"282","title":"unsafe-attr-outside-unsafe"},"283":{"body":"#![warn(unsafe_attr_outside_unsafe)] #[no_mangle]\\nextern \\"C\\" fn foo() {} fn main() {} This will produce: warning: unsafe attribute used without unsafe --> lint_example.rs:3:3 |\\n3 | #[no_mangle] | ^^^^^^^^^ usage of unsafe attribute | = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-attributes.html>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![warn(unsafe_attr_outside_unsafe)] | ^^^^^^^^^^^^^^^^^^^^^^^^^^\\nhelp: wrap the attribute in `unsafe(...)` |\\n3 | #[unsafe(no_mangle)] | +++++++ +","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"283","title":"Example"},"284":{"body":"Some attributes (e.g. no_mangle, export_name, link_section -- see issue #82499 for a more complete list) are considered \\"unsafe\\" attributes. An unsafe attribute must only be used inside unsafe(...). This lint can automatically wrap the attributes in unsafe(...) , but this obviously cannot verify that the preconditions of the unsafe attributes are fulfilled, so that is still up to the user. The lint is currently \\"allow\\" by default, but that might change in the future.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"284","title":"Explanation"},"285":{"body":"The unsafe_code lint catches usage of unsafe code and other potentially unsound constructs like no_mangle, export_name, and link_section.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unsafe-code","id":"285","title":"unsafe-code"},"286":{"body":"#![deny(unsafe_code)]\\nfn main() { unsafe { }\\n} #[no_mangle]\\nfn func_0() { } #[export_name = \\"exported_symbol_name\\"]\\npub fn name_in_rust() { } #[no_mangle]\\n#[link_section = \\".example_section\\"]\\npub static VAR1: u32 = 1; This will produce: error: usage of an `unsafe` block --> lint_example.rs:3:5 |\\n3 | / unsafe {\\n4 | |\\n5 | | } | |_____^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unsafe_code)] | ^^^^^^^^^^^ error: declaration of a `no_mangle` function --> lint_example.rs:8:1 |\\n8 | #[no_mangle] | ^^^^^^^^^^^^ | = note: the linker\'s behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them error: declaration of a function with `export_name` --> lint_example.rs:11:1 |\\n11 | #[export_name = \\"exported_symbol_name\\"] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: the linker\'s behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them error: declaration of a `no_mangle` static --> lint_example.rs:14:1 |\\n14 | #[no_mangle] | ^^^^^^^^^^^^ | = note: the linker\'s behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them error: declaration of a static with `link_section` --> lint_example.rs:15:1 |\\n15 | #[link_section = \\".example_section\\"] | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: the program\'s behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"286","title":"Example"},"287":{"body":"This lint is intended to restrict the usage of unsafe blocks and other constructs (including, but not limited to no_mangle, link_section and export_name attributes) wrong usage of which causes undefined behavior.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"287","title":"Explanation"},"288":{"body":"The unsafe_op_in_unsafe_fn lint detects unsafe operations in unsafe functions without an explicit unsafe block.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unsafe-op-in-unsafe-fn","id":"288","title":"unsafe-op-in-unsafe-fn"},"289":{"body":"#![deny(unsafe_op_in_unsafe_fn)] unsafe fn foo() {} unsafe fn bar() { foo();\\n} fn main() {} This will produce: error[E0133]: call to unsafe function `foo` is unsafe and requires unsafe block --> lint_example.rs:6:5 |\\n6 | foo(); | ^^^^^ call to unsafe function | = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html> = note: consult the function\'s documentation for information on how to avoid undefined behavior\\nnote: an unsafe function restricts its caller, but its body is safe by default --> lint_example.rs:5:1 |\\n5 | unsafe fn bar() { | ^^^^^^^^^^^^^^^\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unsafe_op_in_unsafe_fn)] | ^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"289","title":"Example"},"29":{"body":"This flag will set which lints should be set to the forbid level . Note: The order of these lint level arguments is taken into account, see lint level via compiler flag for more information.","breadcrumbs":"Command-line Arguments  -F: set lint forbidden","id":"29","title":"-F: set lint forbidden"},"290":{"body":"Currently, an unsafe fn allows any unsafe operation within its body. However, this can increase the surface area of code that needs to be scrutinized for proper behavior. The unsafe block provides a convenient way to make it clear exactly which parts of the code are performing unsafe operations. In the future, it is desired to change it so that unsafe operations cannot be performed in an unsafe fn without an unsafe block. The fix to this is to wrap the unsafe code in an unsafe block. This lint is \\"allow\\" by default on editions up to 2021, from 2024 it is \\"warn\\" by default; the plan for increasing severity further is still being considered. See RFC #2585 and issue #71668 for more details.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"290","title":"Explanation"},"291":{"body":"The unstable_features lint detects uses of #![feature].","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unstable-features","id":"291","title":"unstable-features"},"292":{"body":"#![deny(unstable_features)]\\n#![feature(test)] This will produce: error: use of an unstable feature --> lint_example.rs:2:12 |\\n2 | #![feature(test)] | ^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unstable_features)] | ^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"292","title":"Example"},"293":{"body":"In larger nightly-based projects which consist of a multitude of crates where a subset of crates has to compile on stable either unconditionally or depending on a cfg flag to for example allow stable users to depend on them, don\'t use nightly for experimental features but for, e.g., unstable options only, this lint may come in handy to enforce policies of these kinds.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"293","title":"Explanation"},"294":{"body":"The unused_crate_dependencies lint detects crate dependencies that are never used.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unused-crate-dependencies","id":"294","title":"unused-crate-dependencies"},"295":{"body":"#![deny(unused_crate_dependencies)] This will produce: error: extern crate `regex` is unused in crate `lint_example` | = help: remove the dependency or add `use regex as _;` to the crate root\\nnote: the lint level is defined here --> src/lib.rs:1:9 |\\n1 | #![deny(unused_crate_dependencies)] | ^^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"295","title":"Example"},"296":{"body":"After removing the code that uses a dependency, this usually also requires removing the dependency from the build configuration. However, sometimes that step can be missed, which leads to time wasted building dependencies that are no longer used. This lint can be enabled to detect dependencies that are never used (more specifically, any dependency passed with the --extern command-line flag that is never referenced via use , extern crate , or in any path ). This lint is \\"allow\\" by default because it can provide false positives depending on how the build system is configured. For example, when using Cargo, a \\"package\\" consists of multiple crates (such as a library and a binary), but the dependencies are defined for the package as a whole. If there is a dependency that is only used in the binary, but not the library, then the lint will be incorrectly issued in the library.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"296","title":"Explanation"},"297":{"body":"The unused_extern_crates lint guards against extern crate items that are never used.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unused-extern-crates","id":"297","title":"unused-extern-crates"},"298":{"body":"#![deny(unused_extern_crates)]\\n#![deny(warnings)]\\nextern crate proc_macro; This will produce: error: unused extern crate --> lint_example.rs:4:1 |\\n4 | extern crate proc_macro; | ^^^^^^^^^^^^^^^^^^^^^^^^ unused |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unused_extern_crates)] | ^^^^^^^^^^^^^^^^^^^^\\nhelp: remove the unused `extern crate` |\\n4 - extern crate proc_macro; |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"298","title":"Example"},"299":{"body":"extern crate items that are unused have no effect and should be removed. Note that there are some cases where specifying an extern crate is desired for the side effect of ensuring the given crate is linked, even though it is not otherwise directly referenced. The lint can be silenced by aliasing the crate to an underscore, such as extern crate foo as _. Also note that it is no longer idiomatic to use extern crate in the 2018 edition , as extern crates are now automatically added in scope. This lint is \\"allow\\" by default because it can be noisy, and produce false-positives. If a dependency is being removed from a project, it is recommended to remove it from the build configuration (such as Cargo.toml) to ensure stale build entries aren\'t left behind.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"299","title":"Explanation"},"3":{"body":"This flag will print out help information for rustc.","breadcrumbs":"Command-line Arguments  -h/--help: get help","id":"3","title":"-h/--help: get help"},"30":{"body":"This flag will allow you to set unstable options of rustc. In order to set multiple options, the -Z flag can be used multiple times. For example: rustc -Z verbose-internals -Z time-passes. Specifying options with -Z is only available on nightly. To view all available options run: rustc -Z help, or see The Unstable Book .","breadcrumbs":"Command-line Arguments  -Z: set unstable options","id":"30","title":"-Z: set unstable options"},"300":{"body":"The unused_import_braces lint catches unnecessary braces around an imported item.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unused-import-braces","id":"300","title":"unused-import-braces"},"301":{"body":"#![deny(unused_import_braces)]\\nuse test::{A}; pub mod test { pub struct A;\\n}\\n# fn main() {} This will produce: error: braces around A is unnecessary --> lint_example.rs:2:1 |\\n2 | use test::{A}; | ^^^^^^^^^^^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unused_import_braces)] | ^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"301","title":"Example"},"302":{"body":"If there is only a single item, then remove the braces (use test::A; for example). This lint is \\"allow\\" by default because it is only enforcing a stylistic choice.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"302","title":"Explanation"},"303":{"body":"The unused_lifetimes lint detects lifetime parameters that are never used.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unused-lifetimes","id":"303","title":"unused-lifetimes"},"304":{"body":"#[deny(unused_lifetimes)] pub fn foo<\'a>() {} This will produce: error: lifetime parameter `\'a` never used --> lint_example.rs:4:12 |\\n4 | pub fn foo<\'a>() {} | -^^- help: elide the unused lifetime |\\nnote: the lint level is defined here --> lint_example.rs:2:8 |\\n2 | #[deny(unused_lifetimes)] | ^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"304","title":"Example"},"305":{"body":"Unused lifetime parameters may signal a mistake or unfinished code. Consider removing the parameter.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"305","title":"Explanation"},"306":{"body":"The unused_macro_rules lint detects macro rules that were not used. Note that the lint is distinct from the unused_macros lint, which fires if the entire macro is never called, while this lint fires for single unused rules of the macro that is otherwise used. unused_macro_rules fires only if unused_macros wouldn\'t fire.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unused-macro-rules","id":"306","title":"unused-macro-rules"},"307":{"body":"#[warn(unused_macro_rules)]\\nmacro_rules! unused_empty { (hello) => { println!(\\"Hello, world!\\") }; // This rule is unused () => { println!(\\"empty\\") }; // This rule is used\\n} fn main() { unused_empty!(hello);\\n} This will produce: warning: rule #2 of macro `unused_empty` is never used --> lint_example.rs:4:5 |\\n4 | () => { println!(\\"empty\\") }; // This rule is used | ^^ |\\nnote: the lint level is defined here --> lint_example.rs:1:8 |\\n1 | #[warn(unused_macro_rules)] | ^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"307","title":"Example"},"308":{"body":"Unused macro rules may signal a mistake or unfinished code. Furthermore, they slow down compilation. Right now, silencing the warning is not supported on a single rule level, so you have to add an allow to the entire macro definition. If you intended to export the macro to make it available outside of the crate, use the macro_export attribute .","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"308","title":"Explanation"},"309":{"body":"The unused_qualifications lint detects unnecessarily qualified names.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unused-qualifications","id":"309","title":"unused-qualifications"},"31":{"body":"This flag lets you \'cap\' lints, for more, see here .","breadcrumbs":"Command-line Arguments  --cap-lints: set the most restrictive lint level","id":"31","title":"--cap-lints: set the most restrictive lint level"},"310":{"body":"#![deny(unused_qualifications)]\\nmod foo { pub fn bar() {}\\n} fn main() { use foo::bar; foo::bar(); bar();\\n} This will produce: error: unnecessary qualification --> lint_example.rs:8:5 |\\n8 | foo::bar(); | ^^^^^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unused_qualifications)] | ^^^^^^^^^^^^^^^^^^^^^\\nhelp: remove the unnecessary path segments |\\n8 - foo::bar();\\n8 + bar(); |","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"310","title":"Example"},"311":{"body":"If an item from another module is already brought into scope, then there is no need to qualify it in this case. You can call bar() directly, without the foo::. This lint is \\"allow\\" by default because it is somewhat pedantic, and doesn\'t indicate an actual problem, but rather a stylistic choice, and can be noisy when refactoring or moving around code.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"311","title":"Explanation"},"312":{"body":"The unused_results lint checks for the unused result of an expression in a statement.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  unused-results","id":"312","title":"unused-results"},"313":{"body":"#![deny(unused_results)]\\nfn foo<T>() -> T { panic!() } fn main() { foo::<usize>();\\n} This will produce: error: unused result of type `usize` --> lint_example.rs:5:5 |\\n5 | foo::<usize>(); | ^^^^^^^^^^^^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(unused_results)] | ^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"313","title":"Example"},"314":{"body":"Ignoring the return value of a function may indicate a mistake. In cases were it is almost certain that the result should be used, it is recommended to annotate the function with the must_use attribute . Failure to use such a return value will trigger the unused_must_use lint which is warn-by-default. The unused_results lint is essentially the same, but triggers for all return values. This lint is \\"allow\\" by default because it can be noisy, and may not be an actual problem. For example, calling the remove method of a Vec or HashMap returns the previous value, which you may not care about. Using this lint would require explicitly ignoring or discarding such values.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"314","title":"Explanation"},"315":{"body":"The variant_size_differences lint detects enums with widely varying variant sizes.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  variant-size-differences","id":"315","title":"variant-size-differences"},"316":{"body":"#![deny(variant_size_differences)]\\nenum En { V0(u8), VBig([u8; 1024]),\\n} This will produce: error: enum variant is more than three times larger (1024 bytes) than the next largest --> lint_example.rs:5:5 |\\n5 | VBig([u8; 1024]), | ^^^^^^^^^^^^^^^^ |\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(variant_size_differences)] | ^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Example","id":"316","title":"Example"},"317":{"body":"It can be a mistake to add a variant to an enum that is much larger than the other variants, bloating the overall size required for all variants. This can impact performance and memory usage. This is triggered if one variant is more than 3 times larger than the second-largest variant. Consider placing the large variant\'s contents on the heap (for example via Box ) to keep the overall size of the enum itself down. This lint is \\"allow\\" by default because it can be noisy, and may not be an actual problem. Decisions about this should be guided with profiling and benchmarking.","breadcrumbs":"Lints  Lint Listing  Allowed-by-default Lints  Explanation","id":"317","title":"Explanation"},"318":{"body":"These lints are all set to the \'warn\' level by default. aarch64_softfloat_neon ambiguous_glob_reexports ambiguous_wide_pointer_comparisons anonymous_parameters array_into_iter asm_sub_register async_fn_in_trait bad_asm_style bare-trait-object bare_trait_objects boxed_slice_into_iter break_with_label_and_loop clashing_extern_declarations coherence_leak_check confusable_idents const_evaluatable_unchecked const_item_mutation dangling_pointers_from_locals dangling_pointers_from_temporaries dead_code deprecated deprecated_where_clause_location deref_nullptr double_negations drop_bounds dropping_copy_types dropping_references duplicate_macro_attributes dyn_drop ellipsis_inclusive_range_patterns exported_private_dependencies for_loops_over_fallibles forbidden_lint_groups forgetting_copy_types forgetting_references function_item_references hidden_glob_reexports improper_ctypes improper_ctypes_definitions incomplete_features inline_always_mismatching_target_features inline_no_sanitize integer_to_ptr_transmutes internal_features invalid_from_utf8 invalid_nan_comparisons invalid_value irrefutable_let_patterns large_assignments late_bound_lifetime_arguments malformed_diagnostic_attributes malformed_diagnostic_format_literals map_unit_fn mismatched_lifetime_syntaxes misplaced_diagnostic_attributes missing_abi mixed_script_confusables named_arguments_used_positionally no_mangle_generic_items non-fmt-panic non_camel_case_types non_contiguous_range_endpoints non_fmt_panics non_local_definitions non_shorthand_field_patterns non_snake_case non_upper_case_globals noop_method_call opaque_hidden_inferred_bound overlapping-patterns overlapping_range_endpoints path_statements private_bounds private_interfaces ptr_to_integer_transmute_in_consts redundant-semicolon redundant_semicolons refining_impl_trait_internal refining_impl_trait_reachable renamed_and_removed_lints repr_transparent_external_private_fields self_constructor_from_outer_item special_module_name stable_features static-mut-ref static_mut_refs suspicious_double_ref_op tail_call_track_caller trivial_bounds type_alias_bounds tyvar_behind_raw_pointer uncommon_codepoints unconditional_recursion uncovered_param_in_projection unexpected_cfgs unfulfilled_lint_expectations ungated_async_fn_track_caller uninhabited_static unknown_diagnostic_attributes unknown_lints unnameable_test_items unnecessary_transmutes unpredictable_function_pointer_comparisons unreachable_code unreachable_patterns unstable-name-collision unstable_name_collisions unstable_syntax_pre_expansion unsupported_calling_conventions unsupported_fn_ptr_calling_conventions unused-doc-comment unused-tuple-struct-fields unused_allocation unused_assignments unused_associated_type_bounds unused_attributes unused_braces unused_comparisons unused_doc_comments unused_features unused_imports unused_labels unused_macros unused_must_use unused_mut unused_parens unused_unsafe unused_variables useless_ptr_null_checks uses_power_alignment warnings while_true","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Warn-by-default Lints","id":"318","title":"Warn-by-default Lints"},"319":{"body":"The aarch64_softfloat_neon lint detects usage of #[target_feature(enable = \\"neon\\")] on softfloat aarch64 targets. Enabling this target feature causes LLVM to alter the ABI of function calls, making this attribute unsound to use.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  aarch64-softfloat-neon","id":"319","title":"aarch64-softfloat-neon"},"32":{"body":"This flag will allow you to set codegen options .","breadcrumbs":"Command-line Arguments  -C/--codegen: code generation options","id":"32","title":"-C/--codegen: code generation options"},"320":{"body":"#[target_feature(enable = \\"neon\\")]\\nfn with_neon() {} This will produce: error: enabling the `neon` target feature on the current target is unsound due to ABI issues --> $DIR/abi-incompatible-target-feature-attribute-fcw.rs:11:18 | | #[target_feature(enable = \\"neon\\")] | ^^^^^^^^^^^^^^^ | = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release! = note: for more information, see issue #134375 <https://github.com/rust-lang/rust/issues/134375>","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"320","title":"Example"},"321":{"body":"If a function like with_neon above ends up containing calls to LLVM builtins, those will not use the correct ABI. This is caused by a lack of support in LLVM for mixing code with and without the neon target feature. The target feature should never have been stabilized on this target due to this issue, but the problem was not known at the time of stabilization.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"321","title":"Explanation"},"322":{"body":"The ambiguous_glob_reexports lint detects cases where names re-exported via globs collide. Downstream users trying to use the same name re-exported from multiple globs will receive a warning pointing out redefinition of the same name.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  ambiguous-glob-reexports","id":"322","title":"ambiguous-glob-reexports"},"323":{"body":"#![deny(ambiguous_glob_reexports)]\\npub mod foo { pub type X = u8;\\n} pub mod bar { pub type Y = u8; pub type X = u8;\\n} pub use foo::*;\\npub use bar::*; pub fn main() {} This will produce: error: ambiguous glob re-exports --> lint_example.rs:11:9 |\\n11 | pub use foo::*; | ^^^^^^ the name `X` in the type namespace is first re-exported here\\n12 | pub use bar::*; | ------ but the name `X` in the type namespace is also re-exported here |\\nnote: the lint level is defined here --> lint_example.rs:1:9 | 1 | #![deny(ambiguous_glob_reexports)] | ^^^^^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"323","title":"Example"},"324":{"body":"This was previously accepted but it could silently break a crate\'s downstream users code. For example, if foo::* and bar::* were re-exported before bar::X was added to the re-exports, down stream users could use this_crate::X without problems. However, adding bar::X would cause compilation errors in downstream crates because X is defined multiple times in the same namespace of this_crate.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"324","title":"Explanation"},"325":{"body":"The ambiguous_wide_pointer_comparisons lint checks comparison of *const/*mut ?Sized as the operands.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  ambiguous-wide-pointer-comparisons","id":"325","title":"ambiguous-wide-pointer-comparisons"},"326":{"body":"# struct A;\\n# struct B; # trait T {}\\n# impl T for A {}\\n# impl T for B {} let ab = (A, B);\\nlet a = &ab.0 as *const dyn T;\\nlet b = &ab.1 as *const dyn T; let _ = a == b; This will produce: warning: ambiguous wide pointer comparison, the comparison includes metadata which may not be expected --> lint_example.rs:13:9 |\\n13 | let _ = a == b; | ^^^^^^ | = note: `#[warn(ambiguous_wide_pointer_comparisons)]` on by default\\nhelp: use `std::ptr::addr_eq` or untyped pointers to only compare their addresses |\\n13 - let _ = a == b;\\n13 + let _ = std::ptr::addr_eq(a, b); |","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"326","title":"Example"},"327":{"body":"The comparison includes metadata which may not be expected.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"327","title":"Explanation"},"328":{"body":"The anonymous_parameters lint detects anonymous parameters in trait definitions.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  anonymous-parameters","id":"328","title":"anonymous-parameters"},"329":{"body":"#![deny(anonymous_parameters)]\\n// edition 2015\\npub trait Foo { fn foo(usize);\\n}\\nfn main() {} This will produce: error: anonymous parameters are deprecated and will be removed in the next edition --> lint_example.rs:4:12 |\\n4 | fn foo(usize); | ^^^^^ help: try naming the parameter or explicitly ignoring it: `_: usize` | = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018! = note: for more information, see issue #41686 <https://github.com/rust-lang/rust/issues/41686>\\nnote: the lint level is defined here --> lint_example.rs:1:9 |\\n1 | #![deny(anonymous_parameters)] | ^^^^^^^^^^^^^^^^^^^^","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"329","title":"Example"},"33":{"body":"This flag will print out rustc\'s version.","breadcrumbs":"Command-line Arguments  -V/--version: print a version","id":"33","title":"-V/--version: print a version"},"330":{"body":"This syntax is mostly a historical accident, and can be worked around quite easily by adding an _ pattern or a descriptive identifier: trait Foo { fn foo(_: usize);\\n} This syntax is now a hard error in the 2018 edition. In the 2015 edition, this lint is \\"warn\\" by default. This lint enables the cargo fix tool with the --edition flag to automatically transition old code from the 2015 edition to 2018. The tool will run this lint and automatically apply the suggested fix from the compiler (which is to add _ to each parameter). This provides a completely automated way to update old code for a new edition. See issue #41686 for more details.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"330","title":"Explanation"},"331":{"body":"The array_into_iter lint detects calling into_iter on arrays.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  array-into-iter","id":"331","title":"array-into-iter"},"332":{"body":"# #![allow(unused)]\\n[1, 2, 3].into_iter().for_each(|n| { *n; }); This will produce: warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to `<[T; N] as IntoIterator>::into_iter` in Rust 2021 --> lint_example.rs:3:11 |\\n3 | [1, 2, 3].into_iter().for_each(|n| { *n; }); | ^^^^^^^^^ | = warning: this changes meaning in Rust 2021 = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html> = note: `#[warn(array_into_iter)]` (part of `#[warn(rust_2021_compatibility)]`) on by default\\nhelp: use `.iter()` instead of `.into_iter()` to avoid ambiguity |\\n3 - [1, 2, 3].into_iter().for_each(|n| { *n; });\\n3 + [1, 2, 3].iter().for_each(|n| { *n; }); |\\nhelp: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value |\\n3 - [1, 2, 3].into_iter().for_each(|n| { *n; });\\n3 + IntoIterator::into_iter([1, 2, 3]).for_each(|n| { *n; }); |","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"332","title":"Example"},"333":{"body":"Since Rust 1.53, arrays implement IntoIterator. However, to avoid breakage, array.into_iter() in Rust 2015 and 2018 code will still behave as (&array).into_iter(), returning an iterator over references, just like in Rust 1.52 and earlier. This only applies to the method call syntax array.into_iter(), not to any other syntax such as for _ in array or IntoIterator::into_iter(array).","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"333","title":"Explanation"},"334":{"body":"The asm_sub_register lint detects using only a subset of a register for inline asm inputs.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  asm-sub-register","id":"334","title":"asm-sub-register"},"335":{"body":"#[cfg(target_arch=\\"x86_64\\")]\\nuse std::arch::asm; fn main() { #[cfg(target_arch=\\"x86_64\\")] unsafe { asm!(\\"mov {0}, {0}\\", in(reg) 0i16); }\\n} This will produce: warning: formatting may not be suitable for sub-register argument --> src/main.rs:7:19 |\\n7 | asm!(\\"mov {0}, {0}\\", in(reg) 0i16); | ^^^ ^^^ ---- for this argument | = note: `#[warn(asm_sub_register)]` on by default = help: use the `x` modifier to have the register formatted as `ax` = help: or use the `r` modifier to keep the default formatting of `rax`","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"335","title":"Example"},"336":{"body":"Registers on some architectures can use different names to refer to a subset of the register. By default, the compiler will use the name for the full register size. To explicitly use a subset of the register, you can override the default by using a modifier on the template string operand to specify when subregister to use. This lint is issued if you pass in a value with a smaller data type than the default register size, to alert you of possibly using the incorrect width. To fix this, add the suggested modifier to the template, or cast the value to the correct size. See register template modifiers in the reference for more details.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"336","title":"Explanation"},"337":{"body":"The async_fn_in_trait lint detects use of async fn in the definition of a publicly-reachable trait.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  async-fn-in-trait","id":"337","title":"async-fn-in-trait"},"338":{"body":"pub trait Trait { async fn method(&self);\\n}\\n# fn main() {} This will produce: warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified --> lint_example.rs:2:5 |\\n2 | async fn method(&self); | ^^^^^ | = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future` = note: `#[warn(async_fn_in_trait)]` on by default\\nhelp: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change |\\n2 - async fn method(&self);\\n2 + fn method(&self) -> impl std::future::Future<Output = ()> + Send; |","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"338","title":"Example"},"339":{"body":"When async fn is used in a trait definition, the trait does not promise that the opaque Future returned by the associated function or method will implement any auto traits such as Send . This may be surprising and may make the associated functions or methods on the trait less useful than intended. On traits exposed publicly from a crate, this may affect downstream crates whose authors cannot alter the trait definition. For example, this code is invalid: pub trait Trait { async fn method(&self) {}\\n} fn test<T: Trait>(x: T) { fn spawn<T: Send>(_: T) {} spawn(x.method()); // Not OK.\\n} This lint exists to warn authors of publicly-reachable traits that they may want to consider desugaring the async fn to a normal fn that returns an opaque impl Future<..> + Send type. For example, instead of: pub trait Trait { async fn method(&self) {}\\n} The author of the trait may want to write: use core::future::Future;\\npub trait Trait { fn method(&self) -> impl Future<Output = ()> + Send { async {} }\\n} This still allows the use of async fn within impls of the trait. However, it also means that the trait will never be compatible with impls where the returned Future of the method does not implement Send. Conversely, if the trait is used only locally, if it is never used in generic functions, or if it is only used in single-threaded contexts that do not care whether the returned Future implements Send , then the lint may be suppressed.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"339","title":"Explanation"},"34":{"body":"This flag, when combined with other flags, makes them produce extra output.","breadcrumbs":"Command-line Arguments  -v/--verbose: use verbose output","id":"34","title":"-v/--verbose: use verbose output"},"340":{"body":"The bad_asm_style lint detects the use of the .intel_syntax and .att_syntax directives.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  bad-asm-style","id":"340","title":"bad-asm-style"},"341":{"body":"#[cfg(target_arch=\\"x86_64\\")]\\nuse std::arch::asm; fn main() { #[cfg(target_arch=\\"x86_64\\")] unsafe { asm!( \\".att_syntax\\", \\"movq %{0}, %{0}\\", in(reg) 0usize ); }\\n} This will produce: warning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead --> src/main.rs:8:14 |\\n8 | \\".att_syntax\\", | ^^^^^^^^^^^ | = note: `#[warn(bad_asm_style)]` on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"341","title":"Example"},"342":{"body":"On x86, asm! uses the intel assembly syntax by default. While this can be switched using assembler directives like .att_syntax, using the att_syntax option is recommended instead because it will also properly prefix register placeholders with % as required by AT&T syntax.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"342","title":"Explanation"},"343":{"body":"The lint bare-trait-object has been renamed to bare-trait-objects .","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  bare-trait-object","id":"343","title":"bare-trait-object"},"344":{"body":"The bare_trait_objects lint suggests using dyn Trait for trait objects.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  bare-trait-objects","id":"344","title":"bare-trait-objects"},"345":{"body":"trait Trait { } fn takes_trait_object(_: Box<Trait>) {\\n} This will produce: warning: trait objects without an explicit `dyn` are deprecated --> lint_example.rs:4:30 |\\n4 | fn takes_trait_object(_: Box<Trait>) { | ^^^^^ | = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021! = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2021/warnings-promoted-to-error.html> = note: `#[warn(bare_trait_objects)]` (part of `#[warn(rust_2021_compatibility)]`) on by default\\nhelp: if this is a dyn-compatible trait, use `dyn` |\\n4 | fn takes_trait_object(_: Box<dyn Trait>) { | +++","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"345","title":"Example"},"346":{"body":"Without the dyn indicator, it can be ambiguous or confusing when reading code as to whether or not you are looking at a trait object. The dyn keyword makes it explicit, and adds a symmetry to contrast with impl Trait .","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"346","title":"Explanation"},"347":{"body":"The boxed_slice_into_iter lint detects calling into_iter on boxed slices.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  boxed-slice-into-iter","id":"347","title":"boxed-slice-into-iter"},"348":{"body":"# #![allow(unused)]\\nvec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; }); This will produce: warning: this method call resolves to `<&Box<[T]> as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to `<Box<[T]> as IntoIterator>::into_iter` in Rust 2024 --> lint_example.rs:3:34 |\\n3 | vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; }); | ^^^^^^^^^ | = warning: this changes meaning in Rust 2024 = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/intoiterator-box-slice.html> = note: `#[warn(boxed_slice_into_iter)]` (part of `#[warn(rust_2024_compatibility)]`) on by default\\nhelp: use `.iter()` instead of `.into_iter()` to avoid ambiguity |\\n3 - vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });\\n3 + vec![1, 2, 3].into_boxed_slice().iter().for_each(|n| { *n; }); |\\nhelp: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value |\\n3 - vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });\\n3 + IntoIterator::into_iter(vec![1, 2, 3].into_boxed_slice()).for_each(|n| { *n; }); |","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"348","title":"Example"},"349":{"body":"Since Rust 1.80.0, boxed slices implement IntoIterator. However, to avoid breakage, boxed_slice.into_iter() in Rust 2015, 2018, and 2021 code will still behave as (&boxed_slice).into_iter(), returning an iterator over references, just like in Rust 1.79.0 and earlier. This only applies to the method call syntax boxed_slice.into_iter(), not to any other syntax such as for _ in boxed_slice or IntoIterator::into_iter(boxed_slice).","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"349","title":"Explanation"},"35":{"body":"This flag allows you to pass the name and location for an external crate of a direct dependency. Indirect dependencies (dependencies of dependencies) are located using the -L flag . The given crate name is added to the extern prelude , similar to specifying extern crate within the root module. The given crate name does not need to match the name the library was built with. Specifying --extern has one behavior difference from extern crate: --extern merely makes the crate a candidate for being linked; it does not actually link it unless it\'s actively used. In rare occasions you may wish to ensure a crate is linked even if you don\'t actively use it from your code: for example, if it changes the global allocator or if it contains #[no_mangle] symbols for use by other programming languages. In such cases you\'ll need to use extern crate. This flag may be specified multiple times. This flag takes an argument with either of the following formats: CRATENAME=PATH Indicates the given crate is found at the given path. CRATENAME Indicates the given crate may be found in the search path, such as within the sysroot or via the -L flag. The same crate name may be specified multiple times for different crate types. If both an rlib and dylib are found, an internal algorithm is used to decide which to use for linking. The -C prefer-dynamic flag may be used to influence which is used. If the same crate name is specified with and without a path, the one with the path is used and the pathless flag has no effect.","breadcrumbs":"Command-line Arguments  --extern: specify where an external library is located","id":"35","title":"--extern: specify where an external library is located"},"350":{"body":"The break_with_label_and_loop lint detects labeled break expressions with an unlabeled loop as their value expression.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  break-with-label-and-loop","id":"350","title":"break-with-label-and-loop"},"351":{"body":"\'label: loop { break \'label loop { break 42; };\\n}; This will produce: warning: this labeled break expression is easy to confuse with an unlabeled break with a labeled value expression --> lint_example.rs:3:5 |\\n3 | break \'label loop { break 42; }; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: `#[warn(break_with_label_and_loop)]` on by default\\nhelp: wrap this expression in parentheses |\\n3 | break \'label (loop { break 42; }); | + +","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"351","title":"Example"},"352":{"body":"In Rust, loops can have a label, and break expressions can refer to that label to break out of specific loops (and not necessarily the innermost one). break expressions can also carry a value expression, which can be another loop. A labeled break with an unlabeled loop as its value expression is easy to confuse with an unlabeled break with a labeled loop and is thus discouraged (but allowed for compatibility); use parentheses around the loop expression to silence this warning. Unlabeled break expressions with labeled loops yield a hard error, which can also be silenced by wrapping the expression in parentheses.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"352","title":"Explanation"},"353":{"body":"The clashing_extern_declarations lint detects when an extern fn has been declared with the same name but different types.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  clashing-extern-declarations","id":"353","title":"clashing-extern-declarations"},"354":{"body":"mod m { unsafe extern \\"C\\" { fn foo(); }\\n} unsafe extern \\"C\\" { fn foo(_: u32);\\n} This will produce: warning: `foo` redeclared with a different signature --> lint_example.rs:9:5 |\\n4 | fn foo(); | --------- `foo` previously declared here\\n...\\n9 | fn foo(_: u32); | ^^^^^^^^^^^^^^^ this signature doesn\'t match the previous declaration | = note: expected `unsafe extern \\"C\\" fn()` found `unsafe extern \\"C\\" fn(u32)` = note: `#[warn(clashing_extern_declarations)]` on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"354","title":"Example"},"355":{"body":"Because two symbols of the same name cannot be resolved to two different functions at link time, and one function cannot possibly have two types, a clashing extern declaration is almost certainly a mistake. Check to make sure that the extern definitions are correct and equivalent, and possibly consider unifying them in one location. This lint does not run between crates because a project may have dependencies which both rely on the same extern function, but declare it in a different (but valid) way. For example, they may both declare an opaque type for one or more of the arguments (which would end up distinct types), or use types that are valid conversions in the language the extern fn is defined in. In these cases, the compiler can\'t say that the clashing declaration is incorrect.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"355","title":"Explanation"},"356":{"body":"The coherence_leak_check lint detects conflicting implementations of a trait that are only distinguished by the old leak-check code.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  coherence-leak-check","id":"356","title":"coherence-leak-check"},"357":{"body":"trait SomeTrait { }\\nimpl SomeTrait for for<\'a> fn(&\'a u8) { }\\nimpl<\'a> SomeTrait for fn(&\'a u8) { } This will produce: warning: conflicting implementations of trait `SomeTrait` for type `for<\'a> fn(&\'a u8)` --> lint_example.rs:4:1 |\\n3 | impl SomeTrait for for<\'a> fn(&\'a u8) { } | ------------------------------------- first implementation here\\n4 | impl<\'a> SomeTrait for fn(&\'a u8) { } | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<\'a> fn(&\'a u8)` | = warning: the behavior may change in a future release = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105> = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details = note: `#[warn(coherence_leak_check)]` (part of `#[warn(future_incompatible)]`) on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"357","title":"Example"},"358":{"body":"In the past, the compiler would accept trait implementations for identical functions that differed only in where the lifetime binder appeared. Due to a change in the borrow checker implementation to fix several bugs, this is no longer allowed. However, since this affects existing code, this is a future-incompatible lint to transition this to a hard error in the future. Code relying on this pattern should introduce \\" newtypes \\", like struct Foo(for<\'a> fn(&\'a u8)). See issue #56105 for more details.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"358","title":"Explanation"},"359":{"body":"The confusable_idents lint detects visually confusable pairs between identifiers.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  confusable-idents","id":"359","title":"confusable-idents"},"36":{"body":"The \\"sysroot\\" is where rustc looks for the crates that come with the Rust distribution; this flag allows that to be overridden.","breadcrumbs":"Command-line Arguments  --sysroot: Override the system root","id":"36","title":"--sysroot: Override the system root"},"360":{"body":"// Latin Capital Letter E With Caron\\npub const : i32 = 1;\\n// Latin Capital Letter E With Breve\\npub const : i32 = 2; This will produce: warning: found both `` and `` as identifiers, which look alike --> lint_example.rs:5:11 |\\n3 | pub const : i32 = 1; | - other identifier used here\\n4 | // Latin Capital Letter E With Breve\\n5 | pub const : i32 = 2; | ^ this identifier can be confused with `` | = note: `#[warn(confusable_idents)]` on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"360","title":"Example"},"361":{"body":"This lint warns when different identifiers may appear visually similar, which can cause confusion. The confusable detection algorithm is based on Unicode Technical Standard #39 Unicode Security Mechanisms Section 4 Confusable Detection . For every distinct identifier X execute the function skeleton(X). If there exist two distinct identifiers X and Y in the same crate where skeleton(X) = skeleton(Y) report it. The compiler uses the same mechanism to check if an identifier is too similar to a keyword. Note that the set of confusable characters may change over time. Beware that if you \\"forbid\\" this lint that existing code may fail in the future.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"361","title":"Explanation"},"362":{"body":"The const_evaluatable_unchecked lint detects a generic constant used in a type.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  const-evaluatable-unchecked","id":"362","title":"const-evaluatable-unchecked"},"363":{"body":"const fn foo<T>() -> usize { if size_of::<*mut T>() < 8 { // size of *mut T does not depend on T 4 } else { 8 }\\n} fn test<T>() { let _ = [0; foo::<T>()];\\n} This will produce: warning: cannot use constants which depend on generic parameters in types --> lint_example.rs:11:17 |\\n11 | let _ = [0; foo::<T>()]; | ^^^^^^^^^^ | = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release! = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200> = note: `#[warn(const_evaluatable_unchecked)]` (part of `#[warn(future_incompatible)]`) on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"363","title":"Example"},"364":{"body":"In the 1.43 release, some uses of generic parameters in array repeat expressions were accidentally allowed. This is a future-incompatible lint to transition this to a hard error in the future. See issue #76200 for a more detailed description and possible fixes.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"364","title":"Explanation"},"365":{"body":"The const_item_mutation lint detects attempts to mutate a const item.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  const-item-mutation","id":"365","title":"const-item-mutation"},"366":{"body":"const FOO: [i32; 1] = [0]; fn main() { FOO[0] = 1; // This will print \\"[0]\\". println!(\\"{:?}\\", FOO);\\n} This will produce: warning: attempting to modify a `const` item --> lint_example.rs:4:5 |\\n4 | FOO[0] = 1; | ^^^^^^^^^^ | = note: each usage of a `const` item creates a new temporary; the original `const` item will not be modified\\nnote: `const` item defined here --> lint_example.rs:1:1 |\\n1 | const FOO: [i32; 1] = [0]; | ^^^^^^^^^^^^^^^^^^^ = note: `#[warn(const_item_mutation)]` on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"366","title":"Example"},"367":{"body":"Trying to directly mutate a const item is almost always a mistake. What is happening in the example above is that a temporary copy of the const is mutated, but the original const is not. Each time you refer to the const by name (such as FOO in the example above), a separate copy of the value is inlined at that location. This lint checks for writing directly to a field (FOO.field = some_value) or array entry (FOO[0] = val), or taking a mutable reference to the const item (&mut FOO), including through an autoderef (FOO.some_mut_self_method()). There are various alternatives depending on what you are trying to accomplish: First, always reconsider using mutable globals, as they can be difficult to use correctly, and can make the code more difficult to use or understand. If you are trying to perform a one-time initialization of a global: If the value can be computed at compile-time, consider using const-compatible values (see Constant Evaluation ). For more complex single-initialization cases, consider using std::sync::LazyLock . If you truly need a mutable global, consider using a static , which has a variety of options: Simple data types can be directly defined and mutated with an atomic type. More complex types can be placed in a synchronization primitive like a Mutex , which can be initialized with one of the options listed above. A mutable static is a low-level primitive, requiring unsafe. Typically This should be avoided in preference of something higher-level like one of the above.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"367","title":"Explanation"},"368":{"body":"The dangling_pointers_from_locals lint detects getting a pointer to data of a local that will be dropped at the end of the function.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  dangling-pointers-from-locals","id":"368","title":"dangling-pointers-from-locals"},"369":{"body":"fn f() -> *const u8 { let x = 0; &x // returns a dangling ptr to `x`\\n} This will produce: warning: a dangling pointer will be produced because the local variable `x` will be dropped --> lint_example.rs:4:5 |\\n2 | fn f() -> *const u8 { | --------- return type of the function is `*const u8`\\n3 | let x = 0; | - `x` is part the function and will be dropped at the end of the function\\n4 | &x // returns a dangling ptr to `x` | ^^ | = note: pointers do not have a lifetime; after returning, the `u8` will be deallocated at the end of the function because nothing is referencing it as far as the type system is concerned = note: `#[warn(dangling_pointers_from_locals)]` on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"369","title":"Example"},"37":{"body":"This flag lets you control the format of messages. Messages are printed to stderr. The valid options are: human  Human-readable output. This is the default. json  Structured JSON output. See the JSON chapter for more detail. short  Short, one-line messages.","breadcrumbs":"Command-line Arguments  --error-format: control how errors are produced","id":"37","title":"--error-format: control how errors are produced"},"370":{"body":"Returning a pointer from a local value will not prolong its lifetime, which means that the value can be dropped and the allocation freed while the pointer still exists, making the pointer dangling. This is not an error (as far as the type system is concerned) but probably is not what the user intended either. If you need stronger guarantees, consider using references instead, as they are statically verified by the borrow-checker to never dangle.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"370","title":"Explanation"},"371":{"body":"The dangling_pointers_from_temporaries lint detects getting a pointer to data of a temporary that will immediately get dropped.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  dangling-pointers-from-temporaries","id":"371","title":"dangling-pointers-from-temporaries"},"372":{"body":"# #![allow(unused)]\\n# unsafe fn use_data(ptr: *const u8) { }\\nfn gather_and_use(bytes: impl Iterator<Item = u8>) { let x: *const u8 = bytes.collect::<Vec<u8>>().as_ptr(); unsafe { use_data(x) }\\n} This will produce: warning: a dangling pointer will be produced because the temporary `Vec<u8>` will be dropped --> lint_example.rs:5:51 |\\n5 | let x: *const u8 = bytes.collect::<Vec<u8>>().as_ptr(); | -------------------------- ^^^^^^ this pointer will immediately be invalid | | | this `Vec<u8>` is deallocated at the end of the statement, bind it to a variable to extend its lifetime | = note: pointers do not have a lifetime; when calling `as_ptr` the `Vec<u8>` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned = help: you must make sure that the variable you bind the `Vec<u8>` to lives at least as long as the pointer returned by the call to `as_ptr` = help: in particular, if this pointer is returned from the current function, binding the `Vec<u8>` inside the function will not suffice = help: for more information, see <https://doc.rust-lang.org/reference/destructors.html> = note: `#[warn(dangling_pointers_from_temporaries)]` on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"372","title":"Example"},"373":{"body":"Getting a pointer from a temporary value will not prolong its lifetime, which means that the value can be dropped and the allocation freed while the pointer still exists, making the pointer dangling. This is not an error (as far as the type system is concerned) but probably is not what the user intended either. If you need stronger guarantees, consider using references instead, as they are statically verified by the borrow-checker to never dangle.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"373","title":"Explanation"},"374":{"body":"The dead_code lint detects unused, unexported items.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  dead-code","id":"374","title":"dead-code"},"375":{"body":"fn foo() {} This will produce: warning: function `foo` is never used --> lint_example.rs:2:4 |\\n2 | fn foo() {} | ^^^ | = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"375","title":"Example"},"376":{"body":"Dead code may signal a mistake or unfinished code. To silence the warning for individual items, prefix the name with an underscore such as _foo. If it was intended to expose the item outside of the crate, consider adding a visibility modifier like pub. To preserve the numbering of tuple structs with unused fields, change the unused fields to have unit type or use PhantomData. Otherwise consider removing the unused code.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"376","title":"Explanation"},"377":{"body":"Removing fields that are only used for side-effects and never read will result in behavioral changes. Examples of this include: If a field\'s value performs an action when it is dropped. If a field\'s type does not implement an auto trait (e.g. Send, Sync, Unpin). For side-effects from dropping field values, this lint should be allowed on those fields. For side-effects from containing field types, PhantomData should be used.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Limitations","id":"377","title":"Limitations"},"378":{"body":"The deprecated lint detects use of deprecated items.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  deprecated","id":"378","title":"deprecated"},"379":{"body":"#[deprecated]\\nfn foo() {} fn bar() { foo();\\n} This will produce: warning: use of deprecated function `main::foo` --> lint_example.rs:6:5 |\\n6 | foo(); | ^^^ | = note: `#[warn(deprecated)]` on by default","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"379","title":"Example"},"38":{"body":"This flag lets you control color settings of the output. The valid options are: auto  Use colors if output goes to a tty. This is the default. always Always use colors. never Never colorize output.","breadcrumbs":"Command-line Arguments  --color: configure coloring of output","id":"38","title":"--color: configure coloring of output"},"380":{"body":"Items may be marked \\"deprecated\\" with the deprecated attribute to indicate that they should no longer be used. Usually the attribute should include a note on what to use instead, or check the documentation.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"380","title":"Explanation"},"381":{"body":"The deprecated_where_clause_location lint detects when a where clause in front of the equals in an associated type.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  deprecated-where-clause-location","id":"381","title":"deprecated-where-clause-location"},"382":{"body":"trait Trait { type Assoc<\'a> where Self: \'a;\\n} impl Trait for () { type Assoc<\'a> where Self: \'a = ();\\n} This will produce: warning: where clause not allowed here --> lint_example.rs:7:18 |\\n7 | type Assoc<\'a> where Self: \'a = (); | ^^^^^^^^^^^^^^ | = note: see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information = note: `#[warn(deprecated_where_clause_location)]` on by default\\nhelp: move it to the end of the type declaration |\\n7 - type Assoc<\'a> where Self: \'a = ();\\n7 + type Assoc<\'a> = () where Self: \'a; |","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Example","id":"382","title":"Example"},"383":{"body":"The preferred location for where clauses on associated types is after the type. However, for most of generic associated types development, it was only accepted before the equals. To provide a transition period and further evaluate this change, both are currently accepted. At some point in the future, this may be disallowed at an edition boundary; but, that is undecided currently.","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  Explanation","id":"383","title":"Explanation"},"384":{"body":"The deref_nullptr lint detects when a null pointer is dereferenced, which causes undefined behavior .","breadcrumbs":"Lints  Lint Listing  Warn-by-default Lints  deref-nullptr","id":"384","title":"deref-nullptr"},"385":{"body":"# #![allow(unused)]\\nuse std::ptr;\\nunsafe { let x = &*ptr::null::<i32>(); let x = ptr::addr_of!(*ptr::null::<i32>()); let x = *(0 as *const i32);\\n} This will produce: warning: dereferencing a null pointer --> lint_example.rs:5:14 |\\n5 | let x = &*ptr::null::<i32>(); | ^^^^^^^^^^^^^^^^^^^ this code causes undefined b