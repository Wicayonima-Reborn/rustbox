window.search = Object.assign(window.search, JSON.parse('{"doc_urls":["introduction.html#introduction","introduction.html#rust-releases","introduction.html#what--the-reference--is-not","introduction.html#how-to-use-this-book","introduction.html#conventions","introduction.html#contributing","notation.html#notation","notation.html#grammar","notation.html#string-table-productions","notation.html#grammar-visualizations","lexical-structure.html#lexical-structure","input-format.html#input-format","input-format.html#source-encoding","input-format.html#byte-order-mark-removal","input-format.html#crlf-normalization","input-format.html#shebang-removal","input-format.html#tokenization","keywords.html#keywords","keywords.html#strict-keywords","keywords.html#reserved-keywords","keywords.html#weak-keywords","identifiers.html#identifiers","identifiers.html#normalization","identifiers.html#raw-identifiers","comments.html#comments","comments.html#non-doc-comments","comments.html#doc-comments","comments.html#examples","whitespace.html#whitespace","tokens.html#tokens","tokens.html#literals","tokens.html#examples","tokens.html#character-and-string-literals","tokens.html#byte-and-byte-string-literals","tokens.html#c-string-and-raw-c-string-literals","tokens.html#number-literals","tokens.html#lifetimes-and-loop-labels","tokens.html#punctuation","tokens.html#delimiters","tokens.html#reserved-tokens","tokens.html#reserved-prefixes","tokens.html#reserved-guards","macros.html#macros","macros.html#macro-invocation","macros-by-example.html#macros-by-example","macros-by-example.html#transcribing","macros-by-example.html#forwarding-a-matched-fragment","macros-by-example.html#metavariables","macros-by-example.html#repetitions","macros-by-example.html#scoping-exporting-and-importing","macros-by-example.html#textual-scope","macros-by-example.html#the-macro_use-attribute","macros-by-example.html#path-based-scope","macros-by-example.html#hygiene","macros-by-example.html#follow-set-ambiguity-restrictions","procedural-macros.html#procedural-macros","procedural-macros.html#the-proc_macro-crate","procedural-macros.html#procedural-macro-hygiene","procedural-macros.html#function-like-procedural-macros","procedural-macros.html#the-proc_macro_derive-attribute","procedural-macros.html#derive-macro-helper-attributes","procedural-macros.html#attribute-macros","procedural-macros.html#declarative-macro-tokens-and-procedural-macro-tokens","crates-and-source-files.html#crates-and-source-files","crates-and-source-files.html#main-functions","crates-and-source-files.html#uncaught-foreign-unwinding","crates-and-source-files.html#the-no_main-attribute","crates-and-source-files.html#the-crate_name-attribute","conditional-compilation.html#conditional-compilation","conditional-compilation.html#set-configuration-options","conditional-compilation.html#target_arch","conditional-compilation.html#target_feature","conditional-compilation.html#target_os","conditional-compilation.html#target_family","conditional-compilation.html#unix-and-windows","conditional-compilation.html#target_env","conditional-compilation.html#target_abi","conditional-compilation.html#target_endian","conditional-compilation.html#target_pointer_width","conditional-compilation.html#target_vendor","conditional-compilation.html#target_has_atomic","conditional-compilation.html#test","conditional-compilation.html#debug_assertions","conditional-compilation.html#proc_macro","conditional-compilation.html#panic","conditional-compilation.html#forms-of-conditional-compilation","conditional-compilation.html#the-cfg-attribute","conditional-compilation.html#the-cfg_attr-attribute","conditional-compilation.html#the-cfg-macro","items.html#items","items/modules.html#modules","items/modules.html#module-source-filenames","items/modules.html#the-path-attribute","items/modules.html#attributes-on-modules","items/extern-crates.html#extern-crate-declarations","items/extern-crates.html#underscore-imports","items/extern-crates.html#the-no_link-attribute","items/use-declarations.html#use-declarations","items/use-declarations.html#use-visibility","items/use-declarations.html#use-paths","items/use-declarations.html#as-renames","items/use-declarations.html#brace-syntax","items/use-declarations.html#self-imports","items/use-declarations.html#glob-imports","items/use-declarations.html#underscore-imports","items/use-declarations.html#restrictions","items/use-declarations.html#ambiguities","items/functions.html#functions","items/functions.html#function-parameters","items/functions.html#function-body","items/functions.html#generic-functions","items/functions.html#extern-function-qualifier","items/functions.html#unwinding","items/functions.html#const-functions","items/functions.html#async-functions","items/functions.html#combining-async-and-unsafe","items/functions.html#attributes-on-functions","items/functions.html#attributes-on-function-parameters","items/type-aliases.html#type-aliases","items/structs.html#structs","items/enumerations.html#enumerations","items/enumerations.html#discriminants","items/enumerations.html#assigning-discriminant-values","items/enumerations.html#accessing-discriminant","items/enumerations.html#zero-variant-enums","items/enumerations.html#variant-visibility","items/unions.html#unions","items/unions.html#initialization-of-a-union","items/unions.html#reading-and-writing-union-fields","items/unions.html#pattern-matching-on-unions","items/unions.html#references-to-union-fields","items/constant-items.html#constant-items","items/constant-items.html#constants-with-destructors","items/constant-items.html#unnamed-constant","items/constant-items.html#evaluation","items/static-items.html#static-items","items/static-items.html#statics--generics","items/static-items.html#mutable-statics","items/static-items.html#using-statics-or-consts","items/traits.html#traits","items/traits.html#trait-bounds","items/traits.html#generic-traits","items/traits.html#dyn-compatibility","items/traits.html#supertraits","items/traits.html#unsafe-traits","items/traits.html#parameter-patterns","items/traits.html#item-visibility","items/implementations.html#implementations","items/implementations.html#inherent-implementations","items/implementations.html#trait-implementations","items/implementations.html#trait-implementation-coherence","items/implementations.html#generic-implementations","items/implementations.html#attributes-on-implementations","items/external-blocks.html#external-blocks","items/external-blocks.html#functions","items/external-blocks.html#statics","items/external-blocks.html#abi","items/external-blocks.html#variadic-functions","items/external-blocks.html#attributes-on-extern-blocks","items/external-blocks.html#the-link-attribute","items/external-blocks.html#linking-modifiers-verbatim","items/external-blocks.html#the-link_name-attribute","items/external-blocks.html#the-link_ordinal-attribute","items/external-blocks.html#attributes-on-function-parameters","items/generics.html#generic-parameters","items/generics.html#const-generics","items/generics.html#where-clauses","items/generics.html#attributes","items/associated-items.html#associated-items","items/associated-items.html#associated-functions-and-methods","items/associated-items.html#methods","items/associated-items.html#associated-types","items/associated-items.html#associated-types-container-example","items/associated-items.html#relationship-between-bounds-and-wherebounds","items/associated-items.html#required-where-clauses-on-generic-associated-types","items/associated-items.html#associated-constants","items/associated-items.html#associated-constants-examples","attributes.html#attributes","attributes.html#meta-item-attribute-syntax","attributes.html#active-and-inert-attributes","attributes.html#tool-attributes","attributes.html#built-in-attributes-index","attributes/testing.html#testing-attributes","attributes/testing.html#the-test-attribute","attributes/testing.html#the-ignore-attribute","attributes/testing.html#the-should_panic-attribute","attributes/derive.html#derive","attributes/derive.html#the-automatically_derived-attribute","attributes/diagnostics.html#diagnostic-attributes","attributes/diagnostics.html#lint-check-attributes","attributes/diagnostics.html#lint-reasons","attributes/diagnostics.html#the-expect-attribute","attributes/diagnostics.html#lint-groups","attributes/diagnostics.html#tool-lint-attributes","attributes/diagnostics.html#the-deprecated-attribute","attributes/diagnostics.html#the-must_use-attribute","attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace","attributes/diagnostics.html#the-diagnosticon_unimplemented-attribute","attributes/diagnostics.html#the-diagnosticdo_not_recommend-attribute","attributes/codegen.html#code-generation-attributes","attributes/codegen.html#the-inline-attribute","attributes/codegen.html#the-cold-attribute","attributes/codegen.html#the-naked-attribute","attributes/codegen.html#the-no_builtins-attribute","attributes/codegen.html#the-target_feature-attribute","attributes/codegen.html#available-features","attributes/codegen.html#additional-information","attributes/codegen.html#the-track_caller-attribute","attributes/codegen.html#behavior","attributes/codegen.html#limitations","attributes/codegen.html#the-instruction_set-attribute","attributes/codegen.html#instruction_set-on-arm","attributes/limits.html#limits","attributes/limits.html#the-recursion_limit-attribute","attributes/limits.html#the-type_length_limit-attribute","attributes/type_system.html#type-system-attributes","attributes/type_system.html#the-non_exhaustive-attribute","attributes/debugger.html#debugger-attributes","attributes/debugger.html#the-debugger_visualizer-attribute","attributes/debugger.html#using-debugger_visualizer-with-natvis","attributes/debugger.html#using-debugger_visualizer-with-gdb","attributes/debugger.html#the-collapse_debuginfo-attribute","statements-and-expressions.html#statements-and-expressions","statements.html#statements","statements.html#declaration-statements","statements.html#item-declarations","statements.html#let-statements","statements.html#expression-statements","statements.html#attributes-on-statements","expressions.html#expressions","expressions.html#expression-precedence","expressions.html#evaluation-order-of-operands","expressions.html#place-expressions-and-value-expressions","expressions.html#moved-and-copied-types","expressions.html#mutability","expressions.html#temporaries","expressions.html#super-macros","expressions.html#implicit-borrows","expressions.html#overloading-traits","expressions.html#expression-attributes","expressions/literal-expr.html#literal-expressions","expressions/literal-expr.html#escapes","expressions/literal-expr.html#simple-escapes","expressions/literal-expr.html#8-bit-escapes","expressions/literal-expr.html#7-bit-escapes","expressions/literal-expr.html#unicode-escapes","expressions/literal-expr.html#string-continuation-escapes","expressions/literal-expr.html#character-literal-expressions","expressions/literal-expr.html#string-literal-expressions","expressions/literal-expr.html#byte-literal-expressions","expressions/literal-expr.html#byte-string-literal-expressions","expressions/literal-expr.html#c-string-literal-expressions","expressions/literal-expr.html#integer-literal-expressions","expressions/literal-expr.html#floating-point-literal-expressions","expressions/literal-expr.html#boolean-literal-expressions","expressions/path-expr.html#path-expressions","expressions/block-expr.html#block-expressions","expressions/block-expr.html#async-blocks","expressions/block-expr.html#capture-modes","expressions/block-expr.html#async-context","expressions/block-expr.html#control-flow-operators","expressions/block-expr.html#const-blocks","expressions/block-expr.html#unsafe-blocks","expressions/block-expr.html#labelled-block-expressions","expressions/block-expr.html#attributes-on-block-expressions","expressions/operator-expr.html#operator-expressions","expressions/operator-expr.html#overflow","expressions/operator-expr.html#borrow-operators","expressions/operator-expr.html#raw-borrow-operators","expressions/operator-expr.html#the-dereference-operator","expressions/operator-expr.html#the-try-propagation-expression","expressions/operator-expr.html#negation-operators","expressions/operator-expr.html#arithmetic-and-logical-binary-operators","expressions/operator-expr.html#comparison-operators","expressions/operator-expr.html#lazy-boolean-operators","expressions/operator-expr.html#type-cast-expressions","expressions/operator-expr.html#semantics","expressions/operator-expr.html#assignment-expressions","expressions/operator-expr.html#basic-assignments","expressions/operator-expr.html#destructuring-assignments","expressions/operator-expr.html#compound-assignment-expressions","expressions/grouped-expr.html#grouped-expressions","expressions/array-expr.html#array-and-array-index-expressions","expressions/array-expr.html#array-expressions","expressions/array-expr.html#array-and-slice-indexing-expressions","expressions/tuple-expr.html#tuple-and-tuple-indexing-expressions","expressions/tuple-expr.html#tuple-expressions","expressions/tuple-expr.html#tuple-indexing-expressions","expressions/struct-expr.html#struct-expressions","expressions/struct-expr.html#field-struct-expression","expressions/struct-expr.html#functional-update-syntax","expressions/struct-expr.html#struct-field-init-shorthand","expressions/call-expr.html#call-expressions","expressions/call-expr.html#disambiguating-function-calls","expressions/method-call-expr.html#method-call-expressions","expressions/field-expr.html#field-access-expressions","expressions/field-expr.html#automatic-dereferencing","expressions/field-expr.html#borrowing","expressions/closure-expr.html#closure-expressions","expressions/closure-expr.html#closure-trait-implementations","expressions/closure-expr.html#async-closures","expressions/closure-expr.html#example","expressions/closure-expr.html#attributes-on-closure-parameters","expressions/loop-expr.html#loops-and-other-breakable-expressions","expressions/loop-expr.html#infinite-loops","expressions/loop-expr.html#predicate-loops","expressions/loop-expr.html#while-let-patterns","expressions/loop-expr.html#while-condition-chains","expressions/loop-expr.html#iterator-loops","expressions/loop-expr.html#loop-labels","expressions/loop-expr.html#break-expressions","expressions/loop-expr.html#labelled-block-expressions","expressions/loop-expr.html#continue-expressions","expressions/loop-expr.html#break-and-loop-values","expressions/range-expr.html#range-expressions","expressions/if-expr.html#if-expressions","expressions/if-expr.html#if-let-patterns","expressions/if-expr.html#chains-of-conditions","expressions/match-expr.html#match-expressions","expressions/match-expr.html#match-guards","expressions/match-expr.html#attributes-on-match-arms","expressions/return-expr.html#return-expressions","expressions/await-expr.html#await-expressions","expressions/await-expr.html#task-context","expressions/await-expr.html#approximate-desugaring","expressions/underscore-expr.html#_-expressions","patterns.html#patterns","patterns.html#destructuring","patterns.html#refutability","patterns.html#literal-patterns","patterns.html#identifier-patterns","patterns.html#binding-modes","patterns.html#wildcard-pattern","patterns.html#rest-patterns","patterns.html#range-patterns","patterns.html#reference-patterns","patterns.html#struct-patterns","patterns.html#tuple-struct-patterns","patterns.html#tuple-patterns","patterns.html#grouped-patterns","patterns.html#slice-patterns","patterns.html#path-patterns","patterns.html#constant-patterns","patterns.html#or-patterns","patterns.html#static-semantics","patterns.html#dynamic-semantics","patterns.html#precedence-with-other-undelimited-patterns","type-system.html#type-system","types.html#types","types.html#type-expressions","types.html#parenthesized-types","types.html#recursive-types","types/boolean.html#boolean-type","types/boolean.html#operations-on-boolean-values","types/boolean.html#logical-not","types/boolean.html#logical-or","types/boolean.html#logical-and","types/boolean.html#logical-xor","types/boolean.html#comparisons","types/boolean.html#bit-validity","types/numeric.html#numeric-types","types/numeric.html#integer-types","types/numeric.html#floating-point-types","types/numeric.html#machine-dependent-integer-types","types/numeric.html#bit-validity","types/textual.html#textual-types","types/textual.html#layout-and-bit-validity","types/never.html#never-type","types/tuple.html#tuple-types","types/array.html#array-types","types/slice.html#slice-types","types/struct.html#struct-types","types/enum.html#enumerated-types","types/union.html#union-types","types/function-item.html#function-item-types","types/closure.html#closure-types","types/closure.html#capture-modes","types/closure.html#copy-values","types/closure.html#async-input-capture","types/closure.html#capture-precision","types/closure.html#shared-prefix","types/closure.html#rightmost-shared-reference-truncation","types/closure.html#wildcard-pattern-bindings","types/closure.html#capturing-references-in-move-contexts","types/closure.html#raw-pointer-dereference","types/closure.html#union-fields","types/closure.html#reference-into-unaligned-structs","types/closure.html#box-vs-other-deref-implementations","types/closure.html#unique-immutable-borrows-in-captures","types/closure.html#call-traits-and-coercions","types/closure.html#async-closure-traits","types/closure.html#other-traits","types/closure.html#drop-order","types/closure.html#edition-2018-and-before","types/closure.html#closure-types-difference","types/closure.html#capture-precision-difference","types/closure.html#drop-order-difference","types/pointer.html#pointer-types","types/pointer.html#references--and-mut","types/pointer.html#shared-references-","types/pointer.html#mutable-references-mut","types/pointer.html#raw-pointers-const-and-mut","types/pointer.html#smart-pointers","types/pointer.html#bit-validity","types/function-pointer.html#function-pointer-types","types/function-pointer.html#attributes-on-function-pointer-parameters","types/trait-object.html#trait-objects","types/trait-object.html#trait-object-lifetime-bounds","types/impl-trait.html#impl-trait","types/impl-trait.html#anonymous-type-parameters","types/impl-trait.html#abstract-return-types","types/impl-trait.html#return-position-impl-trait-in-traits-and-trait-implementations","types/impl-trait.html#capturing","types/impl-trait.html#automatic-capturing","types/impl-trait.html#precise-capturing","types/impl-trait.html#differences-between-generics-and-impl-trait-in-return-position","types/impl-trait.html#limitations","types/parameters.html#type-parameters","types/inferred.html#inferred-type","dynamically-sized-types.html#dynamically-sized-types","type-layout.html#type-layout","type-layout.html#size-and-alignment","type-layout.html#primitive-data-layout","type-layout.html#pointers-and-references-layout","type-layout.html#array-layout","type-layout.html#slice-layout","type-layout.html#str-layout","type-layout.html#tuple-layout","type-layout.html#trait-object-layout","type-layout.html#closure-layout","type-layout.html#representations","type-layout.html#the-rust-representation","type-layout.html#the-c-representation","type-layout.html#primitive-representations","type-layout.html#the-alignment-modifiers","type-layout.html#the-transparent-representation","interior-mutability.html#interior-mutability","subtyping.html#subtyping-and-variance","subtyping.html#variance","trait-bounds.html#trait-and-lifetime-bounds","trait-bounds.html#sized","trait-bounds.html#lifetime-bounds","trait-bounds.html#higher-ranked-trait-bounds","trait-bounds.html#implied-bounds","trait-bounds.html#use-bounds","type-coercions.html#type-coercions","type-coercions.html#coercion-sites","type-coercions.html#coercion-types","type-coercions.html#unsized-coercions","type-coercions.html#least-upper-bound-coercions","type-coercions.html#examples","type-coercions.html#caveat","destructors.html#destructors","destructors.html#drop-scopes","destructors.html#scopes-of-function-parameters","destructors.html#scopes-of-local-variables","destructors.html#temporary-scopes","destructors.html#operands","destructors.html#constant-promotion","destructors.html#temporary-lifetime-extension","destructors.html#not-running-destructors","destructors.html#manually-suppressing-destructors","destructors.html#process-termination-without-unwinding","lifetime-elision.html#lifetime-elision","lifetime-elision.html#lifetime-elision-in-functions","lifetime-elision.html#default-trait-object-lifetimes","lifetime-elision.html#const-and-static-elision","special-types-and-traits.html#special-types-and-traits","special-types-and-traits.html#box","special-types-and-traits.html#rc","special-types-and-traits.html#arc","special-types-and-traits.html#pin","special-types-and-traits.html#unsafecell","special-types-and-traits.html#phantomdata","special-types-and-traits.html#operator-traits","special-types-and-traits.html#deref-and-derefmut","special-types-and-traits.html#drop","special-types-and-traits.html#copy","special-types-and-traits.html#clone","special-types-and-traits.html#send","special-types-and-traits.html#sync","special-types-and-traits.html#termination","special-types-and-traits.html#auto-traits","special-types-and-traits.html#sized","names.html#names","names.html#explicitly-declared-entities","names.html#implicitly-declared-entities","names/namespaces.html#namespaces","names/namespaces.html#named-entities-without-a-namespace","names/namespaces.html#fields","names/namespaces.html#use-declarations","names/namespaces.html#sub-namespaces","names/scopes.html#scopes","names/scopes.html#item-scopes","names/scopes.html#associated-item-scopes","names/scopes.html#pattern-binding-scopes","names/scopes.html#pattern-binding-shadowing","names/scopes.html#generic-parameter-scopes","names/scopes.html#generic-parameter-shadowing","names/scopes.html#lifetime-scopes","names/scopes.html#loop-label-scopes","names/scopes.html#prelude-scopes","names/scopes.html#macro_rules-scopes","names/scopes.html#derive-macro-helper-attributes","names/scopes.html#self-scope","names/preludes.html#preludes","names/preludes.html#standard-library-prelude","names/preludes.html#extern-prelude","names/preludes.html#the-no_std-attribute","names/preludes.html#language-prelude","names/preludes.html#macro_use-prelude","names/preludes.html#tool-prelude","names/preludes.html#the-no_implicit_prelude-attribute","paths.html#paths","paths.html#types-of-paths","paths.html#simple-paths","paths.html#paths-in-expressions","paths.html#qualified-paths","paths.html#paths-in-types","paths.html#path-qualifiers","paths.html#","paths.html#self","paths.html#self-1","paths.html#super","paths.html#crate","paths.html#crate-1","paths.html#canonical-paths","names/name-resolution.html#name-resolution","visibility-and-privacy.html#visibility-and-privacy","visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself","visibility-and-privacy.html#re-exporting-and-visibility","memory-model.html#memory-model","memory-model.html#bytes","memory-allocation-and-lifetime.html#memory-allocation-and-lifetime","variables.html#variables","panic.html#panic","panic.html#the-panic_handler-attribute","panic.html#standard-behavior","panic.html#panic-strategy","panic.html#unwinding","panic.html#unwinding-across-ffi-boundaries","linkage.html#linkage","linkage.html#static-and-dynamic-c-runtimes","linkage.html#mixed-rust-and-foreign-codebases","linkage.html#prohibited-linkage-and-unwinding","inline-assembly.html#inline-assembly","inline-assembly.html#example","inline-assembly.html#syntax","inline-assembly.html#scope","inline-assembly.html#template-string-arguments","inline-assembly.html#operand-type","inline-assembly.html#register-operands","inline-assembly.html#register-names","inline-assembly.html#template-modifiers","inline-assembly.html#abi-clobbers","inline-assembly.html#options","inline-assembly.html#rules-for-inline-assembly","inline-assembly.html#rules-for-naked-inline-assembly","inline-assembly.html#correctness-and-validity","inline-assembly.html#directives-support","unsafety.html#unsafety","unsafe-keyword.html#the-unsafe-keyword","unsafe-keyword.html#unsafe-functions-unsafe-fn","unsafe-keyword.html#unsafe-blocks-unsafe-","unsafe-keyword.html#unsafe-traits-unsafe-trait","unsafe-keyword.html#unsafe-trait-implementations-unsafe-impl","unsafe-keyword.html#unsafe-external-blocks-unsafe-extern","unsafe-keyword.html#unsafe-attributes-unsafeattr","behavior-considered-undefined.html#behavior-considered-undefined","behavior-considered-undefined.html#pointed-to-bytes","behavior-considered-undefined.html#places-based-on-misaligned-pointers","behavior-considered-undefined.html#dangling-pointers","behavior-considered-undefined.html#invalid-values","behavior-not-considered-unsafe.html#behavior-not-considered-unsafe","behavior-not-considered-unsafe.html#integer-overflow","behavior-not-considered-unsafe.html#logic-errors","const_eval.html#constant-evaluation","const_eval.html#constant-expressions","const_eval.html#const-context","const_eval.html#const-functions","abi.html#application-binary-interface-abi","abi.html#the-used-attribute","abi.html#the-no_mangle-attribute","abi.html#the-link_section-attribute","abi.html#the-export_name-attribute","runtime.html#the-rust-runtime","runtime.html#the-global_allocator-attribute","runtime.html#the-windows_subsystem-attribute","appendices.html#appendices","macro-ambiguity.html#appendix-macro-follow-set-ambiguity-formal-specification","macro-ambiguity.html#definitions--conventions","macro-ambiguity.html#the-matcher-invariants","macro-ambiguity.html#first-and-follow-informally","macro-ambiguity.html#first-last","macro-ambiguity.html#examples-of-first-and-last","macro-ambiguity.html#followm","macro-ambiguity.html#examples-of-valid-and-invalid-matchers","influences.html#influences","glossary.html#glossary","glossary.html#abstract-syntax-tree","glossary.html#alignment","glossary.html#application-binary-interface-abi","glossary.html#arity","glossary.html#array","glossary.html#associated-item","glossary.html#blanket-implementation","glossary.html#bound","glossary.html#combinator","glossary.html#crate","glossary.html#dispatch","glossary.html#dynamically-sized-type","glossary.html#entity","glossary.html#expression","glossary.html#free-item","glossary.html#fundamental-traits","glossary.html#fundamental-type-constructors","glossary.html#inhabited","glossary.html#inherent-implementation","glossary.html#inherent-method","glossary.html#initialized","glossary.html#local-trait","glossary.html#local-type","glossary.html#module","glossary.html#name","glossary.html#name-resolution","glossary.html#namespace","glossary.html#nominal-types","glossary.html#dyn-compatible-traits","glossary.html#path","glossary.html#prelude","glossary.html#scope","glossary.html#scrutinee","glossary.html#size","glossary.html#slice","glossary.html#statement","glossary.html#string-literal","glossary.html#string-slice","glossary.html#trait","glossary.html#turbofish","glossary.html#uncovered-type","glossary.html#undefined-behavior","glossary.html#uninhabited"],"index":{"documentStore":{"docInfo":{"0":{"body":25,"breadcrumbs":2,"title":1},"1":{"body":54,"breadcrumbs":3,"title":2},"10":{"body":0,"breadcrumbs":4,"title":2},"100":{"body":24,"breadcrumbs":4,"title":1},"101":{"body":81,"breadcrumbs":5,"title":2},"102":{"body":109,"breadcrumbs":5,"title":2},"103":{"body":165,"breadcrumbs":5,"title":2},"104":{"body":110,"breadcrumbs":5,"title":2},"105":{"body":68,"breadcrumbs":4,"title":1},"106":{"body":110,"breadcrumbs":4,"title":1},"107":{"body":238,"breadcrumbs":3,"title":1},"108":{"body":55,"breadcrumbs":4,"title":2},"109":{"body":67,"breadcrumbs":4,"title":2},"11":{"body":34,"breadcrumbs":6,"title":2},"110":{"body":119,"breadcrumbs":4,"title":2},"111":{"body":141,"breadcrumbs":5,"title":3},"112":{"body":229,"breadcrumbs":3,"title":1},"113":{"body":7,"breadcrumbs":4,"title":2},"114":{"body":136,"breadcrumbs":4,"title":2},"115":{"body":133,"breadcrumbs":5,"title":3},"116":{"body":59,"breadcrumbs":4,"title":2},"117":{"body":71,"breadcrumbs":5,"title":3},"118":{"body":164,"breadcrumbs":5,"title":2},"119":{"body":194,"breadcrumbs":3,"title":1},"12":{"body":51,"breadcrumbs":6,"title":2},"120":{"body":272,"breadcrumbs":3,"title":1},"121":{"body":33,"breadcrumbs":3,"title":1},"122":{"body":129,"breadcrumbs":5,"title":3},"123":{"body":139,"breadcrumbs":4,"title":2},"124":{"body":35,"breadcrumbs":5,"title":3},"125":{"body":53,"breadcrumbs":4,"title":2},"126":{"body":135,"breadcrumbs":3,"title":1},"127":{"body":59,"breadcrumbs":4,"title":2},"128":{"body":136,"breadcrumbs":6,"title":4},"129":{"body":125,"breadcrumbs":5,"title":3},"13":{"body":29,"breadcrumbs":8,"title":4},"130":{"body":128,"breadcrumbs":5,"title":3},"131":{"body":240,"breadcrumbs":5,"title":2},"132":{"body":40,"breadcrumbs":5,"title":2},"133":{"body":56,"breadcrumbs":5,"title":2},"134":{"body":29,"breadcrumbs":4,"title":1},"135":{"body":173,"breadcrumbs":5,"title":2},"136":{"body":86,"breadcrumbs":5,"title":2},"137":{"body":149,"breadcrumbs":5,"title":2},"138":{"body":29,"breadcrumbs":6,"title":3},"139":{"body":177,"breadcrumbs":3,"title":1},"14":{"body":61,"breadcrumbs":6,"title":2},"140":{"body":8,"breadcrumbs":4,"title":2},"141":{"body":33,"breadcrumbs":4,"title":2},"142":{"body":366,"breadcrumbs":4,"title":2},"143":{"body":187,"breadcrumbs":3,"title":1},"144":{"body":27,"breadcrumbs":4,"title":2},"145":{"body":152,"breadcrumbs":4,"title":2},"146":{"body":67,"breadcrumbs":4,"title":2},"147":{"body":72,"breadcrumbs":3,"title":1},"148":{"body":157,"breadcrumbs":4,"title":2},"149":{"body":161,"breadcrumbs":4,"title":2},"15":{"body":78,"breadcrumbs":6,"title":2},"150":{"body":166,"breadcrumbs":5,"title":3},"151":{"body":241,"breadcrumbs":4,"title":2},"152":{"body":29,"breadcrumbs":4,"title":2},"153":{"body":124,"breadcrumbs":5,"title":2},"154":{"body":97,"breadcrumbs":4,"title":1},"155":{"body":89,"breadcrumbs":4,"title":1},"156":{"body":398,"breadcrumbs":4,"title":1},"157":{"body":84,"breadcrumbs":5,"title":2},"158":{"body":8,"breadcrumbs":6,"title":3},"159":{"body":349,"breadcrumbs":5,"title":2},"16":{"body":8,"breadcrumbs":5,"title":1},"160":{"body":286,"breadcrumbs":6,"title":3},"161":{"body":72,"breadcrumbs":5,"title":2},"162":{"body":99,"breadcrumbs":5,"title":2},"163":{"body":11,"breadcrumbs":6,"title":3},"164":{"body":180,"breadcrumbs":5,"title":2},"165":{"body":622,"breadcrumbs":5,"title":2},"166":{"body":87,"breadcrumbs":4,"title":1},"167":{"body":39,"breadcrumbs":4,"title":1},"168":{"body":93,"breadcrumbs":5,"title":2},"169":{"body":131,"breadcrumbs":6,"title":3},"17":{"body":10,"breadcrumbs":4,"title":1},"170":{"body":307,"breadcrumbs":4,"title":1},"171":{"body":309,"breadcrumbs":5,"title":2},"172":{"body":68,"breadcrumbs":7,"title":4},"173":{"body":25,"breadcrumbs":7,"title":4},"174":{"body":179,"breadcrumbs":8,"title":5},"175":{"body":106,"breadcrumbs":5,"title":2},"176":{"body":49,"breadcrumbs":6,"title":3},"177":{"body":286,"breadcrumbs":2,"title":1},"178":{"body":200,"breadcrumbs":5,"title":4},"179":{"body":25,"breadcrumbs":4,"title":3},"18":{"body":71,"breadcrumbs":5,"title":2},"180":{"body":79,"breadcrumbs":3,"title":2},"181":{"body":326,"breadcrumbs":4,"title":3},"182":{"body":30,"breadcrumbs":4,"title":2},"183":{"body":169,"breadcrumbs":4,"title":2},"184":{"body":97,"breadcrumbs":4,"title":2},"185":{"body":133,"breadcrumbs":4,"title":2},"186":{"body":158,"breadcrumbs":3,"title":1},"187":{"body":83,"breadcrumbs":4,"title":2},"188":{"body":11,"breadcrumbs":4,"title":2},"189":{"body":263,"breadcrumbs":5,"title":3},"19":{"body":61,"breadcrumbs":5,"title":2},"190":{"body":84,"breadcrumbs":4,"title":2},"191":{"body":247,"breadcrumbs":4,"title":2},"192":{"body":100,"breadcrumbs":4,"title":2},"193":{"body":74,"breadcrumbs":5,"title":3},"194":{"body":126,"breadcrumbs":4,"title":2},"195":{"body":222,"breadcrumbs":4,"title":2},"196":{"body":64,"breadcrumbs":6,"title":4},"197":{"body":260,"breadcrumbs":4,"title":2},"198":{"body":359,"breadcrumbs":4,"title":2},"199":{"body":8,"breadcrumbs":6,"title":3},"2":{"body":108,"breadcrumbs":2,"title":1},"20":{"body":112,"breadcrumbs":5,"title":2},"200":{"body":209,"breadcrumbs":5,"title":2},"201":{"body":110,"breadcrumbs":5,"title":2},"202":{"body":128,"breadcrumbs":5,"title":2},"203":{"body":43,"breadcrumbs":5,"title":2},"204":{"body":237,"breadcrumbs":5,"title":2},"205":{"body":1187,"breadcrumbs":5,"title":2},"206":{"body":64,"breadcrumbs":5,"title":2},"207":{"body":59,"breadcrumbs":5,"title":2},"208":{"body":178,"breadcrumbs":4,"title":1},"209":{"body":78,"breadcrumbs":4,"title":1},"21":{"body":200,"breadcrumbs":4,"title":1},"210":{"body":121,"breadcrumbs":5,"title":2},"211":{"body":37,"breadcrumbs":5,"title":2},"212":{"body":8,"breadcrumbs":3,"title":1},"213":{"body":61,"breadcrumbs":4,"title":2},"214":{"body":102,"breadcrumbs":4,"title":2},"215":{"body":10,"breadcrumbs":6,"title":3},"216":{"body":539,"breadcrumbs":5,"title":2},"217":{"body":14,"breadcrumbs":4,"title":2},"218":{"body":54,"breadcrumbs":4,"title":2},"219":{"body":140,"breadcrumbs":5,"title":3},"22":{"body":26,"breadcrumbs":4,"title":1},"220":{"body":189,"breadcrumbs":5,"title":3},"221":{"body":128,"breadcrumbs":4,"title":2},"222":{"body":50,"breadcrumbs":4,"title":2},"223":{"body":36,"breadcrumbs":4,"title":1},"224":{"body":25,"breadcrumbs":5,"title":2},"225":{"body":78,"breadcrumbs":5,"title":2},"226":{"body":130,"breadcrumbs":4,"title":1},"227":{"body":109,"breadcrumbs":5,"title":2},"228":{"body":11,"breadcrumbs":5,"title":2},"229":{"body":155,"breadcrumbs":4,"title":1},"23":{"body":38,"breadcrumbs":5,"title":2},"230":{"body":62,"breadcrumbs":5,"title":2},"231":{"body":140,"breadcrumbs":6,"title":3},"232":{"body":179,"breadcrumbs":7,"title":4},"233":{"body":84,"breadcrumbs":6,"title":3},"234":{"body":94,"breadcrumbs":4,"title":1},"235":{"body":29,"breadcrumbs":4,"title":1},"236":{"body":215,"breadcrumbs":5,"title":2},"237":{"body":82,"breadcrumbs":5,"title":2},"238":{"body":17,"breadcrumbs":5,"title":2},"239":{"body":44,"breadcrumbs":5,"title":2},"24":{"body":72,"breadcrumbs":4,"title":1},"240":{"body":118,"breadcrumbs":7,"title":2},"241":{"body":48,"breadcrumbs":6,"title":1},"242":{"body":46,"breadcrumbs":7,"title":2},"243":{"body":38,"breadcrumbs":8,"title":3},"244":{"body":29,"breadcrumbs":8,"title":3},"245":{"body":41,"breadcrumbs":7,"title":2},"246":{"body":85,"breadcrumbs":8,"title":3},"247":{"body":110,"breadcrumbs":8,"title":3},"248":{"body":139,"breadcrumbs":8,"title":3},"249":{"body":119,"breadcrumbs":8,"title":3},"25":{"body":21,"breadcrumbs":6,"title":3},"250":{"body":175,"breadcrumbs":9,"title":4},"251":{"body":212,"breadcrumbs":9,"title":4},"252":{"body":235,"breadcrumbs":8,"title":3},"253":{"body":162,"breadcrumbs":9,"title":4},"254":{"body":22,"breadcrumbs":8,"title":3},"255":{"body":74,"breadcrumbs":7,"title":2},"256":{"body":234,"breadcrumbs":7,"title":2},"257":{"body":101,"breadcrumbs":7,"title":2},"258":{"body":29,"breadcrumbs":7,"title":2},"259":{"body":27,"breadcrumbs":7,"title":2},"26":{"body":125,"breadcrumbs":5,"title":2},"260":{"body":63,"breadcrumbs":8,"title":3},"261":{"body":151,"breadcrumbs":7,"title":2},"262":{"body":46,"breadcrumbs":7,"title":2},"263":{"body":9,"breadcrumbs":8,"title":3},"264":{"body":66,"breadcrumbs":8,"title":3},"265":{"body":45,"breadcrumbs":7,"title":2},"266":{"body":158,"breadcrumbs":6,"title":1},"267":{"body":149,"breadcrumbs":7,"title":2},"268":{"body":156,"breadcrumbs":8,"title":3},"269":{"body":75,"breadcrumbs":7,"title":2},"27":{"body":111,"breadcrumbs":4,"title":1},"270":{"body":224,"breadcrumbs":8,"title":3},"271":{"body":72,"breadcrumbs":7,"title":2},"272":{"body":217,"breadcrumbs":9,"title":4},"273":{"body":163,"breadcrumbs":7,"title":2},"274":{"body":67,"breadcrumbs":8,"title":3},"275":{"body":300,"breadcrumbs":8,"title":3},"276":{"body":609,"breadcrumbs":6,"title":1},"277":{"body":66,"breadcrumbs":7,"title":2},"278":{"body":76,"breadcrumbs":7,"title":2},"279":{"body":339,"breadcrumbs":7,"title":2},"28":{"body":117,"breadcrumbs":4,"title":1},"280":{"body":436,"breadcrumbs":8,"title":3},"281":{"body":115,"breadcrumbs":7,"title":2},"282":{"body":1,"breadcrumbs":10,"title":4},"283":{"body":261,"breadcrumbs":8,"title":2},"284":{"body":136,"breadcrumbs":10,"title":4},"285":{"body":1,"breadcrumbs":10,"title":4},"286":{"body":130,"breadcrumbs":8,"title":2},"287":{"body":153,"breadcrumbs":9,"title":3},"288":{"body":241,"breadcrumbs":7,"title":2},"289":{"body":32,"breadcrumbs":8,"title":3},"29":{"body":75,"breadcrumbs":4,"title":1},"290":{"body":161,"breadcrumbs":8,"title":3},"291":{"body":47,"breadcrumbs":9,"title":4},"292":{"body":99,"breadcrumbs":7,"title":2},"293":{"body":186,"breadcrumbs":8,"title":3},"294":{"body":404,"breadcrumbs":9,"title":3},"295":{"body":97,"breadcrumbs":9,"title":3},"296":{"body":24,"breadcrumbs":8,"title":2},"297":{"body":68,"breadcrumbs":7,"title":1},"298":{"body":204,"breadcrumbs":7,"title":2},"299":{"body":33,"breadcrumbs":8,"title":3},"3":{"body":101,"breadcrumbs":3,"title":2},"30":{"body":5,"breadcrumbs":4,"title":1},"300":{"body":50,"breadcrumbs":7,"title":2},"301":{"body":43,"breadcrumbs":6,"title":1},"302":{"body":12,"breadcrumbs":8,"title":3},"303":{"body":83,"breadcrumbs":8,"title":3},"304":{"body":43,"breadcrumbs":7,"title":2},"305":{"body":89,"breadcrumbs":7,"title":2},"306":{"body":86,"breadcrumbs":6,"title":1},"307":{"body":39,"breadcrumbs":7,"title":2},"308":{"body":161,"breadcrumbs":7,"title":2},"309":{"body":74,"breadcrumbs":7,"title":2},"31":{"body":288,"breadcrumbs":4,"title":1},"310":{"body":77,"breadcrumbs":7,"title":2},"311":{"body":72,"breadcrumbs":8,"title":3},"312":{"body":63,"breadcrumbs":7,"title":2},"313":{"body":70,"breadcrumbs":8,"title":3},"314":{"body":121,"breadcrumbs":7,"title":2},"315":{"body":166,"breadcrumbs":5,"title":1},"316":{"body":73,"breadcrumbs":5,"title":1},"317":{"body":127,"breadcrumbs":6,"title":2},"318":{"body":286,"breadcrumbs":7,"title":2},"319":{"body":159,"breadcrumbs":7,"title":2},"32":{"body":413,"breadcrumbs":6,"title":3},"320":{"body":29,"breadcrumbs":8,"title":3},"321":{"body":51,"breadcrumbs":7,"title":2},"322":{"body":130,"breadcrumbs":7,"title":2},"323":{"body":21,"breadcrumbs":7,"title":2},"324":{"body":47,"breadcrumbs":7,"title":2},"325":{"body":83,"breadcrumbs":7,"title":2},"326":{"body":158,"breadcrumbs":2,"title":1},"327":{"body":105,"breadcrumbs":2,"title":1},"328":{"body":45,"breadcrumbs":2,"title":1},"329":{"body":77,"breadcrumbs":3,"title":2},"33":{"body":452,"breadcrumbs":7,"title":4},"330":{"body":321,"breadcrumbs":3,"title":2},"331":{"body":316,"breadcrumbs":3,"title":2},"332":{"body":107,"breadcrumbs":3,"title":2},"333":{"body":143,"breadcrumbs":3,"title":2},"334":{"body":588,"breadcrumbs":3,"title":2},"335":{"body":74,"breadcrumbs":3,"title":2},"336":{"body":301,"breadcrumbs":3,"title":2},"337":{"body":199,"breadcrumbs":4,"title":3},"338":{"body":64,"breadcrumbs":3,"title":2},"339":{"body":37,"breadcrumbs":3,"title":2},"34":{"body":485,"breadcrumbs":9,"title":6},"340":{"body":121,"breadcrumbs":3,"title":2},"341":{"body":62,"breadcrumbs":3,"title":2},"342":{"body":158,"breadcrumbs":3,"title":2},"343":{"body":31,"breadcrumbs":2,"title":1},"344":{"body":153,"breadcrumbs":3,"title":2},"345":{"body":36,"breadcrumbs":3,"title":2},"346":{"body":46,"breadcrumbs":4,"title":3},"347":{"body":0,"breadcrumbs":4,"title":2},"348":{"body":82,"breadcrumbs":4,"title":1},"349":{"body":121,"breadcrumbs":5,"title":2},"35":{"body":777,"breadcrumbs":5,"title":2},"350":{"body":48,"breadcrumbs":5,"title":2},"351":{"body":67,"breadcrumbs":5,"title":2},"352":{"body":122,"breadcrumbs":7,"title":2},"353":{"body":13,"breadcrumbs":8,"title":3},"354":{"body":7,"breadcrumbs":6,"title":1},"355":{"body":15,"breadcrumbs":6,"title":1},"356":{"body":15,"breadcrumbs":6,"title":1},"357":{"body":15,"breadcrumbs":7,"title":2},"358":{"body":52,"breadcrumbs":6,"title":1},"359":{"body":17,"breadcrumbs":7,"title":2},"36":{"body":130,"breadcrumbs":6,"title":3},"360":{"body":2,"breadcrumbs":7,"title":2},"361":{"body":59,"breadcrumbs":7,"title":2},"362":{"body":12,"breadcrumbs":8,"title":3},"363":{"body":107,"breadcrumbs":9,"title":4},"364":{"body":15,"breadcrumbs":7,"title":2},"365":{"body":109,"breadcrumbs":7,"title":2},"366":{"body":28,"breadcrumbs":8,"title":3},"367":{"body":47,"breadcrumbs":7,"title":2},"368":{"body":174,"breadcrumbs":7,"title":2},"369":{"body":75,"breadcrumbs":7,"title":2},"37":{"body":271,"breadcrumbs":4,"title":1},"370":{"body":83,"breadcrumbs":7,"title":2},"371":{"body":100,"breadcrumbs":7,"title":2},"372":{"body":75,"breadcrumbs":7,"title":2},"373":{"body":69,"breadcrumbs":7,"title":2},"374":{"body":167,"breadcrumbs":9,"title":3},"375":{"body":120,"breadcrumbs":7,"title":2},"376":{"body":73,"breadcrumbs":7,"title":2},"377":{"body":18,"breadcrumbs":7,"title":2},"378":{"body":11,"breadcrumbs":8,"title":3},"379":{"body":81,"breadcrumbs":7,"title":2},"38":{"body":30,"breadcrumbs":4,"title":1},"380":{"body":73,"breadcrumbs":7,"title":2},"381":{"body":80,"breadcrumbs":9,"title":4},"382":{"body":167,"breadcrumbs":8,"title":3},"383":{"body":42,"breadcrumbs":9,"title":4},"384":{"body":35,"breadcrumbs":8,"title":3},"385":{"body":48,"breadcrumbs":7,"title":2},"386":{"body":108,"breadcrumbs":8,"title":3},"387":{"body":150,"breadcrumbs":9,"title":4},"388":{"body":104,"breadcrumbs":9,"title":4},"389":{"body":106,"breadcrumbs":8,"title":3},"39":{"body":39,"breadcrumbs":5,"title":2},"390":{"body":167,"breadcrumbs":8,"title":3},"391":{"body":86,"breadcrumbs":6,"title":1},"392":{"body":40,"breadcrumbs":7,"title":2},"393":{"body":0,"breadcrumbs":8,"title":3},"394":{"body":56,"breadcrumbs":8,"title":3},"395":{"body":107,"breadcrumbs":8,"title":3},"396":{"body":32,"breadcrumbs":8,"title":3},"397":{"body":15,"breadcrumbs":7,"title":2},"398":{"body":14,"breadcrumbs":7,"title":2},"399":{"body":66,"breadcrumbs":7,"title":2},"4":{"body":257,"breadcrumbs":2,"title":1},"40":{"body":228,"breadcrumbs":5,"title":2},"400":{"body":26,"breadcrumbs":8,"title":3},"401":{"body":103,"breadcrumbs":9,"title":4},"402":{"body":12,"breadcrumbs":7,"title":2},"403":{"body":63,"breadcrumbs":7,"title":2},"404":{"body":148,"breadcrumbs":9,"title":3},"405":{"body":11,"breadcrumbs":10,"title":4},"406":{"body":330,"breadcrumbs":8,"title":2},"407":{"body":22,"breadcrumbs":10,"title":4},"408":{"body":73,"breadcrumbs":8,"title":2},"409":{"body":139,"breadcrumbs":9,"title":3},"41":{"body":70,"breadcrumbs":5,"title":2},"410":{"body":147,"breadcrumbs":9,"title":3},"411":{"body":40,"breadcrumbs":13,"title":7},"412":{"body":24,"breadcrumbs":7,"title":1},"413":{"body":53,"breadcrumbs":8,"title":2},"414":{"body":140,"breadcrumbs":8,"title":2},"415":{"body":72,"breadcrumbs":13,"title":7},"416":{"body":17,"breadcrumbs":7,"title":1},"417":{"body":40,"breadcrumbs":7,"title":2},"418":{"body":36,"breadcrumbs":7,"title":2},"419":{"body":134,"breadcrumbs":8,"title":3},"42":{"body":46,"breadcrumbs":2,"title":1},"420":{"body":49,"breadcrumbs":6,"title":2},"421":{"body":123,"breadcrumbs":6,"title":2},"422":{"body":89,"breadcrumbs":7,"title":3},"423":{"body":43,"breadcrumbs":7,"title":3},"424":{"body":24,"breadcrumbs":6,"title":2},"425":{"body":16,"breadcrumbs":6,"title":2},"426":{"body":18,"breadcrumbs":6,"title":2},"427":{"body":21,"breadcrumbs":6,"title":2},"428":{"body":21,"breadcrumbs":7,"title":3},"429":{"body":4,"breadcrumbs":6,"title":2},"43":{"body":167,"breadcrumbs":3,"title":2},"430":{"body":138,"breadcrumbs":5,"title":1},"431":{"body":97,"breadcrumbs":6,"title":2},"432":{"body":543,"breadcrumbs":6,"title":2},"433":{"body":331,"breadcrumbs":6,"title":2},"434":{"body":251,"breadcrumbs":6,"title":2},"435":{"body":66,"breadcrumbs":6,"title":2},"436":{"body":124,"breadcrumbs":6,"title":2},"437":{"body":139,"breadcrumbs":6,"title":2},"438":{"body":249,"breadcrumbs":5,"title":1},"439":{"body":336,"breadcrumbs":8,"title":3},"44":{"body":174,"breadcrumbs":5,"title":2},"440":{"body":15,"breadcrumbs":6,"title":1},"441":{"body":70,"breadcrumbs":7,"title":2},"442":{"body":101,"breadcrumbs":9,"title":4},"443":{"body":165,"breadcrumbs":7,"title":2},"444":{"body":20,"breadcrumbs":7,"title":2},"445":{"body":37,"breadcrumbs":6,"title":2},"446":{"body":256,"breadcrumbs":6,"title":2},"447":{"body":135,"breadcrumbs":6,"title":2},"448":{"body":167,"breadcrumbs":6,"title":2},"449":{"body":140,"breadcrumbs":7,"title":3},"45":{"body":103,"breadcrumbs":4,"title":1},"450":{"body":76,"breadcrumbs":5,"title":1},"451":{"body":17,"breadcrumbs":5,"title":1},"452":{"body":154,"breadcrumbs":4,"title":1},"453":{"body":170,"breadcrumbs":5,"title":2},"454":{"body":59,"breadcrumbs":6,"title":3},"455":{"body":173,"breadcrumbs":6,"title":3},"456":{"body":232,"breadcrumbs":5,"title":2},"457":{"body":67,"breadcrumbs":4,"title":1},"458":{"body":46,"breadcrumbs":5,"title":2},"459":{"body":697,"breadcrumbs":6,"title":3},"46":{"body":72,"breadcrumbs":6,"title":3},"460":{"body":2,"breadcrumbs":5,"title":2},"461":{"body":45,"breadcrumbs":6,"title":3},"462":{"body":45,"breadcrumbs":7,"title":4},"463":{"body":16,"breadcrumbs":6,"title":2},"464":{"body":286,"breadcrumbs":7,"title":3},"465":{"body":258,"breadcrumbs":8,"title":4},"466":{"body":169,"breadcrumbs":7,"title":3},"467":{"body":21,"breadcrumbs":6,"title":3},"468":{"body":48,"breadcrumbs":4,"title":1},"469":{"body":8,"breadcrumbs":4,"title":1},"47":{"body":167,"breadcrumbs":4,"title":1},"470":{"body":8,"breadcrumbs":4,"title":1},"471":{"body":9,"breadcrumbs":4,"title":1},"472":{"body":34,"breadcrumbs":4,"title":1},"473":{"body":16,"breadcrumbs":4,"title":1},"474":{"body":12,"breadcrumbs":5,"title":2},"475":{"body":13,"breadcrumbs":5,"title":2},"476":{"body":11,"breadcrumbs":4,"title":1},"477":{"body":70,"breadcrumbs":4,"title":1},"478":{"body":43,"breadcrumbs":4,"title":1},"479":{"body":12,"breadcrumbs":4,"title":1},"48":{"body":171,"breadcrumbs":4,"title":1},"480":{"body":24,"breadcrumbs":4,"title":1},"481":{"body":13,"breadcrumbs":4,"title":1},"482":{"body":201,"breadcrumbs":5,"title":2},"483":{"body":46,"breadcrumbs":4,"title":1},"484":{"body":111,"breadcrumbs":2,"title":1},"485":{"body":110,"breadcrumbs":4,"title":3},"486":{"body":103,"breadcrumbs":4,"title":3},"487":{"body":239,"breadcrumbs":3,"title":1},"488":{"body":8,"breadcrumbs":6,"title":4},"489":{"body":24,"breadcrumbs":3,"title":1},"49":{"body":106,"breadcrumbs":6,"title":3},"490":{"body":25,"breadcrumbs":4,"title":2},"491":{"body":64,"breadcrumbs":4,"title":2},"492":{"body":41,"breadcrumbs":3,"title":1},"493":{"body":86,"breadcrumbs":4,"title":2},"494":{"body":39,"breadcrumbs":5,"title":3},"495":{"body":69,"breadcrumbs":5,"title":3},"496":{"body":54,"breadcrumbs":5,"title":3},"497":{"body":115,"breadcrumbs":5,"title":3},"498":{"body":76,"breadcrumbs":5,"title":3},"499":{"body":170,"breadcrumbs":4,"title":2},"5":{"body":52,"breadcrumbs":2,"title":1},"50":{"body":137,"breadcrumbs":5,"title":2},"500":{"body":109,"breadcrumbs":5,"title":3},"501":{"body":53,"breadcrumbs":4,"title":2},"502":{"body":14,"breadcrumbs":4,"title":2},"503":{"body":26,"breadcrumbs":6,"title":4},"504":{"body":84,"breadcrumbs":4,"title":2},"505":{"body":48,"breadcrumbs":3,"title":1},"506":{"body":52,"breadcrumbs":5,"title":3},"507":{"body":117,"breadcrumbs":4,"title":2},"508":{"body":129,"breadcrumbs":4,"title":2},"509":{"body":56,"breadcrumbs":4,"title":2},"51":{"body":95,"breadcrumbs":5,"title":2},"510":{"body":14,"breadcrumbs":4,"title":2},"511":{"body":17,"breadcrumbs":4,"title":2},"512":{"body":50,"breadcrumbs":4,"title":2},"513":{"body":27,"breadcrumbs":3,"title":1},"514":{"body":1,"breadcrumbs":4,"title":2},"515":{"body":45,"breadcrumbs":4,"title":2},"516":{"body":233,"breadcrumbs":4,"title":2},"517":{"body":87,"breadcrumbs":4,"title":2},"518":{"body":91,"breadcrumbs":4,"title":2},"519":{"body":10,"breadcrumbs":4,"title":2},"52":{"body":47,"breadcrumbs":6,"title":3},"520":{"body":111,"breadcrumbs":2,"title":0},"521":{"body":45,"breadcrumbs":3,"title":1},"522":{"body":177,"breadcrumbs":3,"title":1},"523":{"body":65,"breadcrumbs":3,"title":1},"524":{"body":25,"breadcrumbs":3,"title":1},"525":{"body":44,"breadcrumbs":3,"title":1},"526":{"body":196,"breadcrumbs":4,"title":2},"527":{"body":4,"breadcrumbs":5,"title":2},"528":{"body":489,"breadcrumbs":5,"title":2},"529":{"body":228,"breadcrumbs":8,"title":5},"53":{"body":273,"breadcrumbs":4,"title":1},"530":{"body":76,"breadcrumbs":6,"title":3},"531":{"body":9,"breadcrumbs":4,"title":2},"532":{"body":63,"breadcrumbs":3,"title":1},"533":{"body":66,"breadcrumbs":8,"title":3},"534":{"body":134,"breadcrumbs":4,"title":1},"535":{"body":62,"breadcrumbs":2,"title":1},"536":{"body":81,"breadcrumbs":3,"title":2},"537":{"body":55,"breadcrumbs":3,"title":2},"538":{"body":78,"breadcrumbs":3,"title":2},"539":{"body":121,"breadcrumbs":2,"title":1},"54":{"body":198,"breadcrumbs":7,"title":4},"540":{"body":183,"breadcrumbs":4,"title":3},"541":{"body":741,"breadcrumbs":2,"title":1},"542":{"body":248,"breadcrumbs":5,"title":4},"543":{"body":108,"breadcrumbs":5,"title":4},"544":{"body":146,"breadcrumbs":4,"title":3},"545":{"body":46,"breadcrumbs":4,"title":2},"546":{"body":38,"breadcrumbs":3,"title":1},"547":{"body":140,"breadcrumbs":3,"title":1},"548":{"body":111,"breadcrumbs":3,"title":1},"549":{"body":418,"breadcrumbs":5,"title":3},"55":{"body":154,"breadcrumbs":5,"title":2},"550":{"body":687,"breadcrumbs":4,"title":2},"551":{"body":1189,"breadcrumbs":4,"title":2},"552":{"body":567,"breadcrumbs":4,"title":2},"553":{"body":407,"breadcrumbs":4,"title":2},"554":{"body":399,"breadcrumbs":4,"title":2},"555":{"body":717,"breadcrumbs":3,"title":1},"556":{"body":798,"breadcrumbs":5,"title":3},"557":{"body":389,"breadcrumbs":6,"title":4},"558":{"body":137,"breadcrumbs":4,"title":2},"559":{"body":269,"breadcrumbs":4,"title":2},"56":{"body":108,"breadcrumbs":5,"title":2},"560":{"body":93,"breadcrumbs":2,"title":1},"561":{"body":95,"breadcrumbs":5,"title":2},"562":{"body":50,"breadcrumbs":7,"title":4},"563":{"body":193,"breadcrumbs":6,"title":3},"564":{"body":31,"breadcrumbs":7,"title":4},"565":{"body":43,"breadcrumbs":8,"title":5},"566":{"body":35,"breadcrumbs":8,"title":5},"567":{"body":20,"breadcrumbs":6,"title":3},"568":{"body":502,"breadcrumbs":7,"title":3},"569":{"body":14,"breadcrumbs":6,"title":2},"57":{"body":55,"breadcrumbs":6,"title":3},"570":{"body":157,"breadcrumbs":8,"title":4},"571":{"body":58,"breadcrumbs":6,"title":2},"572":{"body":235,"breadcrumbs":6,"title":2},"573":{"body":27,"breadcrumbs":7,"title":3},"574":{"body":103,"breadcrumbs":6,"title":2},"575":{"body":69,"breadcrumbs":6,"title":2},"576":{"body":20,"breadcrumbs":4,"title":2},"577":{"body":676,"breadcrumbs":4,"title":2},"578":{"body":81,"breadcrumbs":4,"title":2},"579":{"body":112,"breadcrumbs":4,"title":2},"58":{"body":114,"breadcrumbs":6,"title":3},"580":{"body":28,"breadcrumbs":7,"title":4},"581":{"body":120,"breadcrumbs":5,"title":2},"582":{"body":64,"breadcrumbs":5,"title":2},"583":{"body":60,"breadcrumbs":5,"title":2},"584":{"body":54,"breadcrumbs":5,"title":2},"585":{"body":9,"breadcrumbs":4,"title":2},"586":{"body":82,"breadcrumbs":4,"title":2},"587":{"body":89,"breadcrumbs":4,"title":2},"588":{"body":0,"breadcrumbs":2,"title":1},"589":{"body":21,"breadcrumbs":14,"title":7},"59":{"body":181,"breadcrumbs":5,"title":2},"590":{"body":441,"breadcrumbs":9,"title":2},"591":{"body":171,"breadcrumbs":9,"title":2},"592":{"body":115,"breadcrumbs":10,"title":3},"593":{"body":356,"breadcrumbs":9,"title":2},"594":{"body":116,"breadcrumbs":10,"title":3},"595":{"body":125,"breadcrumbs":8,"title":1},"596":{"body":70,"breadcrumbs":11,"title":4},"597":{"body":86,"breadcrumbs":3,"title":1},"598":{"body":0,"breadcrumbs":3,"title":1},"599":{"body":10,"breadcrumbs":5,"title":3},"6":{"body":2,"breadcrumbs":2,"title":1},"60":{"body":63,"breadcrumbs":7,"title":4},"600":{"body":15,"breadcrumbs":3,"title":1},"601":{"body":46,"breadcrumbs":6,"title":4},"602":{"body":22,"breadcrumbs":3,"title":1},"603":{"body":23,"breadcrumbs":3,"title":1},"604":{"body":20,"breadcrumbs":4,"title":2},"605":{"body":30,"breadcrumbs":4,"title":2},"606":{"body":15,"breadcrumbs":3,"title":1},"607":{"body":18,"breadcrumbs":3,"title":1},"608":{"body":44,"breadcrumbs":3,"title":1},"609":{"body":26,"breadcrumbs":3,"title":1},"61":{"body":197,"breadcrumbs":5,"title":2},"610":{"body":10,"breadcrumbs":5,"title":3},"611":{"body":25,"breadcrumbs":3,"title":1},"612":{"body":21,"breadcrumbs":3,"title":1},"613":{"body":11,"breadcrumbs":4,"title":2},"614":{"body":13,"breadcrumbs":4,"title":2},"615":{"body":44,"breadcrumbs":5,"title":3},"616":{"body":13,"breadcrumbs":3,"title":1},"617":{"body":8,"breadcrumbs":4,"title":2},"618":{"body":6,"breadcrumbs":4,"title":2},"619":{"body":17,"breadcrumbs":3,"title":1},"62":{"body":261,"breadcrumbs":9,"title":6},"620":{"body":23,"breadcrumbs":4,"title":2},"621":{"body":21,"breadcrumbs":4,"title":2},"622":{"body":26,"breadcrumbs":3,"title":1},"623":{"body":22,"breadcrumbs":3,"title":1},"624":{"body":11,"breadcrumbs":4,"title":2},"625":{"body":32,"breadcrumbs":3,"title":1},"626":{"body":11,"breadcrumbs":4,"title":2},"627":{"body":18,"breadcrumbs":5,"title":3},"628":{"body":14,"breadcrumbs":3,"title":1},"629":{"body":14,"breadcrumbs":3,"title":1},"63":{"body":245,"breadcrumbs":6,"title":3},"630":{"body":8,"breadcrumbs":3,"title":1},"631":{"body":18,"breadcrumbs":3,"title":1},"632":{"body":39,"breadcrumbs":3,"title":1},"633":{"body":26,"breadcrumbs":3,"title":1},"634":{"body":10,"breadcrumbs":3,"title":1},"635":{"body":18,"breadcrumbs":4,"title":2},"636":{"body":30,"breadcrumbs":4,"title":2},"637":{"body":24,"breadcrumbs":3,"title":1},"638":{"body":46,"breadcrumbs":3,"title":1},"639":{"body":14,"breadcrumbs":4,"title":2},"64":{"body":70,"breadcrumbs":5,"title":2},"640":{"body":19,"breadcrumbs":4,"title":2},"641":{"body":24,"breadcrumbs":3,"title":1},"65":{"body":44,"breadcrumbs":6,"title":3},"66":{"body":18,"breadcrumbs":5,"title":2},"67":{"body":58,"breadcrumbs":5,"title":2},"68":{"body":205,"breadcrumbs":4,"title":2},"69":{"body":72,"breadcrumbs":5,"title":3},"7":{"body":115,"breadcrumbs":2,"title":1},"70":{"body":28,"breadcrumbs":3,"title":1},"71":{"body":44,"breadcrumbs":3,"title":1},"72":{"body":34,"breadcrumbs":3,"title":1},"73":{"body":33,"breadcrumbs":3,"title":1},"74":{"body":12,"breadcrumbs":4,"title":2},"75":{"body":57,"breadcrumbs":3,"title":1},"76":{"body":35,"breadcrumbs":3,"title":1},"77":{"body":13,"breadcrumbs":3,"title":1},"78":{"body":17,"breadcrumbs":3,"title":1},"79":{"body":16,"breadcrumbs":3,"title":1},"8":{"body":57,"breadcrumbs":4,"title":3},"80":{"body":36,"breadcrumbs":3,"title":1},"81":{"body":15,"breadcrumbs":3,"title":1},"82":{"body":20,"breadcrumbs":3,"title":1},"83":{"body":10,"breadcrumbs":3,"title":1},"84":{"body":18,"breadcrumbs":3,"title":1},"85":{"body":1,"breadcrumbs":5,"title":3},"86":{"body":177,"breadcrumbs":4,"title":2},"87":{"body":129,"breadcrumbs":4,"title":2},"88":{"body":26,"breadcrumbs":4,"title":2},"89":{"body":176,"breadcrumbs":2,"title":1},"9":{"body":17,"breadcrumbs":3,"title":2},"90":{"body":130,"breadcrumbs":3,"title":1},"91":{"body":107,"breadcrumbs":5,"title":3},"92":{"body":191,"breadcrumbs":4,"title":2},"93":{"body":34,"breadcrumbs":4,"title":2},"94":{"body":207,"breadcrumbs":6,"title":3},"95":{"body":40,"breadcrumbs":5,"title":2},"96":{"body":68,"breadcrumbs":5,"title":2},"97":{"body":191,"breadcrumbs":5,"title":2},"98":{"body":85,"breadcrumbs":5,"title":2},"99":{"body":169,"breadcrumbs":5,"title":2}},"docs":{"0":{"body":"This book is the primary reference for the Rust programming language. Note For known bugs and omissions in this book, see our GitHub issues . If you see a case where the compiler behavior and the text here do not agree, file an issue so we can think about which is correct.","breadcrumbs":"Introduction  Introduction","id":"0","title":"Introduction"},"1":{"body":"Rust has a new language release every six weeks. The first stable release of the language was Rust 1.0.0, followed by Rust 1.1.0 and so on. Tools (rustc, cargo, etc.) and documentation ( Standard library , this book, etc.) are released with the language release. The latest release of this book, matching the latest Rust version, can always be found at https://doc.rust-lang.org/reference/ . Prior versions can be found by adding the Rust version before the \\"reference\\" directory. For example, the Reference for Rust 1.49.0 is located at https://doc.rust-lang.org/1.49.0/reference/ .","breadcrumbs":"Introduction  Rust releases","id":"1","title":"Rust releases"},"10":{"body":"","breadcrumbs":"Lexical structure  Lexical structure","id":"10","title":"Lexical structure"},"100":{"body":"The as keyword can be used to change the name of an imported entity. For example: // Creates a non-public alias `bar` for the function `foo`.\\nuse inner::foo as bar; mod inner { pub fn foo() {}\\n} [items.use.multiple-syntax]","breadcrumbs":"Items  Use declarations  as renames","id":"100","title":"as renames"},"101":{"body":"[items.use.multiple-syntax.intro] Braces can be used in the last segment of the path to import multiple entities from the previous segment, or, if there are no previous segments, from the current scope. Braces can be nested, creating a tree of paths, where each grouping of segments is logically combined with its parent to create a full path. // Creates bindings to:\\n// - `std::collections::BTreeSet`\\n// - `std::collections::hash_map`\\n// - `std::collections::hash_map::HashMap`\\nuse std::collections::{BTreeSet, hash_map::{self, HashMap}}; [items.use.multiple-syntax.empty] An empty brace does not import anything, though the leading path is validated that it is accessible. [items.use.multiple-syntax.edition2018] 2018 Edition differences In the 2015 edition, paths are relative to the crate root, so an import such as use {foo, bar}; will import the names foo and bar from the crate root, whereas starting in 2018, those names are relative to the current scope. [items.use.self]","breadcrumbs":"Items  Use declarations  Brace syntax","id":"101","title":"Brace syntax"},"102":{"body":"[items.use.self.intro] The keyword self may be used within brace syntax to create a binding of the parent entity under its own name. mod stuff { pub fn foo() {} pub fn bar() {}\\n}\\nmod example { // Creates a binding for `stuff` and `foo`. use crate::stuff::{self, foo}; pub fn baz() { foo(); stuff::bar(); }\\n}\\n# fn main() {} [items.use.self.namespace] self only creates a binding from the type namespace of the parent entity. For example, in the following, only the foo mod is imported: mod bar { pub mod foo {} pub fn foo() {}\\n} // This only imports the module `foo`. The function `foo` lives in\\n// the value namespace and is not imported.\\nuse bar::foo::{self}; fn main() { foo(); //~ ERROR `foo` is a module\\n} Note self may also be used as the first segment of a path. The usage of self as the first segment and inside a use brace is logically the same; it means the current module of the parent segment, or the current module if there is no parent segment. See self in the paths chapter for more information on the meaning of a leading self. [items.use.glob]","breadcrumbs":"Items  Use declarations  self imports","id":"102","title":"self imports"},"103":{"body":"[items.use.glob.intro] The * character may be used as the last segment of a use path to import all importable entities from the entity of the preceding segment. For example: // Creates a non-public alias to `bar`.\\nuse foo::*; mod foo { fn i_am_private() {} enum Example { V1, V2, } pub fn bar() { // Creates local aliases to `V1` and `V2` // of the `Example` enum. use Example::*; let x = V1; }\\n} [items.use.glob.shadowing] Items and named imports are allowed to shadow names from glob imports in the same namespace . That is, if there is a name already defined by another item in the same namespace, the glob import will be shadowed. For example: // This creates a binding to the `clashing::Foo` tuple struct\\n// constructor, but does not import its type because that would\\n// conflict with the `Foo` struct defined here.\\n//\\n// Note that the order of definition here is unimportant.\\nuse clashing::*;\\nstruct Foo { field: f32,\\n} fn do_stuff() { // Uses the constructor from `clashing::Foo`. let f1 = Foo(123); // The struct expression uses the type from // the `Foo` struct defined above. let f2 = Foo { field: 1.0 }; // `Bar` is also in scope due to the glob import. let z = Bar {};\\n} mod clashing { pub struct Foo(pub i32); pub struct Bar {}\\n} [items.use.glob.last-segment-only] * cannot be used as the first or intermediate segments. [items.use.glob.self-import] * cannot be used to import a module\'s contents into itself (such as use self::*;). [items.use.glob.edition2018] 2018 Edition differences In the 2015 edition, paths are relative to the crate root, so an import such as use *; is valid, and it means to import everything from the crate root. This cannot be used in the crate root itself. [items.use.as-underscore]","breadcrumbs":"Items  Use declarations  Glob imports","id":"103","title":"Glob imports"},"104":{"body":"[items.use.as-underscore.intro] Items can be imported without binding to a name by using an underscore with the form use path as _. This is particularly useful to import a trait so that its methods may be used without importing the trait\'s symbol, for example if the trait\'s symbol may conflict with another symbol. Another example is to link an external crate without importing its name. [items.use.as-underscore.glob] Asterisk glob imports will import items imported with _ in their unnameable form. mod foo { pub trait Zoo { fn zoo(&self) {} } impl<T> Zoo for T {}\\n} use self::foo::Zoo as _;\\nstruct Zoo; // Underscore import avoids name conflict with this item. fn main() { let z = Zoo; z.zoo();\\n} [items.use.as-underscore.macro] The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to _ imports. For example, the following should not produce an error: macro_rules! m { ($item: item) => { $item $item }\\n} m!(use std as _;);\\n// This expands to:\\n// use std as _;\\n// use std as _; [items.use.restrictions]","breadcrumbs":"Items  Use declarations  Underscore imports","id":"104","title":"Underscore imports"},"105":{"body":"The following are restrictions for valid use declarations: [items.use.restrictions.crate] use crate; must use as to define the name to which to bind the crate root. [items.use.restrictions.self] use {self}; is an error; there must be a leading segment when using self. [items.use.restrictions.duplicate-name] As with any item definition, use imports cannot create duplicate bindings of the same name in the same namespace in a module or block. [items.use.restrictions.macro-crate] use paths with $crate are not allowed in a macro_rules expansion. [items.use.restrictions.variant] use paths cannot refer to enum variants through a type alias . For example: enum MyEnum { MyVariant\\n}\\ntype TypeAlias = MyEnum; use MyEnum::MyVariant; //~ OK\\nuse TypeAlias::MyVariant; //~ ERROR [items.use.ambiguities]","breadcrumbs":"Items  Use declarations  Restrictions","id":"105","title":"Restrictions"},"106":{"body":"Note This section is incomplete. [items.use.ambiguities.intro] Some situations are an error when there is an ambiguity as to which name a use declaration refers. This happens when there are two name candidates that do not resolve to the same entity. [items.use.ambiguities.glob] Glob imports are allowed to import conflicting names in the same namespace as long as the name is not used. For example: mod foo { pub struct Qux;\\n} mod bar { pub struct Qux;\\n} use foo::*;\\nuse bar::*; //~ OK, no name conflict. fn main() { // This would be an error, due to the ambiguity. //let x = Qux;\\n} Multiple glob imports are allowed to import the same name, and that name is allowed to be used, if the imports are of the same item (following re-exports). The visibility of the name is the maximum visibility of the imports. For example: mod foo { pub struct Qux;\\n} mod bar { pub use super::foo::Qux;\\n} // These both import the same `Qux`. The visibility of `Qux`\\n// is `pub` because that is the maximum visibility between\\n// these two `use` declarations.\\npub use bar::*;\\nuse foo::*; fn main() { let _: Qux = Qux;\\n}","breadcrumbs":"Items  Use declarations  Ambiguities","id":"106","title":"Ambiguities"},"107":{"body":"[items.fn] [items.fn.syntax] Syntax Function  FunctionQualifiers fn IDENTIFIER GenericParams ? ( FunctionParameters ? ) FunctionReturnType ? WhereClause ? ( BlockExpression | ; ) FunctionQualifiers  const? async? [1] ItemSafety ? [2] ( extern Abi ? )? ItemSafety  safe [3] | unsafe Abi  STRING_LITERAL | RAW_STRING_LITERAL FunctionParameters  SelfParam ,? | ( SelfParam , )? FunctionParam ( , FunctionParam )* ,? SelfParam  OuterAttribute * ( ShorthandSelf | TypedSelf ) ShorthandSelf  ( & | & Lifetime )? mut? self TypedSelf  mut? self : Type FunctionParam  OuterAttribute * ( FunctionParamPattern | ... | Type  [4] ) FunctionParamPattern  PatternNoTopAlt : ( Type | ... ) FunctionReturnType  -> Type Show Railroad Function FunctionQualifiers fn IDENTIFIER GenericParams ( FunctionParameters ) FunctionReturnType WhereClause BlockExpression ; FunctionQualifiers const async ItemSafety extern Abi ItemSafety safe unsafe Abi STRING_LITERAL RAW_STRING_LITERAL FunctionParameters SelfParam , SelfParam , FunctionParam , FunctionParam , SelfParam OuterAttribute ShorthandSelf TypedSelf ShorthandSelf &amp; &amp; Lifetime mut self TypedSelf mut self : Type FunctionParam OuterAttribute FunctionParamPattern ... Type FunctionParamPattern PatternNoTopAlt : Type ... FunctionReturnType -&gt; Type The async qualifier is not allowed in the 2015 edition. The safe function qualifier is only allowed semantically within extern blocks. Relevant to editions earlier than Rust 2024 : Within extern blocks, the safe or unsafe function qualifier is only allowed when the extern is qualified as unsafe. Function parameters with only a type are only allowed in an associated function of a trait item in the 2015 edition. [items.fn.intro] A function consists of a block (that\'s the body of the function), along with a name, a set of parameters, and an output type. Other than a name, all these are optional. [items.fn.namespace] Functions are declared with the keyword fn which defines the given name in the value namespace of the module or block where it is located. [items.fn.signature] Functions may declare a set of input variables as parameters, through which the caller passes arguments into the function, and the output type of the value the function will return to its caller on completion. [items.fn.implicit-return] If the output type is not explicitly stated, it is the unit type . [items.fn.fn-item-type] When referred to, a function yields a first-class value of the corresponding zero-sized function item type , which when called evaluates to a direct call to the function. For example, this is a simple function: fn answer_to_life_the_universe_and_everything() -> i32 { return 42;\\n} [items.fn.safety-qualifiers] The safe function is semantically only allowed when used in an extern block . [items.fn.params]","breadcrumbs":"Items  Functions  Functions","id":"107","title":"Functions"},"108":{"body":"[items.fn.params.intro] Function parameters are irrefutable patterns , so any pattern that is valid in an else-less let binding is also valid as a parameter: fn first((value, _): (i32, i32)) -> i32 { value } [items.fn.params.self-pat] If the first parameter is a SelfParam , this indicates that the function is a method . [items.fn.params.self-restriction] Functions with a self parameter may only appear as an associated function in a trait or implementation . [items.fn.params.varargs] A parameter with the ... token indicates a variadic function , and may only be used as the last parameter of an external block function. The variadic parameter may have an optional identifier, such as args: .... [items.fn.body]","breadcrumbs":"Items  Functions  Function parameters","id":"108","title":"Function parameters"},"109":{"body":"[items.fn.body.intro] The body block of a function is conceptually wrapped in another block that first binds the argument patterns and then returns the value of the function\'s body. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached. For example, the function above behaves as if it was written as: // argument_0 is the actual first argument passed from the caller\\nlet (value, _) = argument_0;\\nreturn { value\\n}; [items.fn.body.bodyless] Functions without a body block are terminated with a semicolon. This form may only appear in a trait or external block . [items.fn.generics]","breadcrumbs":"Items  Functions  Function body","id":"109","title":"Function body"},"11":{"body":"[input] [input.syntax] Lexer CHAR  <a Unicode scalar value> NUL  U+0000 Show Railroad CHAR a Unicode scalar value NUL U+0000 [input.intro] This chapter describes how a source file is interpreted as a sequence of tokens. See Crates and source files for a description of how programs are organised into files. [input.encoding]","breadcrumbs":"Lexical structure  Input format  Input format","id":"11","title":"Input format"},"110":{"body":"[items.fn.generics.intro] A generic function allows one or more parameterized types to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name. // foo is generic over A and B fn foo<A, B>(x: A, y: B) {\\n# } [items.fn.generics.param-names] Inside the function signature and body, the name of the type parameter can be used as a type name. [items.fn.generics.param-bounds] Trait bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the where syntax: # use std::fmt::Debug;\\nfn foo<T>(x: T) where T: Debug {\\n# } [items.fn.generics.mono] When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the foo function here: use std::fmt::Debug; fn foo<T>(x: &[T]) where T: Debug { // details elided\\n} foo(&[1, 2]); will instantiate type parameter T with i32. [items.fn.generics.explicit-arguments] The type parameters can also be explicitly supplied in a trailing path component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, mem::size_of::<u32>() == 4. [items.fn.extern]","breadcrumbs":"Items  Functions  Generic functions","id":"110","title":"Generic functions"},"111":{"body":"[items.fn.extern.intro] The extern function qualifier allows providing function definitions that can be called with a particular ABI: extern \\"ABI\\" fn foo() { /* ... */ } [items.fn.extern.def] These are often used in combination with external block items which provide function declarations that can be used to call functions without providing their definition : unsafe extern \\"ABI\\" { unsafe fn foo(); /* no body */ safe fn bar(); /* no body */\\n}\\nunsafe { foo() };\\nbar(); [items.fn.extern.default-abi] When \\"extern\\" Abi?* is omitted from FunctionQualifiers in function items, the ABI \\"Rust\\" is assigned. For example: fn foo() {} is equivalent to: extern \\"Rust\\" fn foo() {} [items.fn.extern.foreign-call] Functions can be called by foreign code, and using an ABI that differs from Rust allows, for example, to provide functions that can be called from other programming languages like C: // Declares a function with the \\"C\\" ABI\\nextern \\"C\\" fn new_i32() -> i32 { 0 } // Declares a function with the \\"stdcall\\" ABI\\n# #[cfg(any(windows, target_arch = \\"x86\\"))]\\nextern \\"stdcall\\" fn new_i32_stdcall() -> i32 { 0 } [items.fn.extern.default-extern] Just as with external block , when the extern keyword is used and the \\"ABI\\" is omitted, the ABI used defaults to \\"C\\". That is, this: extern fn new_i32() -> i32 { 0 }\\nlet fptr: extern fn() -> i32 = new_i32; is equivalent to: extern \\"C\\" fn new_i32() -> i32 { 0 }\\nlet fptr: extern \\"C\\" fn() -> i32 = new_i32; [items.fn.extern.unwind]","breadcrumbs":"Items  Functions  Extern function qualifier","id":"111","title":"Extern function qualifier"},"112":{"body":"[items.fn.extern.unwind.intro] Most ABI strings come in two variants, one with an -unwind suffix and one without. The Rust ABI always permits unwinding, so there is no Rust-unwind ABI. The choice of ABI, together with the runtime panic handler , determines the behavior when unwinding out of a function. [items.fn.extern.unwind.behavior] The table below indicates the behavior of an unwinding operation reaching each type of ABI boundary (function declaration or definition using the corresponding ABI string). Note that the Rust runtime is not affected by, and cannot have an effect on, any unwinding that occurs entirely within another language\'s runtime, that is, unwinds that are thrown and caught without reaching a Rust ABI boundary. The panic-unwind column refers to panicking via the panic! macro and similar standard library mechanisms, as well as to any other Rust operations that cause a panic, such as out-of-bounds array indexing or integer overflow. The \\"unwinding\\" ABI category refers to \\"Rust\\" (the implicit ABI of Rust functions not marked extern), \\"C-unwind\\", and any other ABI with -unwind in its name. The \\"non-unwinding\\" ABI category refers to all other ABI strings, including \\"C\\" and \\"stdcall\\". Native unwinding is defined per-target. On targets that support throwing and catching C++ exceptions, it refers to the mechanism used to implement this feature. Some platforms implement a form of unwinding referred to as \\"forced unwinding\\" ; longjmp on Windows and pthread_exit in glibc are implemented this way. Forced unwinding is explicitly excluded from the \\"Native unwind\\" column in the table. panic runtime ABI panic-unwind Native unwind (unforced) panic=unwind unwinding unwind unwind panic=unwind non-unwinding abort (see notes below) undefined behavior panic=abort unwinding panic aborts without unwinding abort panic=abort non-unwinding panic aborts without unwinding undefined behavior [items.fn.extern.abort] With panic=unwind, when a panic is turned into an abort by a non-unwinding ABI boundary, either no destructors (Drop calls) will run, or all destructors up until the ABI boundary will run. It is unspecified which of those two behaviors will happen. For other considerations and limitations regarding unwinding across FFI boundaries, see the relevant section in the Panic documentation . [items.fn.const]","breadcrumbs":"Items  Functions  Unwinding","id":"112","title":"Unwinding"},"113":{"body":"See const functions for the definition of const functions. [items.fn.async]","breadcrumbs":"Items  Functions  Const functions","id":"113","title":"Const functions"},"114":{"body":"[items.fn.async.intro] Functions may be qualified as async, and this can also be combined with the unsafe qualifier: async fn regular_example() { }\\nasync unsafe fn unsafe_example() { } [items.fn.async.future] Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function\'s body. [items.fn.async.desugar-brief] An async function is roughly equivalent to a function that returns impl Future and with an async move block as its body: // Source\\nasync fn example(x: &str) -> usize { x.len()\\n} is roughly equivalent to: # use std::future::Future;\\n// Desugared\\nfn example<\'a>(x: &\'a str) -> impl Future<Output = usize> + \'a { async move { x.len() }\\n} [items.fn.async.desugar] The actual desugaring is more complex: [items.fn.async.lifetime-capture] The return type in the desugaring is assumed to capture all lifetime parameters from the async fn declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, \'a. [items.fn.async.param-capture] The async move block in the body captures all function parameters, including those that are unused or bound to a _ pattern. This ensures that function parameters are dropped in the same order as they would be if the function were not async, except that the drop occurs when the returned future has been fully awaited. For more information on the effect of async, see async blocks . [items.fn.async.edition2018] 2018 Edition differences Async functions are only available beginning with Rust 2018. [items.fn.async.safety]","breadcrumbs":"Items  Functions  Async functions","id":"114","title":"Async functions"},"115":{"body":"[items.fn.async.safety.intro] It is legal to declare a function that is both async and unsafe. The resulting function is unsafe to call and (like any async function) returns a future. This future is just an ordinary future and thus an unsafe context is not required to \\"await\\" it: // Returns a future that, when awaited, dereferences `x`.\\n//\\n// Soundness condition: `x` must be safe to dereference until\\n// the resulting future is complete.\\nasync unsafe fn unsafe_example(x: *const i32) -> i32 { *x\\n} async fn safe_example() { // An `unsafe` block is required to invoke the function initially: let p = 22; let future = unsafe { unsafe_example(&p) }; // But no `unsafe` block required here. This will // read the value of `p`: let q = future.await;\\n} Note that this behavior is a consequence of the desugaring to a function that returns an impl Future -- in this case, the function we desugar to is an unsafe function, but the return value remains the same. Unsafe is used on an async function in precisely the same way that it is used on other functions: it indicates that the function imposes some additional obligations on its caller to ensure soundness. As in any other unsafe function, these conditions may extend beyond the initial call itself -- in the snippet above, for example, the unsafe_example function took a pointer x as argument, and then (when awaited) dereferenced that pointer. This implies that x would have to be valid until the future is finished executing, and it is the caller\'s responsibility to ensure that. [items.fn.attributes]","breadcrumbs":"Items  Functions  Combining async and unsafe","id":"115","title":"Combining async and unsafe"},"116":{"body":"[items.fn.attributes.intro] Outer attributes are allowed on functions. Inner attributes are allowed directly after the { inside its body block . This example shows an inner attribute on a function. The function is documented with just the word \\"Example\\". fn documented() { #![doc = \\"Example\\"]\\n} Note Except for lints, it is idiomatic to only use outer attributes on function items. [items.fn.attributes.builtin-attributes] The attributes that have meaning on a function are: cfg_attr cfg cold deprecated doc export_name inline link_section must_use no_mangle Lint check attributes Procedural macro attributes Testing attributes [items.fn.param-attributes]","breadcrumbs":"Items  Functions  Attributes on functions","id":"116","title":"Attributes on functions"},"117":{"body":"[items.fn.param-attributes.intro] Outer attributes are allowed on function parameters and the permitted built-in attributes are restricted to cfg, cfg_attr, allow, warn, deny, and forbid. fn len( #[cfg(windows)] slice: &[u16], #[cfg(not(windows))] slice: &[u8],\\n) -> usize { slice.len()\\n} [items.fn.param-attributes.parsed-attributes] Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final TokenStream. For example, the following code defines an inert some_inert_attribute attribute that is not formally defined anywhere and the some_proc_macro_attribute procedural macro is responsible for detecting its presence and removing it from the output token stream. #[some_proc_macro_attribute]\\nfn foo_oof(#[some_inert_attribute] arg: u8) {\\n}","breadcrumbs":"Items  Functions  Attributes on function parameters","id":"117","title":"Attributes on function parameters"},"118":{"body":"[items.type] [items.type.syntax] Syntax TypeAlias  type IDENTIFIER GenericParams ? ( : TypeParamBounds )? WhereClause ? ( = Type WhereClause ? )? ; Show Railroad TypeAlias type IDENTIFIER GenericParams : TypeParamBounds WhereClause = Type WhereClause ; [items.type.intro] A type alias defines a new name for an existing type in the type namespace of the module or block where it is located. Type aliases are declared with the keyword type. Every value has a single, specific type, but may implement several different traits, and may be compatible with several different type constraints. For example, the following defines the type Point as a synonym for the type (u8, u8), the type of pairs of unsigned 8 bit integers: type Point = (u8, u8);\\nlet p: Point = (41, 68); [items.type.constructor-alias] A type alias to a tuple-struct or unit-struct cannot be used to qualify that type\'s constructor: struct MyStruct(u32); use MyStruct as UseAlias;\\ntype TypeAlias = MyStruct; let _ = UseAlias(5); // OK\\nlet _ = TypeAlias(5); // Doesn\'t work [items.type.associated-type] A type alias, when not used as an associated type , must include a Type and may not include TypeParamBounds . [items.type.associated-trait] A type alias, when used as an associated type in a trait , must not include a Type specification but may include TypeParamBounds . [items.type.associated-impl] A type alias, when used as an associated type in a trait impl , must include a Type specification and may not include TypeParamBounds . [items.type.deprecated] Where clauses before the equals sign on a type alias in a trait impl (like type TypeAlias<T> where T: Foo = Bar<T>) are deprecated. Where clauses after the equals sign (like type TypeAlias<T> = Bar<T> where T: Foo) are preferred.","breadcrumbs":"Items  Type aliases  Type aliases","id":"118","title":"Type aliases"},"119":{"body":"[items.struct] [items.struct.syntax] Syntax Struct  StructStruct | TupleStruct StructStruct  struct IDENTIFIER GenericParams ? WhereClause ? ( { StructFields ? } | ; ) TupleStruct  struct IDENTIFIER GenericParams ? ( TupleFields ? ) WhereClause ? ; StructFields  StructField ( , StructField )* ,? StructField  OuterAttribute * Visibility ? IDENTIFIER : Type TupleFields  TupleField ( , TupleField )* ,? TupleField  OuterAttribute * Visibility ? Type Show Railroad Struct StructStruct TupleStruct StructStruct struct IDENTIFIER GenericParams WhereClause { StructFields } ; TupleStruct struct IDENTIFIER GenericParams ( TupleFields ) WhereClause ; StructFields StructField , StructField , StructField OuterAttribute Visibility IDENTIFIER : Type TupleFields TupleField , TupleField , TupleField OuterAttribute Visibility Type [items.struct.intro] A struct is a nominal struct type defined with the keyword struct. [items.struct.namespace] A struct declaration defines the given name in the type namespace of the module or block where it is located. An example of a struct item and its use: struct Point {x: i32, y: i32}\\nlet p = Point {x: 10, y: 11};\\nlet px: i32 = p.x; [items.struct.tuple] A tuple struct is a nominal tuple type , and is also defined with the keyword struct. In addition to defining a type, it also defines a constructor of the same name in the value namespace . The constructor is a function which can be called to create a new instance of the struct. For example: struct Point(i32, i32);\\nlet p = Point(10, 11);\\nlet px: i32 = match p { Point(x, _) => x }; [items.struct.unit] A unit-like struct is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example: struct Cookie;\\nlet c = [Cookie, Cookie {}, Cookie, Cookie {}]; is equivalent to struct Cookie {}\\nconst Cookie: Cookie = Cookie {};\\nlet c = [Cookie, Cookie {}, Cookie, Cookie {}]; [items.struct.layout] The precise memory layout of a struct is not specified. One can specify a particular layout using the repr attribute .","breadcrumbs":"Items  Structs  Structs","id":"119","title":"Structs"},"12":{"body":"[input.encoding.utf8] Tests Tests with this rule:\\ntests/ui/macros/not-utf8.rs\\ntests/ui/parser/utf16-be-without-bom.rs\\ntests/ui/parser/utf16-le-without-bom.rs Each source file is interpreted as a sequence of Unicode characters encoded in UTF-8. [input.encoding.invalid] Tests Tests with this rule:\\ntests/ui/macros/not-utf8.rs It is an error if the file is not valid UTF-8. [input.byte-order-mark] Tests Tests with this rule:\\ntests/ui/codemap_tests/utf8-bom.rs\\ntests/ui/json/json-bom-plus-crlf-multifile.rs\\ntests/ui/json/json-bom-plus-crlf.rs","breadcrumbs":"Lexical structure  Input format  Source encoding","id":"12","title":"Source encoding"},"120":{"body":"[items.enum] [items.enum.syntax] Syntax Enumeration  enum IDENTIFIER GenericParams ? WhereClause ? { EnumVariants ? } EnumVariants  EnumVariant ( , EnumVariant )* ,? EnumVariant  OuterAttribute * Visibility ? IDENTIFIER ( EnumVariantTuple | EnumVariantStruct )? EnumVariantDiscriminant ? EnumVariantTuple  ( TupleFields ? ) EnumVariantStruct  { StructFields ? } EnumVariantDiscriminant  = Expression Show Railroad Enumeration enum IDENTIFIER GenericParams WhereClause { EnumVariants } EnumVariants EnumVariant , EnumVariant , EnumVariant OuterAttribute Visibility IDENTIFIER EnumVariantTuple EnumVariantStruct EnumVariantDiscriminant EnumVariantTuple ( TupleFields ) EnumVariantStruct { StructFields } EnumVariantDiscriminant = Expression [items.enum.intro] An enumeration , also referred to as an enum , is a simultaneous definition of a nominal enumerated type as well as a set of constructors , that can be used to create or pattern-match values of the corresponding enumerated type. [items.enum.decl] Enumerations are declared with the keyword enum. [items.enum.namespace] The enum declaration defines the enumeration type in the type namespace of the module or block where it is located. An example of an enum item and its use: enum Animal { Dog, Cat,\\n} let mut a: Animal = Animal::Dog;\\na = Animal::Cat; [items.enum.constructor] Enum constructors can have either named or unnamed fields: enum Animal { Dog(String, f64), Cat { name: String, weight: f64 },\\n} let mut a: Animal = Animal::Dog(\\"Cocoa\\".to_string(), 37.2);\\na = Animal::Cat { name: \\"Spotty\\".to_string(), weight: 2.7 }; In this example, Cat is a struct-like enum variant , whereas Dog is simply called an enum variant. [items.enum.fieldless] An enum where no constructors contain fields is called a field-less enum . For example, this is a fieldless enum: enum Fieldless { Tuple(), Struct{}, Unit,\\n} [items.enum.unit-only] If a field-less enum only contains unit variants, the enum is called an unit-only enum . For example: enum Enum { Foo = 3, Bar = 2, Baz = 1,\\n} [items.enum.constructor-names] Variant constructors are similar to struct definitions, and can be referenced by a path from the enumeration name, including in use declarations . [items.enum.constructor-namespace] Each variant defines its type in the type namespace , though that type cannot be used as a type specifier. Tuple-like and unit-like variants also define a constructor in the value namespace . [items.enum.struct-expr] A struct-like variant can be instantiated with a struct expression . [items.enum.tuple-expr] A tuple-like variant can be instantiated with a call expression or a struct expression . [items.enum.path-expr] A unit-like variant can be instantiated with a path expression or a struct expression . For example: enum Examples { UnitLike, TupleLike(i32), StructLike { value: i32 },\\n} use Examples::*; // Creates aliases to all variants.\\nlet x = UnitLike; // Path expression of the const item.\\nlet x = UnitLike {}; // Struct expression.\\nlet y = TupleLike(123); // Call expression.\\nlet y = TupleLike { 0: 123 }; // Struct expression using integer field names.\\nlet z = StructLike { value: 123 }; // Struct expression. [items.enum.discriminant]","breadcrumbs":"Items  Enumerations  Enumerations","id":"120","title":"Enumerations"},"121":{"body":"[items.enum.discriminant.intro] Each enum instance has a discriminant : an integer logically associated to it that is used to determine which variant it holds. [items.enum.discriminant.repr-rust] Under the Rust representation , the discriminant is interpreted as an isize value. However, the compiler is allowed to use a smaller type (or another means of distinguishing variants) in its actual memory layout.","breadcrumbs":"Items  Enumerations  Discriminants","id":"121","title":"Discriminants"},"122":{"body":"[items.enum.discriminant.explicit] Explicit discriminants [items.enum.discriminant.explicit.intro] In two circumstances, the discriminant of a variant may be explicitly set by following the variant name with = and a constant expression : [items.enum.discriminant.explicit.unit-only] if the enumeration is \\" unit-only \\". [items.enum.discriminant.explicit.primitive-repr] if a primitive representation is used. For example: #[repr(u8)]\\nenum Enum { Unit = 3, Tuple(u16), Struct { a: u8, b: u16, } = 1,\\n} [items.enum.discriminant.implicit] Implicit discriminants If a discriminant for a variant is not specified, then it is set to one higher than the discriminant of the previous variant in the declaration. If the discriminant of the first variant in the declaration is unspecified, then it is set to zero. enum Foo { Bar, // 0 Baz = 123, // 123 Quux, // 124\\n} let baz_discriminant = Foo::Baz as u32;\\nassert_eq!(baz_discriminant, 123); [items.enum.discriminant.restrictions] Restrictions [items.enum.discriminant.restrictions.same-discriminant] It is an error when two variants share the same discriminant. enum SharedDiscriminantError { SharedA = 1, SharedB = 1\\n} enum SharedDiscriminantError2 { Zero, // 0 One, // 1 OneToo = 1 // 1 (collision with previous!)\\n} [items.enum.discriminant.restrictions.above-max-discriminant] It is also an error to have an unspecified discriminant where the previous discriminant is the maximum value for the size of the discriminant. #[repr(u8)]\\nenum OverflowingDiscriminantError { Max = 255, MaxPlusOne // Would be 256, but that overflows the enum.\\n} #[repr(u8)]\\nenum OverflowingDiscriminantError2 { MaxMinusOne = 254, // 254 Max, // 255 MaxPlusOne // Would be 256, but that overflows the enum.\\n}","breadcrumbs":"Items  Enumerations  Assigning discriminant values","id":"122","title":"Assigning discriminant values"},"123":{"body":"Via mem::discriminant [items.enum.discriminant.access-opaque] std::mem::discriminant returns an opaque reference to the discriminant of an enum value which can be compared. This cannot be used to get the value of the discriminant. [items.enum.discriminant.coercion] Casting [items.enum.discriminant.coercion.intro] If an enumeration is unit-only (with no tuple and struct variants), then its discriminant can be directly accessed with a numeric cast ; e.g.: enum Enum { Foo, Bar, Baz,\\n} assert_eq!(0, Enum::Foo as isize);\\nassert_eq!(1, Enum::Bar as isize);\\nassert_eq!(2, Enum::Baz as isize); [items.enum.discriminant.coercion.fieldless] Field-less enums can be casted if they do not have explicit discriminants, or where only unit variants are explicit. enum Fieldless { Tuple(), Struct{}, Unit,\\n} assert_eq!(0, Fieldless::Tuple() as isize);\\nassert_eq!(1, Fieldless::Struct{} as isize);\\nassert_eq!(2, Fieldless::Unit as isize); #[repr(u8)]\\nenum FieldlessWithDiscriminants { First = 10, Tuple(), Second = 20, Struct{}, Unit,\\n} assert_eq!(10, FieldlessWithDiscriminants::First as u8);\\nassert_eq!(11, FieldlessWithDiscriminants::Tuple() as u8);\\nassert_eq!(20, FieldlessWithDiscriminants::Second as u8);\\nassert_eq!(21, FieldlessWithDiscriminants::Struct{} as u8);\\nassert_eq!(22, FieldlessWithDiscriminants::Unit as u8); Pointer casting [items.enum.discriminant.access-memory] If the enumeration specifies a primitive representation , then the discriminant may be reliably accessed via unsafe pointer casting: #[repr(u8)]\\nenum Enum { Unit, Tuple(bool), Struct{a: bool},\\n} impl Enum { fn discriminant(&self) -> u8 { unsafe { *(self as *const Self as *const u8) } }\\n} let unit_like = Enum::Unit;\\nlet tuple_like = Enum::Tuple(true);\\nlet struct_like = Enum::Struct{a: false}; assert_eq!(0, unit_like.discriminant());\\nassert_eq!(1, tuple_like.discriminant());\\nassert_eq!(2, struct_like.discriminant()); [items.enum.empty]","breadcrumbs":"Items  Enumerations  Accessing discriminant","id":"123","title":"Accessing discriminant"},"124":{"body":"[items.enum.empty.intro] Enums with zero variants are known as zero-variant enums . As they have no valid values, they cannot be instantiated. enum ZeroVariants {} [items.enum.empty.uninhabited] Zero-variant enums are equivalent to the never type , but they cannot be coerced into other types. # enum ZeroVariants {}\\nlet x: ZeroVariants = panic!();\\nlet y: u32 = x; // mismatched type error [items.enum.variant-visibility]","breadcrumbs":"Items  Enumerations  Zero-variant enums","id":"124","title":"Zero-variant enums"},"125":{"body":"Enum variants syntactically allow a Visibility annotation, but this is rejected when the enum is validated. This allows items to be parsed with a unified syntax across different contexts where they are used. macro_rules! mac_variant { ($vis:vis $name:ident) => { enum $name { $vis Unit, $vis Tuple(u8, u16), $vis Struct { f: u8 }, } }\\n} // Empty `vis` is allowed.\\nmac_variant! { E } // This is allowed, since it is removed before being validated.\\n#[cfg(false)]\\nenum E { pub U, pub(crate) T(u8), pub(super) T { f: String }\\n}","breadcrumbs":"Items  Enumerations  Variant visibility","id":"125","title":"Variant visibility"},"126":{"body":"[items.union] [items.union.syntax] Syntax Union  union IDENTIFIER GenericParams ? WhereClause ? { StructFields ? } Show Railroad Union union IDENTIFIER GenericParams WhereClause { StructFields } [items.union.intro] A union declaration uses the same syntax as a struct declaration, except with union in place of struct. [items.union.namespace] A union declaration defines the given name in the type namespace of the module or block where it is located. #[repr(C)]\\nunion MyUnion { f1: u32, f2: f32,\\n} [items.union.common-storage] The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field. [items.union.field-restrictions] Union field types are restricted to the following subset of types: [items.union.field-copy] Copy types [items.union.field-references] References (&T and &mut T for arbitrary T) [items.union.field-manually-drop] ManuallyDrop<T> (for arbitrary T) [items.union.field-tuple] Tuples and arrays containing only allowed union field types [items.union.drop] This restriction ensures, in particular, that union fields never need to be dropped. Like for structs and enums, it is possible to impl Drop for a union to manually define what happens when it gets dropped. [items.union.fieldless] Unions without any fields are not accepted by the compiler, but can be accepted by macros. [items.union.init]","breadcrumbs":"Items  Unions  Unions","id":"126","title":"Unions"},"127":{"body":"[items.union.init.intro] A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field: # union MyUnion { f1: u32, f2: f32 }\\n#\\nlet u = MyUnion { f1: 1 }; [items.union.init.result] The expression above creates a value of type MyUnion and initializes the storage using field f1. The union can be accessed using the same syntax as struct fields: # union MyUnion { f1: u32, f2: f32 }\\n#\\n# let u = MyUnion { f1: 1 };\\nlet f = unsafe { u.f1 }; [items.union.fields]","breadcrumbs":"Items  Unions  Initialization of a union","id":"127","title":"Initialization of a union"},"128":{"body":"[items.union.fields.intro] Unions have no notion of an \\"active field\\". Instead, every union access just interprets the storage as the type of the field used for the access. [items.union.fields.read] Reading a union field reads the bits of the union at the field\'s type. [items.union.fields.offset] Fields might have a non-zero offset (except when the C representation is used); in that case the bits starting at the offset of the fields are read [items.union.fields.validity] It is the programmer\'s responsibility to make sure that the data is valid at the field\'s type. Failing to do so results in undefined behavior . For example, reading the value 3 from a field of the boolean type is undefined behavior. Effectively, writing to and then reading from a union with the C representation is analogous to a transmute from the type used for writing to the type used for reading. [items.union.fields.read-safety] Consequently, all reads of union fields have to be placed in unsafe blocks: # union MyUnion { f1: u32, f2: f32 }\\n# let u = MyUnion { f1: 1 };\\n#\\nunsafe { let f = u.f1;\\n} Commonly, code using unions will provide safe wrappers around unsafe union field accesses. [items.union.fields.write-safety] In contrast, writes to union fields are safe, since they just overwrite arbitrary data, but cannot cause undefined behavior. (Note that union field types can never have drop glue, so a union field write will never implicitly drop anything.) [items.union.pattern]","breadcrumbs":"Items  Unions  Reading and writing union fields","id":"128","title":"Reading and writing union fields"},"129":{"body":"[items.union.pattern.intro] Another way to access union fields is to use pattern matching. [items.union.pattern.one-field] Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field. [items.union.pattern.safety] Since pattern matching is like reading the union with a particular field, it has to be placed in unsafe blocks as well. # union MyUnion { f1: u32, f2: f32 }\\n#\\nfn f(u: MyUnion) { unsafe { match u { MyUnion { f1: 10 } => { println!(\\"ten\\"); } MyUnion { f2 } => { println!(\\"{}\\", f2); } } }\\n} [items.union.pattern.subpattern] Pattern matching may match a union as a field of a larger structure. In particular, when using a Rust union to implement a C tagged union via FFI, this allows matching on the tag and the corresponding field simultaneously: #[repr(u32)]\\nenum Tag { I, F } #[repr(C)]\\nunion U { i: i32, f: f32,\\n} #[repr(C)]\\nstruct Value { tag: Tag, u: U,\\n} fn is_zero(v: Value) -> bool { unsafe { match v { Value { tag: Tag::I, u: U { i: 0 } } => true, Value { tag: Tag::F, u: U { f: num } } if num == 0.0 => true, _ => false, } }\\n} [items.union.ref]","breadcrumbs":"Items  Unions  Pattern matching on unions","id":"129","title":"Pattern matching on unions"},"13":{"body":"If the first character in the sequence is U+FEFF ( BYTE ORDER MARK ), it is removed. [input.crlf] Tests Tests with this rule:\\ntests/ui/json/json-bom-plus-crlf-multifile.rs\\ntests/ui/json/json-bom-plus-crlf.rs\\ntests/ui/lexer/lexer-crlf-line-endings-string-literal-doc-comment.rs","breadcrumbs":"Lexical structure  Input format  Byte order mark removal","id":"13","title":"Byte order mark removal"},"130":{"body":"[items.union.ref.intro] Since union fields share common storage, gaining write access to one field of a union can give write access to all its remaining fields. [items.union.ref.borrow] Borrow checking rules have to be adjusted to account for this fact. As a result, if one field of a union is borrowed, all its remaining fields are borrowed as well for the same lifetime. # union MyUnion { f1: u32, f2: f32 }\\n// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time\\nfn test() { let mut u = MyUnion { f1: 1 }; unsafe { let b1 = &mut u.f1;\\n// ---- first mutable borrow occurs here (via `u.f1`) let b2 = &mut u.f2;\\n// ^^^^ second mutable borrow occurs here (via `u.f2`) *b1 = 5; }\\n// - first borrow ends here assert_eq!(unsafe { u.f1 }, 5);\\n} [items.union.ref.usage] As you could see, in many aspects (except for layouts, safety, and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).","breadcrumbs":"Items  Unions  References to union fields","id":"130","title":"References to union fields"},"131":{"body":"[items.const] [items.const.syntax] Syntax ConstantItem  const ( IDENTIFIER | _ ) : Type ( = Expression )? ; Show Railroad ConstantItem const IDENTIFIER _ : Type = Expression ; [items.const.intro] A constant item is an optionally named constant value which is not associated with a specific memory location in the program. [items.const.behavior] Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non- Copy types. References to the same constant are not necessarily guaranteed to refer to the same memory address. [items.const.namespace] The constant declaration defines the constant value in the value namespace of the module or block where it is located. [items.const.static] Constants must be explicitly typed. The type must have a \'static lifetime: any references in the initializer must have \'static lifetimes. References in the type of a constant default to \'static lifetime; see static lifetime elision . [items.const.static-temporary] A reference to a constant will have \'static lifetime if the constant value is eligible for promotion ; otherwise, a temporary will be created. const BIT1: u32 = 1 << 0;\\nconst BIT2: u32 = 1 << 1; const BITS: [u32; 2] = [BIT1, BIT2];\\nconst STRING: &\'static str = \\"bitstring\\"; struct BitsNStrings<\'a> { mybits: [u32; 2], mystring: &\'a str,\\n} const BITS_N_STRINGS: BitsNStrings<\'static> = BitsNStrings { mybits: BITS, mystring: STRING,\\n}; [items.const.no-mut-refs] The final value of a const item cannot contain any mutable references. # #![allow(static_mut_refs)]\\nstatic mut S: u8 = 0;\\nconst C: &u8 = unsafe { &mut S }; // OK # use core::sync::atomic::AtomicU8;\\nstatic S: AtomicU8 = AtomicU8::new(0);\\nconst C: &AtomicU8 = &S; // OK # #![allow(static_mut_refs)]\\nstatic mut S: u8 = 0;\\nconst C: &mut u8 = unsafe { &mut S }; // ERROR not allowed Note We also disallow, in the final value, shared references to mutable statics created in the initializer for a separate reason. Consider: # use core::sync::atomic::AtomicU8;\\nconst C: &AtomicU8 = &AtomicU8::new(0); // ERROR Here, the AtomicU8 is a temporary that is lifetime extended to \'static (see destructors.scope.lifetime-extension.static ), and references to lifetime-extended temporaries with interior mutability are not allowed in the final value of a constant expression (see const-eval.const-expr.borrows ). [items.const.expr-omission] The constant expression may only be omitted in a trait definition . [items.const.destructor]","breadcrumbs":"Items  Constant items  Constant items","id":"131","title":"Constant items"},"132":{"body":"Constants can contain destructors. Destructors are run when the value goes out of scope. struct TypeWithDestructor(i32); impl Drop for TypeWithDestructor { fn drop(&mut self) { println!(\\"Dropped. Held {}.\\", self.0); }\\n} const ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0); fn create_and_drop_zero_with_destructor() { let x = ZERO_WITH_DESTRUCTOR; // x gets dropped at end of function, calling drop. // prints \\"Dropped. Held 0.\\".\\n} [items.const.unnamed]","breadcrumbs":"Items  Constant items  Constants with destructors","id":"132","title":"Constants with destructors"},"133":{"body":"[items.const.unnamed.intro] Unlike an associated constant , a free constant may be unnamed by using an underscore instead of the name. For example: const _: () = { struct _SameNameTwice; }; // OK although it is the same name as above:\\nconst _: () = { struct _SameNameTwice; }; [items.const.unnamed.repetition] As with underscore imports , macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error: macro_rules! m { ($item: item) => { $item $item }\\n} m!(const _: () = (););\\n// This expands to:\\n// const _: () = ();\\n// const _: () = (); [items.const.eval]","breadcrumbs":"Items  Constant items  Unnamed constant","id":"133","title":"Unnamed constant"},"134":{"body":"Free constants are always evaluated at compile-time to surface panics. This happens even within an unused function: // Compile-time panic\\nconst PANIC: () = std::unimplemented!(); fn unused_generic_function<T>() { // A failing compile-time assertion const _: () = assert!(usize::BITS == 0);\\n}","breadcrumbs":"Items  Constant items  Evaluation","id":"134","title":"Evaluation"},"135":{"body":"[items.static] [items.static.syntax] Syntax StaticItem  ItemSafety ? [1] static mut? IDENTIFIER : Type ( = Expression )? ; Show Railroad StaticItem ItemSafety static mut IDENTIFIER : Type = Expression ; The safe and unsafe function qualifiers are only allowed semantically within extern blocks. [items.static.intro] A static item is similar to a constant , except that it represents an allocation in the program that is initialized with the initializer expression. All references and raw pointers to the static refer to the same allocation. [items.static.lifetime] Static items have the static lifetime, which outlives all other lifetimes in a Rust program. Static items do not call drop at the end of the program. [items.static.storage-disjointness] If the static has a size of at least 1 byte, this allocation is disjoint from all other such static allocations as well as heap allocations and stack-allocated variables. However, the storage of immutable static items can overlap with allocations that do not themselves have a unique address, such as promoteds and const items . [items.static.namespace] The static declaration defines a static value in the value namespace of the module or block where it is located. [items.static.init] The static initializer is a constant expression evaluated at compile time. Static initializers may refer to and read from other statics. When reading from mutable statics, they read the initial value of that static. [items.static.read-only] Non-mut static items that contain a type that is not interior mutable may be placed in read-only memory. [items.static.safety] All access to a static is safe, but there are a number of restrictions on statics: [items.static.sync] The type must have the Sync trait bound to allow thread-safe access. [items.static.init.omission] The initializer expression must be omitted in an external block , and must be provided for free static items. [items.static.safety-qualifiers] The safe and unsafe qualifiers are semantically only allowed when used in an external block . [items.static.generics]","breadcrumbs":"Items  Static items  Static items","id":"135","title":"Static items"},"136":{"body":"A static item defined in a generic scope (for example in a blanket or default implementation) will result in exactly one static item being defined, as if the static definition was pulled out of the current scope into the module. There will not be one item per monomorphization. This code: use std::sync::atomic::{AtomicUsize, Ordering}; trait Tr { fn default_impl() { static COUNTER: AtomicUsize = AtomicUsize::new(0); println!(\\"default_impl: counter was {}\\", COUNTER.fetch_add(1, Ordering::Relaxed)); } fn blanket_impl();\\n} struct Ty1 {}\\nstruct Ty2 {} impl<T> Tr for T { fn blanket_impl() { static COUNTER: AtomicUsize = AtomicUsize::new(0); println!(\\"blanket_impl: counter was {}\\", COUNTER.fetch_add(1, Ordering::Relaxed)); }\\n} fn main() { <Ty1 as Tr>::default_impl(); <Ty2 as Tr>::default_impl(); <Ty1 as Tr>::blanket_impl(); <Ty2 as Tr>::blanket_impl();\\n} prints default_impl: counter was 0\\ndefault_impl: counter was 1\\nblanket_impl: counter was 0\\nblanket_impl: counter was 1 [items.static.mut]","breadcrumbs":"Items  Static items  Statics & generics","id":"136","title":"Statics & generics"},"137":{"body":"[items.static.mut.intro] If a static item is declared with the mut keyword, then it is allowed to be modified by the program. One of Rust\'s goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. [items.static.mut.safety] For this reason, an unsafe block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process. [items.static.mut.extern] Mutable statics are still very useful, however. They can be used with C libraries and can also be bound from C libraries in an extern block. # fn atomic_add(_: *mut u32, _: u32) -> u32 { 2 } static mut LEVELS: u32 = 0; // This violates the idea of no shared state, and this doesn\'t internally\\n// protect against races, so this function is `unsafe`\\nunsafe fn bump_levels_unsafe() -> u32 { unsafe { let ret = LEVELS; LEVELS += 1; return ret; }\\n} // As an alternative to `bump_levels_unsafe`, this function is safe, assuming\\n// that we have an atomic_add function which returns the old value. This\\n// function is safe only if no other code accesses the static in a non-atomic\\n// fashion. If such accesses are possible (such as in `bump_levels_unsafe`),\\n// then this would need to be `unsafe` to indicate to the caller that they\\n// must still guard against concurrent access.\\nfn bump_levels_safe() -> u32 { unsafe { return atomic_add(&raw mut LEVELS, 1); }\\n} [items.static.mut.sync] Mutable statics have the same restrictions as normal statics, except that the type does not have to implement the Sync trait. [items.static.alternate]","breadcrumbs":"Items  Static items  Mutable statics","id":"137","title":"Mutable statics"},"138":{"body":"It can be confusing whether or not you should use a constant item or a static item. Constants should, in general, be preferred over statics unless one of the following are true: Large amounts of data are being stored. The single-address property of statics is required. Interior mutability is required.","breadcrumbs":"Items  Static items  Using statics or consts","id":"138","title":"Using statics or consts"},"139":{"body":"[items.traits] [items.traits.syntax] Syntax Trait  unsafe? trait IDENTIFIER GenericParams ? ( : TypeParamBounds ? )? WhereClause ? { InnerAttribute * AssociatedItem * } Show Railroad Trait unsafe trait IDENTIFIER GenericParams : TypeParamBounds WhereClause { InnerAttribute AssociatedItem } [items.traits.intro] A trait describes an abstract interface that types can implement. This interface consists of associated items , which come in three varieties: functions types constants [items.traits.namespace] The trait declaration defines a trait in the type namespace of the module or block where it is located. [items.traits.associated-item-namespaces] Associated items are defined as members of the trait within their respective namespaces. Associated types are defined in the type namespace. Associated constants and associated functions are defined in the value namespace. [items.traits.self-param] All traits define an implicit type parameter Self that refers to \\"the type that is implementing this interface\\". Traits may also contain additional type parameters. These type parameters, including Self, may be constrained by other traits and so forth as usual . [items.traits.impls] Traits are implemented for specific types through separate implementations . [items.traits.associated-item-decls] Trait functions may omit the function body by replacing it with a semicolon. This indicates that the implementation must define the function. If the trait function defines a body, this definition acts as a default for any implementation which does not override it. Similarly, associated constants may omit the equals sign and expression to indicate implementations must define the constant value. Associated types must never define the type, the type may only be specified in an implementation. // Examples of associated trait items with and without definitions.\\ntrait Example { const CONST_NO_DEFAULT: i32; const CONST_WITH_DEFAULT: i32 = 99; type TypeNoDefault; fn method_without_default(&self); fn method_with_default(&self) {}\\n} [items.traits.const-fn] Trait functions are not allowed to be const . [items.traits.bounds]","breadcrumbs":"Items  Traits  Traits","id":"139","title":"Traits"},"14":{"body":"Each pair of characters U+000D (CR) immediately followed by U+000A (LF) is replaced by a single U+000A (LF). This happens once, not repeatedly, so after the normalization, there can still exist U+000D (CR) immediately followed by U+000A (LF) in the input (e.g. if the raw input contained \\"CR CR LF LF\\"). Other occurrences of the character U+000D (CR) are left in place (they are treated as whitespace ). [input.shebang] Tests Tests with this rule:\\ntests/ui/parser/shebang/issue-71471-ignore-tidy.rs\\ntests/ui/parser/shebang/shebang-comment.rs\\ntests/ui/parser/shebang/shebang-empty.rs\\ntests/ui/parser/shebang/shebang-must-start-file.rs\\ntests/ui/parser/shebang/shebang-space.rs\\ntests/ui/parser/shebang/valid-shebang.rs","breadcrumbs":"Lexical structure  Input format  CRLF normalization","id":"14","title":"CRLF normalization"},"140":{"body":"Generic items may use traits as bounds on their type parameters. [items.traits.generic]","breadcrumbs":"Items  Traits  Trait bounds","id":"140","title":"Trait bounds"},"141":{"body":"Type parameters can be specified for a trait to make it generic. These appear after the trait name, using the same syntax used in generic functions . trait Seq<T> { fn len(&self) -> u32; fn elt_at(&self, n: u32) -> T; fn iter<F>(&self, f: F) where F: Fn(T);\\n} [items.traits.dyn-compatible]","breadcrumbs":"Items  Traits  Generic traits","id":"141","title":"Generic traits"},"142":{"body":"[items.traits.dyn-compatible.intro] A dyn-compatible trait can be the base trait of a trait object . A trait is dyn compatible if it has the following qualities: [items.traits.dyn-compatible.supertraits] All supertraits must also be dyn compatible. [items.traits.dyn-compatible.sized] Sized must not be a supertrait . In other words, it must not require Self: Sized. [items.traits.dyn-compatible.associated-consts] It must not have any associated constants. [items.traits.dyn-compatible.associated-types] It must not have any associated types with generics. [items.traits.dyn-compatible.associated-functions] All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable: Dispatchable functions must: Not have any type parameters (although lifetime parameters are allowed). Be a method that does not use Self except in the type of the receiver. Have a receiver with one of the following types: &Self (i.e. &self) &mut Self (i.e &mut self) Box<Self> Rc<Self> Arc<Self> Pin<P> where P is one of the types above Not have an opaque return type; that is, Not be an async fn (which has a hidden Future type). Not have a return position impl Trait type (fn example(&self) -> impl Trait). Not have a where Self: Sized bound (receiver type of Self (i.e. self) implies this). Explicitly non-dispatchable functions require: Have a where Self: Sized bound (receiver type of Self (i.e. self) implies this). [items.traits.dyn-compatible.async-traits] The AsyncFn , AsyncFnMut , and AsyncFnOnce traits are not dyn-compatible. Note This concept was formerly known as object safety . # use std::rc::Rc;\\n# use std::sync::Arc;\\n# use std::pin::Pin;\\n// Examples of dyn compatible methods.\\ntrait TraitMethods { fn by_ref(self: &Self) {} fn by_ref_mut(self: &mut Self) {} fn by_box(self: Box<Self>) {} fn by_rc(self: Rc<Self>) {} fn by_arc(self: Arc<Self>) {} fn by_pin(self: Pin<&Self>) {} fn with_lifetime<\'a>(self: &\'a Self) {} fn nested_pin(self: Pin<Arc<Self>>) {}\\n}\\n# struct S;\\n# impl TraitMethods for S {}\\n# let t: Box<dyn TraitMethods> = Box::new(S); // This trait is dyn compatible, but these methods cannot be dispatched on a trait object.\\ntrait NonDispatchable { // Non-methods cannot be dispatched. fn foo() where Self: Sized {} // Self type isn\'t known until runtime. fn returns(&self) -> Self where Self: Sized; // `other` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {} // Generics are not compatible with vtables. fn typed<T>(&self, x: T) where Self: Sized {}\\n} struct S;\\nimpl NonDispatchable for S { fn returns(&self) -> Self where Self: Sized { S }\\n}\\nlet obj: Box<dyn NonDispatchable> = Box::new(S);\\nobj.returns(); // ERROR: cannot call with Self return\\nobj.param(S); // ERROR: cannot call with Self parameter\\nobj.typed(1); // ERROR: cannot call with generic type # use std::rc::Rc;\\n// Examples of dyn-incompatible traits.\\ntrait DynIncompatible { const CONST: i32 = 1; // ERROR: cannot have associated const fn foo() {} // ERROR: associated function without Sized fn returns(&self) -> Self; // ERROR: Self in return type fn typed<T>(&self, x: T) {} // ERROR: has generic type parameters fn nested(self: Rc<Box<Self>>) {} // ERROR: nested receiver cannot be downcasted\\n} struct S;\\nimpl DynIncompatible for S { fn returns(&self) -> Self { S }\\n}\\nlet obj: Box<dyn DynIncompatible> = Box::new(S); // ERROR // `Self: Sized` traits are dyn-incompatible.\\ntrait TraitWithSize where Self: Sized {} struct S;\\nimpl TraitWithSize for S {}\\nlet obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR // Dyn-incompatible if `Self` is a type argument.\\ntrait Super<A> {}\\ntrait WithSelf: Super<Self> where Self: Sized {} struct S;\\nimpl<A> Super<A> for S {}\\nimpl WithSelf for S {}\\nlet obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use `Self` type parameter [items.traits.supertraits]","breadcrumbs":"Items  Traits  Dyn compatibility","id":"142","title":"Dyn compatibility"},"143":{"body":"[items.traits.supertraits.intro] Supertraits are traits that are required to be implemented for a type to implement a specific trait. Furthermore, anywhere a generic or trait object is bounded by a trait, it has access to the associated items of its supertraits. [items.traits.supertraits.decl] Supertraits are declared by trait bounds on the Self type of a trait and transitively the supertraits of the traits declared in those trait bounds. It is an error for a trait to be its own supertrait. [items.traits.supertraits.subtrait] The trait with a supertrait is called a subtrait of its supertrait. The following is an example of declaring Shape to be a supertrait of Circle. trait Shape { fn area(&self) -> f64; }\\ntrait Circle: Shape { fn radius(&self) -> f64; } And the following is the same example, except using where clauses . trait Shape { fn area(&self) -> f64; }\\ntrait Circle where Self: Shape { fn radius(&self) -> f64; } This next example gives radius a default implementation using the area function from Shape. # trait Shape { fn area(&self) -> f64; }\\ntrait Circle where Self: Shape { fn radius(&self) -> f64 { // A = pi * r^2 // so algebraically, // r = sqrt(A / pi) (self.area() / std::f64::consts::PI).sqrt() }\\n} This next example calls a supertrait method on a generic parameter. # trait Shape { fn area(&self) -> f64; }\\n# trait Circle: Shape { fn radius(&self) -> f64; }\\nfn print_area_and_radius<C: Circle>(c: C) { // Here we call the area method from the supertrait `Shape` of `Circle`. println!(\\"Area: {}\\", c.area()); println!(\\"Radius: {}\\", c.radius());\\n} Similarly, here is an example of calling supertrait methods on trait objects. # trait Shape { fn area(&self) -> f64; }\\n# trait Circle: Shape { fn radius(&self) -> f64; }\\n# struct UnitCircle;\\n# impl Shape for UnitCircle { fn area(&self) -> f64 { std::f64::consts::PI } }\\n# impl Circle for UnitCircle { fn radius(&self) -> f64 { 1.0 } }\\n# let circle = UnitCircle;\\nlet circle = Box::new(circle) as Box<dyn Circle>;\\nlet nonsense = circle.radius() * circle.area(); [items.traits.safety]","breadcrumbs":"Items  Traits  Supertraits","id":"143","title":"Supertraits"},"144":{"body":"[items.traits.safety.intro] Traits items that begin with the unsafe keyword indicate that implementing the trait may be unsafe . It is safe to use a correctly implemented unsafe trait. The trait implementation must also begin with the unsafe keyword. Sync and Send are examples of unsafe traits. [items.traits.params]","breadcrumbs":"Items  Traits  Unsafe traits","id":"144","title":"Unsafe traits"},"145":{"body":"[items.traits.params.patterns-no-body] Parameters in associated functions without a body only allow IDENTIFIER or _ wild card patterns, as well as the form allowed by SelfParam . mut IDENTIFIER is currently allowed, but it is deprecated and will become a hard error in the future. trait T { fn f1(&self); fn f2(x: Self, _: i32);\\n} trait T { fn f2(&x: &i32); // ERROR: patterns aren\'t allowed in functions without bodies\\n} [items.traits.params.patterns-with-body] Parameters in associated functions with a body only allow irrefutable patterns. trait T { fn f1((a, b): (i32, i32)) {} // OK: is irrefutable\\n} trait T { fn f1(123: i32) {} // ERROR: pattern is refutable fn f2(Some(x): Option<i32>) {} // ERROR: pattern is refutable\\n} [items.traits.params.pattern-required.edition2018] 2018 Edition differences Prior to the 2018 edition, the pattern for an associated function parameter is optional: // 2015 Edition\\ntrait T { fn f(i32); // OK: parameter identifiers are not required\\n} Beginning in the 2018 edition, patterns are no longer optional. [items.traits.params.restriction-patterns.edition2018] 2018 Edition differences Prior to the 2018 edition, parameters in associated functions with a body are limited to the following kinds of patterns: IDENTIFIER mut IDENTIFIER _ & IDENTIFIER && IDENTIFIER // 2015 Edition\\ntrait T { fn f1((a, b): (i32, i32)) {} // ERROR: pattern not allowed\\n} Beginning in 2018, all irrefutable patterns are allowed as described in items.traits.params.patterns-with-body . [items.traits.associated-visibility]","breadcrumbs":"Items  Traits  Parameter patterns","id":"145","title":"Parameter patterns"},"146":{"body":"[items.traits.associated-visibility.intro] Trait items syntactically allow a Visibility annotation, but this is rejected when the trait is validated. This allows items to be parsed with a unified syntax across different contexts where they are used. As an example, an empty vis macro fragment specifier can be used for trait items, where the macro rule may be used in other situations where visibility is allowed. macro_rules! create_method { ($vis:vis $name:ident) => { $vis fn $name(&self) {} };\\n} trait T1 { // Empty `vis` is allowed. create_method! { method_of_t1 }\\n} struct S; impl S { // Visibility is allowed here. create_method! { pub method_of_s }\\n} impl T1 for S {} fn main() { let s = S; s.method_of_t1(); s.method_of_s();\\n}","breadcrumbs":"Items  Traits  Item visibility","id":"146","title":"Item visibility"},"147":{"body":"[items.impl] [items.impl.syntax] Syntax Implementation  InherentImpl | TraitImpl InherentImpl  impl GenericParams ? Type WhereClause ? { InnerAttribute * AssociatedItem * } TraitImpl  unsafe? impl GenericParams ? !? TypePath for Type WhereClause ? { InnerAttribute * AssociatedItem * } Show Railroad Implementation InherentImpl TraitImpl InherentImpl impl GenericParams Type WhereClause { InnerAttribute AssociatedItem } TraitImpl unsafe impl GenericParams ! TypePath for Type WhereClause { InnerAttribute AssociatedItem } [items.impl.intro] An implementation is an item that associates items with an implementing type . Implementations are defined with the keyword impl and contain functions that belong to an instance of the type that is being implemented or to the type statically. [items.impl.kinds] There are two types of implementations: inherent implementations trait implementations [items.impl.inherent]","breadcrumbs":"Items  Implementations  Implementations","id":"147","title":"Implementations"},"148":{"body":"[items.impl.inherent.intro] An inherent implementation is defined as the sequence of the impl keyword, generic type declarations, a path to a nominal type, a where clause, and a bracketed set of associable items. [items.impl.inherent.implementing-type] The nominal type is called the implementing type and the associable items are the associated items to the implementing type. [items.impl.inherent.associated-items] Inherent implementations associate the contained items to the implementing type. [items.impl.inherent.associated-items.allowed-items] Inherent implementations can contain associated functions (including methods ) and associated constants . [items.impl.inherent.type-alias] They cannot contain associated type aliases. [items.impl.inherent.associated-item-path] The path to an associated item is any path to the implementing type, followed by the associated item\'s identifier as the final path component. [items.impl.inherent.coherence] A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition. pub mod color { pub struct Color(pub u8, pub u8, pub u8); impl Color { pub const WHITE: Color = Color(255, 255, 255); }\\n} mod values { use super::color::Color; impl Color { pub fn red() -> Color { Color(255, 0, 0) } }\\n} pub use self::color::Color;\\nfn main() { // Actual path to the implementing type and impl in the same module. color::Color::WHITE; // Impl blocks in different modules are still accessed through a path to the type. color::Color::red(); // Re-exported paths to the implementing type also work. Color::red(); // Does not work, because use in `values` is not pub. // values::Color::red();\\n} [items.impl.trait]","breadcrumbs":"Items  Implementations  Inherent implementations","id":"148","title":"Inherent implementations"},"149":{"body":"[items.impl.trait.intro] A trait implementation is defined like an inherent implementation except that the optional generic type declarations are followed by a trait , followed by the keyword for, followed by a path to a nominal type. [items.impl.trait.implemented-trait] The trait is known as the implemented trait . The implementing type implements the implemented trait. [items.impl.trait.def-requirement] A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items. [items.impl.trait.associated-item-path] The path to the associated items is < followed by a path to the implementing type followed by as followed by a path to the trait followed by > as a path component followed by the associated item\'s path component. [items.impl.trait.safety] Unsafe traits require the trait implementation to begin with the unsafe keyword. # #[derive(Copy, Clone)]\\n# struct Point {x: f64, y: f64};\\n# type Surface = i32;\\n# struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\\n# trait Shape { fn draw(&self, s: Surface); fn bounding_box(&self) -> BoundingBox; }\\n# fn do_draw_circle(s: Surface, c: Circle) { }\\nstruct Circle { radius: f64, center: Point,\\n} impl Copy for Circle {} impl Clone for Circle { fn clone(&self) -> Circle { *self }\\n} impl Shape for Circle { fn draw(&self, s: Surface) { do_draw_circle(s, *self); } fn bounding_box(&self) -> BoundingBox { let r = self.radius; BoundingBox { x: self.center.x - r, y: self.center.y - r, width: 2.0 * r, height: 2.0 * r, } }\\n} [items.impl.trait.coherence]","breadcrumbs":"Items  Implementations  Trait implementations","id":"149","title":"Trait implementations"},"15":{"body":"[input.shebang.intro] If the remaining sequence begins with the characters #!, the characters up to and including the first U+000A (LF) are removed from the sequence. For example, the first line of the following file would be ignored: #!/usr/bin/env rustx fn main() { println!(\\"Hello!\\");\\n} [input.shebang.inner-attribute] Tests Tests with this rule:\\ntests/ui/parser/shebang/multiline-attrib.rs\\ntests/ui/parser/shebang/regular-attrib.rs\\ntests/ui/parser/shebang/shebang-and-attrib.rs\\ntests/ui/parser/shebang/shebang-doc-comment.rs\\ntests/ui/parser/shebang/sneaky-attrib.rs As an exception, if the #! characters are followed (ignoring intervening comments or whitespace ) by a [ token, nothing is removed. This prevents an inner attribute at the start of a source file being removed. Note The standard library include! macro applies byte order mark removal, CRLF normalization, and shebang removal to the file it reads. The include_str! and include_bytes! macros do not. [input.tokenization]","breadcrumbs":"Lexical structure  Input format  Shebang removal","id":"15","title":"Shebang removal"},"150":{"body":"[items.impl.trait.coherence.intro] A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances. [items.impl.trait.coherence.overlapping] Two trait implementations overlap when there is a non-empty intersection of the traits the implementation is for, the implementations can be instantiated with the same type. [items.impl.trait.orphan-rule] Orphan rules [items.impl.trait.orphan-rule.intro] The orphan rule states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherence. An orphan implementation is one that implements a foreign trait for a foreign type. If these were freely allowed, two crates could implement the same trait for the same type in incompatible ways, creating a situation where adding or updating a dependency could break compilation due to conflicting implementations. The orphan rule enables library authors to add new implementations to their traits without fear that they\'ll break downstream code. Without these restrictions, a library couldn\'t add an implementation like impl<T: Display> MyTrait for T without potentially conflicting with downstream implementations. [items.impl.trait.orphan-rule.general] Given impl<P1..=Pn> Trait<T1..=Tn> for T0, an impl is valid only if at least one of the following is true: Trait is a local trait All of At least one of the types T0..=Tn must be a local type . Let Ti be the first such type. No uncovered type parameters P1..=Pn may appear in T0..Ti (excluding Ti) [items.impl.trait.uncovered-param] Only the appearance of uncovered type parameters is restricted. [items.impl.trait.fundamental] Note that for the purposes of coherence, fundamental types are special. The T in Box<T> is not considered covered, and Box<LocalType> is considered local. [items.impl.generics]","breadcrumbs":"Items  Implementations  Trait implementation coherence","id":"150","title":"Trait implementation coherence"},"151":{"body":"[items.impl.generics.intro] An implementation can take generic parameters , which can be used in the rest of the implementation. Implementation parameters are written directly after the impl keyword. # trait Seq<T> { fn dummy(&self, _: T) { } }\\nimpl<T> Seq<T> for Vec<T> { /* ... */\\n}\\nimpl Seq<bool> for u32 { /* Treat the integer as a sequence of bits */\\n} [items.impl.generics.usage] Generic parameters constrain an implementation if the parameter appears at least once in one of: The implemented trait, if it has one The implementing type As an associated type in the bounds of a type that contains another parameter that constrains the implementation [items.impl.generics.constrain] Type and const parameters must always constrain the implementation. Lifetimes must constrain the implementation if the lifetime is used in an associated type. Examples of constraining situations: # trait Trait{}\\n# trait GenericTrait<T> {}\\n# trait HasAssocType { type Ty; }\\n# struct Struct;\\n# struct GenericStruct<T>(T);\\n# struct ConstGenericStruct<const N: usize>([(); N]);\\n// T constrains by being an argument to GenericTrait.\\nimpl<T> GenericTrait<T> for i32 { /* ... */ } // T constrains by being an argument to GenericStruct\\nimpl<T> Trait for GenericStruct<T> { /* ... */ } // Likewise, N constrains by being an argument to ConstGenericStruct\\nimpl<const N: usize> Trait for ConstGenericStruct<N> { /* ... */ } // T constrains by being in an associated type in a bound for type `U` which is\\n// itself a generic parameter constraining the trait.\\nimpl<T, U> GenericTrait<U> for u32 where U: HasAssocType<Ty = T> { /* ... */ } // Like previous, except the type is `(U, isize)`. `U` appears inside the type\\n// that includes `T`, and is not the type itself.\\nimpl<T, U> GenericStruct<U> where (U, isize): HasAssocType<Ty = T> { /* ... */ } Examples of non-constraining situations: // The rest of these are errors, since they have type or const parameters that\\n// do not constrain. // T does not constrain since it does not appear at all.\\nimpl<T> Struct { /* ... */ } // N does not constrain for the same reason.\\nimpl<const N: usize> Struct { /* ... */ } // Usage of T inside the implementation does not constrain the impl.\\nimpl<T> Struct { fn uses_t(t: &T) { /* ... */ }\\n} // T is used as an associated type in the bounds for U, but U does not constrain.\\nimpl<T, U> Struct where U: HasAssocType<Ty = T> { /* ... */ } // T is used in the bounds, but not as an associated type, so it does not constrain.\\nimpl<T, U> GenericTrait<U> for u32 where U: GenericTrait<T> {} Example of an allowed unconstraining lifetime parameter: # struct Struct;\\nimpl<\'a> Struct {} Example of a disallowed unconstraining lifetime parameter: # struct Struct;\\n# trait HasAssocType { type Ty; }\\nimpl<\'a> HasAssocType for Struct { type Ty = &\'a Struct;\\n} [items.impl.attributes]","breadcrumbs":"Items  Implementations  Generic implementations","id":"151","title":"Generic implementations"},"152":{"body":"Implementations may contain outer attributes before the impl keyword and inner attributes inside the brackets that contain the associated items. Inner attributes must come before any associated items. The attributes that have meaning here are cfg , deprecated , doc , and the lint check attributes .","breadcrumbs":"Items  Implementations  Attributes on implementations","id":"152","title":"Attributes on implementations"},"153":{"body":"[items.extern] [items.extern.syntax] Syntax ExternBlock  unsafe? [1] extern Abi ? { InnerAttribute * ExternalItem * } ExternalItem  OuterAttribute * ( MacroInvocationSemi | Visibility ? StaticItem | Visibility ? Function ) Show Railroad ExternBlock unsafe extern Abi { InnerAttribute ExternalItem } ExternalItem OuterAttribute MacroInvocationSemi Visibility StaticItem Visibility Function Starting with the 2024 Edition, the unsafe keyword is required semantically. [items.extern.intro] External blocks provide declarations of items that are not defined in the current crate and are the basis of Rust\'s foreign function interface. These are akin to unchecked imports. [items.extern.allowed-kinds] Two kinds of item declarations are allowed in external blocks: functions and statics . [items.extern.safety] Calling unsafe functions or accessing unsafe statics that are declared in external blocks is only allowed in an unsafe context . [items.extern.namespace] The external block defines its functions and statics in the value namespace of the module or block where it is located. [items.extern.unsafe-required] The unsafe keyword is semantically required to appear before the extern keyword on external blocks. [items.extern.edition2024] 2024 Edition differences Prior to the 2024 edition, the unsafe keyword is optional. The safe and unsafe item qualifiers are only allowed if the external block itself is marked as unsafe. [items.extern.fn]","breadcrumbs":"Items  External blocks  External blocks","id":"153","title":"External blocks"},"154":{"body":"[items.extern.fn.body] Functions within external blocks are declared in the same way as other Rust functions, with the exception that they must not have a body and are instead terminated by a semicolon. [items.extern.fn.param-patterns] Patterns are not allowed in parameters, only IDENTIFIER or _ may be used. [items.extern.fn.qualifiers] The safe and unsafe function qualifiers are allowed, but other function qualifiers (e.g. const, async, extern) are not. [items.extern.fn.foreign-abi] Functions within external blocks may be called by Rust code, just like functions defined in Rust. The Rust compiler automatically translates between the Rust ABI and the foreign ABI. [items.extern.fn.safety] A function declared in an extern block is implicitly unsafe unless the safe function qualifier is present. [items.extern.fn.fn-ptr] When coerced to a function pointer, a function declared in an extern block has type extern \\"abi\\" for<\'l1, ..., \'lm> fn(A1, ..., An) -> R, where \'l1, ... \'lm are its lifetime parameters, A1, ..., An are the declared types of its parameters, R is the declared return type. [items.extern.static]","breadcrumbs":"Items  External blocks  Functions","id":"154","title":"Functions"},"155":{"body":"[items.extern.static.intro] Statics within external blocks are declared in the same way as statics outside of external blocks, except that they do not have an expression initializing their value. [items.extern.static.safety] Unless a static item declared in an extern block is qualified as safe, it is unsafe to access that item, whether or not it\'s mutable, because there is nothing guaranteeing that the bit pattern at the static\'s memory is valid for the type it is declared with, since some arbitrary (e.g. C) code is in charge of initializing the static. [items.extern.static.mut] Extern statics can be either immutable or mutable just like statics outside of external blocks. [items.extern.static.read-only] An immutable static must be initialized before any Rust code is executed. It is not enough for the static to be initialized before Rust code reads from it. Once Rust code runs, mutating an immutable static (from inside or outside Rust) is UB, except if the mutation happens to bytes inside of an UnsafeCell. [items.extern.abi]","breadcrumbs":"Items  External blocks  Statics","id":"155","title":"Statics"},"156":{"body":"[items.extern.abi.intro] The extern keyword can be followed by an optional ABI string. The ABI specifies the calling convention of the functions in the block. The calling convention defines a low-level interface for functions, such as how arguments are placed in registers or on the stack, how return values are passed, and who is responsible for cleaning up the stack. Example // Interface to the Windows API.\\nunsafe extern \\"system\\" { /* ... */ } [items.extern.abi.default] If the ABI string is not specified, it defaults to \\"C\\". Note The extern syntax without an explicit ABI is being phased out, so it\'s better to always write the ABI explicitly. For more details, see Rust issue #134986 . [items.extern.abi.standard] The following ABI strings are supported on all platforms: [items.extern.abi.rust] unsafe extern \\"Rust\\" --- The native calling convention for Rust functions and closures. This is the default when a function is declared without using extern fn . The Rust ABI offers no stability guarantees. [items.extern.abi.c] unsafe extern \\"C\\" --- The \\"C\\" ABI matches the default ABI chosen by the dominant C compiler for the target. [items.extern.abi.system] unsafe extern \\"system\\" --- This is equivalent to extern \\"C\\" except on Windows x86_32 where it is equivalent to \\"stdcall\\". Note As the correct underlying ABI on Windows is target-specific, it\'s best to use extern \\"system\\" when attempting to link Windows API functions that don\'t use an explicitly defined ABI. [items.extern.abi.unwind] extern \\"C-unwind\\" and extern \\"system-unwind\\" --- Identical to \\"C\\" and \\"system\\", respectively, but with different behavior when the callee unwinds (by panicking or throwing a C++ style exception). [items.extern.abi.platform] There are also some platform-specific ABI strings: [items.extern.abi.cdecl] unsafe extern \\"cdecl\\" --- The calling convention typically used with x86_32 C code. Only available on x86_32 targets. Corresponds to MSVC\'s __cdecl and GCC and clang\'s __attribute__((cdecl)). Note For details, see: https://learn.microsoft.com/en-us/cpp/cpp/cdecl https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl [items.extern.abi.stdcall] unsafe extern \\"stdcall\\" --- The calling convention typically used by the Win32 API on x86_32. Only available on x86_32 targets. Corresponds to MSVC\'s __stdcall and GCC and clang\'s __attribute__((stdcall)). Note For details, see: https://learn.microsoft.com/en-us/cpp/cpp/stdcall https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall [items.extern.abi.win64] unsafe extern \\"win64\\" --- The Windows x64 ABI. Only available on x86_64 targets. \\"win64\\" is the same as the \\"C\\" ABI on Windows x86_64 targets. Corresponds to GCC and clang\'s __attribute__((ms_abi)). Note For details, see: https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention [items.extern.abi.sysv64] unsafe extern \\"sysv64\\" --- The System V ABI. Only available on x86_64 targets. \\"sysv64\\" is the same as the \\"C\\" ABI on non-Windows x86_64 targets. Corresponds to GCC and clang\'s __attribute__((sysv_abi)). Note For details, see: https://wiki.osdev.org/System_V_ABI https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI [items.extern.abi.aapcs] unsafe extern \\"aapcs\\" --- The soft-float ABI for ARM. Only available on ARM32 targets. \\"aapcs\\" is the same as the \\"C\\" ABI on soft-float ARM32. Corresponds to clang\'s __attribute__((pcs(\\"aapcs\\"))). Note For details, see: Arm Procedure Call Standard [items.extern.abi.fastcall] unsafe extern \\"fastcall\\" --- A \\"fast\\" variant of stdcall that passes some arguments in registers. Only available on x86_32 targets. Corresponds to MSVC\'s __fastcall and GCC and clang\'s __attribute__((fastcall)). Note For details, see: https://learn.microsoft.com/en-us/cpp/cpp/fastcall https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_fastcall [items.extern.abi.thiscall] unsafe extern \\"thiscall\\" --- The calling convention typically used on C++ class member functions on x86_32 MSVC. Only available on x86_32 targets. Corresponds to MSVC\'s __thiscall and GCC and clang\'s __attribute__((thiscall)). Note For details, see: https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall https://learn.microsoft.com/en-us/cpp/cpp/thiscall [items.extern.abi.efiapi] unsafe extern \\"efiapi\\" --- The ABI used for UEFI functions. Only available on x86 and ARM targets (32bit and 64bit). [items.extern.abi.platform-unwind-variants] Like \\"C\\" and \\"system\\", most platform-specific ABI strings also have a corresponding -unwind variant ; specifically, these are: \\"aapcs-unwind\\" \\"cdecl-unwind\\" \\"fastcall-unwind\\" \\"stdcall-unwind\\" \\"sysv64-unwind\\" \\"thiscall-unwind\\" \\"win64-unwind\\" [items.extern.variadic]","breadcrumbs":"Items  External blocks  ABI","id":"156","title":"ABI"},"157":{"body":"Functions within external blocks may be variadic by specifying ... as the last argument. The variadic parameter may optionally be specified with an identifier. unsafe extern \\"C\\" { unsafe fn foo(...); unsafe fn bar(x: i32, ...); unsafe fn with_name(format: *const u8, args: ...); // SAFETY: This function guarantees it will not access // variadic arguments. safe fn ignores_variadic_arguments(x: i32, ...);\\n} Warning The safe qualifier should not be used on a function in an extern block unless that function guarantees that it will not access the variadic arguments at all. Passing an unexpected number of arguments or arguments of unexpected type to a variadic function may lead to undefined behavior . [items.extern.variadic.conventions] Variadic parameters can only be specified within extern blocks with the following ABI strings or their corresponding -unwind variants : \\"aapcs\\" \\"C\\" \\"cdecl\\" \\"efiapi\\" \\"sysv64\\" \\"win64\\" [items.extern.attributes]","breadcrumbs":"Items  External blocks  Variadic functions","id":"157","title":"Variadic functions"},"158":{"body":"[items.extern.attributes.intro] The following attributes control the behavior of external blocks. [items.extern.attributes.link]","breadcrumbs":"Items  External blocks  Attributes on extern blocks","id":"158","title":"Attributes on extern blocks"},"159":{"body":"[items.extern.attributes.link.intro] The link attribute specifies the name of a native library that the compiler should link with for the items within an extern block. [items.extern.attributes.link.syntax] It uses the MetaListNameValueStr syntax to specify its inputs. The name key is the name of the native library to link. The kind key is an optional value which specifies the kind of library with the following possible values: [items.extern.attributes.link.dylib] dylib --- Indicates a dynamic library. This is the default if kind is not specified. [items.extern.attributes.link.static] static --- Indicates a static library. [items.extern.attributes.link.framework] framework --- Indicates a macOS framework. This is only valid for macOS targets. [items.extern.attributes.link.raw-dylib] raw-dylib --- Indicates a dynamic library where the compiler will generate an import library to link against (see dylib versus raw-dylib below for details). This is only valid for Windows targets. [items.extern.attributes.link.name-requirement] The name key must be included if kind is specified. [items.extern.attributes.link.modifiers] The optional modifiers argument is a way to specify linking modifiers for the library to link. [items.extern.attributes.link.modifiers.syntax] Modifiers are specified as a comma-delimited string with each modifier prefixed with either a + or - to indicate that the modifier is enabled or disabled, respectively. [items.extern.attributes.link.modifiers.multiple] Specifying multiple modifiers arguments in a single link attribute, or multiple identical modifiers in the same modifiers argument is not currently supported. Example: #[link(name = \\"mylib\\", kind = \\"static\\", modifiers = \\"+whole-archive\\")]. [items.extern.attributes.link.wasm_import_module] The wasm_import_module key may be used to specify the WebAssembly module name for the items within an extern block when importing symbols from the host environment. The default module name is env if wasm_import_module is not specified. #[link(name = \\"crypto\\")]\\nunsafe extern { // \\n} #[link(name = \\"CoreFoundation\\", kind = \\"framework\\")]\\nunsafe extern { // \\n} #[link(wasm_import_module = \\"foo\\")]\\nunsafe extern { // \\n} [items.extern.attributes.link.empty-block] It is valid to add the link attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block. [items.extern.attributes.link.modifiers.bundle] Linking modifiers: bundle [items.extern.attributes.link.modifiers.bundle.allowed-kinds] This modifier is only compatible with the static linking kind. Using any other kind will result in a compiler error. [items.extern.attributes.link.modifiers.bundle.behavior] When building a rlib or staticlib +bundle means that the native static library will be packed into the rlib or staticlib archive, and then retrieved from there during linking of the final binary. [items.extern.attributes.link.modifiers.bundle.behavior-negative] When building a rlib -bundle means that the native static library is registered as a dependency of that rlib \\"by name\\", and object files from it are included only during linking of the final binary, the file search by that name is also performed during final linking. When building a staticlib -bundle means that the native static library is simply not included into the archive and some higher level build system will need to add it later during linking of the final binary. [items.extern.attributes.link.modifiers.bundle.no-effect] This modifier has no effect when building other targets like executables or dynamic libraries. [items.extern.attributes.link.modifiers.bundle.default] The default for this modifier is +bundle. More implementation details about this modifier can be found in bundle documentation for rustc . [items.extern.attributes.link.modifiers.whole-archive] Linking modifiers: whole-archive [items.extern.attributes.link.modifiers.whole-archive.allowed-kinds] This modifier is only compatible with the static linking kind. Using any other kind will result in a compiler error. [items.extern.attributes.link.modifiers.whole-archive.behavior] +whole-archive means that the static library is linked as a whole archive without throwing any object files away. [items.extern.attributes.link.modifiers.whole-archive.default] The default for this modifier is -whole-archive. More implementation details about this modifier can be found in whole-archive documentation for rustc . [items.extern.attributes.link.modifiers.verbatim]","breadcrumbs":"Items  External blocks  The link attribute","id":"159","title":"The link attribute"},"16":{"body":"The resulting sequence of characters is then converted into tokens as described in the remainder of this chapter.","breadcrumbs":"Lexical structure  Input format  Tokenization","id":"16","title":"Tokenization"},"160":{"body":"[items.extern.attributes.link.modifiers.verbatim.allowed-kinds] This modifier is compatible with all linking kinds. [items.extern.attributes.link.modifiers.verbatim.behavior] +verbatim means that rustc itself won\'t add any target-specified library prefixes or suffixes (like lib or .a) to the library name, and will try its best to ask for the same thing from the linker. [items.extern.attributes.link.modifiers.verbatim.behavior-negative] -verbatim means that rustc will either add a target-specific prefix and suffix to the library name before passing it to linker, or won\'t prevent linker from implicitly adding it. [items.extern.attributes.link.modifiers.verbatim.default] The default for this modifier is -verbatim. More implementation details about this modifier can be found in verbatim documentation for rustc . [items.extern.attributes.link.kind-raw-dylib] dylib versus raw-dylib [items.extern.attributes.link.kind-raw-dylib.intro] On Windows, linking against a dynamic library requires that an import library is provided to the linker: this is a special static library that declares all of the symbols exported by the dynamic library in such a way that the linker knows that they have to be dynamically loaded at runtime. [items.extern.attributes.link.kind-raw-dylib.import] Specifying kind = \\"dylib\\" instructs the Rust compiler to link an import library based on the name key. The linker will then use its normal library resolution logic to find that import library. Alternatively, specifying kind = \\"raw-dylib\\" instructs the compiler to generate an import library during compilation and provide that to the linker instead. [items.extern.attributes.link.kind-raw-dylib.platform-specific] raw-dylib is only supported on Windows. Using it when targeting other platforms will result in a compiler error. [items.extern.attributes.link.import_name_type] The import_name_type key [items.extern.attributes.link.import_name_type.intro] On x86 Windows, names of functions are \\"decorated\\" (i.e., have a specific prefix and/or suffix added) to indicate their calling convention. For example, a stdcall calling convention function with the name fn1 that has no arguments would be decorated as _fn1@0. However, the PE Format does also permit names to have no prefix or be undecorated. Additionally, the MSVC and GNU toolchains use different decorations for the same calling conventions which means, by default, some Win32 functions cannot be called using the raw-dylib link kind via the GNU toolchain. [items.extern.attributes.link.import_name_type.values] To allow for these differences, when using the raw-dylib link kind you may also specify the import_name_type key with one of the following values to change how functions are named in the generated import library: decorated: The function name will be fully-decorated using the MSVC toolchain format. noprefix: The function name will be decorated using the MSVC toolchain format, but skipping the leading ?, @, or optionally _. undecorated: The function name will not be decorated. [items.extern.attributes.link.import_name_type.default] If the import_name_type key is not specified, then the function name will be fully-decorated using the target toolchain\'s format. [items.extern.attributes.link.import_name_type.variables] Variables are never decorated and so the import_name_type key has no effect on how they are named in the generated import library. [items.extern.attributes.link.import_name_type.platform-specific] The import_name_type key is only supported on x86 Windows. Using it when targeting other platforms will result in a compiler error. [items.extern.attributes.link_name]","breadcrumbs":"Items  External blocks  Linking modifiers: verbatim","id":"160","title":"Linking modifiers: verbatim"},"161":{"body":"[items.extern.attributes.link_name.intro] The link_name attribute may be applied to declarations inside an extern block to specify the symbol to import for the given function or static. Example unsafe extern \\"C\\" { #[link_name = \\"actual_symbol_name\\"] safe fn name_in_rust();\\n} [items.extern.attributes.link_name.syntax] The link_name attribute uses the MetaNameValueStr syntax. [items.extern.attributes.link_name.allowed-positions] The link_name attribute may only be applied to a function or static item in an extern block. Note rustc ignores use in other positions but lints against it. This may become an error in the future. [items.extern.attributes.link_name.duplicates] Only the last use of link_name on an item has effect. Note rustc lints against any use preceding the last. This may become an error in the future. [items.extern.attributes.link_name.link_ordinal] The link_name attribute may not be used with the link_ordinal attribute. [items.extern.attributes.link_ordinal]","breadcrumbs":"Items  External blocks  The link_name attribute","id":"161","title":"The link_name attribute"},"162":{"body":"[items.extern.attributes.link_ordinal.intro] The link_ordinal attribute can be applied on declarations inside an extern block to indicate the numeric ordinal to use when generating the import library to link against. An ordinal is a unique number per symbol exported by a dynamic library on Windows and can be used when the library is being loaded to find that symbol rather than having to look it up by name. Warning link_ordinal should only be used in cases where the ordinal of the symbol is known to be stable: if the ordinal of a symbol is not explicitly set when its containing binary is built then one will be automatically assigned to it, and that assigned ordinal may change between builds of the binary. # #[cfg(all(windows, target_arch = \\"x86\\"))]\\n#[link(name = \\"exporter\\", kind = \\"raw-dylib\\")]\\nunsafe extern \\"stdcall\\" { #[link_ordinal(15)] safe fn imported_function_stdcall(i: i32);\\n} [items.extern.attributes.link_ordinal.allowed-kinds] This attribute is only used with the raw-dylib linking kind. Using any other kind will result in a compiler error. [items.extern.attributes.link_ordinal.exclusive] Using this attribute with the link_name attribute will result in a compiler error. [items.extern.attributes.fn-parameters]","breadcrumbs":"Items  External blocks  The link_ordinal attribute","id":"162","title":"The link_ordinal attribute"},"163":{"body":"Attributes on extern function parameters follow the same rules and restrictions as regular function parameters .","breadcrumbs":"Items  External blocks  Attributes on function parameters","id":"163","title":"Attributes on function parameters"},"164":{"body":"[items.generics] [items.generics.syntax] Syntax GenericParams  < ( GenericParam ( , GenericParam )* ,? )? > GenericParam  OuterAttribute * ( LifetimeParam | TypeParam | ConstParam ) LifetimeParam  Lifetime ( : LifetimeBounds )? TypeParam  IDENTIFIER ( : TypeParamBounds ? )? ( = Type )? ConstParam  const IDENTIFIER : Type ( = ( BlockExpression | IDENTIFIER | -? LiteralExpression ) )? Show Railroad GenericParams &lt; GenericParam , GenericParam , &gt; GenericParam OuterAttribute LifetimeParam TypeParam ConstParam LifetimeParam Lifetime : LifetimeBounds TypeParam IDENTIFIER : TypeParamBounds = Type ConstParam const IDENTIFIER : Type = BlockExpression IDENTIFIER - LiteralExpression [items.generics.syntax.intro] Functions , type aliases , structs , enumerations , unions , traits , and implementations may be parameterized by types, constants, and lifetimes. These parameters are listed in angle brackets (<...>), usually immediately after the name of the item and before its definition. For implementations, which don\'t have a name, they come directly after impl. [items.generics.syntax.decl-order] The order of generic parameters is restricted to lifetime parameters and then type and const parameters intermixed. [items.generics.syntax.duplicate-params] The same parameter name may not be declared more than once in a GenericParams list. Some examples of items with type, const, and lifetime parameters: fn foo<\'a, T>() {}\\ntrait A<U> {}\\nstruct Ref<\'a, T> where T: \'a { r: &\'a T }\\nstruct InnerArray<T, const N: usize>([T; N]);\\nstruct EitherOrderWorks<const N: bool, U>(U); [items.generics.syntax.scope] Generic parameters are in scope within the item definition where they are declared. They are not in scope for items declared within the body of a function as described in item declarations . See generic parameter scopes for more details. [items.generics.builtin-generic-types] References , raw pointers , arrays , slices , tuples , and function pointers have lifetime or type parameters as well, but are not referred to with path syntax. [items.generics.invalid-lifetimes] \'_ and \'static are not valid lifetime parameter names. [items.generics.const]","breadcrumbs":"Items  Generic parameters  Generic parameters","id":"164","title":"Generic parameters"},"165":{"body":"[items.generics.const.intro] Const generic parameters allow items to be generic over constant values. [items.generics.const.namespace] The const identifier introduces a name in the value namespace for the constant parameter, and all instances of the item must be instantiated with a value of the given type. [items.generics.const.allowed-types] The only allowed types of const parameters are u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, char and bool. [items.generics.const.usage] Const parameters can be used anywhere a const item can be used, with the exception that when used in a type or array repeat expression , it must be standalone (as described below). That is, they are allowed in the following places: As an applied const to any type which forms a part of the signature of the item in question. As part of a const expression used to define an associated const , or as a parameter to an associated type . As a value in any runtime expression in the body of any functions in the item. As a parameter to any type used in the body of any functions in the item. As a part of the type of any fields in the item. // Examples where const generic parameters can be used. // Used in the signature of the item itself.\\nfn foo<const N: usize>(arr: [i32; N]) { // Used as a type within a function body. let x: [i32; N]; // Used as an expression. println!(\\"{}\\", N * 2);\\n} // Used as a field of a struct.\\nstruct Foo<const N: usize>([i32; N]); impl<const N: usize> Foo<N> { // Used as an associated constant. const CONST: usize = N * 4;\\n} trait Trait { type Output;\\n} impl<const N: usize> Trait for Foo<N> { // Used as an associated type. type Output = [i32; N];\\n} // Examples where const generic parameters cannot be used.\\nfn foo<const N: usize>() { // Cannot use in item definitions within a function body. const BAD_CONST: [usize; N] = [1; N]; static BAD_STATIC: [usize; N] = [1; N]; fn inner(bad_arg: [usize; N]) { let bad_value = N * 2; } type BadAlias = [usize; N]; struct BadStruct([usize; N]);\\n} [items.generics.const.standalone] As a further restriction, const parameters may only appear as a standalone argument inside of a type or array repeat expression . In those contexts, they may only be used as a single segment path expression , possibly inside a block (such as N or {N}). That is, they cannot be combined with other expressions. // Examples where const parameters may not be used. // Not allowed to combine in other expressions in types, such as the\\n// arithmetic expression in the return type here.\\nfn bad_function<const N: usize>() -> [u8; {N + 1}] { // Similarly not allowed for array repeat expressions. [1; {N + 1}]\\n} [items.generics.const.argument] A const argument in a path specifies the const value to use for that item. [items.generics.const.argument.const-expr] The argument must either be an inferred const or be a const expression of the type ascribed to the const parameter. The const expression must be a block expression (surrounded with braces) unless it is a single path segment (an IDENTIFIER ) or a literal (with a possibly leading - token). Note This syntactic restriction is necessary to avoid requiring infinite lookahead when parsing an expression inside of a type. struct S<const N: i64>;\\nconst C: i64 = 1;\\nfn f<const N: i64>() -> S<N> { S } let _ = f::<1>(); // Literal.\\nlet _ = f::<-1>(); // Negative literal.\\nlet _ = f::<{ 1 + 2 }>(); // Constant expression.\\nlet _ = f::<C>(); // Single segment path.\\nlet _ = f::<{ C + 1 }>(); // Constant expression.\\nlet _: S<1> = f::<_>(); // Inferred const.\\nlet _: S<1> = f::<(((_)))>(); // Inferred const. Note In a generic argument list, an inferred const is parsed as an inferred type but then semantically treated as a separate kind of const generic argument . [items.generics.const.inferred] Tests Tests with this rule:\\ntests/ui/const-generics/generic_arg_infer/paren_infer.rs Where a const argument is expected, an _ (optionally surrounded by any number of matching parentheses), called the inferred const ( path rules , array expression rules ), can be used instead. This asks the compiler to infer the const argument if possible based on surrounding information. fn make_buf<const N: usize>() -> [u8; N] { [0; _] // ^ Infers `N`.\\n}\\nlet _: [u8; 1024] = make_buf::<_>();\\n// ^ Infers `1024`. Note An inferred const is not semantically an expression and so is not accepted within braces. fn f<const N: usize>() -> [u8; N] { [0; _] }\\nlet _: [_; 1] = f::<{ _ }>();\\n// ^ ERROR `_` not allowed here [items.generics.const.inferred.constraint] The inferred const cannot be used in item signatures. fn f<const N: usize>(x: [u8; N]) -> [u8; _] { x }\\n// ^ ERROR not allowed [items.generics.const.type-ambiguity] When there is ambiguity if a generic argument could be resolved as either a type or const argument, it is always resolved as a type. Placing the argument in a block expression can force it to be interpreted as a const argument. type N = u32;\\nstruct Foo<const N: usize>;\\n// The following is an error, because `N` is interpreted as the type alias `N`.\\nfn foo<const N: usize>() -> Foo<N> { todo!() } // ERROR\\n// Can be fixed by wrapping in braces to force it to be interpreted as the `N`\\n// const parameter:\\nfn bar<const N: usize>() -> Foo<{ N }> { todo!() } // ok [items.generics.const.variance] Unlike type and lifetime parameters, const parameters can be declared without being used inside of a parameterized item, with the exception of implementations as described in generic implementations : // ok\\nstruct Foo<const N: usize>;\\nenum Bar<const M: usize> { A, B } // ERROR: unused parameter\\nstruct Baz<T>;\\nstruct Biz<\'a>;\\nstruct Unconstrained;\\nimpl<const N: usize> Unconstrained {} [items.generics.const.exhaustiveness] When resolving a trait bound obligation, the exhaustiveness of all implementations of const parameters is not considered when determining if the bound is satisfied. For example, in the following, even though all possible const values for the bool type are implemented, it is still an error that the trait bound is not satisfied: struct Foo<const B: bool>;\\ntrait Bar {}\\nimpl Bar for Foo<true> {}\\nimpl Bar for Foo<false> {} fn needs_bar(_: impl Bar) {}\\nfn generic<const B: bool>() { let v = Foo::<B>; needs_bar(v); // ERROR: trait bound `Foo<B>: Bar` is not satisfied\\n} [items.generics.where]","breadcrumbs":"Items  Generic parameters  Const generics","id":"165","title":"Const generics"},"166":{"body":"[items.generics.where.syntax] Syntax WhereClause  where ( WhereClauseItem , )* WhereClauseItem ? WhereClauseItem  LifetimeWhereClauseItem | TypeBoundWhereClauseItem LifetimeWhereClauseItem  Lifetime : LifetimeBounds TypeBoundWhereClauseItem  ForLifetimes ? Type : TypeParamBounds ? Show Railroad WhereClause where WhereClauseItem , WhereClauseItem WhereClauseItem LifetimeWhereClauseItem TypeBoundWhereClauseItem LifetimeWhereClauseItem Lifetime : LifetimeBounds TypeBoundWhereClauseItem ForLifetimes Type : TypeParamBounds [items.generics.where.intro] Where clauses provide another way to specify bounds on type and lifetime parameters as well as a way to specify bounds on types that aren\'t type parameters. [items.generics.where.higher-ranked-lifetimes] The for keyword can be used to introduce higher-ranked lifetimes . It only allows LifetimeParam parameters. struct A<T>\\nwhere T: Iterator, // Could use A<T: Iterator> instead T::Item: Copy, // Bound on an associated type String: PartialEq<T>, // Bound on `String`, using the type parameter i32: Default, // Allowed, but not useful\\n{ f: T,\\n} [items.generics.attributes]","breadcrumbs":"Items  Generic parameters  Where clauses","id":"166","title":"Where clauses"},"167":{"body":"Generic lifetime and type parameters allow attributes on them. There are no built-in attributes that do anything in this position, although custom derive attributes may give meaning to it. This example shows using a custom derive attribute to modify the meaning of a generic parameter. // Assume that the derive for MyFlexibleClone declared `my_flexible_clone` as\\n// an attribute it understands.\\n#[derive(MyFlexibleClone)]\\nstruct Foo<#[my_flexible_clone(unbounded)] H> { a: *const H\\n}","breadcrumbs":"Items  Generic parameters  Attributes","id":"167","title":"Attributes"},"168":{"body":"[items.associated] [items.associated.syntax] Syntax AssociatedItem  OuterAttribute * ( MacroInvocationSemi | ( Visibility ? ( TypeAlias | ConstantItem | Function ) ) ) Show Railroad AssociatedItem OuterAttribute MacroInvocationSemi Visibility TypeAlias ConstantItem Function [items.associated.intro] Associated Items are the items declared in traits or defined in implementations . They are called this because they are defined on an associate type  the type in the implementation. [items.associated.kinds] They are a subset of the kinds of items you can declare in a module. Specifically, there are associated functions (including methods), associated types , and associated constants . [items.associated.related] Associated items are useful when the associated item is logically related to the associating item. For example, the is_some method on Option is intrinsically related to Options, so should be associated. [items.associated.decl-def] Every associated item kind comes in two varieties: definitions that contain the actual implementation and declarations that declare signatures for definitions. [items.associated.trait-items] It is the declarations that make up the contract of traits and what is available on generic types. [items.associated.fn]","breadcrumbs":"Items  Associated items  Associated items","id":"168","title":"Associated items"},"169":{"body":"[items.associated.fn.intro] Associated functions are functions associated with a type. [items.associated.fn.decl] An associated function declaration declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a ;. [items.associated.name] The identifier is the name of the function. [items.associated.same-signature] The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations\'s. [items.associated.fn.def] An associated function definition defines a function associated with another type. It is written the same as a function item . Note A common example is an associated function named new that returns a value of the type with which it is associated. struct Struct { field: i32\\n} impl Struct { fn new() -> Struct { Struct { field: 0i32 } }\\n} fn main () { let _struct = Struct::new();\\n} [items.associated.fn.qualified-self] When the associated function is declared on a trait, the function can also be called with a path that is a path to the trait appended by the name of the trait. When this happens, it is substituted for <_ as Trait>::function_name. trait Num { fn from_i32(n: i32) -> Self;\\n} impl Num for f64 { fn from_i32(n: i32) -> f64 { n as f64 }\\n} // These 4 are all equivalent in this case.\\nlet _: f64 = Num::from_i32(42);\\nlet _: f64 = <_ as Num>::from_i32(42);\\nlet _: f64 = <f64 as Num>::from_i32(42);\\nlet _: f64 = f64::from_i32(42); [items.associated.fn.method]","breadcrumbs":"Items  Associated items  Associated functions and methods","id":"169","title":"Associated functions and methods"},"17":{"body":"[lex.keywords] Rust divides keywords into three categories: strict reserved weak [lex.keywords.strict]","breadcrumbs":"Lexical structure  Keywords  Keywords","id":"17","title":"Keywords"},"170":{"body":"[items.associated.fn.method.intro] Associated functions whose first parameter is named self are called methods and may be invoked using the method call operator , for example, x.foo(), as well as the usual function call notation. [items.associated.fn.method.self-ty] If the type of the self parameter is specified, it is limited to types resolving to one generated by the following grammar (where \'lt denotes some arbitrary lifetime): P = &\'lt S | &\'lt mut S | Box<S> | Rc<S> | Arc<S> | Pin<P>\\nS = Self | P The Self terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias Self, other type aliases, or associated type projections resolving to the implementing type. # use std::rc::Rc;\\n# use std::sync::Arc;\\n# use std::pin::Pin;\\n// Examples of methods implemented on struct `Example`.\\nstruct Example;\\ntype Alias = Example;\\ntrait Trait { type Output; }\\nimpl Trait for Example { type Output = Example; }\\nimpl Example { fn by_value(self: Self) {} fn by_ref(self: &Self) {} fn by_ref_mut(self: &mut Self) {} fn by_box(self: Box<Self>) {} fn by_rc(self: Rc<Self>) {} fn by_arc(self: Arc<Self>) {} fn by_pin(self: Pin<&Self>) {} fn explicit_type(self: Arc<Example>) {} fn with_lifetime<\'a>(self: &\'a Self) {} fn nested<\'a>(self: &mut &\'a Arc<Rc<Box<Alias>>>) {} fn via_projection(self: <Example as Trait>::Output) {}\\n} [associated.fn.method.self-pat-shorthands] Shorthand syntax can be used without specifying a type, which have the following equivalents: Shorthand Equivalent self self: Self &\'lifetime self self: &\'lifetime Self &\'lifetime mut self self: &\'lifetime mut Self Note Lifetimes can be, and usually are, elided with this shorthand. [associated.fn.method.self-pat-mut] If the self parameter is prefixed with mut, it becomes a mutable variable, similar to regular parameters using a mut identifier pattern . For example: trait Changer: Sized { fn change(mut self) {} fn modify(mut self: Box<Self>) {}\\n} As an example of methods on a trait, consider the following: # type Surface = i32;\\n# type BoundingBox = i32;\\ntrait Shape { fn draw(&self, surface: Surface); fn bounding_box(&self) -> BoundingBox;\\n} This defines a trait with two methods. All values that have implementations of this trait while the trait is in scope can have their draw and bounding_box methods called. # type Surface = i32;\\n# type BoundingBox = i32;\\n# trait Shape {\\n# fn draw(&self, surface: Surface);\\n# fn bounding_box(&self) -> BoundingBox;\\n# }\\n#\\nstruct Circle { // ...\\n} impl Shape for Circle { // ...\\n# fn draw(&self, _: Surface) {}\\n# fn bounding_box(&self) -> BoundingBox { 0i32 }\\n} # impl Circle {\\n# fn new() -> Circle { Circle{} }\\n# }\\n#\\nlet circle_shape = Circle::new();\\nlet bounding_box = circle_shape.bounding_box(); [items.associated.fn.params.edition2018] 2018 Edition differences In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. fn foo(u8)). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name. [items.associated.fn.param-attributes] Attributes on method parameters Attributes on method parameters follow the same rules and restrictions as regular function parameters . [items.associated.type]","breadcrumbs":"Items  Associated items  Methods","id":"170","title":"Methods"},"171":{"body":"[items.associated.type.intro] Associated types are type aliases associated with another type. [items.associated.type.restrictions] Associated types cannot be defined in inherent implementations nor can they be given a default implementation in traits. [items.associated.type.decl] An associated type declaration declares a signature for associated type definitions. It is written in one of the following forms, where Assoc is the name of the associated type, Params is a comma-separated list of type, lifetime or const parameters, Bounds is a plus-separated list of trait bounds that the associated type must meet, and WhereBounds is a comma-separated list of bounds that the parameters must meet: type Assoc;\\ntype Assoc: Bounds;\\ntype Assoc<Params>;\\ntype Assoc<Params>: Bounds;\\ntype Assoc<Params> where WhereBounds;\\ntype Assoc<Params>: Bounds where WhereBounds; [items.associated.type.name] The identifier is the name of the declared type alias. [items.associated.type.impl-fulfillment] The optional trait bounds must be fulfilled by the implementations of the type alias. [items.associated.type.sized] There is an implicit Sized bound on associated types that can be relaxed using the special ?Sized bound. [items.associated.type.def] An associated type definition defines a type alias for the implementation of a trait on a type [items.associated.type.def.restriction] They are written similarly to an associated type declaration , but cannot contain Bounds, but instead must contain a Type: type Assoc = Type;\\ntype Assoc<Params> = Type; // the type `Type` here may reference `Params`\\ntype Assoc<Params> = Type where WhereBounds;\\ntype Assoc<Params> where WhereBounds = Type; // deprecated, prefer the form above [items.associated.type.alias] If a type Item has an associated type Assoc from a trait Trait, then <Item as Trait>::Assoc is a type that is an alias of the type specified in the associated type definition [items.associated.type.param] Furthermore, if Item is a type parameter, then Item::Assoc can be used in type parameters. [items.associated.type.generic] Associated types may include generic parameters and where clauses ; these are often referred to as generic associated types , or GATs . If the type Thing has an associated type Item from a trait Trait with the generics <\'a> , the type can be named like <Thing as Trait>::Item<\'x>, where \'x is some lifetime in scope. In this case, \'x will be used wherever \'a appears in the associated type definitions on impls. trait AssociatedType { // Associated type declaration type Assoc;\\n} struct Struct; struct OtherStruct; impl AssociatedType for Struct { // Associated type definition type Assoc = OtherStruct;\\n} impl OtherStruct { fn new() -> OtherStruct { OtherStruct }\\n} fn main() { // Usage of the associated type to refer to OtherStruct as <Struct as AssociatedType>::Assoc let _other_struct: OtherStruct = <Struct as AssociatedType>::Assoc::new();\\n} An example of associated types with generics and where clauses: struct ArrayLender<\'a, T>(&\'a mut [T; 16]); trait Lend { // Generic associated type declaration type Lender<\'a> where Self: \'a; fn lend<\'a>(&\'a mut self) -> Self::Lender<\'a>;\\n} impl<T> Lend for [T; 16] { // Generic associated type definition type Lender<\'a> = ArrayLender<\'a, T> where Self: \'a; fn lend<\'a>(&\'a mut self) -> Self::Lender<\'a> { ArrayLender(self) }\\n} fn borrow<\'a, T: Lend>(array: &\'a mut T) -> <T as Lend>::Lender<\'a> { array.lend()\\n} fn main() { let mut array = [0usize; 16]; let lender = borrow(&mut array);\\n}","breadcrumbs":"Items  Associated items  Associated types","id":"171","title":"Associated types"},"172":{"body":"Consider the following example of a Container trait. Notice that the type is available for use in the method signatures: trait Container { type E; fn empty() -> Self; fn insert(&mut self, elem: Self::E);\\n} In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type E. Here\'s an implementation of Container for the standard library type Vec: # trait Container {\\n# type E;\\n# fn empty() -> Self;\\n# fn insert(&mut self, elem: Self::E);\\n# }\\nimpl<T> Container for Vec<T> { type E = T; fn empty() -> Vec<T> { Vec::new() } fn insert(&mut self, x: T) { self.push(x); }\\n}","breadcrumbs":"Items  Associated items  Associated types container example","id":"172","title":"Associated types container example"},"173":{"body":"In this example: # use std::fmt::Debug;\\ntrait Example { type Output<T>: Ord where T: Debug;\\n} Given a reference to the associated type like <X as Example>::Output<Y>, the associated type itself must be Ord, and the type Y must be Debug. [items.associated.type.generic-where-clause]","breadcrumbs":"Items  Associated items  Relationship between Bounds and WhereBounds","id":"173","title":"Relationship between Bounds and WhereBounds"},"174":{"body":"[items.associated.type.generic-where-clause.intro] Generic associated type declarations on traits currently may require a list of where clauses, dependent on functions in the trait and how the GAT is used. These rules may be loosened in the future; updates can be found on the generic associated types initiative repository . [items.associated.type.generic-where-clause.valid-fn] In a few words, these where clauses are required in order to maximize the allowed definitions of the associated type in impls. To do this, any clauses that can be proven to hold on functions (using the parameters of the function or trait) where a GAT appears as an input or output must also be written on the GAT itself. trait LendingIterator { type Item<\'x> where Self: \'x; fn next<\'a>(&\'a mut self) -> Self::Item<\'a>;\\n} In the above, on the next function, we can prove that Self: \'a, because of the implied bounds from &\'a mut self; therefore, we must write the equivalent bound on the GAT itself: where Self: \'x. [items.associated.type.generic-where-clause.intersection] When there are multiple functions in a trait that use the GAT, then the intersection of the bounds from the different functions are used, rather than the union. trait Check<T> { type Checker<\'x>; fn create_checker<\'a>(item: &\'a T) -> Self::Checker<\'a>; fn do_check(checker: Self::Checker<\'_>);\\n} In this example, no bounds are required on the type Checker<\'a>;. While we know that T: \'a on create_checker, we do not know that on do_check. However, if do_check was commented out, then the where T: \'x bound would be required on Checker. [items.associated.type.generic-where-clause.forward] The bounds on associated types also propagate required where clauses. trait Iterable { type Item<\'a> where Self: \'a; type Iterator<\'a>: Iterator<Item = Self::Item<\'a>> where Self: \'a; fn iter<\'a>(&\'a self) -> Self::Iterator<\'a>;\\n} Here, where Self: \'a is required on Item because of iter. However, Item is used in the bounds of Iterator, the where Self: \'a clause is also required there. [items.associated.type.generic-where-clause.static] Finally, any explicit uses of \'static on GATs in the trait do not count towards the required bounds. trait StaticReturn { type Y<\'a>; fn foo(&self) -> Self::Y<\'static>;\\n} [items.associated.const]","breadcrumbs":"Items  Associated items  Required where clauses on generic associated types","id":"174","title":"Required where clauses on generic associated types"},"175":{"body":"[items.associated.const.intro] Associated constants are constants associated with a type. [items.associated.const.decl] An associated constant declaration declares a signature for associated constant definitions. It is written as const, then an identifier, then :, then a type, finished by a ;. [items.associated.const.name] The identifier is the name of the constant used in the path. The type is the type that the definition has to implement. [items.associated.const.def] An associated constant definition defines a constant associated with a type. It is written the same as a constant item . [items.associated.const.eval] Associated constant definitions undergo constant evaluation only when referenced. Further, definitions that include generic parameters are evaluated after monomorphization. struct Struct;\\nstruct GenericStruct<const ID: i32>; impl Struct { // Definition not immediately evaluated const PANIC: () = panic!(\\"compile-time panic\\");\\n} impl<const ID: i32> GenericStruct<ID> { // Definition not immediately evaluated const NON_ZERO: () = if ID == 0 { panic!(\\"contradiction\\") };\\n} fn main() { // Referencing Struct::PANIC causes compilation error let _ = Struct::PANIC; // Fine, ID is not 0 let _ = GenericStruct::<1>::NON_ZERO; // Compilation error from evaluating NON_ZERO with ID=0 let _ = GenericStruct::<0>::NON_ZERO;\\n}","breadcrumbs":"Items  Associated items  Associated constants","id":"175","title":"Associated constants"},"176":{"body":"A basic example: trait ConstantId { const ID: i32;\\n} struct Struct; impl ConstantId for Struct { const ID: i32 = 1;\\n} fn main() { assert_eq!(1, Struct::ID);\\n} Using default values: trait ConstantIdDefault { const ID: i32 = 1;\\n} struct Struct;\\nstruct OtherStruct; impl ConstantIdDefault for Struct {} impl ConstantIdDefault for OtherStruct { const ID: i32 = 5;\\n} fn main() { assert_eq!(1, Struct::ID); assert_eq!(5, OtherStruct::ID);\\n}","breadcrumbs":"Items  Associated items  Associated constants examples","id":"176","title":"Associated constants examples"},"177":{"body":"[attributes] [attributes.syntax] Syntax InnerAttribute  # ! [ Attr ] OuterAttribute  # [ Attr ] Attr  SimplePath AttrInput ? | unsafe ( SimplePath AttrInput ? ) AttrInput  DelimTokenTree | = Expression Show Railroad InnerAttribute # ! [ Attr ] OuterAttribute # [ Attr ] Attr SimplePath AttrInput unsafe ( SimplePath AttrInput ) AttrInput DelimTokenTree = Expression [attributes.intro] An attribute is a general, free-form metadatum that is interpreted according to name, convention, language, and compiler version. Attributes are modeled on Attributes in ECMA-335 , with the syntax coming from ECMA-334 (C#). [attributes.inner] Inner attributes , written with a bang (!) after the hash (#), apply to the item that the attribute is declared within. Outer attributes , written without the bang after the hash, apply to the thing that follows the attribute. [attributes.input] The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (=) followed by an expression. See the meta item syntax below for more details. [attributes.safety] An attribute may be unsafe to apply. To avoid undefined behavior when using these attributes, certain obligations that cannot be checked by the compiler must be met. To assert these have been, the attribute is wrapped in unsafe(..), e.g. #[unsafe(no_mangle)]. The following attributes are unsafe: export_name link_section naked no_mangle [attributes.kind] Attributes can be classified into the following kinds: Built-in attributes Proc macro attributes Derive macro helper attributes Tool attributes [attributes.allowed-position] Attributes may be applied to many things in the language: All item declarations accept outer attributes while external blocks , functions , implementations , and modules accept inner attributes. Most statements accept outer attributes (see Expression Attributes for limitations on expression statements). Block expressions accept outer and inner attributes, but only when they are the outer expression of an expression statement or the final expression of another block expression. Enum variants and struct and union fields accept outer attributes. Match expression arms accept outer attributes. Generic lifetime or type parameter accept outer attributes. Expressions accept outer attributes in limited situations, see Expression Attributes for details. Function , closure and function pointer parameters accept outer attributes. This includes attributes on variadic parameters denoted with ... in function pointers and external blocks . Some examples of attributes: // General metadata applied to the enclosing module or crate.\\n#![crate_type = \\"lib\\"] // A function marked as a unit test\\n#[test]\\nfn test_foo() { /* ... */\\n} // A conditionally-compiled module\\n#[cfg(target_os = \\"linux\\")]\\nmod bar { /* ... */\\n} // A lint attribute used to suppress a warning/error\\n#[allow(non_camel_case_types)]\\ntype int8_t = i8; // Inner attribute applies to the entire function.\\nfn some_unused_variables() { #![allow(unused_variables)] let x = (); let y = (); let z = ();\\n} [attributes.meta]","breadcrumbs":"Attributes  Attributes","id":"177","title":"Attributes"},"178":{"body":"[attributes.meta.intro] A \\"meta item\\" is the syntax used for the Attr rule by most built-in attributes . It has the following grammar: [attributes.meta.syntax] Syntax MetaItem  SimplePath | SimplePath = Expression | SimplePath ( MetaSeq ? ) MetaSeq  MetaItemInner ( , MetaItemInner )* ,? MetaItemInner  MetaItem | Expression Show Railroad MetaItem SimplePath SimplePath = Expression SimplePath ( MetaSeq ) MetaSeq MetaItemInner , MetaItemInner , MetaItemInner MetaItem Expression [attributes.meta.literal-expr] Expressions in meta items must macro-expand to literal expressions, which must not include integer or float type suffixes. Expressions which are not literal expressions will be syntactically accepted (and can be passed to proc-macros), but will be rejected after parsing. [attributes.meta.order] Note that if the attribute appears within another macro, it will be expanded after that outer macro. For example, the following code will expand the Serialize proc-macro first, which must preserve the include_str! call in order for it to be expanded: #[derive(Serialize)]\\nstruct Foo { #[doc = include_str!(\\"x.md\\")] x: u32\\n} [attributes.meta.order-macro] Additionally, macros in attributes will be expanded only after all other attributes applied to the item: #[macro_attr1] // expanded first\\n#[doc = mac!()] // `mac!` is expanded fourth.\\n#[macro_attr2] // expanded second\\n#[derive(MacroDerive1, MacroDerive2)] // expanded third\\nfn foo() {} [attributes.meta.builtin] Various built-in attributes use different subsets of the meta item syntax to specify their inputs. The following grammar rules show some commonly used forms: [attributes.meta.builtin.syntax] Syntax MetaWord  IDENTIFIER MetaNameValueStr  IDENTIFIER = ( STRING_LITERAL | RAW_STRING_LITERAL ) MetaListPaths  IDENTIFIER ( ( SimplePath ( , SimplePath )* ,? )? ) MetaListIdents  IDENTIFIER ( ( IDENTIFIER ( , IDENTIFIER )* ,? )? ) MetaListNameValueStr  IDENTIFIER ( ( MetaNameValueStr ( , MetaNameValueStr )* ,? )? ) Show Railroad MetaWord IDENTIFIER MetaNameValueStr IDENTIFIER = STRING_LITERAL RAW_STRING_LITERAL MetaListPaths IDENTIFIER ( SimplePath , SimplePath , ) MetaListIdents IDENTIFIER ( IDENTIFIER , IDENTIFIER , ) MetaListNameValueStr IDENTIFIER ( MetaNameValueStr , MetaNameValueStr , ) Some examples of meta items are: Style Example MetaWord no_std MetaNameValueStr doc = \\"example\\" MetaListPaths allow(unused, clippy::inline_always) MetaListIdents macro_use(foo, bar) MetaListNameValueStr link(name = \\"CoreFoundation\\", kind = \\"framework\\") [attributes.activity]","breadcrumbs":"Attributes  Meta item attribute syntax","id":"178","title":"Meta item attribute syntax"},"179":{"body":"[attributes.activity.intro] An attribute is either active or inert. During attribute processing, active attributes remove themselves from the thing they are on while inert attributes stay on. The cfg and cfg_attr attributes are active. Attribute macros are active. All other attributes are inert. [attributes.tool]","breadcrumbs":"Attributes  Active and inert attributes","id":"179","title":"Active and inert attributes"},"18":{"body":"[lex.keywords.strict.intro] These keywords can only be used in their correct contexts. They cannot be used as the names of: Items Variables and function parameters Fields and variants Type parameters Lifetime parameters or loop labels Macros or attributes Macro placeholders Crates [lex.keywords.strict.list] The following keywords are in all editions: as async await break const continue crate dyn else enum extern false fn for if impl in let loop match mod move mut pub ref return self Self static struct super trait true type unsafe use where while [lex.keywords.strict.edition2018] 2018 Edition differences The following keywords were added in the 2018 edition: async await dyn [lex.keywords.reserved]","breadcrumbs":"Lexical structure  Keywords  Strict keywords","id":"18","title":"Strict keywords"},"180":{"body":"[attributes.tool.intro] The compiler may allow attributes for external tools where each tool resides in its own module in the tool prelude . The first segment of the attribute path is the name of the tool, with one or more additional segments whose interpretation is up to the tool. [attributes.tool.ignored] When a tool is not in use, the tool\'s attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes. [attributes.tool.prelude] Tool attributes are not available if the no_implicit_prelude attribute is used. // Tells the rustfmt tool to not format the following element.\\n#[rustfmt::skip]\\nstruct S {\\n} // Controls the \\"cyclomatic complexity\\" threshold for the clippy tool.\\n#[clippy::cyclomatic_complexity = \\"100\\"]\\npub fn f() {} Note rustc currently recognizes the tools \\"clippy\\", \\"rustfmt\\", \\"diagnostic\\", \\"miri\\" and \\"rust_analyzer\\". [attributes.builtin]","breadcrumbs":"Attributes  Tool attributes","id":"180","title":"Tool attributes"},"181":{"body":"The following is an index of all built-in attributes. Conditional compilation cfg --- Controls conditional compilation. cfg_attr --- Conditionally includes attributes. Testing test --- Marks a function as a test. ignore --- Disables a test function. should_panic --- Indicates a test should generate a panic. Derive derive --- Automatic trait implementations. automatically_derived --- Marker for implementations created by derive. Macros macro_export --- Exports a macro_rules macro for cross-crate usage. macro_use --- Expands macro visibility, or imports macros from other crates. proc_macro --- Defines a function-like macro. proc_macro_derive --- Defines a derive macro. proc_macro_attribute --- Defines an attribute macro. Diagnostics allow , expect , warn , deny , forbid --- Alters the default lint level. deprecated --- Generates deprecation notices. must_use --- Generates a lint for unused values. diagnostic::on_unimplemented --- Hints the compiler to emit a certain error message if a trait is not implemented. diagnostic::do_not_recommend --- Hints the compiler to not show a certain trait impl in error messages. ABI, linking, symbols, and FFI link --- Specifies a native library to link with an extern block. link_name --- Specifies the name of the symbol for functions or statics in an extern block. link_ordinal --- Specifies the ordinal of the symbol for functions or statics in an extern block. no_link --- Prevents linking an extern crate. repr --- Controls type layout. crate_type --- Specifies the type of crate (library, executable, etc.). no_main --- Disables emitting the main symbol. export_name --- Specifies the exported symbol name for a function or static. link_section --- Specifies the section of an object file to use for a function or static. no_mangle --- Disables symbol name encoding. used --- Forces the compiler to keep a static item in the output object file. crate_name --- Specifies the crate name. Code generation inline --- Hint to inline code. cold --- Hint that a function is unlikely to be called. naked --- Prevent the compiler from emitting a function prologue and epilogue. no_builtins --- Disables use of certain built-in functions. target_feature --- Configure platform-specific code generation. track_caller --- Pass the parent call location to std::panic::Location::caller(). instruction_set --- Specify the instruction set used to generate a functions code Documentation doc --- Specifies documentation. See The Rustdoc Book for more information. Doc comments are transformed into doc attributes. Preludes no_std --- Removes std from the prelude. no_implicit_prelude --- Disables prelude lookups within a module. Modules path --- Specifies the filename for a module. Limits recursion_limit --- Sets the maximum recursion limit for certain compile-time operations. type_length_limit --- Sets the maximum size of a polymorphic type. Runtime panic_handler --- Sets the function to handle panics. global_allocator --- Sets the global memory allocator. windows_subsystem --- Specifies the windows subsystem to link with. Features feature --- Used to enable unstable or experimental compiler features. See The Unstable Book for features implemented in rustc. Type System non_exhaustive --- Indicate that a type will have more fields/variants added in future. Debugger debugger_visualizer --- Embeds a file that specifies debugger output for a type. collapse_debuginfo --- Controls how macro invocations are encoded in debuginfo.","breadcrumbs":"Attributes  Built-in attributes index","id":"181","title":"Built-in attributes index"},"182":{"body":"[attributes.testing] The following attributes are used for specifying functions for performing tests. Compiling a crate in \\"test\\" mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the test conditional compilation option . [attributes.testing.test]","breadcrumbs":"Attributes  Testing  Testing attributes","id":"182","title":"Testing attributes"},"183":{"body":"[attributes.testing.test.intro] The test attribute marks a function to be executed as a test. Example # pub fn add(left: u64, right: u64) -> u64 { left + right }\\n#[test]\\nfn it_works() { let result = add(2, 2); assert_eq!(result, 4);\\n} [attributes.testing.test.syntax] The test attribute uses the MetaWord syntax. [attributes.testing.test.allowed-positions] The test attribute may only be applied to free functions that are monomorphic, that take no arguments, and where the return type implements the Termination trait. Note Some of types that implement the Termination trait include: () Result<T, E> where T: Termination, E: Debug [attributes.testing.test.duplicates] Only the first use of test on a function has effect. Note rustc lints against any use following the first. This may become an error in the future. [attributes.testing.test.stdlib] The test attribute is exported from the standard library prelude as std::prelude::v1::test . [attributes.testing.test.enabled] These functions are only compiled when in test mode. Note The test mode is enabled by passing the --test argument to rustc or using cargo test. [attributes.testing.test.success] The test harness calls the returned value\'s report method, and classifies the test as passed or failed depending on whether the resulting ExitCode represents successful termination. In particular: Tests that return () pass as long as they terminate and do not panic. Tests that return a Result<(), E> pass as long as they return Ok(()). Tests that return ExitCode::SUCCESS pass, and tests that return ExitCode::FAILURE fail. Tests that do not terminate neither pass nor fail. Example # use std::io;\\n# fn setup_the_thing() -> io::Result<i32> { Ok(1) }\\n# fn do_the_thing(s: &i32) -> io::Result<()> { Ok(()) }\\n#[test]\\nfn test_the_thing() -> io::Result<()> { let state = setup_the_thing()?; // expected to succeed do_the_thing(&state)?; // expected to succeed Ok(())\\n} [attributes.testing.ignore]","breadcrumbs":"Attributes  Testing  The test attribute","id":"183","title":"The test attribute"},"184":{"body":"[attributes.testing.ignore.intro] The ignore attribute can be used with the test attribute to tell the test harness to not execute that function as a test. Example #[test]\\n#[ignore]\\nfn check_thing() { // \\n} Note The rustc test harness supports the --include-ignored flag to force ignored tests to be run. [attributes.testing.ignore.syntax] The ignore attribute uses the MetaWord and MetaNameValueStr syntaxes. [attributes.testing.ignore.reason] The MetaNameValueStr form of the ignore attribute provides a way to specify a reason why the test is ignored. Example #[test]\\n#[ignore = \\"not yet implemented\\"]\\nfn mytest() { // \\n} [attributes.testing.ignore.allowed-positions] The ignore attribute may only be applied to functions annotated with the test attribute. Note rustc ignores use in other positions but lints against it. This may become an error in the future. [attributes.testing.ignore.duplicates] Only the first use of ignore on a function has effect. Note rustc lints against any use following the first. This may become an error in the future. [attributes.testing.ignore.behavior] Ignored tests are still compiled when in test mode, but they are not executed. [attributes.testing.should_panic]","breadcrumbs":"Attributes  Testing  The ignore attribute","id":"184","title":"The ignore attribute"},"185":{"body":"[attributes.testing.should_panic.intro] The should_panic attribute causes a test to pass only if the test function to which the attribute is applied panics. Example #[test]\\n#[should_panic(expected = \\"values don\'t match\\")]\\nfn mytest() { assert_eq!(1, 2, \\"values don\'t match\\");\\n} [attributes.testing.should_panic.syntax] The should_panic attribute has these forms: MetaWord Example #[test]\\n#[should_panic]\\nfn mytest() { panic!(\\"error: some message, and more\\"); } MetaNameValueStr --- The given string must appear within the panic message for the test to pass. Example #[test]\\n#[should_panic = \\"some message\\"]\\nfn mytest() { panic!(\\"error: some message, and more\\"); } MetaListNameValueStr --- As with the MetaNameValueStr syntax, the given string must appear within the panic message. Example #[test]\\n#[should_panic(expected = \\"some message\\")]\\nfn mytest() { panic!(\\"error: some message, and more\\"); } [attributes.testing.should_panic.allowed-positions] The should_panic attribute may only be applied to functions annotated with the test attribute. Note rustc ignores use in other positions but lints against it. This may become an error in the future. [attributes.testing.should_panic.duplicates] Only the first use of should_panic on a function has effect. Note rustc lints against any use following the first with a future-compatibility warning. This may become an error in the future. [attributes.testing.should_panic.expected] When the MetaNameValueStr form or the MetaListNameValueStr form with the expected key is used, the given string must appear somewhere within the panic message for the test to pass. [attributes.testing.should_panic.return] The return type of the test function must be ().","breadcrumbs":"Attributes  Testing  The should_panic attribute","id":"185","title":"The should_panic attribute"},"186":{"body":"[attributes.derive] [attributes.derive.intro] The derive attribute invokes one or more derive macros , allowing new items to be automatically generated for data structures. You can create derive macros with procedural macros . Example The PartialEq derive macro emits an implementation of PartialEq for Foo<T> where T: PartialEq. The Clone derive macro does likewise for Clone . #[derive(PartialEq, Clone)]\\nstruct Foo<T> { a: i32, b: T,\\n} The generated impl items are equivalent to: # struct Foo<T> { a: i32, b: T }\\nimpl<T: PartialEq> PartialEq for Foo<T> { fn eq(&self, other: &Foo<T>) -> bool { self.a == other.a && self.b == other.b }\\n} impl<T: Clone> Clone for Foo<T> { fn clone(&self) -> Self { Foo { a: self.a.clone(), b: self.b.clone() } }\\n} [attributes.derive.syntax] The derive attribute uses the MetaListPaths syntax to specify a list of paths to derive macros to invoke. [attributes.derive.allowed-positions] The derive attribute may only be applied to structs , enums , and unions . [attributes.derive.duplicates] The derive attribute may be used any number of times on an item. All derive macros listed in all attributes are invoked. [attributes.derive.stdlib] The derive attribute is exported in the standard library prelude as core::prelude::v1::derive . [attributes.derive.built-in] Built-in derives are defined in the language prelude . The list of built-in derives are: Clone Copy Debug Default Eq Hash Ord PartialEq PartialOrd [attributes.derive.built-in-automatically_derived] The built-in derives include the automatically_derived attribute on the implementations they generate. [attributes.derive.behavior] During macro expansion, for each element in the list of derives, the corresponding derive macro expands to zero or more items . [attributes.derive.automatically_derived]","breadcrumbs":"Attributes  Derive  Derive","id":"186","title":"Derive"},"187":{"body":"[attributes.derive.automatically_derived.intro] The automatically_derived attribute is used to annotate an implementation to indicate that it was automatically created by a derive macro . It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations. Example Given #[derive(Clone)] on struct Example, the derive macro may produce: # struct Example;\\n#[automatically_derived]\\nimpl ::core::clone::Clone for Example { #[inline] fn clone(&self) -> Self { Example }\\n} [attributes.derive.automatically_derived.syntax] The automatically_derived attribute uses the MetaWord syntax. [attributes.derive.automatically_derived.allowed-positions] The automatically_derived attribute may only be applied to an implementation . Note rustc ignores use in other positions but lints against it. This may become an error in the future. [attributes.derive.automatically_derived.duplicates] Using automatically_derived more than once on an implementation has the same effect as using it once. Note rustc lints against any use following the first. [attributes.derive.automatically_derived.behavior] The automatically_derived attribute has no behavior.","breadcrumbs":"Attributes  Derive  The automatically_derived attribute","id":"187","title":"The automatically_derived attribute"},"188":{"body":"[attributes.diagnostics] The following attributes are used for controlling or generating diagnostic messages during compilation. [attributes.diagnostics.lint]","breadcrumbs":"Attributes  Diagnostics  Diagnostic attributes","id":"188","title":"Diagnostic attributes"},"189":{"body":"A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. [attributes.diagnostics.lint.level] The lint attributes allow, expect, warn, deny, and forbid use the MetaListPaths syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies. For any lint check C: [attributes.diagnostics.lint.allow] #[allow(C)] overrides the check for C so that violations will go unreported. [attributes.diagnostics.lint.expect] #[expect(C)] indicates that lint C is expected to be emitted. The attribute will suppress the emission of C or issue a warning, if the expectation is unfulfilled. [attributes.diagnostics.lint.warn] #[warn(C)] warns about violations of C but continues compilation. [attributes.diagnostics.lint.deny] #[deny(C)] signals an error after encountering a violation of C, [attributes.diagnostics.lint.forbid] #[forbid(C)] is the same as deny(C), but also forbids changing the lint level afterwards, Note The lint checks supported by rustc can be found via rustc -W help, along with their default settings and are documented in the rustc book . pub mod m1 { // Missing documentation is ignored here #[allow(missing_docs)] pub fn undocumented_one() -> i32 { 1 } // Missing documentation signals a warning here #[warn(missing_docs)] pub fn undocumented_too() -> i32 { 2 } // Missing documentation signals an error here #[deny(missing_docs)] pub fn undocumented_end() -> i32 { 3 }\\n} [attributes.diagnostics.lint.override] Lint attributes can override the level specified from a previous attribute, as long as the level does not attempt to change a forbidden lint (except for deny, which is allowed inside a forbid context, but ignored). Previous attributes are those from a higher level in the syntax tree, or from a previous attribute on the same entity as listed in left-to-right source order. This example shows how one can use allow and warn to toggle a particular check on and off: #[warn(missing_docs)]\\npub mod m2 { #[allow(missing_docs)] pub mod nested { // Missing documentation is ignored here pub fn undocumented_one() -> i32 { 1 } // Missing documentation signals a warning here, // despite the allow above. #[warn(missing_docs)] pub fn undocumented_two() -> i32 { 2 } } // Missing documentation signals a warning here pub fn undocumented_too() -> i32 { 3 }\\n} This example shows how one can use forbid to disallow uses of allow or expect for that lint check: #[forbid(missing_docs)]\\npub mod m3 { // Attempting to toggle warning signals an error here #[allow(missing_docs)] /// Returns 2. pub fn undocumented_too() -> i32 { 2 }\\n} Note rustc allows setting lint levels on the command-line , and also supports setting caps on the lints that are reported. [attributes.diagnostics.lint.reason]","breadcrumbs":"Attributes  Diagnostics  Lint check attributes","id":"189","title":"Lint check attributes"},"19":{"body":"[lex.keywords.reserved.intro] These keywords aren\'t used yet, but they are reserved for future use. They have the same restrictions as strict keywords. The reasoning behind this is to make current programs forward compatible with future versions of Rust by forbidding them to use these keywords. [lex.keywords.reserved.list] abstract become box do final gen macro override priv try typeof unsized virtual yield [lex.keywords.reserved.edition2018] 2018 Edition differences The try keyword was added as a reserved keyword in the 2018 edition. [lex.keywords.reserved.edition2024] 2024 Edition differences The gen keyword was added as a reserved keyword in the 2024 edition. [lex.keywords.weak]","breadcrumbs":"Lexical structure  Keywords  Reserved keywords","id":"19","title":"Reserved keywords"},"190":{"body":"All lint attributes support an additional reason parameter, to give context why a certain attribute was added. This reason will be displayed as part of the lint message if the lint is emitted at the defined level. // `keyword_idents` is allowed by default. Here we deny it to\\n// avoid migration of identifiers when we update the edition.\\n#![deny( keyword_idents, reason = \\"we want to avoid these idents to be future compatible\\"\\n)] // This name was allowed in Rust\'s 2015 edition. We still aim to avoid\\n// this to be future compatible and not confuse end users.\\nfn dyn() {} Here is another example, where the lint is allowed with a reason: use std::path::PathBuf; pub fn get_path() -> PathBuf { // The `reason` parameter on `allow` attributes acts as documentation for the reader. #[allow(unused_mut, reason = \\"this is only modified on some platforms\\")] let mut file_name = PathBuf::from(\\"git\\"); #[cfg(target_os = \\"windows\\")] file_name.set_extension(\\"exe\\"); file_name\\n} [attributes.diagnostics.expect]","breadcrumbs":"Attributes  Diagnostics  Lint reasons","id":"190","title":"Lint reasons"},"191":{"body":"[attributes.diagnostics.expect.intro] The #[expect(C)] attribute creates a lint expectation for lint C. The expectation will be fulfilled, if a #[warn(C)] attribute at the same location would result in a lint emission. If the expectation is unfulfilled, because lint C would not be emitted, the unfulfilled_lint_expectations lint will be emitted at the attribute. fn main() { // This `#[expect]` attribute creates a lint expectation, that the `unused_variables` // lint would be emitted by the following statement. This expectation is // unfulfilled, since the `question` variable is used by the `println!` macro. // Therefore, the `unfulfilled_lint_expectations` lint will be emitted at the // attribute. #[expect(unused_variables)] let question = \\"who lives in a pineapple under the sea?\\"; println!(\\"{question}\\"); // This `#[expect]` attribute creates a lint expectation that will be fulfilled, since // the `answer` variable is never used. The `unused_variables` lint, that would usually // be emitted, is suppressed. No warning will be issued for the statement or attribute. #[expect(unused_variables)] let answer = \\"SpongeBob SquarePants!\\";\\n} [attributes.diagnostics.expect.fulfillment] The lint expectation is only fulfilled by lint emissions which have been suppressed by the expect attribute. If the lint level is modified in the scope with other level attributes like allow or warn, the lint emission will be handled accordingly and the expectation will remain unfulfilled. #[expect(unused_variables)]\\nfn select_song() { // This will emit the `unused_variables` lint at the warn level // as defined by the `warn` attribute. This will not fulfill the // expectation above the function. #[warn(unused_variables)] let song_name = \\"Crab Rave\\"; // The `allow` attribute suppresses the lint emission. This will not // fulfill the expectation as it has been suppressed by the `allow` // attribute and not the `expect` attribute above the function. #[allow(unused_variables)] let song_creator = \\"Noisestorm\\"; // This `expect` attribute will suppress the `unused_variables` lint emission // at the variable. The `expect` attribute above the function will still not // be fulfilled, since this lint emission has been suppressed by the local // expect attribute. #[expect(unused_variables)] let song_version = \\"Monstercat Release\\";\\n} [attributes.diagnostics.expect.independent] If the expect attribute contains several lints, each one is expected separately. For a lint group it\'s enough if one lint inside the group has been emitted: // This expectation will be fulfilled by the unused value inside the function\\n// since the emitted `unused_variables` lint is inside the `unused` lint group.\\n#[expect(unused)]\\npub fn thoughts() { let unused = \\"I\'m running out of examples\\";\\n} pub fn another_example() { // This attribute creates two lint expectations. The `unused_mut` lint will be // suppressed and with that fulfill the first expectation. The `unused_variables` // wouldn\'t be emitted, since the variable is used. That expectation will therefore // be unsatisfied, and a warning will be emitted. #[expect(unused_mut, unused_variables)] let mut link = \\"https://www.rust-lang.org/\\"; println!(\\"Welcome to our community: {link}\\");\\n} Note The behavior of #[expect(unfulfilled_lint_expectations)] is currently defined to always generate the unfulfilled_lint_expectations lint. [attributes.diagnostics.lint.group]","breadcrumbs":"Attributes  Diagnostics  The #[expect] attribute","id":"191","title":"The #[expect] attribute"},"192":{"body":"Lints may be organized into named groups so that the level of related lints can be adjusted together. Using a named group is equivalent to listing out the lints within that group. // This allows all lints in the \\"unused\\" group.\\n#[allow(unused)]\\n// This overrides the \\"unused_must_use\\" lint from the \\"unused\\"\\n// group to deny.\\n#[deny(unused_must_use)]\\nfn example() { // This does not generate a warning because the \\"unused_variables\\" // lint is in the \\"unused\\" group. let x = 1; // This generates an error because the result is unused and // \\"unused_must_use\\" is marked as \\"deny\\". std::fs::remove_file(\\"some_file\\"); // ERROR: unused `Result` that must be used\\n} [attributes.diagnostics.lint.group.warnings] There is a special group named \\"warnings\\" which includes all lints at the \\"warn\\" level. The \\"warnings\\" group ignores attribute order and applies to all lints that would otherwise warn within the entity. # unsafe fn an_unsafe_fn() {}\\n// The order of these two attributes does not matter.\\n#[deny(warnings)]\\n// The unsafe_code lint is normally \\"allow\\" by default.\\n#[warn(unsafe_code)]\\nfn example_err() { // This is an error because the `unsafe_code` warning has // been lifted to \\"deny\\". unsafe { an_unsafe_fn() } // ERROR: usage of `unsafe` block\\n} [attributes.diagnostics.lint.tool]","breadcrumbs":"Attributes  Diagnostics  Lint groups","id":"192","title":"Lint groups"},"193":{"body":"[attributes.diagnostics.lint.tool.intro] Tool lints allows using scoped lints, to allow, warn, deny or forbid lints of certain tools. [attributes.diagnostics.lint.tool.activation] Tool lints only get checked when the associated tool is active. If a lint attribute, such as allow, references a nonexistent tool lint, the compiler will not warn about the nonexistent lint until you use the tool. Otherwise, they work just like regular lint attributes: // set the entire `pedantic` clippy lint group to warn\\n#![warn(clippy::pedantic)]\\n// silence warnings from the `filter_map` clippy lint\\n#![allow(clippy::filter_map)] fn main() { // ...\\n} // silence the `cmp_nan` clippy lint just for this function\\n#[allow(clippy::cmp_nan)]\\nfn foo() { // ...\\n} Note rustc currently recognizes the tool lints for \\" clippy \\" and \\" rustdoc \\". [attributes.diagnostics.deprecated]","breadcrumbs":"Attributes  Diagnostics  Tool lint attributes","id":"193","title":"Tool lint attributes"},"194":{"body":"[attributes.diagnostics.deprecated.intro] The deprecated attribute marks an item as deprecated. rustc will issue warnings on usage of #[deprecated] items. rustdoc will show item deprecation, including the since version and note, if available. [attributes.diagnostics.deprecated.syntax] The deprecated attribute has several forms: deprecated --- Issues a generic message. deprecated = \\"message\\" --- Includes the given string in the deprecation message. MetaListNameValueStr syntax with two optional fields: since --- Specifies a version number when the item was deprecated. rustc does not currently interpret the string, but external tools like Clippy may check the validity of the value. note --- Specifies a string that should be included in the deprecation message. This is typically used to provide an explanation about the deprecation and preferred alternatives. [attributes.diagnostic.deprecated.allowed-positions] The deprecated attribute may be applied to any item , trait item , enum variant , struct field , external block item , or macro definition . It cannot be applied to trait implementation items . When applied to an item containing other items, such as a module or implementation , all child items inherit the deprecation attribute. Here is an example: #[deprecated(since = \\"5.2.0\\", note = \\"foo was rarely used. Users should instead use bar\\")]\\npub fn foo() {} pub fn bar() {} The RFC contains motivations and more details. [attributes.diagnostics.must_use]","breadcrumbs":"Attributes  Diagnostics  The deprecated attribute","id":"194","title":"The deprecated attribute"},"195":{"body":"[attributes.diagnostics.must_use.intro] The must_use attribute is used to issue a diagnostic warning when a value is not \\"used\\". [attributes.diagnostics.must_use.allowed-positions] The must_use attribute can be applied to user-defined composite types ( structs , enums , and unions ), functions , and traits . [attributes.diagnostics.must_use.message] The must_use attribute may include a message by using the MetaNameValueStr syntax such as #[must_use = \\"example message\\"]. The message will be given alongside the warning. [attributes.diagnostics.must_use.type] When used on user-defined composite types, if the expression of an expression statement has that type, then the unused_must_use lint is violated. #[must_use]\\nstruct MustUse { // some fields\\n} # impl MustUse {\\n# fn new() -> MustUse { MustUse {} }\\n# }\\n#\\n// Violates the `unused_must_use` lint.\\nMustUse::new(); [attributes.diagnostics.must_use.fn] When used on a function, if the expression of an expression statement is a call expression to that function, then the unused_must_use lint is violated. #[must_use]\\nfn five() -> i32 { 5i32 } // Violates the unused_must_use lint.\\nfive(); [attributes.diagnostics.must_use.trait] When used on a trait declaration , a call expression of an expression statement to a function that returns an impl trait or a dyn trait of that trait violates the unused_must_use lint. #[must_use]\\ntrait Critical {}\\nimpl Critical for i32 {} fn get_critical() -> impl Critical { 4i32\\n} // Violates the `unused_must_use` lint.\\nget_critical(); [attributes.diagnostics.must_use.trait-function] When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait. trait Trait { #[must_use] fn use_me(&self) -> i32;\\n} impl Trait for i32 { fn use_me(&self) -> i32 { 0i32 }\\n} // Violates the `unused_must_use` lint.\\n5i32.use_me(); [attributes.diagnostics.must_use.trait-impl-function] When used on a function in a trait implementation, the attribute does nothing. Note Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement Drop and then not using that type and being the final expression of a block expression that is not used. #[must_use]\\nfn five() -> i32 { 5i32 } // None of these violate the unused_must_use lint.\\n(five(),);\\nSome(five());\\n{ five() };\\nif true { five() } else { 0i32 };\\nmatch true { _ => five()\\n}; Note It is idiomatic to use a let statement with a pattern of _ when a must-used value is purposely discarded. #[must_use]\\nfn five() -> i32 { 5i32 } // Does not violate the unused_must_use lint.\\nlet _ = five(); [attributes.diagnostic.namespace]","breadcrumbs":"Attributes  Diagnostics  The must_use attribute","id":"195","title":"The must_use attribute"},"196":{"body":"[attributes.diagnostic.namespace.intro] The #[diagnostic] attribute namespace is a home for attributes to influence compile-time error messages. The hints provided by these attributes are not guaranteed to be used. [attributes.diagnostic.namespace.unknown-invalid-syntax] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/deny_malformed_attribute.rs\\ntests/ui/diagnostic_namespace/non_existing_attributes_accepted.rs\\ntests/ui/diagnostic_namespace/suggest_typos.rs Unknown attributes in this namespace are accepted, though they may emit warnings for unused attributes. Additionally, invalid inputs to known attributes will typically be a warning (see the attribute definitions for details). This is meant to allow adding or discarding attributes and changing inputs in the future to allow changes without the need to keep the non-meaningful attributes or options working. [attributes.diagnostic.on_unimplemented]","breadcrumbs":"Attributes  Diagnostics  The diagnostic tool attribute namespace","id":"196","title":"The diagnostic tool attribute namespace"},"197":{"body":"[attributes.diagnostic.on_unimplemented.intro] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/on_unimplemented/custom-on-unimplemented-diagnostic.rs\\ntests/ui/diagnostic_namespace/on_unimplemented/error_is_shown_in_downstream_crates.rs\\ntests/ui/diagnostic_namespace/on_unimplemented/on_unimplemented_simple.rs\\ntests/ui/traits/negative-bounds/on-unimplemented.rs The #[diagnostic::on_unimplemented] attribute is a hint to the compiler to supplement the error message that would normally be generated in scenarios where a trait is required but not implemented on a type. [attributes.diagnostic.on_unimplemented.allowed-positions] The attribute should be placed on a trait declaration , though it is not an error to be located in other positions. [attributes.diagnostic.on_unimplemented.syntax] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/malformed_foreign_on_unimplemented.rs\\ntests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs\\ntests/ui/diagnostic_namespace/on_unimplemented/do_not_fail_parsing_on_invalid_options_1.rs\\ntests/ui/diagnostic_namespace/on_unimplemented/ignore_unsupported_options_and_continue_to_use_fallback.rs The attribute uses the MetaListNameValueStr syntax to specify its inputs, though any malformed input to the attribute is not considered as an error to provide both forwards and backwards compatibility. [attributes.diagnostic.on_unimplemented.keys] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/on_unimplemented/custom-on-unimplemented-diagnostic.rs\\ntests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs\\ntests/ui/diagnostic_namespace/on_unimplemented/on_unimplemented_simple.rs The following keys have the given meaning: message --- The text for the top level error message. label --- The text for the label shown inline in the broken code in the error message. note --- Provides additional notes. [attributes.diagnostic.on_unimplemented.note-repetition] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/on_unimplemented/multiple_notes.rs The note option can appear several times, which results in several note messages being emitted. [attributes.diagnostic.on_unimplemented.repetition] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/on_unimplemented/ignore_unsupported_options_and_continue_to_use_fallback.rs\\ntests/ui/diagnostic_namespace/on_unimplemented/report_warning_on_duplicated_options.rs If any of the other options appears several times the first occurrence of the relevant option specifies the actually used value. Subsequent occurrences generates a warning. [attributes.diagnostic.on_unimplemented.unknown-keys] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/on_unimplemented/do_not_fail_parsing_on_invalid_options_1.rs A warning is generated for any unknown keys. [attributes.diagnostic.on_unimplemented.format-string] All three options accept a string as an argument, interpreted using the same formatting as a std::fmt string. [attributes.diagnostic.on_unimplemented.format-parameters] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs Format parameters with the given named parameter will be replaced with the following text: {Self} --- The name of the type implementing the trait. { GenericParameterName } --- The name of the generic argument\'s type for the given generic parameter. [attributes.diagnostic.on_unimplemented.invalid-formats] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/on_unimplemented/do_not_accept_options_of_the_internal_rustc_attribute.rs Any other format parameter will generate a warning, but will otherwise be included in the string as-is. [attributes.diagnostic.on_unimplemented.invalid-string] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/on_unimplemented/broken_format.rs Invalid format strings may generate a warning, but are otherwise allowed, but may not display as intended. Format specifiers may generate a warning, but are otherwise ignored. In this example: #[diagnostic::on_unimplemented( message = \\"My Message for `ImportantTrait<{A}>` implemented for `{Self}`\\", label = \\"My Label\\", note = \\"Note 1\\", note = \\"Note 2\\"\\n)]\\ntrait ImportantTrait<A> {} fn use_my_trait(_: impl ImportantTrait<i32>) {} fn main() { use_my_trait(String::new());\\n} the compiler may generate an error message which looks like this: error[E0277]: My Message for `ImportantTrait<i32>` implemented for `String` --> src/main.rs:14:18 |\\n14 | use_my_trait(String::new()); | ------------ ^^^^^^^^^^^^^ My Label | | | required by a bound introduced by this call | = help: the trait `ImportantTrait<i32>` is not implemented for `String` = note: Note 1 = note: Note 2 [attributes.diagnostic.do_not_recommend]","breadcrumbs":"Attributes  Diagnostics  The diagnostic::on_unimplemented attribute","id":"197","title":"The diagnostic::on_unimplemented attribute"},"198":{"body":"[attributes.diagnostic.do_not_recommend.intro] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/do_not_recommend/as_expression.rs\\ntests/ui/diagnostic_namespace/do_not_recommend/nested.rs\\ntests/ui/diagnostic_namespace/do_not_recommend/simple.rs\\ntests/ui/diagnostic_namespace/do_not_recommend/stacked.rs\\ntests/ui/diagnostic_namespace/do_not_recommend/supress_suggestions_in_help.rs\\ntests/ui/diagnostic_namespace/do_not_recommend/type_mismatch.rs\\ntests/ui/diagnostic_namespace/do_not_recommend/with_lifetime.rs The #[diagnostic::do_not_recommend] attribute is a hint to the compiler to not show the annotated trait implementation as part of a diagnostic message. Note Suppressing the recommendation can be useful if you know that the recommendation would normally not be useful to the programmer. This often occurs with broad, blanket impls. The recommendation may send the programmer down the wrong path, or the trait implementation may be an internal detail that you don\'t want to expose, or the bounds may not be able to be satisfied by the programmer. For example, in an error message about a type not implementing a required trait, the compiler may find a trait implementation that would satisfy the requirements if it weren\'t for specific bounds in the trait implementation. The compiler may tell the user that there is an impl, but the problem is the bounds in the trait implementation. The #[diagnostic::do_not_recommend] attribute can be used to tell the compiler to not tell the user about the trait implementation, and instead simply tell the user the type doesn\'t implement the required trait. [attributes.diagnostic.do_not_recommend.allowed-positions] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/do_not_recommend/incorrect-locations.rs The attribute should be placed on a trait implementation item , though it is not an error to be located in other positions. [attributes.diagnostic.do_not_recommend.syntax] Tests Tests with this rule:\\ntests/ui/diagnostic_namespace/do_not_recommend/does_not_acccept_args.rs The attribute does not accept any arguments, though unexpected arguments are not considered as an error. In the following example, there is a trait called AsExpression which is used for casting arbitrary types to the Expression type used in an SQL library. There is a method called check which takes an AsExpression. # pub trait Expression {\\n# type SqlType;\\n# }\\n#\\n# pub trait AsExpression<ST> {\\n# type Expression: Expression<SqlType = ST>;\\n# }\\n#\\n# pub struct Text;\\n# pub struct Integer;\\n#\\n# pub struct Bound<T>(T);\\n# pub struct SelectInt;\\n#\\n# impl Expression for SelectInt {\\n# type SqlType = Integer;\\n# }\\n#\\n# impl<T> Expression for Bound<T> {\\n# type SqlType = T;\\n# }\\n#\\n# impl AsExpression<Integer> for i32 {\\n# type Expression = Bound<Integer>;\\n# }\\n#\\n# impl AsExpression<Text> for &\'_ str {\\n# type Expression = Bound<Text>;\\n# }\\n#\\n# impl<T> Foo for T where T: Expression {} // Uncomment this line to change the recommendation.\\n// #[diagnostic::do_not_recommend]\\nimpl<T, ST> AsExpression<ST> for T\\nwhere T: Expression<SqlType = ST>,\\n{ type Expression = T;\\n} trait Foo: Expression + Sized { fn check<T>(&self, _: T) -> <T as AsExpression<<Self as Expression>::SqlType>>::Expression where T: AsExpression<Self::SqlType>, { todo!() }\\n} fn main() { SelectInt.check(\\"bar\\");\\n} The SelectInt type\'s check method is expecting an Integer type. Calling it with an i32 type works, as it gets converted to an Integer by the AsExpression trait. However, calling it with a string does not, and generates a an error that may look like this: error[E0277]: the trait bound `&str: Expression` is not satisfied --> src/main.rs:53:15 |\\n53 | SelectInt.check(\\"bar\\"); | ^^^^^ the trait `Expression` is not implemented for `&str` | = help: the following other types implement trait `Expression`: Bound<T> SelectInt\\nnote: required for `&str` to implement `AsExpression<Integer>` --> src/main.rs:45:13 |\\n45 | impl<T, ST> AsExpression<ST> for T | ^^^^^^^^^^^^^^^^ ^\\n46 | where\\n47 | T: Expression<SqlType = ST>, | ------------------------ unsatisfied trait bound introduced here By adding the #[diagnostic::do_not_recommend] attribute to the blanket impl for AsExpression, the message changes to: error[E0277]: the trait bound `&str: AsExpression<Integer>` is not satisfied --> src/main.rs:53:15 |\\n53 | SelectInt.check(\\"bar\\"); | ^^^^^ the trait `AsExpression<Integer>` is not implemented for `&str` | = help: the trait `AsExpression<Integer>` is not implemented for `&str` but trait `AsExpression<Text>` is implemented for it = help: for that trait implementation, expected `Text`, found `Integer` The first error message includes a somewhat confusing error message about the relationship of &str and Expression, as well as the unsatisfied trait bound in the blanket impl. After adding #[diagnostic::do_not_recommend], it no longer considers the blanket impl for the recommendation. The message should be a little clearer, with an indication that a string cannot be converted to an Integer.","breadcrumbs":"Attributes  Diagnostics  The diagnostic::do_not_recommend attribute","id":"198","title":"The diagnostic::do_not_recommend attribute"},"199":{"body":"[attributes.codegen] The following attributes are used for controlling code generation. [attributes.codegen.inline]","breadcrumbs":"Attributes  Code generation  Code generation attributes","id":"199","title":"Code generation attributes"},"2":{"body":"This book does not serve as an introduction to the language. Background familiarity with the language is assumed. A separate book is available to help acquire such background familiarity. This book also does not serve as a reference to the standard library included in the language distribution. Those libraries are documented separately by extracting documentation attributes from their source code. Many of the features that one might expect to be language features are library features in Rust, so what you\'re looking for may be there, not here. Similarly, this book does not usually document the specifics of rustc as a tool or of Cargo. rustc has its own book . Cargo has a book that contains a reference . There are a few pages such as linkage that still describe how rustc works. This book also only serves as a reference to what is available in stable Rust. For unstable features being worked on, see the Unstable Book . Rust compilers, including rustc, will perform optimizations. The reference does not specify what optimizations are allowed or disallowed. Instead, think of the compiled program as a black box. You can only probe by running it, feeding it input and observing its output. Everything that happens that way must conform to what the reference says.","breadcrumbs":"Introduction  What The Reference is not","id":"2","title":"What The Reference is not"},"20":{"body":"[lex.keywords.weak.intro] These keywords have special meaning only in certain contexts. For example, it is possible to declare a variable or method with the name union. \'static macro_rules raw safe union [lex.keywords.weak.macro_rules] macro_rules is used to create custom macros . [lex.keywords.weak.union] union is used to declare a union and is only a keyword when used in a union declaration. [lex.keywords.weak.lifetime-static] \'static is used for the static lifetime and cannot be used as a generic lifetime parameter or loop label // error[E0262]: invalid lifetime parameter name: `\'static`\\nfn invalid_lifetime_parameter<\'static>(s: &\'static str) -> &\'static str { s } [lex.keywords.weak.safe] safe is used for functions and statics, which has meaning in external blocks . [lex.keywords.weak.raw] raw is used for raw borrow operators , and is only a keyword when matching a raw borrow operator form (such as &raw const expr or &raw mut expr). [lex.keywords.weak.dyn.edition2018] 2018 Edition differences In the 2015 edition, dyn is a keyword when used in a type position followed by a path that does not start with :: or <, a lifetime, a question mark, a for keyword or an opening parenthesis. Beginning in the 2018 edition, dyn has been promoted to a strict keyword.","breadcrumbs":"Lexical structure  Keywords  Weak keywords","id":"20","title":"Weak keywords"},"200":{"body":"[attributes.codegen.inline.intro] The inline attribute suggests whether a copy of the attributed function\'s code should be placed in the caller rather than generating a call to the function. Example #[inline]\\npub fn example1() {} #[inline(always)]\\npub fn example2() {} #[inline(never)]\\npub fn example3() {} Note rustc automatically inlines functions when doing so seems worthwhile. Use this attribute carefully as poor decisions about what to inline can slow down programs. [attributes.codegen.inline.syntax] The syntax for the inline attribute is: Syntax InlineAttribute  inline ( always ) | inline ( never ) | inline Show Railroad InlineAttribute inline ( always ) inline ( never ) inline [attributes.codegen.inline.allowed-positions] The inline attribute may only be applied to functions with bodies --- closures , async blocks , free functions , associated functions in an inherent impl or trait impl , and associated functions in a trait definition when those functions have a default definition . Note rustc ignores use in other positions but lints against it. This may become an error in the future. Note Though the attribute can be applied to closures and async blocks , the usefulness of this is limited as we do not yet support attributes on expressions. // We allow attributes on statements.\\n#[inline] || (); // OK\\n#[inline] async {}; // OK // We don\'t yet allow attributes on expressions.\\nlet f = #[inline] || (); // ERROR [attributes.codegen.inline.duplicates] Only the first use of inline on a function has effect. Note rustc lints against any use following the first. This may become an error in the future. [attributes.codegen.inline.modes] The inline attribute supports these modes: #[inline] suggests performing inline expansion. #[inline(always)] suggests that inline expansion should always be performed. #[inline(never)] suggests that inline expansion should never be performed. Note In every form the attribute is a hint. The compiler may ignore it. [attributes.codegen.inline.trait] When inline is applied to a function in a trait , it applies only to the code of the default definition . [attributes.codegen.inline.async] When inline is applied to an async function or async closure , it applies only to the code of the generated poll function. Note For more details, see Rust issue #129347 . [attributes.codegen.inline.externally-exported] The inline attribute is ignored if the function is externally exported with no_mangle or export_name . [attributes.codegen.cold]","breadcrumbs":"Attributes  Code generation  The inline attribute","id":"200","title":"The inline attribute"},"201":{"body":"[attributes.codegen.cold.intro] Tests Tests with this rule:\\ntests/codegen-llvm/cold-attribute.rs The cold attribute suggests that the attributed function is unlikely to be called which may help the compiler produce better code. Example #[cold]\\npub fn example() {} [attributes.codegen.cold.syntax] The cold attribute uses the MetaWord syntax. [attributes.codegen.cold.allowed-positions] The cold attribute may only be applied to functions with bodies --- closures , async blocks , free functions , associated functions in an inherent impl or trait impl , and associated functions in a trait definition when those functions have a default definition . Note rustc ignores use in other positions but lints against it. This may become an error in the future. Note Though the attribute can be applied to closures and async blocks , the usefulness of this is limited as we do not yet support attributes on expressions. [attributes.codegen.cold.duplicates] Only the first use of cold on a function has effect. Note rustc lints against any use following the first. This may become an error in the future. [attributes.codegen.cold.trait] Tests Tests with this rule:\\ntests/codegen-llvm/cold-attribute.rs When cold is applied to a function in a trait , it applies only to the code of the default definition . [attributes.codegen.naked]","breadcrumbs":"Attributes  Code generation  The cold attribute","id":"201","title":"The cold attribute"},"202":{"body":"[attributes.codegen.naked.intro] The naked attribute prevents the compiler from emitting a function prologue and epilogue for the attributed function. [attributes.codegen.naked.body] The function body must consist of exactly one naked_asm! macro invocation. [attributes.codegen.naked.prologue-epilogue] No function prologue or epilogue is generated for the attributed function. The assembly code in the naked_asm! block constitutes the full body of a naked function. [attributes.codegen.naked.unsafe-attribute] The naked attribute is an unsafe attribute . Annotating a function with #[unsafe(naked)] comes with the safety obligation that the body must respect the function\'s calling convention, uphold its signature, and either return or diverge (i.e., not fall through past the end of the assembly code). [attributes.codegen.naked.call-stack] The assembly code may assume that the call stack and register state are valid on entry as per the signature and calling convention of the function. [attributes.codegen.naked.no-duplication] The assembly code may not be duplicated by the compiler except when monomorphizing polymorphic functions. Note Guaranteeing when the assembly code may or may not be duplicated is important for naked functions that define symbols. [attributes.codegen.naked.unused-variables] The unused_variables lint is suppressed within naked functions. [attributes.codegen.naked.inline] The inline attribute cannot by applied to a naked function. [attributes.codegen.naked.track_caller] The track_caller attribute cannot be applied to a naked function. [attributes.codegen.naked.testing] The testing attributes cannot be applied to a naked function. [attributes.codegen.no_builtins]","breadcrumbs":"Attributes  Code generation  The naked attribute","id":"202","title":"The naked attribute"},"203":{"body":"[attributes.codegen.no_builtins.intro] The no_builtins attribute disables optimization of certain code patterns related to calls to library functions that are assumed to exist. Example #![no_builtins] [attributes.codegen.no_builtins.syntax] The no_builtins attribute uses the MetaWord syntax. [attributes.codegen.no_builtins.allowed-positions] The no_builtins attribute can only be applied to the crate root. [attributes.codegen.no_builtins.duplicates] Only the first use of the no_builtins attribute has effect. Note rustc lints against any use following the first. [attributes.codegen.target_feature]","breadcrumbs":"Attributes  Code generation  The no_builtins attribute","id":"203","title":"The no_builtins attribute"},"204":{"body":"[attributes.codegen.target_feature.intro] The target_feature attribute may be applied to a function to enable code generation of that function for specific platform architecture features. It uses the MetaListNameValueStr syntax with a single key of enable whose value is a string of comma-separated feature names to enable. # #[cfg(target_feature = \\"avx2\\")]\\n#[target_feature(enable = \\"avx2\\")]\\nfn foo_avx2() {} [attributes.codegen.target_feature.arch] Each target architecture has a set of features that may be enabled. It is an error to specify a feature for a target architecture that the crate is not being compiled for. [attributes.codegen.target_feature.closures] Closures defined within a target_feature-annotated function inherit the attribute from the enclosing function. [attributes.codegen.target_feature.target-ub] It is undefined behavior to call a function that is compiled with a feature that is not supported on the current platform the code is running on, except if the platform explicitly documents this to be safe. [attributes.codegen.target_feature.safety-restrictions] The following restrictions apply unless otherwise specified by the platform rules below: Safe #[target_feature] functions (and closures that inherit the attribute) can only be safely called within a caller that enables all the target_features that the callee enables. This restriction does not apply in an unsafe context. Safe #[target_feature] functions (and closures that inherit the attribute) can only be coerced to safe function pointers in contexts that enable all the target_features that the coercee enables. This restriction does not apply to unsafe function pointers. Implicitly enabled features are included in this rule. For example an sse2 function can call ones marked with sse. # #[cfg(target_feature = \\"sse2\\")] {\\n#[target_feature(enable = \\"sse\\")]\\nfn foo_sse() {} fn bar() { // Calling `foo_sse` here is unsafe, as we must ensure that SSE is // available first, even if `sse` is enabled by default on the target // platform or manually enabled as compiler flags. unsafe { foo_sse(); }\\n} #[target_feature(enable = \\"sse\\")]\\nfn bar_sse() { // Calling `foo_sse` here is safe. foo_sse(); || foo_sse();\\n} #[target_feature(enable = \\"sse2\\")]\\nfn bar_sse2() { // Calling `foo_sse` here is safe because `sse2` implies `sse`. foo_sse();\\n}\\n# } [attributes.codegen.target_feature.fn-traits] A function with a #[target_feature] attribute never implements the Fn family of traits, although closures inheriting features from the enclosing function do. [attributes.codegen.target_feature.allowed-positions] The #[target_feature] attribute is not allowed on the following places: the main function a panic_handler function safe trait methods safe default functions in traits [attributes.codegen.target_feature.inline] Functions marked with target_feature are not inlined into a context that does not support the given features. The #[inline(always)] attribute may not be used with a target_feature attribute. [attributes.codegen.target_feature.availability]","breadcrumbs":"Attributes  Code generation  The target_feature attribute","id":"204","title":"The target_feature attribute"},"205":{"body":"The following is a list of the available feature names. [attributes.codegen.target_feature.x86] x86 or x86_64 Executing code with unsupported features is undefined behavior on this platform. Hence on this platform usage of #[target_feature] functions follows the above restrictions . Feature Implicitly Enables Description adx ADX --- Multi-Precision Add-Carry Instruction Extensions aes sse2 AES --- Advanced Encryption Standard avx sse4.2 AVX --- Advanced Vector Extensions avx2 avx AVX2 --- Advanced Vector Extensions 2 avx512bf16 avx512bw AVX512-BF16 --- Advanced Vector Extensions 512-bit - Bfloat16 Extensions avx512bitalg avx512bw AVX512-BITALG --- Advanced Vector Extensions 512-bit - Bit Algorithms avx512bw avx512f AVX512-BW --- Advanced Vector Extensions 512-bit - Byte and Word Instructions avx512cd avx512f AVX512-CD --- Advanced Vector Extensions 512-bit - Conflict Detection Instructions avx512dq avx512f AVX512-DQ --- Advanced Vector Extensions 512-bit - Doubleword and Quadword Instructions avx512f avx2, fma, f16c AVX512-F --- Advanced Vector Extensions 512-bit - Foundation avx512fp16 avx512bw AVX512-FP16 --- Advanced Vector Extensions 512-bit - Float16 Extensions avx512ifma avx512f AVX512-IFMA --- Advanced Vector Extensions 512-bit - Integer Fused Multiply Add avx512vbmi avx512bw AVX512-VBMI --- Advanced Vector Extensions 512-bit - Vector Byte Manipulation Instructions avx512vbmi2 avx512bw AVX512-VBMI2 --- Advanced Vector Extensions 512-bit - Vector Byte Manipulation Instructions 2 avx512vl avx512f AVX512-VL --- Advanced Vector Extensions 512-bit - Vector Length Extensions avx512vnni avx512f AVX512-VNNI --- Advanced Vector Extensions 512-bit - Vector Neural Network Instructions avx512vp2intersect avx512f AVX512-VP2INTERSECT --- Advanced Vector Extensions 512-bit - Vector Pair Intersection to a Pair of Mask Registers avx512vpopcntdq avx512f AVX512-VPOPCNTDQ --- Advanced Vector Extensions 512-bit - Vector Population Count Instruction avxifma avx2 AVX-IFMA --- Advanced Vector Extensions - Integer Fused Multiply Add avxneconvert avx2 AVX-NE-CONVERT --- Advanced Vector Extensions - No-Exception Floating-Point conversion Instructions avxvnni avx2 AVX-VNNI --- Advanced Vector Extensions - Vector Neural Network Instructions avxvnniint16 avx2 AVX-VNNI-INT16 --- Advanced Vector Extensions - Vector Neural Network Instructions with 16-bit Integers avxvnniint8 avx2 AVX-VNNI-INT8 --- Advanced Vector Extensions - Vector Neural Network Instructions with 8-bit Integers bmi1 BMI1 --- Bit Manipulation Instruction Sets bmi2 BMI2 --- Bit Manipulation Instruction Sets 2 cmpxchg16b cmpxchg16b --- Compares and exchange 16 bytes (128 bits) of data atomically f16c avx F16C --- 16-bit floating point conversion instructions fma avx FMA3 --- Three-operand fused multiply-add fxsr fxsave and fxrstor --- Save and restore x87 FPU, MMX Technology, and SSE State gfni sse2 GFNI --- Galois Field New Instructions kl sse2 KEYLOCKER --- Intel Key Locker Instructions lzcnt lzcnt --- Leading zeros count movbe movbe --- Move data after swapping bytes pclmulqdq sse2 pclmulqdq --- Packed carry-less multiplication quadword popcnt popcnt --- Count of bits set to 1 rdrand rdrand --- Read random number rdseed rdseed --- Read random seed sha sse2 SHA --- Secure Hash Algorithm sha512 avx2 SHA512 --- Secure Hash Algorithm with 512-bit digest sm3 avx SM3 --- ShangMi 3 Hash Algorithm sm4 avx2 SM4 --- ShangMi 4 Cipher Algorithm sse SSE --- Streaming SIMD Extensions sse2 sse SSE2 --- Streaming SIMD Extensions 2 sse3 sse2 SSE3 --- Streaming SIMD Extensions 3 sse4.1 ssse3 SSE4.1 --- Streaming SIMD Extensions 4.1 sse4.2 sse4.1 SSE4.2 --- Streaming SIMD Extensions 4.2 sse4a sse3 SSE4a --- Streaming SIMD Extensions 4a ssse3 sse3 SSSE3 --- Supplemental Streaming SIMD Extensions 3 tbm TBM --- Trailing Bit Manipulation vaes avx2, aes VAES --- Vector AES Instructions vpclmulqdq avx, pclmulqdq VPCLMULQDQ --- Vector Carry-less multiplication of Quadwords widekl kl KEYLOCKER_WIDE --- Intel Wide Keylocker Instructions xsave xsave --- Save processor extended states xsavec xsavec --- Save processor extended states with compaction xsaveopt xsaveopt --- Save processor extended states optimized xsaves xsaves --- Save processor extended states supervisor [attributes.codegen.target_feature.aarch64] aarch64 On this platform the usage of #[target_feature] functions follows the above restrictions . Further documentation on these features can be found in the ARM Architecture Reference Manual , or elsewhere on developer.arm.com . Note The following pairs of features should both be marked as enabled or disabled together if used: paca and pacg, which LLVM currently implements as one feature. Feature Implicitly Enables Feature Name aes neon FEAT_AES & FEAT_PMULL --- Advanced SIMD AES & PMULL instructions bf16 FEAT_BF16 --- BFloat16 instructions bti FEAT_BTI --- Branch Target Identification crc FEAT_CRC --- CRC32 checksum instructions dit FEAT_DIT --- Data Independent Timing instructions dotprod neon FEAT_DotProd --- Advanced SIMD Int8 dot product instructions dpb FEAT_DPB --- Data cache clean to point of persistence dpb2 dpb FEAT_DPB2 --- Data cache clean to point of deep persistence f32mm sve FEAT_F32MM --- SVE single-precision FP matrix multiply instruction f64mm sve FEAT_F64MM --- SVE double-precision FP matrix multiply instruction fcma neon FEAT_FCMA --- Floating point complex number support fhm fp16 FEAT_FHM --- Half-precision FP FMLAL instructions flagm FEAT_FLAGM --- Conditional flag manipulation fp16 neon FEAT_FP16 --- Half-precision FP data processing frintts FEAT_FRINTTS --- Floating-point to int helper instructions i8mm FEAT_I8MM --- Int8 Matrix Multiplication jsconv neon FEAT_JSCVT --- JavaScript conversion instruction lor FEAT_LOR --- Limited Ordering Regions extension lse FEAT_LSE --- Large System Extensions mte FEAT_MTE & FEAT_MTE2 --- Memory Tagging Extension neon FEAT_AdvSimd & FEAT_FP --- Floating Point and Advanced SIMD extension paca FEAT_PAUTH --- Pointer Authentication (address authentication) pacg FEAT_PAUTH --- Pointer Authentication (generic authentication) pan FEAT_PAN --- Privileged Access-Never extension pmuv3 FEAT_PMUv3 --- Performance Monitors extension (v3) rand FEAT_RNG --- Random Number Generator ras FEAT_RAS & FEAT_RASv1p1 --- Reliability, Availability and Serviceability extension rcpc FEAT_LRCPC --- Release consistent Processor Consistent rcpc2 rcpc FEAT_LRCPC2 --- RcPc with immediate offsets rdm neon FEAT_RDM --- Rounding Double Multiply accumulate sb FEAT_SB --- Speculation Barrier sha2 neon FEAT_SHA1 & FEAT_SHA256 --- Advanced SIMD SHA instructions sha3 sha2 FEAT_SHA512 & FEAT_SHA3 --- Advanced SIMD SHA instructions sm4 neon FEAT_SM3 & FEAT_SM4 --- Advanced SIMD SM3/4 instructions spe FEAT_SPE --- Statistical Profiling Extension ssbs FEAT_SSBS & FEAT_SSBS2 --- Speculative Store Bypass Safe sve neon FEAT_SVE --- Scalable Vector Extension sve2 sve FEAT_SVE2 --- Scalable Vector Extension 2 sve2-aes sve2, aes FEAT_SVE_AES & FEAT_SVE_PMULL128 --- SVE AES instructions sve2-bitperm sve2 FEAT_SVE2_BitPerm --- SVE Bit Permute sve2-sha3 sve2, sha3 FEAT_SVE2_SHA3 --- SVE SHA3 instructions sve2-sm4 sve2, sm4 FEAT_SVE2_SM4 --- SVE SM4 instructions tme FEAT_TME --- Transactional Memory Extension vh FEAT_VHE --- Virtualization Host Extensions [attributes.codegen.target_feature.loongarch] loongarch On this platform the usage of #[target_feature] functions follows the above restrictions . Feature Implicitly Enables Description f F --- Single-precision float-point instructions d f D --- Double-precision float-point instructions frecipe FRECIPE --- Reciprocal approximation instructions lasx lsx LASX --- 256-bit vector instructions lbt LBT --- Binary translation instructions lsx d LSX --- 128-bit vector instructions lvz LVZ --- Virtualization instructions [attributes.codegen.target_feature.riscv] riscv32 or riscv64 On this platform the usage of #[target_feature] functions follows the above restrictions . Further documentation on these features can be found in their respective specification. Many specifications are described in the RISC-V ISA Manual , version 20250508 , or in another manual hosted on the RISC-V GitHub Account . Feature Implicitly Enables Description a A --- Atomic instructions c C --- Compressed instructions m M --- Integer Multiplication and Division instructions zba Zba --- Address Generation instructions zbb Zbb --- Basic bit-manipulation zbc zbkc Zbc --- Carry-less multiplication zbkb Zbkb --- Bit Manipulation Instructions for Cryptography zbkc Zbkc --- Carry-less multiplication for Cryptography zbkx Zbkx --- Crossbar permutations zbs Zbs --- Single-bit instructions zk zkn, zkr, zks, zkt, zbkb, zbkc, zkbx Zk --- Scalar Cryptography zkn zknd, zkne, zknh, zbkb, zbkc, zkbx Zkn --- NIST Algorithm suite extension zknd Zknd --- NIST Suite: AES Decryption zkne Zkne --- NIST Suite: AES Encryption zknh Zknh --- NIST Suite: Hash Function Instructions zkr Zkr --- Entropy Source Extension zks zksed, zksh, zbkb, zbkc, zkbx Zks --- ShangMi Algorithm Suite zksed Zksed --- ShangMi Suite: SM4 Block Cipher Instructions zksh Zksh --- ShangMi Suite: SM3 Hash Function Instructions zkt Zkt --- Data Independent Execution Latency Subset [attributes.codegen.target_feature.wasm] wasm32 or wasm64 Safe #[target_feature] functions may always be used in safe contexts on Wasm platforms. It is impossible to cause undefined behavior via the #[target_feature] attribute because attempting to use instructions unsupported by the Wasm engine will fail at load time without the risk of being interpreted in a way different from what the compiler expected. Feature Implicitly Enables Description bulk-memory WebAssembly bulk memory operations proposal extended-const WebAssembly extended const expressions proposal mutable-globals WebAssembly mutable global proposal nontrapping-fptoint WebAssembly non-trapping float-to-int conversion proposal relaxed-simd simd128 WebAssembly relaxed simd proposal sign-ext WebAssembly sign extension operators Proposal simd128 WebAssembly simd proposal multivalue WebAssembly multivalue proposal reference-types WebAssembly reference-types proposal tail-call WebAssembly tail-call proposal [attributes.codegen.target_feature.info]","breadcrumbs":"Attributes  Code generation  Available features","id":"205","title":"Available features"},"206":{"body":"[attributes.codegen.target_feature.remark-cfg] See the target_feature conditional compilation option for selectively enabling or disabling compilation of code based on compile-time settings. Note that this option is not affected by the target_feature attribute, and is only driven by the features enabled for the entire crate. [attributes.codegen.target_feature.remark-rt] See the is_x86_feature_detected or is_aarch64_feature_detected macros in the standard library for runtime feature detection on these platforms. Note rustc has a default set of features enabled for each target and CPU. The CPU may be chosen with the -C target-cpu flag. Individual features may be enabled or disabled for an entire crate with the -C target-feature flag. [attributes.codegen.track_caller]","breadcrumbs":"Attributes  Code generation  Additional information","id":"206","title":"Additional information"},"207":{"body":"[attributes.codegen.track_caller.allowed-positions] The track_caller attribute may be applied to any function with \\"Rust\\" ABI with the exception of the entry point fn main. [attributes.codegen.track_caller.traits] When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations. [attributes.codegen.track_caller.extern] When applied to a function in an extern block the attribute must also be applied to any linked implementations, otherwise undefined behavior results. When applied to a function which is made available to an extern block, the declaration in the extern block must also have the attribute, otherwise undefined behavior results. [attributes.codegen.track_caller.behavior]","breadcrumbs":"Attributes  Code generation  The track_caller attribute","id":"207","title":"The track_caller attribute"},"208":{"body":"Applying the attribute to a function f allows code within f to get a hint of the Location of the \\"topmost\\" tracked call that led to f\'s invocation. At the point of observation, an implementation behaves as if it walks up the stack from f\'s frame to find the nearest frame of an unattributed function outer, and it returns the Location of the tracked call in outer. #[track_caller]\\nfn f() { println!(\\"{}\\", std::panic::Location::caller());\\n} Note core provides core::panic::Location::caller for observing caller locations. It wraps the core::intrinsics::caller_location intrinsic implemented by rustc. Note Because the resulting Location is a hint, an implementation may halt its walk up the stack early. See Limitations for important caveats. Examples When f is called directly by calls_f, code in f observes its callsite within calls_f: # #[track_caller]\\n# fn f() {\\n# println!(\\"{}\\", std::panic::Location::caller());\\n# }\\nfn calls_f() { f(); // <-- f() prints this location\\n} When f is called by another attributed function g which is in turn called by calls_g, code in both f and g observes g\'s callsite within calls_g: # #[track_caller]\\n# fn f() {\\n# println!(\\"{}\\", std::panic::Location::caller());\\n# }\\n#[track_caller]\\nfn g() { println!(\\"{}\\", std::panic::Location::caller()); f();\\n} fn calls_g() { g(); // <-- g() prints this location twice, once itself and once from f()\\n} When g is called by another attributed function h which is in turn called by calls_h, all code in f, g, and h observes h\'s callsite within calls_h: # #[track_caller]\\n# fn f() {\\n# println!(\\"{}\\", std::panic::Location::caller());\\n# }\\n# #[track_caller]\\n# fn g() {\\n# println!(\\"{}\\", std::panic::Location::caller());\\n# f();\\n# }\\n#[track_caller]\\nfn h() { println!(\\"{}\\", std::panic::Location::caller()); g();\\n} fn calls_h() { h(); // <-- prints this location three times, once itself, once from g(), once from f()\\n} And so on. [attributes.codegen.track_caller.limits]","breadcrumbs":"Attributes  Code generation  Behavior","id":"208","title":"Behavior"},"209":{"body":"[attributes.codegen.track_caller.hint] This information is a hint and implementations are not required to preserve it. [attributes.codegen.track_caller.decay] In particular, coercing a function with #[track_caller] to a function pointer creates a shim which appears to observers to have been called at the attributed function\'s definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed. Note The aforementioned shim for function pointers is necessary because rustc implements track_caller in a codegen context by appending an implicit parameter to the function ABI, but this would be unsound for an indirect call because the parameter is not a part of the function\'s type and a given function pointer type may or may not refer to a function with the attribute. The creation of a shim hides the implicit parameter from callers of the function pointer, preserving soundness. [attributes.codegen.instruction_set]","breadcrumbs":"Attributes  Code generation  Limitations","id":"209","title":"Limitations"},"21":{"body":"[ident] [ident.syntax] Lexer IDENTIFIER_OR_KEYWORD  XID_Start XID_Continue * | _ XID_Continue + XID_Start  <XID_Start defined by Unicode> XID_Continue  <XID_Continue defined by Unicode> RAW_IDENTIFIER  r# IDENTIFIER_OR_KEYWORD except crate, self, super, Self NON_KEYWORD_IDENTIFIER  IDENTIFIER_OR_KEYWORD except a strict or reserved keyword IDENTIFIER  NON_KEYWORD_IDENTIFIER | RAW_IDENTIFIER RESERVED_RAW_IDENTIFIER  r#_ Show Railroad IDENTIFIER_OR_KEYWORD XID_Start XID_Continue _ XID_Continue XID_Start `XID_Start` defined by Unicode XID_Continue `XID_Continue` defined by Unicode RAW_IDENTIFIER r# except `crate`, `self`, `super`, `Self` IDENTIFIER_OR_KEYWORD NON_KEYWORD_IDENTIFIER except a strict or reserved keyword IDENTIFIER_OR_KEYWORD IDENTIFIER NON_KEYWORD_IDENTIFIER RAW_IDENTIFIER RESERVED_RAW_IDENTIFIER r#_ [ident.unicode] Tests Tests with this rule:\\ntests/ui-fulldeps/lexer/unicode-version.rs Identifiers follow the specification in Unicode Standard Annex #31 for Unicode version 16.0, with the additions described below. Some examples of identifiers: foo _identifier r#true   [ident.profile] The profile used from UAX #31 is: Start := XID_Start , plus the underscore character (U+005F) Continue := XID_Continue Medial := empty with the additional constraint that a single underscore character is not an identifier. Note Identifiers starting with an underscore are typically used to indicate an identifier that is intentionally unused, and will silence the unused warning in rustc. [ident.keyword] Identifiers may not be a strict or reserved keyword without the r# prefix described below in raw identifiers . [ident.zero-width-chars] Zero width non-joiner (ZWNJ U+200C) and zero width joiner (ZWJ U+200D) characters are not allowed in identifiers. [ident.ascii-limitations] Identifiers are restricted to the ASCII subset of XID_Start and XID_Continue in the following situations: extern crate declarations (except the AsClause identifier) External crate names referenced in a path Module names loaded from the filesystem without a path attribute no_mangle attributed items Item names in external blocks [ident.normalization] Tests Tests with this rule:\\ntests/ui-fulldeps/lexer/unicode-version.rs","breadcrumbs":"Lexical structure  Identifiers  Identifiers","id":"21","title":"Identifiers"},"210":{"body":"[attributes.codegen.instruction_set.intro] The instruction_set attribute specifies the instruction set that a function will use during code generation. This allows mixing more than one instruction set in a single program. Example #[instruction_set(arm::a32)]\\nfn arm_code() {} #[instruction_set(arm::t32)]\\nfn thumb_code() {} [attributes.codegen.instruction_set.syntax] The instruction_set attribute uses the MetaListPaths syntax to specify a single path consisting of the architecture family name and instruction set name. [attributes.codegen.instruction_set.allowed-positions] The instruction_set attribute may only be applied to functions with bodies --- closures , async blocks , free functions , associated functions in an inherent impl or trait impl , and associated functions in a trait definition when those functions have a default definition . Note rustc ignores use in other positions but lints against it. This may become an error in the future. Note Though the attribute can be applied to closures and async blocks , the usefulness of this is limited as we do not yet support attributes on expressions. [attributes.codegen.instruction_set.duplicates] The instruction_set attribute may be used only once on a function. [attributes.codegen.instruction_set.target-limits] The instruction_set attribute may only be used with a target that supports the given value. [attributes.codegen.instruction_set.inline-asm] When the instruction_set attribute is used, any inline assembly in the function must use the specified instruction set instead of the target default. [attributes.codegen.instruction_set.arm]","breadcrumbs":"Attributes  Code generation  The instruction_set attribute","id":"210","title":"The instruction_set attribute"},"211":{"body":"When targeting the ARMv4T and ARMv5te architectures, the supported values for instruction_set are: arm::a32 --- Generate the function as A32 \\"ARM\\" code. arm::t32 --- Generate the function as T32 \\"Thumb\\" code. If the address of the function is taken as a function pointer, the low bit of the address will depend on the selected instruction set: For arm::a32 (\\"ARM\\"), it will be 0. For arm::t32 (\\"Thumb\\"), it will be 1.","breadcrumbs":"Attributes  Code generation  instruction_set on ARM","id":"211","title":"instruction_set on ARM"},"212":{"body":"[attributes.limits] The following attributes affect compile-time limits. [attributes.limits.recursion_limit]","breadcrumbs":"Attributes  Limits  Limits","id":"212","title":"Limits"},"213":{"body":"[attributes.limits.recursion_limit.intro] The recursion_limit attribute may be applied at the crate level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. [attributes.limits.recursion_limit.syntax] It uses the MetaNameValueStr syntax to specify the recursion depth. Note The default in rustc is 128. #![recursion_limit = \\"4\\"] macro_rules! a { () => { a!(1); }; (1) => { a!(2); }; (2) => { a!(3); }; (3) => { a!(4); }; (4) => { };\\n} // This fails to expand because it requires a recursion depth greater than 4.\\na!{} #![recursion_limit = \\"1\\"] // This fails because it requires two recursive steps to auto-dereference.\\n(|_: &u8| {})(&&&1); [attributes.limits.type_length_limit]","breadcrumbs":"Attributes  Limits  The recursion_limit attribute","id":"213","title":"The recursion_limit attribute"},"214":{"body":"[attributes.limits.type_length_limit.intro] The type_length_limit attribute sets the maximum number of type substitutions allowed when constructing a concrete type during monomorphization. Note rustc only enforces the limit when the nightly -Zenforce-type-length-limit flag is active. For more information, see Rust PR #127670 . Example #![type_length_limit = \\"4\\"] fn f<T>(x: T) {} // This fails to compile because monomorphizing to\\n// `f::<((((i32,), i32), i32), i32)>` requires more\\n// than 4 type elements.\\nf(((((1,), 2), 3), 4)); Note The default value in rustc is 1048576. [attributes.limits.type_length_limit.syntax] The type_length_limit attribute uses the MetaNameValueStr syntax. The value in the string must be a non-negative number. [attributes.limits.type_length_limit.allowed-positions] The type_length_limit attribute may only be applied to the crate root. Note rustc ignores use in other positions but lints against it. This may become an error in the future. [attributes.limits.type_length_limit.duplicates] Only the first use of type_length_limit on an item has effect. Note rustc lints against any use following the first. This may become an error in the future.","breadcrumbs":"Attributes  Limits  The type_length_limit attribute","id":"214","title":"The type_length_limit attribute"},"215":{"body":"[attributes.type-system] The following attributes are used for changing how a type can be used. [attributes.type-system.non_exhaustive]","breadcrumbs":"Attributes  Type system  Type system attributes","id":"215","title":"Type system attributes"},"216":{"body":"[attributes.type-system.non_exhaustive.intro] The non_exhaustive attribute indicates that a type or variant may have more fields or variants added in the future. [attributes.type-system.non_exhaustive.allowed-positions] It can be applied to structs , enums , and enum variants. [attributes.type-system.non_exhaustive.syntax] The non_exhaustive attribute uses the MetaWord syntax and thus does not take any inputs. [attributes.type-system.non_exhaustive.same-crate] Within the defining crate, non_exhaustive has no effect. #[non_exhaustive]\\npub struct Config { pub window_width: u16, pub window_height: u16,\\n} #[non_exhaustive]\\npub struct Token; #[non_exhaustive]\\npub struct Id(pub u64); #[non_exhaustive]\\npub enum Error { Message(String), Other,\\n} pub enum Message { #[non_exhaustive] Send { from: u32, to: u32, contents: String }, #[non_exhaustive] Reaction(u32), #[non_exhaustive] Quit,\\n} // Non-exhaustive structs can be constructed as normal within the defining crate.\\nlet config = Config { window_width: 640, window_height: 480 };\\nlet token = Token;\\nlet id = Id(4); // Non-exhaustive structs can be matched on exhaustively within the defining crate.\\nlet Config { window_width, window_height } = config;\\nlet Token = token;\\nlet Id(id_number) = id; let error = Error::Other;\\nlet message = Message::Reaction(3); // Non-exhaustive enums can be matched on exhaustively within the defining crate.\\nmatch error { Error::Message(ref s) => { }, Error::Other => { },\\n} match message { // Non-exhaustive variants can be matched on exhaustively within the defining crate. Message::Send { from, to, contents } => { }, Message::Reaction(id) => { }, Message::Quit => { },\\n} [attributes.type-system.non_exhaustive.external-crate] Outside of the defining crate, types annotated with non_exhaustive have limitations that preserve backwards compatibility when new fields or variants are added. [attributes.type-system.non_exhaustive.construction] Non-exhaustive types cannot be constructed outside of the defining crate: Non-exhaustive variants ( struct or enum variant ) cannot be constructed with a StructExpression (including with functional update syntax ). The implicitly defined same-named constant of a unit-like struct , or the same-named constructor function of a tuple struct , has a visibility no greater than pub(crate). That is, if the structs visibility is pub, then the constant or constructors visibility is pub(crate), and otherwise the visibility of the two items is the same (as is the case without #[non_exhaustive]). enum instances can be constructed. The following examples of construction do not compile when outside the defining crate: // These are types defined in an upstream crate that have been annotated as\\n// `#[non_exhaustive]`.\\nuse upstream::{Config, Token, Id, Error, Message}; // Cannot construct an instance of `Config`; if new fields were added in\\n// a new version of `upstream` then this would fail to compile, so it is\\n// disallowed.\\nlet config = Config { window_width: 640, window_height: 480 }; // Cannot construct an instance of `Token`; if new fields were added, then\\n// it would not be a unit-like struct any more, so the same-named constant\\n// created by it being a unit-like struct is not public outside the crate;\\n// this code fails to compile.\\nlet token = Token; // Cannot construct an instance of `Id`; if new fields were added, then\\n// its constructor function signature would change, so its constructor\\n// function is not public outside the crate; this code fails to compile.\\nlet id = Id(5); // Can construct an instance of `Error`; new variants being introduced would\\n// not result in this failing to compile.\\nlet error = Error::Message(\\"foo\\".to_string()); // Cannot construct an instance of `Message::Send` or `Message::Reaction`;\\n// if new fields were added in a new version of `upstream` then this would\\n// fail to compile, so it is disallowed.\\nlet message = Message::Send { from: 0, to: 1, contents: \\"foo\\".to_string(), };\\nlet message = Message::Reaction(0); // Cannot construct an instance of `Message::Quit`; if this were converted to\\n// a tuple enum variant `upstream`, this would fail to compile.\\nlet message = Message::Quit; [attributes.type-system.non_exhaustive.match] There are limitations when matching on non-exhaustive types outside of the defining crate: When pattern matching on a non-exhaustive variant ( struct or enum variant ), a StructPattern must be used which must include a ... A tuple enum variant\'s constructor\'s visibility is reduced to be no greater than pub(crate). When pattern matching on a non-exhaustive enum , matching on a variant does not contribute towards the exhaustiveness of the arms. The following examples of matching do not compile when outside the defining crate: // These are types defined in an upstream crate that have been annotated as\\n// `#[non_exhaustive]`.\\nuse upstream::{Config, Token, Id, Error, Message}; // Cannot match on a non-exhaustive enum without including a wildcard arm.\\nmatch error { Error::Message(ref s) => { }, Error::Other => { }, // would compile with: `_ => {},`\\n} // Cannot match on a non-exhaustive struct without a wildcard.\\nif let Ok(Config { window_width, window_height }) = config { // would compile with: `..`\\n} // Cannot match a non-exhaustive unit-like or tuple struct except by using\\n// braced struct syntax with a wildcard.\\n// This would compile as `let Token { .. } = token;`\\nlet Token = token;\\n// This would compile as `let Id { 0: id_number, .. } = id;`\\nlet Id(id_number) = id; match message { // Cannot match on a non-exhaustive struct enum variant without including a wildcard. Message::Send { from, to, contents } => { }, // Cannot match on a non-exhaustive tuple or unit enum variant. Message::Reaction(type) => { }, Message::Quit => { },\\n} It\'s also not allowed to use numeric casts (as) on enums that contain any non-exhaustive variants. For example, the following enum can be cast because it doesn\'t contain any non-exhaustive variants: #[non_exhaustive]\\npub enum Example { First, Second\\n} However, if the enum contains even a single non-exhaustive variant, casting will result in an error. Consider this modified version of the same enum: #[non_exhaustive]\\npub enum EnumWithNonExhaustiveVariants { First, #[non_exhaustive] Second\\n} use othercrate::EnumWithNonExhaustiveVariants; // Error: cannot cast an enum with a non-exhaustive variant when it\'s defined in another crate\\nlet _ = EnumWithNonExhaustiveVariants::First as u8; Non-exhaustive types are always considered inhabited in downstream crates.","breadcrumbs":"Attributes  Type system  The non_exhaustive attribute","id":"216","title":"The non_exhaustive attribute"},"217":{"body":"[attributes.debugger] The following attributes are used for enhancing the debugging experience when using third-party debuggers like GDB or WinDbg. [attributes.debugger.debugger_visualizer]","breadcrumbs":"Attributes  Debugger  Debugger attributes","id":"217","title":"Debugger attributes"},"218":{"body":"[attributes.debugger.debugger_visualizer.intro] The debugger_visualizer attribute can be used to embed a debugger visualizer file into the debug information. This improves the debugger experience when displaying values. Example #![debugger_visualizer(natvis_file = \\"Example.natvis\\")]\\n#![debugger_visualizer(gdb_script_file = \\"example.py\\")] [attributes.debugger.debugger_visualizer.syntax] The debugger_visualizer attribute uses the MetaListNameValueStr syntax to specify its inputs. One of the following keys must be specified: natvis_file gdb_script_file [attributes.debugger.debugger_visualizer.allowed-positions] The debugger_visualizer attribute may only be applied to a module or to the crate root. [attributes.debugger.debugger_visualizer.duplicates] The debugger_visualizer attribute may be used any number of times on a form. All specified visualizer files will be loaded. [attributes.debugger.debugger_visualizer.natvis]","breadcrumbs":"Attributes  Debugger  The debugger_visualizer attribute","id":"218","title":"The debugger_visualizer attribute"},"219":{"body":"[attributes.debugger.debugger_visualizer.natvis.intro] Natvis is an XML-based framework for Microsoft debuggers (such as Visual Studio and WinDbg) that uses declarative rules to customize the display of types. For detailed information on the Natvis format, refer to Microsoft\'s Natvis documentation . [attributes.debugger.debugger_visualizer.natvis.msvc] This attribute only supports embedding Natvis files on -windows-msvc targets. [attributes.debugger.debugger_visualizer.natvis.path] The path to the Natvis file is specified with the natvis_file key, which is a path relative to the source file. Example #![debugger_visualizer(natvis_file = \\"Rectangle.natvis\\")] struct FancyRect { x: f32, y: f32, dx: f32, dy: f32,\\n} fn main() { let fancy_rect = FancyRect { x: 10.0, y: 10.0, dx: 5.0, dy: 5.0 }; println!(\\"set breakpoint here\\");\\n} Rectangle.natvis contains: <?xml version=\\"1.0\\" encoding=\\"utf-8\\"?>\\n<AutoVisualizer xmlns=\\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\\"> <Type Name=\\"foo::FancyRect\\"> <DisplayString>({x},{y}) + ({dx}, {dy})</DisplayString> <Expand> <Synthetic Name=\\"LowerLeft\\"> <DisplayString>({x}, {y})</DisplayString> </Synthetic> <Synthetic Name=\\"UpperLeft\\"> <DisplayString>({x}, {y + dy})</DisplayString> </Synthetic> <Synthetic Name=\\"UpperRight\\"> <DisplayString>({x + dx}, {y + dy})</DisplayString> </Synthetic> <Synthetic Name=\\"LowerRight\\"> <DisplayString>({x + dx}, {y})</DisplayString> </Synthetic> </Expand> </Type>\\n</AutoVisualizer> When viewed under WinDbg, the fancy_rect variable would be shown as follows: > Variables: > fancy_rect: (10.0, 10.0) + (5.0, 5.0) > LowerLeft: (10.0, 10.0) > UpperLeft: (10.0, 15.0) > UpperRight: (15.0, 15.0) > LowerRight: (15.0, 10.0) [attributes.debugger.debugger_visualizer.gdb]","breadcrumbs":"Attributes  Debugger  Using debugger_visualizer with Natvis","id":"219","title":"Using debugger_visualizer with Natvis"},"22":{"body":"Identifiers are normalized using Normalization Form C (NFC) as defined in Unicode Standard Annex #15 . Two identifiers are equal if their NFC forms are equal. Procedural and declarative macros receive normalized identifiers in their input. [ident.raw]","breadcrumbs":"Lexical structure  Identifiers  Normalization","id":"22","title":"Normalization"},"220":{"body":"[attributes.debugger.debugger_visualizer.gdb.pretty] GDB supports the use of a structured Python script, called a pretty printer , that describes how a type should be visualized in the debugger view. For detailed information on pretty printers, refer to GDB\'s pretty printing documentation . Note Embedded pretty printers are not automatically loaded when debugging a binary under GDB. There are two ways to enable auto-loading embedded pretty printers: Launch GDB with extra arguments to explicitly add a directory or binary to the auto-load safe path: gdb -iex \\"add-auto-load-safe-path safe-path path/to/binary\\" path/to/binary For more information, see GDB\'s auto-loading documentation . Create a file named gdbinit under $HOME/.config/gdb (you may need to create the directory if it doesn\'t already exist). Add the following line to that file: add-auto-load-safe-path path/to/binary. [attributes.debugger.debugger_visualizer.gdb.path] These scripts are embedded using the gdb_script_file key, which is a path relative to the source file. Example #![debugger_visualizer(gdb_script_file = \\"printer.py\\")] struct Person { name: String, age: i32,\\n} fn main() { let bob = Person { name: String::from(\\"Bob\\"), age: 10 }; println!(\\"set breakpoint here\\");\\n} printer.py contains: import gdb class PersonPrinter: \\"Print a Person\\" def __init__(self, val): self.val = val self.name = val[\\"name\\"] self.age = int(val[\\"age\\"]) def to_string(self): return \\"{} is {} years old.\\".format(self.name, self.age) def lookup(val): lookup_tag = val.type.tag if lookup_tag is None: return None if \\"foo::Person\\" == lookup_tag: return PersonPrinter(val) return None gdb.current_objfile().pretty_printers.append(lookup) When the crate\'s debug executable is passed into GDB [1] , print bob will display: \\"Bob\\" is 10 years old. Note: This assumes you are using the rust-gdb script which configures pretty-printers for standard library types like String. [attributes.debugger.collapse_debuginfo]","breadcrumbs":"Attributes  Debugger  Using debugger_visualizer with GDB","id":"220","title":"Using debugger_visualizer with GDB"},"221":{"body":"[attributes.debugger.collapse_debuginfo.intro] The collapse_debuginfo attribute controls whether code locations from a macro definition are collapsed into a single location associated with the macro\'s call site when generating debuginfo for code calling this macro. Example #[collapse_debuginfo(yes)]\\nmacro_rules! example { () => { println!(\\"hello!\\"); };\\n} When using a debugger, invoking the example macro may appear as though it is calling a function. That is, when you step to the invocation site, it may show the macro invocation rather than the expanded code. [attributes.debugger.collapse_debuginfo.syntax] The syntax for the collapse_debuginfo attribute is: Syntax CollapseDebuginfoAttribute  collapse_debuginfo ( CollapseDebuginfoOption ) CollapseDebuginfoOption  yes | no | external Show Railroad CollapseDebuginfoAttribute collapse_debuginfo ( CollapseDebuginfoOption ) CollapseDebuginfoOption yes no external [attributes.debugger.collapse_debuginfo.allowed-positions] The collapse_debuginfo attribute may only be applied to a macro_rules definition . [attributes.debugger.collapse_debuginfo.duplicates] The collapse_debuginfo attribute may used only once on a macro. [attributes.debugger.collapse_debuginfo.options] The collapse_debuginfo attribute accepts these options: #[collapse_debuginfo(yes)] --- Code locations in debuginfo are collapsed. #[collapse_debuginfo(no)] --- Code locations in debuginfo are not collapsed. #[collapse_debuginfo(external)] --- Code locations in debuginfo are collapsed only if the macro comes from a different crate. [attributes.debugger.collapse_debuginfo.default] The external behavior is the default for macros that don\'t have this attribute unless they are built-in macros. For built-in macros the default is yes. Note rustc has a -C collapse-macro-debuginfo CLI option to override both the default behavior and the values of any #[collapse_debuginfo] attributes.","breadcrumbs":"Attributes  Debugger  The collapse_debuginfo attribute","id":"221","title":"The collapse_debuginfo attribute"},"222":{"body":"[stmt-expr] Rust is primarily an expression language. This means that most forms of value-producing or effect-causing evaluation are directed by the uniform syntax category of expressions . Each kind of expression can typically nest within each other kind of expression, and rules for evaluation of expressions involve specifying both the value produced by the expression and the order in which its sub-expressions are themselves evaluated. In contrast, statements serve mostly to contain and explicitly sequence expression evaluation.","breadcrumbs":"Statements and expressions  Statements and expressions","id":"222","title":"Statements and expressions"},"223":{"body":"[statement] [statement.syntax] Syntax Statement  ; | Item | LetStatement | ExpressionStatement | OuterAttribute * MacroInvocationSemi Show Railroad Statement ; Item LetStatement ExpressionStatement OuterAttribute MacroInvocationSemi [statement.intro] A statement is a component of a block , which is in turn a component of an outer expression or function . [statement.kind] Rust has two kinds of statement: declaration statements and expression statements . [statement.decl]","breadcrumbs":"Statements and expressions  Statements  Statements","id":"223","title":"Statements"},"224":{"body":"A declaration statement is one that introduces one or more names into the enclosing statement block. The declared names may denote new variables or new items . The two kinds of declaration statements are item declarations and let statements. [statement.item]","breadcrumbs":"Statements and expressions  Statements  Declaration statements","id":"224","title":"Declaration statements"},"225":{"body":"[statement.item.intro] An item declaration statement has a syntactic form identical to an item declaration within a module . [statement.item.scope] Declaring an item within a statement block restricts its scope to the block containing the statement. The item is not given a canonical path nor are any sub-items it may declare. [statement.item.associated-scope] The exception to this is that associated items defined by implementations are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module. [statement.item.outer-generics] There is no implicit capture of the containing function\'s generic parameters, parameters, and local variables. For example, inner may not access outer_var. fn outer() { let outer_var = true; fn inner() { /* outer_var is not in scope here */ } inner();\\n} [statement.let]","breadcrumbs":"Statements and expressions  Statements  Item declarations","id":"225","title":"Item declarations"},"226":{"body":"[statement.let.syntax] Syntax LetStatement  OuterAttribute * let PatternNoTopAlt ( : Type )? ( = Expression | = Expression except LazyBooleanExpression or end with a } else BlockExpression )? ; Show Railroad LetStatement OuterAttribute let PatternNoTopAlt : Type = Expression = except LazyBooleanExpression or end with a `}` Expression else BlockExpression ; [statement.let.intro] A let statement introduces a new set of variables , given by a pattern . The pattern is followed optionally by a type annotation and then either ends, or is followed by an initializer expression plus an optional else block. [statement.let.inference] When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. [statement.let.scope] Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope, except when they are shadowed by another variable declaration. [statement.let.constraint] If an else block is not present, the pattern must be irrefutable. If an else block is present, the pattern may be refutable. [statement.let.behavior] If the pattern does not match (this requires it to be refutable), the else block is executed. The else block must always diverge (evaluate to the never type ). let (mut v, w) = (vec![1, 2, 3], 42); // The bindings may be mut or const\\nlet Some(t) = v.pop() else { // Refutable patterns require an else block panic!(); // The else block must diverge\\n};\\nlet [u, v] = [v[0], v[1]] else { // This pattern is irrefutable, so the compiler // will lint as the else block is redundant. panic!();\\n}; [statement.expr]","breadcrumbs":"Statements and expressions  Statements  let statements","id":"226","title":"let statements"},"227":{"body":"[statement.expr.syntax] Syntax ExpressionStatement  ExpressionWithoutBlock ; | ExpressionWithBlock ;? Show Railroad ExpressionStatement ExpressionWithoutBlock ; ExpressionWithBlock ; [statement.expr.intro] An expression statement is one that evaluates an expression and ignores its result. As a rule, an expression statement\'s purpose is to trigger the effects of evaluating its expression. [statement.expr.restriction-semicolon] An expression that consists of only a block expression or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement. [statement.expr.constraint-block] The type of ExpressionWithBlock expressions when used as statements must be the unit type. # let mut v = vec![1, 2, 3];\\nv.pop(); // Ignore the element returned from pop\\nif v.is_empty() { v.push(5);\\n} else { v.remove(0);\\n} // Semicolon can be omitted.\\n[1]; // Separate expression statement, not an indexing expression. When the trailing semicolon is omitted, the result must be type (). // bad: the block\'s type is i32, not ()\\n// Error: expected `()` because of default return type\\n// if true {\\n// 1\\n// } // good: the block\'s type is i32\\nif true { 1\\n} else { 2\\n}; [statement.attribute]","breadcrumbs":"Statements and expressions  Statements  Expression statements","id":"227","title":"Expression statements"},"228":{"body":"Statements accept outer attributes . The attributes that have meaning on a statement are cfg , and the lint check attributes .","breadcrumbs":"Statements and expressions  Statements  Attributes on statements","id":"228","title":"Attributes on statements"},"229":{"body":"[expr] [expr.syntax] Syntax Expression  ExpressionWithoutBlock | ExpressionWithBlock ExpressionWithoutBlock  OuterAttribute * ( LiteralExpression | PathExpression | OperatorExpression | GroupedExpression | ArrayExpression | AwaitExpression | IndexExpression | TupleExpression | TupleIndexingExpression | StructExpression | CallExpression | MethodCallExpression | FieldExpression | ClosureExpression | AsyncBlockExpression | ContinueExpression | BreakExpression | RangeExpression | ReturnExpression | UnderscoreExpression | MacroInvocation ) ExpressionWithBlock  OuterAttribute * ( BlockExpression | ConstBlockExpression | UnsafeBlockExpression | LoopExpression | IfExpression | MatchExpression ) Show Railroad Expression ExpressionWithoutBlock ExpressionWithBlock ExpressionWithoutBlock OuterAttribute LiteralExpression PathExpression OperatorExpression GroupedExpression ArrayExpression AwaitExpression IndexExpression TupleExpression TupleIndexingExpression StructExpression CallExpression MethodCallExpression FieldExpression ClosureExpression AsyncBlockExpression ContinueExpression BreakExpression RangeExpression ReturnExpression UnderscoreExpression MacroInvocation ExpressionWithBlock OuterAttribute BlockExpression ConstBlockExpression UnsafeBlockExpression LoopExpression IfExpression MatchExpression [expr.intro] An expression may have two roles: it always produces a value , and it may have effects (otherwise known as \\"side effects\\"). [expr.evaluation] An expression evaluates to a value, and has effects during evaluation . [expr.operands] Many expressions contain sub-expressions, called the operands of the expression. [expr.behavior] The meaning of each kind of expression dictates several things: Whether or not to evaluate the operands when evaluating the expression The order in which to evaluate the operands How to combine the operands\' values to obtain the value of the expression [expr.structure] In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth. Note We give names to the operands of expressions so that we may discuss them, but these names are not stable and may be changed. [expr.precedence]","breadcrumbs":"Statements and expressions  Expressions  Expressions","id":"229","title":"Expressions"},"23":{"body":"[ident.raw.intro] A raw identifier is like a normal identifier, but prefixed by r#. (Note that the r# prefix is not included as part of the actual identifier.) [ident.raw.allowed] Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for RAW_IDENTIFIER. [ident.raw.reserved] It is an error to use the RESERVED_RAW_IDENTIFIER token r#_ in order to avoid confusion with the WildcardPattern .","breadcrumbs":"Lexical structure  Identifiers  Raw identifiers","id":"23","title":"Raw identifiers"},"230":{"body":"The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity. Operator/Expression Associativity Paths Method calls Field expressions left to right Function calls , array indexing ? Unary - ! * borrow as left to right * / % left to right + - left to right << >> left to right & left to right ^ left to right | left to right == != < > <= >= Require parentheses && left to right || left to right .. ..= Require parentheses = += -= *= /= %= &= |= ^= <<= >>= right to left return break closures [expr.operand-order]","breadcrumbs":"Statements and expressions  Expressions  Expression precedence","id":"230","title":"Expression precedence"},"231":{"body":"[expr.operand-order.default] The following list of expressions all evaluate their operands the same way, as described after the list. Other expressions either don\'t take operands or evaluate them conditionally as described on their respective pages. Dereference expression Error propagation expression Negation expression Arithmetic and logical binary operators Comparison operators Type cast expression Grouped expression Array expression Await expression Index expression Tuple expression Tuple index expression Struct expression Call expression Method call expression Field expression Break expression Range expression Return expression [expr.operand-order.operands-before-primary] The operands of these expressions are evaluated prior to applying the effects of the expression. Expressions taking multiple operands are evaluated left to right as written in the source code. Note Which subexpressions are the operands of an expression is determined by expression precedence as per the previous section. For example, the two next method calls will always be called in the same order: # // Using vec instead of array to avoid references\\n# // since there is no stable owned array iterator\\n# // at the time this example was written.\\nlet mut one_two = vec![1, 2].into_iter();\\nassert_eq!( (1, 2), (one_two.next().unwrap(), one_two.next().unwrap())\\n); Note Since this is applied recursively, these expressions are also evaluated from innermost to outermost, ignoring siblings until there are no inner subexpressions. [expr.place-value]","breadcrumbs":"Statements and expressions  Expressions  Evaluation order of operands","id":"231","title":"Evaluation order of operands"},"232":{"body":"[expr.place-value.intro] Expressions are divided into two main categories: place expressions and value expressions; there is also a third, minor category of expressions called assignee expressions. Within each expression, operands may likewise occur in either place context or value context. The evaluation of an expression depends both on its own category and the context it occurs within. [expr.place-value.place-memory-location] A place expression is an expression that represents a memory location. [expr.place-value.place-expr-kinds] These expressions are paths which refer to local variables, static variables , dereferences (*expr), array indexing expressions (expr[expr]), field references (expr.f) and parenthesized place expressions. [expr.place-value.value-expr-kinds] All other expressions are value expressions. [expr.place-value.value-result] A value expression is an expression that represents an actual value. [expr.place-value.place-context] The following contexts are place expression contexts: The left operand of a compound assignment expression. The operand of a unary borrow , raw borrow or dereference operator. The operand of a field expression. The indexed operand of an array indexing expression. The operand of any implicit borrow . The initializer of a let statement . The scrutinee of an if let , match , or while let expression. The base of a functional update struct expression. Note Historically, place expressions were called lvalues and value expressions were called rvalues . [expr.place-value.assignee] An assignee expression is an expression that appears in the left operand of an assignment expression. Explicitly, the assignee expressions are: Place expressions. Underscores . Tuples of assignee expressions. Slices of assignee expressions. Tuple structs of assignee expressions. Structs of assignee expressions (with optionally named fields). Unit structs [expr.place-value.parenthesis] Arbitrary parenthesisation is permitted inside assignee expressions. [expr.move]","breadcrumbs":"Statements and expressions  Expressions  Place expressions and value expressions","id":"232","title":"Place expressions and value expressions"},"233":{"body":"[expr.move.intro] When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held in that memory location. [expr.move.copy] If the type of that value implements Copy , then the value will be copied. [expr.move.requires-sized] In the remaining situations, if that type is Sized , then it may be possible to move the value. [expr.move.movable-place] Only the following place expressions may be moved out of: Variables which are not currently borrowed. Temporary values . Fields of a place expression which can be moved out of and don\'t implement Drop . The result of dereferencing an expression with type Box<T> and that can also be moved out of. [expr.move.deinitialization] After moving out of a place expression that evaluates to a local variable, the location is deinitialized and cannot be read from again until it is reinitialized. [expr.move.place-invalid] In all other cases, trying to use a place expression in a value expression context is an error. [expr.mut]","breadcrumbs":"Statements and expressions  Expressions  Moved and copied types","id":"233","title":"Moved and copied types"},"234":{"body":"[expr.mut.intro] For a place expression to be assigned to, mutably borrowed , implicitly mutably borrowed , or bound to a pattern containing ref mut, it must be mutable . We call these mutable place expressions . In contrast, other place expressions are called immutable place expressions . [expr.mut.valid-places] The following expressions can be mutable place expression contexts: Mutable variables which are not currently borrowed. Mutable static items . Temporary values . Fields : this evaluates the subexpression in a mutable place expression context. Dereferences of a *mut T pointer. Dereference of a variable, or field of a variable, with type &mut T. Note: This is an exception to the requirement of the next rule. Dereferences of a type that implements DerefMut: this then requires that the value being dereferenced is evaluated in a mutable place expression context. Array indexing of a type that implements IndexMut: this then evaluates the value being indexed, but not the index, in mutable place expression context. [expr.temporary]","breadcrumbs":"Statements and expressions  Expressions  Mutability","id":"234","title":"Mutability"},"235":{"body":"When using a value expression in most place expression contexts, a temporary unnamed memory location is created and initialized to that value. The expression evaluates to that location instead, except if promoted to a static. The drop scope of the temporary is usually the end of the enclosing statement. [expr.super-macros]","breadcrumbs":"Statements and expressions  Expressions  Temporaries","id":"235","title":"Temporaries"},"236":{"body":"[expr.super-macros.intro] Certain built-in macros may create temporaries whose scopes may be extended . These temporaries are super temporaries and these macros are super macros . Invocations of these macros are super macro call expressions . Arguments to these macros may be super operands . Note When a super macro call expression is an extending expression , its super operands are extending expressions and the scopes of the super temporaries are extended . See destructors.scope.lifetime-extension.exprs . [expr.super-macros.format_args] format_args! [expr.super-macros.format_args.super-operands] Except for the format string argument, all arguments passed to format_args! are super operands . # fn temp() -> String { String::from(\\"\\") }\\n// Due to the call being an extending expression and the argument\\n// being a super operand, the inner block is an extending expression,\\n// so the scope of the temporary created in its trailing expression\\n// is extended.\\nlet _ = format_args!(\\"{}\\", { &temp() }); // OK [expr.super-macros.format_args.super-temporaries] The super operands of format_args! are implicitly borrowed and are therefore place expression contexts . When a value expression is passed as an argument, it creates a super temporary . # fn temp() -> String { String::from(\\"\\") }\\nlet x = format_args!(\\"{}\\", temp());\\nx; // <-- The temporary is extended, allowing use here. The expansion of a call to format_args! sometimes creates other internal super temporaries . let x = { // This call creates an internal temporary. let x = format_args!(\\"{:?}\\", 0); x // <-- The temporary is extended, allowing its use here.\\n}; // <-- The temporary is dropped here.\\nx; // ERROR // This call doesn\'t create an internal temporary.\\nlet x = { let x = format_args!(\\"{}\\", 0); x };\\nx; // OK Note The details of when format_args! does or does not create internal temporaries are currently unspecified. [expr.super-macros.pin] pin! [expr.super-macros.pin.super-operands] The argument to pin! is a super operand . # use core::pin::pin;\\n# fn temp() {}\\n// As above for `format_args!`.\\nlet _ = pin!({ &temp() }); // OK [expr.super-macros.pin.super-temporaries] The argument to pin! is a value expression context and creates a super temporary . # use core::pin::pin;\\n# fn temp() {}\\n// The argument is evaluated into a super temporary.\\nlet x = pin!(temp());\\n// The temporary is extended, allowing its use here.\\nx; // OK [expr.implicit-borrow]","breadcrumbs":"Statements and expressions  Expressions  Super macros","id":"236","title":"Super macros"},"237":{"body":"[expr.implicit-borrow-intro] Certain expressions will treat an expression as a place expression by implicitly borrowing it. For example, it is possible to compare two unsized slices for equality directly, because the == operator implicitly borrows its operands: # let c = [1, 2, 3];\\n# let d = vec![1, 2, 3];\\nlet a: &[i32];\\nlet b: &[i32];\\n# a = &c;\\n# b = &d;\\n// ...\\n*a == *b;\\n// Equivalent form:\\n::std::cmp::PartialEq::eq(&*a, &*b); [expr.implicit-borrow.application] Implicit borrows may be taken in the following expressions: Left operand in method-call expressions. Left operand in field expressions. Left operand in call expressions . Left operand in array indexing expressions. Operand of the dereference operator (*). Operands of comparison . Left operands of the compound assignment . Arguments to format_args! except the format string. [expr.overload]","breadcrumbs":"Statements and expressions  Expressions  Implicit borrows","id":"237","title":"Implicit borrows"},"238":{"body":"Many of the following operators and expressions can also be overloaded for other types using traits in std::ops or std::cmp. These traits also exist in core::ops and core::cmp with the same names. [expr.attr]","breadcrumbs":"Statements and expressions  Expressions  Overloading traits","id":"238","title":"Overloading traits"},"239":{"body":"[expr.attr.restriction] Outer attributes before an expression are allowed only in a few specific cases: Before an expression used as a statement . Elements of array expressions , tuple expressions , call expressions , and tuple-style struct expressions. The tail expression of block expressions . [expr.attr.never-before] They are never allowed before: Range expressions. Binary operator expressions ( ArithmeticOrLogicalExpression , ComparisonExpression , LazyBooleanExpression , TypeCastExpression , AssignmentExpression , CompoundAssignmentExpression ).","breadcrumbs":"Statements and expressions  Expressions  Expression attributes","id":"239","title":"Expression attributes"},"24":{"body":"[comments] [comments.syntax] Lexer LINE_COMMENT  // ( ~[/ ! LF ] | // ) ~ LF * | // BLOCK_COMMENT  /* ( ~[* !] | ** | BLOCK_COMMENT_OR_DOC ) ( BLOCK_COMMENT_OR_DOC | ~*/ )* */ | /**/ | /***/ INNER_LINE_DOC  //! ~[ LF CR ]* INNER_BLOCK_DOC  /*! ( BLOCK_COMMENT_OR_DOC | ~[*/ CR ] )* */ OUTER_LINE_DOC  /// ( ~/ ~[ LF CR ]* )? OUTER_BLOCK_DOC  /** ( ~* | BLOCK_COMMENT_OR_DOC ) ( BLOCK_COMMENT_OR_DOC | ~[*/ CR ] )* */ BLOCK_COMMENT_OR_DOC  BLOCK_COMMENT | OUTER_BLOCK_DOC | INNER_BLOCK_DOC Show Railroad LINE_COMMENT //  with the exception of / ! LF CHAR //  with the exception of LF CHAR // BLOCK_COMMENT /*  with the exception of * ! CHAR ** BLOCK_COMMENT_OR_DOC BLOCK_COMMENT_OR_DOC  with the exception of */ CHAR */ /**/ /***/ INNER_LINE_DOC //!  with the exception of LF CR CHAR INNER_BLOCK_DOC /*! BLOCK_COMMENT_OR_DOC  with the exception of */ CR CHAR */ OUTER_LINE_DOC ///  with the exception of / CHAR  with the exception of LF CR CHAR OUTER_BLOCK_DOC /**  with the exception of * CHAR BLOCK_COMMENT_OR_DOC BLOCK_COMMENT_OR_DOC  with the exception of */ CR CHAR */ BLOCK_COMMENT_OR_DOC BLOCK_COMMENT OUTER_BLOCK_DOC INNER_BLOCK_DOC [comments.normal]","breadcrumbs":"Lexical structure  Comments  Comments","id":"24","title":"Comments"},"240":{"body":"[expr.literal] [expr.literal.syntax] Syntax LiteralExpression  CHAR_LITERAL | STRING_LITERAL | RAW_STRING_LITERAL | BYTE_LITERAL | BYTE_STRING_LITERAL | RAW_BYTE_STRING_LITERAL | C_STRING_LITERAL | RAW_C_STRING_LITERAL | INTEGER_LITERAL | FLOAT_LITERAL | true | false Show Railroad LiteralExpression CHAR_LITERAL STRING_LITERAL RAW_STRING_LITERAL BYTE_LITERAL BYTE_STRING_LITERAL RAW_BYTE_STRING_LITERAL C_STRING_LITERAL RAW_C_STRING_LITERAL INTEGER_LITERAL FLOAT_LITERAL true false [expr.literal.intro] A literal expression is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. [expr.literal.const-expr] A literal is a form of constant expression , so is evaluated (primarily) at compile time. [expr.literal.literal-token] Each of the lexical literal forms described earlier can make up a literal expression, as can the keywords true and false. \\"hello\\"; // string type\\n\'5\'; // character type\\n5; // integer type [expr.literal.string-representation] In the descriptions below, the string representation of a token is the sequence of characters from the input which matched the token\'s production in a Lexer grammar snippet. Note This string representation never includes a character U+000D (CR) immediately followed by U+000A (LF): this pair would have been previously transformed into a single U+000A (LF). [expr.literal.escape]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Literal expressions","id":"240","title":"Literal expressions"},"241":{"body":"[expr.literal.escape.intro] The descriptions of textual literal expressions below make use of several forms of escape . [expr.literal.escape.sequence] Each form of escape is characterised by: an escape sequence : a sequence of characters, which always begins with U+005C (\\\\) an escaped value : either a single character or an empty sequence of characters In the definitions of escapes below: An octal digit is any of the characters in the range [0-7]. A hexadecimal digit is any of the characters in the ranges [0-9], [a-f], or [A-F]. [expr.literal.escape.simple]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Escapes","id":"241","title":"Escapes"},"242":{"body":"Each sequence of characters occurring in the first column of the following table is an escape sequence. In each case, the escaped value is the character given in the corresponding entry in the second column. Escape sequence Escaped value \\\\0 U+0000 (NUL) \\\\t U+0009 (HT) \\\\n U+000A (LF) \\\\r U+000D (CR) \\\\\\" U+0022 (QUOTATION MARK) \\\\\' U+0027 (APOSTROPHE) \\\\\\\\ U+005C (REVERSE SOLIDUS) [expr.literal.escape.hex-octet]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Simple escapes","id":"242","title":"Simple escapes"},"243":{"body":"The escape sequence consists of \\\\x followed by two hexadecimal digits. The escaped value is the character whose Unicode scalar value is the result of interpreting the final two characters in the escape sequence as a hexadecimal integer, as if by u8::from_str_radix with radix 16. Note The escaped value therefore has a Unicode scalar value in the range of u8 . [expr.literal.escape.hex-ascii]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  8-bit escapes","id":"243","title":"8-bit escapes"},"244":{"body":"The escape sequence consists of \\\\x followed by an octal digit then a hexadecimal digit. The escaped value is the character whose Unicode scalar value is the result of interpreting the final two characters in the escape sequence as a hexadecimal integer, as if by u8::from_str_radix with radix 16. [expr.literal.escape.unicode]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  7-bit escapes","id":"244","title":"7-bit escapes"},"245":{"body":"The escape sequence consists of \\\\u{, followed by a sequence of characters each of which is a hexadecimal digit or _, followed by }. The escaped value is the character whose Unicode scalar value is the result of interpreting the hexadecimal digits contained in the escape sequence as a hexadecimal integer, as if by u32::from_str_radix with radix 16. Note The permitted forms of a CHAR_LITERAL or STRING_LITERAL token ensure that there is such a character. [expr.literal.continuation]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Unicode escapes","id":"245","title":"Unicode escapes"},"246":{"body":"The escape sequence consists of \\\\ followed immediately by U+000A (LF), and all following whitespace characters before the next non-whitespace character. For this purpose, the whitespace characters are U+0009 (HT), U+000A (LF), U+000D (CR), and U+0020 (SPACE). The escaped value is an empty sequence of characters. Note The effect of this form of escape is that a string continuation skips following whitespace, including additional newlines. Thus a, b and c are equal: let a = \\"foobar\\";\\nlet b = \\"foo\\\\ bar\\";\\nlet c = \\"foo\\\\ bar\\"; assert_eq!(a, b);\\nassert_eq!(b, c); Skipping additional newlines (as in example c) is potentially confusing and unexpected. This behavior may be adjusted in the future. Until a decision is made, it is recommended to avoid relying on skipping multiple newlines with line continuations. See this issue for more information. [expr.literal.char]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  String continuation escapes","id":"246","title":"String continuation escapes"},"247":{"body":"[expr.literal.char.intro] A character literal expression consists of a single CHAR_LITERAL token. [expr.literal.char.type] The expression\'s type is the primitive char type. [expr.literal.char.no-suffix] The token must not have a suffix. [expr.literal.char.literal-content] The token\'s literal content is the sequence of characters following the first U+0027 (\') and preceding the last U+0027 (\') in the string representation of the token. [expr.literal.char.represented] The literal expression\'s represented character is derived from the literal content as follows: [expr.literal.char.escape] If the literal content is one of the following forms of escape sequence, the represented character is the escape sequence\'s escaped value: Simple escapes 7-bit escapes Unicode escapes [expr.literal.char.single] Otherwise the represented character is the single character that makes up the literal content. [expr.literal.char.result] The expression\'s value is the char corresponding to the represented character\'s Unicode scalar value . Note The permitted forms of a CHAR_LITERAL token ensure that these rules always produce a single character. Examples of character literal expressions: \'R\'; // R\\n\'\\\\\'\'; // \'\\n\'\\\\x52\'; // R\\n\'\\\\u{00E6}\'; // LATIN SMALL LETTER AE (U+00E6) [expr.literal.string]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Character literal expressions","id":"247","title":"Character literal expressions"},"248":{"body":"[expr.literal.string.intro] A string literal expression consists of a single STRING_LITERAL or RAW_STRING_LITERAL token. [expr.literal.string.type] The expression\'s type is a shared reference (with static lifetime) to the primitive str type. That is, the type is &\'static str. [expr.literal.string.no-suffix] The token must not have a suffix. [expr.literal.string.literal-content] The token\'s literal content is the sequence of characters following the first U+0022 (\\") and preceding the last U+0022 (\\") in the string representation of the token. [expr.literal.string.represented] The literal expression\'s represented string is a sequence of characters derived from the literal content as follows: [expr.literal.string.escape] If the token is a STRING_LITERAL , each escape sequence of any of the following forms occurring in the literal content is replaced by the escape sequence\'s escaped value. Simple escapes 7-bit escapes Unicode escapes String continuation escapes These replacements take place in left-to-right order. For example, the token \\"\\\\\\\\x41\\" is converted to the characters \\\\ x 4 1. [expr.literal.string.raw] If the token is a RAW_STRING_LITERAL , the represented string is identical to the literal content. [expr.literal.string.result] The expression\'s value is a reference to a statically allocated str containing the UTF-8 encoding of the represented string. Examples of string literal expressions: \\"foo\\"; r\\"foo\\"; // foo\\n\\"\\\\\\"foo\\\\\\"\\"; r#\\"\\"foo\\"\\"#; // \\"foo\\" \\"foo #\\\\\\"# bar\\";\\nr##\\"foo #\\"# bar\\"##; // foo #\\"# bar \\"\\\\x52\\"; \\"R\\"; r\\"R\\"; // R\\n\\"\\\\\\\\x52\\"; r\\"\\\\x52\\"; // \\\\x52 [expr.literal.byte-char]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  String literal expressions","id":"248","title":"String literal expressions"},"249":{"body":"[expr.literal.byte-char.intro] A byte literal expression consists of a single BYTE_LITERAL token. [expr.literal.byte-char.literal] The expression\'s type is the primitive u8 type. [expr.literal.byte-char.no-suffix] The token must not have a suffix. [expr.literal.byte-char.literal-content] The token\'s literal content is the sequence of characters following the first U+0027 (\') and preceding the last U+0027 (\') in the string representation of the token. [expr.literal.byte-char.represented] The literal expression\'s represented character is derived from the literal content as follows: [expr.literal.byte-char.escape] If the literal content is one of the following forms of escape sequence, the represented character is the escape sequence\'s escaped value: Simple escapes 8-bit escapes [expr.literal.byte-char.single] Otherwise the represented character is the single character that makes up the literal content. [expr.literal.byte-char.result] The expression\'s value is the represented character\'s Unicode scalar value . Note The permitted forms of a BYTE_LITERAL token ensure that these rules always produce a single character, whose Unicode scalar value is in the range of u8 . Examples of byte literal expressions: b\'R\'; // 82\\nb\'\\\\\'\'; // 39\\nb\'\\\\x52\'; // 82\\nb\'\\\\xA0\'; // 160 [expr.literal.byte-string]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Byte literal expressions","id":"249","title":"Byte literal expressions"},"25":{"body":"Comments follow the general C++ style of line (//) and block (/* ... */) comment forms. Nested block comments are supported. [comments.normal.tokenization] Non-doc comments are interpreted as a form of whitespace. [comments.doc]","breadcrumbs":"Lexical structure  Comments  Non-doc comments","id":"25","title":"Non-doc comments"},"250":{"body":"[expr.literal.byte-string.intro] A byte string literal expression consists of a single BYTE_STRING_LITERAL or RAW_BYTE_STRING_LITERAL token. [expr.literal.byte-string.type] The expression\'s type is a shared reference (with static lifetime) to an array whose element type is u8 . That is, the type is &\'static [u8; N], where N is the number of bytes in the represented string described below. [expr.literal.byte-string.no-suffix] The token must not have a suffix. [expr.literal.byte-string.literal-content] The token\'s literal content is the sequence of characters following the first U+0022 (\\") and preceding the last U+0022 (\\") in the string representation of the token. [expr.literal.byte-string.represented] The literal expression\'s represented string is a sequence of characters derived from the literal content as follows: [expr.literal.byte-string.escape] If the token is a BYTE_STRING_LITERAL , each escape sequence of any of the following forms occurring in the literal content is replaced by the escape sequence\'s escaped value. Simple escapes 8-bit escapes String continuation escapes These replacements take place in left-to-right order. For example, the token b\\"\\\\\\\\x41\\" is converted to the characters \\\\ x 4 1. [expr.literal.byte-string.raw] If the token is a RAW_BYTE_STRING_LITERAL , the represented string is identical to the literal content. [expr.literal.byte-string.result] The expression\'s value is a reference to a statically allocated array containing the Unicode scalar values of the characters in the represented string, in the same order. Note The permitted forms of BYTE_STRING_LITERAL and RAW_BYTE_STRING_LITERAL tokens ensure that these rules always produce array element values in the range of u8 . Examples of byte string literal expressions: b\\"foo\\"; br\\"foo\\"; // foo\\nb\\"\\\\\\"foo\\\\\\"\\"; br#\\"\\"foo\\"\\"#; // \\"foo\\" b\\"foo #\\\\\\"# bar\\";\\nbr##\\"foo #\\"# bar\\"##; // foo #\\"# bar b\\"\\\\x52\\"; b\\"R\\"; br\\"R\\"; // R\\nb\\"\\\\\\\\x52\\"; br\\"\\\\x52\\"; // \\\\x52 [expr.literal.c-string]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Byte string literal expressions","id":"250","title":"Byte string literal expressions"},"251":{"body":"[expr.literal.c-string.intro] A C string literal expression consists of a single C_STRING_LITERAL or RAW_C_STRING_LITERAL token. [expr.literal.c-string.type] The expression\'s type is a shared reference (with static lifetime) to the standard library CStr type. That is, the type is &\'static core::ffi::CStr. [expr.literal.c-string.no-suffix] The token must not have a suffix. [expr.literal.c-string.literal-content] The token\'s literal content is the sequence of characters following the first \\" and preceding the last \\" in the string representation of the token. [expr.literal.c-string.represented] The literal expression\'s represented bytes are a sequence of bytes derived from the literal content as follows: [expr.literal.c-string.escape] If the token is a C_STRING_LITERAL , the literal content is treated as a sequence of items, each of which is either a single Unicode character other than \\\\ or an escape . The sequence of items is converted to a sequence of bytes as follows: Each single Unicode character contributes its UTF-8 representation. Each simple escape contributes the Unicode scalar value of its escaped value. Each 8-bit escape contributes a single byte containing the Unicode scalar value of its escaped value. Each unicode escape contributes the UTF-8 representation of its escaped value. Each string continuation escape contributes no bytes. [expr.literal.c-string.raw] If the token is a RAW_C_STRING_LITERAL , the represented bytes are the UTF-8 encoding of the literal content. Note The permitted forms of C_STRING_LITERAL and RAW_C_STRING_LITERAL tokens ensure that the represented bytes never include a null byte. [expr.literal.c-string.result] The expression\'s value is a reference to a statically allocated CStr whose array of bytes contains the represented bytes followed by a null byte. Examples of C string literal expressions: c\\"foo\\"; cr\\"foo\\"; // foo\\nc\\"\\\\\\"foo\\\\\\"\\"; cr#\\"\\"foo\\"\\"#; // \\"foo\\" c\\"foo #\\\\\\"# bar\\";\\ncr##\\"foo #\\"# bar\\"##; // foo #\\"# bar c\\"\\\\x52\\"; c\\"R\\"; cr\\"R\\"; // R\\nc\\"\\\\\\\\x52\\"; cr\\"\\\\x52\\"; // \\\\x52 c\\"\\"; // LATIN SMALL LETTER AE (U+00E6)\\nc\\"\\\\u{00E6}\\"; // LATIN SMALL LETTER AE (U+00E6)\\nc\\"\\\\xC3\\\\xA6\\"; // LATIN SMALL LETTER AE (U+00E6) c\\"\\\\xE6\\".to_bytes(); // [230]\\nc\\"\\\\u{00E6}\\".to_bytes(); // [195, 166] [expr.literal.int]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  C string literal expressions","id":"251","title":"C string literal expressions"},"252":{"body":"[expr.literal.int.intro] An integer literal expression consists of a single INTEGER_LITERAL token. [expr.literal.int.suffix] If the token has a suffix , the suffix must be the name of one of the primitive integer types : u8, i8, u16, i16, u32, i32, u64, i64, u128, i128, usize, or isize, and the expression has that type. [expr.literal.int.infer] If the token has no suffix, the expression\'s type is determined by type inference: [expr.literal.int.inference-unique-type] If an integer type can be uniquely determined from the surrounding program context, the expression has that type. [expr.literal.int.inference-default] If the program context under-constrains the type, it defaults to the signed 32-bit integer i32. [expr.literal.int.inference-error] If the program context over-constrains the type, it is considered a static type error. Examples of integer literal expressions: 123; // type i32\\n123i32; // type i32\\n123u32; // type u32\\n123_u32; // type u32\\nlet a: u64 = 123; // type u64 0xff; // type i32\\n0xff_u8; // type u8 0o70; // type i32\\n0o70_i16; // type i16 0b1111_1111_1001_0000; // type i32\\n0b1111_1111_1001_0000i64; // type i64 0usize; // type usize [expr.literal.int.representation] The value of the expression is determined from the string representation of the token as follows: [expr.literal.int.radix] An integer radix is chosen by inspecting the first two characters of the string, as follows: 0b indicates radix 2 0o indicates radix 8 0x indicates radix 16 otherwise the radix is 10. [expr.literal.int.radix-prefix-stripped] If the radix is not 10, the first two characters are removed from the string. [expr.literal.int.type-suffix-stripped] Any suffix is removed from the string. [expr.literal.int.separators-stripped] Any underscores are removed from the string. [expr.literal.int.u128-value] The string is converted to a u128 value as if by u128::from_str_radix with the chosen radix. If the value does not fit in u128, it is a compiler error. [expr.literal.int.cast] The u128 value is converted to the expression\'s type via a numeric cast . Note The final cast will truncate the value of the literal if it does not fit in the expression\'s type. rustc includes a lint check named overflowing_literals, defaulting to deny, which rejects expressions where this occurs. Note -1i8, for example, is an application of the negation operator to the literal expression 1i8, not a single integer literal expression. See Overflow for notes on representing the most negative value for a signed type. [expr.literal.float]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Integer literal expressions","id":"252","title":"Integer literal expressions"},"253":{"body":"[expr.literal.float.intro] A floating-point literal expression has one of two forms: a single FLOAT_LITERAL token a single INTEGER_LITERAL token which has a suffix and no radix indicator [expr.literal.float.suffix] If the token has a suffix , the suffix must be the name of one of the primitive floating-point types : f32 or f64, and the expression has that type. [expr.literal.float.infer] If the token has no suffix, the expression\'s type is determined by type inference: [expr.literal.float.inference-unique-type] If a floating-point type can be uniquely determined from the surrounding program context, the expression has that type. [expr.literal.float.inference-default] If the program context under-constrains the type, it defaults to f64. [expr.literal.float.inference-error] If the program context over-constrains the type, it is considered a static type error. Examples of floating-point literal expressions: 123.0f64; // type f64\\n0.1f64; // type f64\\n0.1f32; // type f32\\n12E+99_f64; // type f64\\n5f32; // type f32\\nlet x: f64 = 2.; // type f64 [expr.literal.float.result] The value of the expression is determined from the string representation of the token as follows: [expr.literal.float.type-suffix-stripped] Any suffix is removed from the string. [expr.literal.float.separators-stripped] Any underscores are removed from the string. [expr.literal.float.value] The string is converted to the expression\'s type as if by f32::from_str or f64::from_str . Note -1.0, for example, is an application of the negation operator to the literal expression 1.0, not a single floating-point literal expression. Note inf and NaN are not literal tokens. The f32::INFINITY , f64::INFINITY , f32::NAN , and f64::NAN constants can be used instead of literal expressions. In rustc, a literal large enough to be evaluated as infinite will trigger the overflowing_literals lint check. [expr.literal.bool]","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Floating-point literal expressions","id":"253","title":"Floating-point literal expressions"},"254":{"body":"[expr.literal.bool.intro] A boolean literal expression consists of one of the keywords true or false. [expr.literal.bool.result] The expression\'s type is the primitive boolean type , and its value is: true if the keyword is true false if the keyword is false","breadcrumbs":"Statements and expressions  Expressions  Literal expressions  Boolean literal expressions","id":"254","title":"Boolean literal expressions"},"255":{"body":"[expr.path] [expr.path.syntax] Syntax PathExpression  PathInExpression | QualifiedPathInExpression Show Railroad PathExpression PathInExpression QualifiedPathInExpression [expr.path.intro] A path used as an expression context denotes either a local variable or an item. [expr.path.place] Path expressions that resolve to local or static variables are place expressions , other paths are value expressions . [expr.path.safety] Using a static mut variable requires an unsafe block . # mod globals {\\n# pub static STATIC_VAR: i32 = 5;\\n# pub static mut STATIC_MUT_VAR: i32 = 7;\\n# }\\n# let local_var = 3;\\nlocal_var;\\nglobals::STATIC_VAR;\\nunsafe { globals::STATIC_MUT_VAR };\\nlet some_constructor = Some::<i32>;\\nlet push_integer = Vec::<i32>::push;\\nlet slice_reverse = <[i32]>::reverse; [expr.path.const] Evaluation of associated constants is handled the same way as const blocks .","breadcrumbs":"Statements and expressions  Expressions  Path expressions  Path expressions","id":"255","title":"Path expressions"},"256":{"body":"[expr.block] [expr.block.syntax] Syntax BlockExpression  { InnerAttribute * Statements ? } Statements  Statement + | Statement + ExpressionWithoutBlock | ExpressionWithoutBlock Show Railroad BlockExpression { InnerAttribute Statements } Statements Statement Statement ExpressionWithoutBlock ExpressionWithoutBlock [expr.block.intro] A block expression , or block , is a control flow expression and anonymous namespace scope for items and variable declarations. [expr.block.sequential-evaluation] As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. [expr.block.namespace] As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by let statements are in scope from the next statement until the end of the block. See the scopes chapter for more details. [expr.block.inner-attributes] The syntax for a block is {, then any inner attributes , then any number of statements , then an optional expression, called the final operand, and finally a }. [expr.block.statements] Statements are usually required to be followed by a semicolon, with two exceptions: Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. [expr.block.null-statement] Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics. [expr.block.evaluation] When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. [expr.block.result] Then the final operand is executed, if given. [expr.block.type] The type of a block is the type of the final operand, or () if the final operand is omitted. # fn fn_call() {}\\nlet _: () = { fn_call();\\n}; let five: i32 = { fn_call(); 5\\n}; assert_eq!(5, five); Note As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is () unless it is followed immediately by a semicolon. [expr.block.value] Blocks are always value expressions and evaluate the last operand in value expression context. Note This can be used to force moving a value if really needed. For example, the following example fails on the call to consume_self because the struct was moved out of s in the block expression. struct Struct; impl Struct { fn consume_self(self) {} fn borrow_self(&self) {}\\n} fn move_by_block_expression() { let s = Struct; // Move the value out of `s` in the block expression. (&{ s }).borrow_self(); // Fails to execute because `s` is moved out of. s.consume_self();\\n} [expr.block.async]","breadcrumbs":"Statements and expressions  Expressions  Block expressions  Block expressions","id":"256","title":"Block expressions"},"257":{"body":"[expr.block.async.syntax] Syntax AsyncBlockExpression  async move? BlockExpression Show Railroad AsyncBlockExpression async move BlockExpression [expr.block.async.intro] An async block is a variant of a block expression which evaluates to a future. [expr.block.async.future-result] The final expression of the block, if present, determines the result value of the future. [expr.block.async.anonymous-type] Executing an async block is similar to executing a closure expression: its immediate effect is to produce and return an anonymous type. [expr.block.async.future] Whereas closures return a type that implements one or more of the std::ops::Fn traits, however, the type returned for an async block implements the std::future::Future trait. [expr.block.async.layout-unspecified] The actual data format for this type is unspecified. Note The future type that rustc generates is roughly equivalent to an enum with one variant per await point, where each variant stores the data needed to resume from its corresponding point. [expr.block.async.edition2018] 2018 Edition differences Async blocks are only available beginning with Rust 2018. [expr.block.async.capture]","breadcrumbs":"Statements and expressions  Expressions  Block expressions  async blocks","id":"257","title":"async blocks"},"258":{"body":"Async blocks capture variables from their environment using the same capture modes as closures. Like closures, when written async { .. } the capture mode for each variable will be inferred from the content of the block. async move { .. } blocks however will move all referenced variables into the resulting future. [expr.block.async.context]","breadcrumbs":"Statements and expressions  Expressions  Block expressions  Capture modes","id":"258","title":"Capture modes"},"259":{"body":"Because async blocks construct a future, they define an async context which can in turn contain await expressions . Async contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks. [expr.block.async.function]","breadcrumbs":"Statements and expressions  Expressions  Block expressions  Async context","id":"259","title":"Async context"},"26":{"body":"[comments.doc.syntax] Line doc comments beginning with exactly three slashes (///), and block doc comments (/** ... */), both outer doc comments, are interpreted as a special syntax for doc attributes . [comments.doc.attributes] That is, they are equivalent to writing #[doc=\\"...\\"] around the body of the comment, i.e., /// Foo turns into #[doc=\\"Foo\\"] and /** Bar */ turns into #[doc=\\"Bar\\"]. They must therefore appear before something that accepts an outer attribute. [comments.doc.inner-syntax] Line comments beginning with //! and block comments /*! ... */ are doc comments that apply to the parent of the comment, rather than the item that follows. [comments.doc.inner-attributes] That is, they are equivalent to writing #![doc=\\"...\\"] around the body of the comment. //! comments are usually used to document modules that occupy a source file. [comments.doc.bare-crs] The character U+000D (CR) is not allowed in doc comments. Note It is conventional for doc comments to contain Markdown, as expected by rustdoc. However, the comment syntax does not respect any internal Markdown. /** `glob = \\"*/*.rs\\";` */ terminates the comment at the first */, and the remaining code would cause a syntax error. This slightly limits the content of block doc comments compared to line doc comments. Note The sequence U+000D (CR) immediately followed by U+000A (LF) would have been previously transformed into a single U+000A (LF).","breadcrumbs":"Lexical structure  Comments  Doc comments","id":"26","title":"Doc comments"},"260":{"body":"[expr.block.async.function.intro] Async blocks act like a function boundary, much like closures. [expr.block.async.function.return-try] Therefore, the ? operator and return expressions both affect the output of the future, not the enclosing function or other context. That is, return <expr> from within an async block will return the result of <expr> as the output of the future. Similarly, if <expr>? propagates an error, that error is propagated as the result of the future. [expr.block.async.function.control-flow] Finally, the break and continue keywords cannot be used to branch out from an async block. Therefore the following is illegal: loop { async move { break; // error[E0267]: `break` inside of an `async` block }\\n} [expr.block.const]","breadcrumbs":"Statements and expressions  Expressions  Block expressions  Control-flow operators","id":"260","title":"Control-flow operators"},"261":{"body":"[expr.block.const.syntax] Syntax ConstBlockExpression  const BlockExpression Show Railroad ConstBlockExpression const BlockExpression [expr.block.const.intro] A const block is a variant of a block expression whose body evaluates at compile-time instead of at runtime. [expr.block.const.context] Const blocks allows you to define a constant value without having to define new constant items , and thus they are also sometimes referred as inline consts . It also supports type inference so there is no need to specify the type, unlike constant items . [expr.block.const.generic-params] Const blocks have the ability to reference generic parameters in scope, unlike free constant items. They are desugared to constant items with generic parameters in scope (similar to associated constants, but without a trait or type they are associated with). For example, this code: fn foo<T>() -> usize { const { std::mem::size_of::<T>() + 1 }\\n} is equivalent to: fn foo<T>() -> usize { { struct Const<T>(T); impl<T> Const<T> { const CONST: usize = std::mem::size_of::<T>() + 1; } Const::<T>::CONST }\\n} [expr.block.const.evaluation] If the const block expression is executed at runtime, then the constant is guaranteed to be evaluated, even if its return value is ignored: fn foo<T>() -> usize { // If this code ever gets executed, then the assertion has definitely // been evaluated at compile-time. const { assert!(std::mem::size_of::<T>() > 0); } // Here we can have unsafe code relying on the type being non-zero-sized. /* ... */ 42\\n} [expr.block.const.not-executed] If the const block expression is not executed at runtime, it may or may not be evaluated: if false { // The panic may or may not occur when the program is built. const { panic!(); }\\n} [expr.block.unsafe]","breadcrumbs":"Statements and expressions  Expressions  Block expressions  const blocks","id":"261","title":"const blocks"},"262":{"body":"[expr.block.unsafe.syntax] Syntax UnsafeBlockExpression  unsafe BlockExpression Show Railroad UnsafeBlockExpression unsafe BlockExpression [expr.block.unsafe.intro] See unsafe blocks for more information on when to use unsafe . A block of code can be prefixed with the unsafe keyword to permit unsafe operations . Examples: unsafe { let b = [13u8, 17u8]; let a = &b[0] as *const u8; assert_eq!(*a, 13); assert_eq!(*a.offset(1), 17);\\n} # unsafe fn an_unsafe_fn() -> i32 { 10 }\\nlet a = unsafe { an_unsafe_fn() }; [expr.block.label]","breadcrumbs":"Statements and expressions  Expressions  Block expressions  unsafe blocks","id":"262","title":"unsafe blocks"},"263":{"body":"Labelled block expressions are documented in the Loops and other breakable expressions section. [expr.block.attributes]","breadcrumbs":"Statements and expressions  Expressions  Block expressions  Labelled block expressions","id":"263","title":"Labelled block expressions"},"264":{"body":"[expr.block.attributes.inner-attributes] Inner attributes are allowed directly after the opening brace of a block expression in the following situations: Function and method bodies. Loop bodies ( loop , while , and for ). Block expressions used as a statement . Block expressions as elements of array expressions , tuple expressions , call expressions , and tuple-style struct expressions. A block expression as the tail expression of another block expression. [expr.block.attributes.valid] The attributes that have meaning on a block expression are cfg and the lint check attributes . For example, this function returns true on unix platforms and false on other platforms. fn is_unix_platform() -> bool { #[cfg(unix)] { true } #[cfg(not(unix))] { false }\\n}","breadcrumbs":"Statements and expressions  Expressions  Block expressions  Attributes on block expressions","id":"264","title":"Attributes on block expressions"},"265":{"body":"[expr.operator] [expr.operator.syntax] Syntax OperatorExpression  BorrowExpression | DereferenceExpression | TryPropagationExpression | NegationExpression | ArithmeticOrLogicalExpression | ComparisonExpression | LazyBooleanExpression | TypeCastExpression | AssignmentExpression | CompoundAssignmentExpression Show Railroad OperatorExpression BorrowExpression DereferenceExpression TryPropagationExpression NegationExpression ArithmeticOrLogicalExpression ComparisonExpression LazyBooleanExpression TypeCastExpression AssignmentExpression CompoundAssignmentExpression [expr.operator.intro] Operators are defined for built in types by the Rust language. [expr.operator.trait] Many of the following operators can also be overloaded using traits in std::ops or std::cmp. [expr.operator.int-overflow]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Operator expressions","id":"265","title":"Operator expressions"},"266":{"body":"[expr.operator.int-overflow.intro] Integer operators will panic when they overflow when compiled in debug mode. The -C debug-assertions and -C overflow-checks compiler flags can be used to control this more directly. The following things are considered to be overflow: [expr.operator.int-overflow.binary-arith] When +, * or binary - create a value greater than the maximum value, or less than the minimum value that can be stored. [expr.operator.int-overflow.unary-neg] Applying unary - to the most negative value of any signed integer type, unless the operand is a literal expression (or a literal expression standing alone inside one or more grouped expressions ). [expr.operator.int-overflow.div] Using / or %, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is -1. These checks occur even when -C overflow-checks is disabled, for legacy reasons. [expr.operator.int-overflow.shift] Using << or >> where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative. Note The exception for literal expressions behind unary - means that forms such as -128_i8 or let j: i8 = -(128) never cause a panic and have the expected value of -128. In these cases, the literal expression already has the most negative value for its type (for example, 128_i8 has the value -128) because integer literals are truncated to their type per the description in Integer literal expressions . Negation of these most negative values leaves the value unchanged due to two\'s complement overflow conventions. In rustc, these most negative expressions are also ignored by the overflowing_literals lint check. [expr.operator.borrow]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Overflow","id":"266","title":"Overflow"},"267":{"body":"[expr.operator.borrow.syntax] Syntax BorrowExpression  ( & | && ) Expression | ( & | && ) mut Expression | ( & | && ) raw const Expression | ( & | && ) raw mut Expression Show Railroad BorrowExpression &amp; &amp;&amp; Expression &amp; &amp;&amp; mut Expression &amp; &amp;&amp; raw const Expression &amp; &amp;&amp; raw mut Expression [expr.operator.borrow.intro] The & (shared borrow) and &mut (mutable borrow) operators are unary prefix operators. [expr.operator.borrow.result] When applied to a place expression , this expressions produces a reference (pointer) to the location that the value refers to. [expr.operator.borrow.lifetime] The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&mut), the place may not be accessed in any way until the borrow expires. [expr.operator.borrow.mut] &mut evaluates its operand in a mutable place expression context. [expr.operator.borrow.temporary] If the & or &mut operators are applied to a value expression , then a temporary value is created. These operators cannot be overloaded. { // a temporary with value 7 is created that lasts for this scope. let shared_reference = &7;\\n}\\nlet mut array = [-2, 3, 9];\\n{ // Mutably borrows `array` for this scope. // `array` may only be used through `mutable_reference`. let mutable_reference = &mut array;\\n} [expr.borrow.and-and-syntax] Even though && is a single token ( the lazy \'and\' operator ), when used in the context of borrow expressions it works as two borrows: // same meanings:\\nlet a = && 10;\\nlet a = & & 10; // same meanings:\\nlet a = &&&& mut 10;\\nlet a = && && mut 10;\\nlet a = & & & & mut 10; [expr.borrow.raw]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Borrow operators","id":"267","title":"Borrow operators"},"268":{"body":"[expr.borrow.raw.intro] &raw const and &raw mut are the raw borrow operators . [expr.borrow.raw.place] The operand expression of these operators is evaluated in place expression context. [expr.borrow.raw.result] &raw const expr then creates a const raw pointer of type *const T to the given place, and &raw mut expr creates a mutable raw pointer of type *mut T. [expr.borrow.raw.invalid-ref] The raw borrow operators must be used instead of a borrow operator whenever the place expression could evaluate to a place that is not properly aligned or does not store a valid value as determined by its type, or whenever creating a reference would introduce incorrect aliasing assumptions. In those situations, using a borrow operator would cause undefined behavior by creating an invalid reference, but a raw pointer may still be constructed. The following is an example of creating a raw pointer to an unaligned place through a packed struct: #[repr(packed)]\\nstruct Packed { f1: u8, f2: u16,\\n} let packed = Packed { f1: 1, f2: 2 };\\n// `&packed.f2` would create an unaligned reference, and thus be undefined behavior!\\nlet raw_f2 = &raw const packed.f2;\\nassert_eq!(unsafe { raw_f2.read_unaligned() }, 2); The following is an example of creating a raw pointer to a place that does not contain a valid value: use std::mem::MaybeUninit; struct Demo { field: bool,\\n} let mut uninit = MaybeUninit::<Demo>::uninit();\\n// `&uninit.as_mut().field` would create a reference to an uninitialized `bool`,\\n// and thus be undefined behavior!\\nlet f1_ptr = unsafe { &raw mut (*uninit.as_mut_ptr()).field };\\nunsafe { f1_ptr.write(true); }\\nlet init = unsafe { uninit.assume_init() }; [expr.deref]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Raw borrow operators","id":"268","title":"Raw borrow operators"},"269":{"body":"[expr.deref.syntax] Syntax DereferenceExpression  * Expression Show Railroad DereferenceExpression * Expression [expr.deref.intro] The * (dereference) operator is also a unary prefix operator. [expr.deref.result] When applied to a pointer it denotes the pointed-to location. [expr.deref.mut] If the expression is of type &mut T or *mut T, and is either a local variable, a (nested) field of a local variable or is a mutable place expression , then the resulting memory location can be assigned to. [expr.deref.safety] Dereferencing a raw pointer requires unsafe. [expr.deref.traits] On non-pointer types *x is equivalent to *std::ops::Deref::deref(&x) in an immutable place expression context and *std::ops::DerefMut::deref_mut(&mut x) in a mutable place expression context. let x = &7;\\nassert_eq!(*x, 7);\\nlet y = &mut 9;\\n*y = 11;\\nassert_eq!(*y, 11); [expr.try]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  The dereference operator","id":"269","title":"The dereference operator"},"27":{"body":"//! A doc comment that applies to the implicit anonymous module of this crate pub mod outer_module { //! - Inner line doc //!! - Still an inner line doc (but with a bang at the beginning) /*! - Inner block doc */ /*!! - Still an inner block doc (but with a bang at the beginning) */ // - Only a comment /// - Outer line doc (exactly 3 slashes) //// - Only a comment /* - Only a comment */ /** - Outer block doc (exactly) 2 asterisks */ /*** - Only a comment */ pub mod inner_module {} pub mod nested_comments { /* In Rust /* we can /* nest comments */ */ */ // All three types of block comments can contain or be nested inside // any other type: /* /* */ /** */ /*! */ */ /*! /* */ /** */ /*! */ */ /** /* */ /** */ /*! */ */ pub mod dummy_item {} } pub mod degenerate_cases { // empty inner line doc //! // empty inner block doc /*!*/ // empty line comment // // empty outer line doc /// // empty block comment /**/ pub mod dummy_item {} // empty 2-asterisk block isn\'t a doc block, it is a block comment /***/ } /* The next one isn\'t allowed because outer doc comments require an item that will receive the doc */ /// Where is my item?\\n# mod boo {}\\n}","breadcrumbs":"Lexical structure  Comments  Examples","id":"27","title":"Examples"},"270":{"body":"[expr.try.syntax] Syntax TryPropagationExpression  Expression ? Show Railroad TryPropagationExpression Expression ? [expr.try.intro] The try propagation expression uses the value of the inner expression and the Try trait to decide whether to produce a value, and if so, what value to produce, or whether to return a value to the caller, and if so, what value to return. Example # use std::num::ParseIntError;\\nfn try_to_parse() -> Result<i32, ParseIntError> { let x: i32 = \\"123\\".parse()?; // `x` is `123`. let y: i32 = \\"24a\\".parse()?; // Returns an `Err()` immediately. Ok(x + y) // Doesn\'t run.\\n} let res = try_to_parse();\\nprintln!(\\"{res:?}\\");\\n# assert!(res.is_err()) fn try_option_some() -> Option<u8> { let val = Some(1)?; Some(val)\\n}\\nassert_eq!(try_option_some(), Some(1)); fn try_option_none() -> Option<u8> { let val = None?; Some(val)\\n}\\nassert_eq!(try_option_none(), None); use std::ops::ControlFlow; pub struct TreeNode<T> { value: T, left: Option<Box<TreeNode<T>>>, right: Option<Box<TreeNode<T>>>,\\n} impl<T> TreeNode<T> { pub fn traverse_inorder<B>(&self, f: &mut impl FnMut(&T) -> ControlFlow<B>) -> ControlFlow<B> { if let Some(left) = &self.left { left.traverse_inorder(f)?; } f(&self.value)?; if let Some(right) = &self.right { right.traverse_inorder(f)?; } ControlFlow::Continue(()) }\\n}\\n#\\n# fn main() {\\n# let n = TreeNode {\\n# value: 1,\\n# left: Some(Box::new(TreeNode{value: 2, left: None, right: None})),\\n# right: None,\\n# };\\n# let v = n.traverse_inorder(&mut |t| {\\n# if *t == 2 {\\n# ControlFlow::Break(\\"found\\")\\n# } else {\\n# ControlFlow::Continue(())\\n# }\\n# });\\n# assert_eq!(v, ControlFlow::Break(\\"found\\"));\\n# } Note The Try trait is currently unstable, and thus cannot be implemented for user types. The try propagation expression is currently roughly equivalent to: # #![ feature(try_trait_v2) ]\\n# fn example() -> Result<(), ()> {\\n# let expr = Ok(());\\nmatch core::ops::Try::branch(expr) { core::ops::ControlFlow::Continue(val) => val, core::ops::ControlFlow::Break(residual) => return core::ops::FromResidual::from_residual(residual),\\n}\\n# Ok(())\\n# } Note The try propagation operator is sometimes called the question mark operator , the ? operator , or the try operator . [expr.try.restricted-types] The try propagation operator can be applied to expressions with the type of: Result<T, E> Result::Ok(val) evaluates to val. Result::Err(e) returns Result::Err(From::from(e)). Option<T> Option::Some(val) evaluates to val. Option::None returns Option::None. ControlFlow<B, C> ControlFlow::Continue(c) evaluates to c. ControlFlow::Break(b) returns ControlFlow::Break(b). Poll<Result<T, E>> Poll::Ready(Ok(val)) evaluates to Poll::Ready(val). Poll::Ready(Err(e)) returns Poll::Ready(Err(From::from(e))). Poll::Pending evaluates to Poll::Pending. Poll<Option<Result<T, E>>> Poll::Ready(Some(Ok(val))) evaluates to Poll::Ready(Some(val)). Poll::Ready(Some(Err(e))) returns Poll::Ready(Some(Err(From::from(e)))). Poll::Ready(None) evaluates to Poll::Ready(None). Poll::Pending evaluates to Poll::Pending. [expr.negate]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  The try propagation expression","id":"270","title":"The try propagation expression"},"271":{"body":"[expr.negate.syntax] Syntax NegationExpression  - Expression | ! Expression Show Railroad NegationExpression - Expression ! Expression [expr.negate.intro] These are the last two unary operators. [expr.negate.results] This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two\'s complement. The operands of all of these operators are evaluated in value expression context so are moved or copied. Symbol Integer bool Floating Point Overloading Trait - Negation* Negation std::ops::Neg ! Bitwise NOT Logical NOT std::ops::Not * Only for signed integer types. Here are some example of these operators let x = 6;\\nassert_eq!(-x, -6);\\nassert_eq!(!x, -7);\\nassert_eq!(true, !false); [expr.arith-logic]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Negation operators","id":"271","title":"Negation operators"},"272":{"body":"[expr.arith-logic.syntax] Syntax ArithmeticOrLogicalExpression  Expression + Expression | Expression - Expression | Expression * Expression | Expression / Expression | Expression % Expression | Expression & Expression | Expression | Expression | Expression ^ Expression | Expression << Expression | Expression >> Expression Show Railroad ArithmeticOrLogicalExpression Expression + Expression Expression - Expression Expression * Expression Expression / Expression Expression % Expression Expression &amp; Expression Expression | Expression Expression ^ Expression Expression &lt;&lt; Expression Expression &gt;&gt; Expression [expr.arith-logic.intro] Binary operators expressions are all written with infix notation. [expr.arith-logic.behavior] This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two\'s complement. The operands of all of these operators are evaluated in value expression context so are moved or copied. Symbol Integer bool Floating Point Overloading Trait Overloading Compound Assignment Trait + Addition Addition std::ops::Add std::ops::AddAssign - Subtraction Subtraction std::ops::Sub std::ops::SubAssign * Multiplication Multiplication std::ops::Mul std::ops::MulAssign / Division* Division std::ops::Div std::ops::DivAssign % Remainder** Remainder std::ops::Rem std::ops::RemAssign & Bitwise AND Logical AND std::ops::BitAnd std::ops::BitAndAssign | Bitwise OR Logical OR std::ops::BitOr std::ops::BitOrAssign ^ Bitwise XOR Logical XOR std::ops::BitXor std::ops::BitXorAssign << Left Shift std::ops::Shl std::ops::ShlAssign >> Right Shift*** std::ops::Shr std::ops::ShrAssign * Integer division rounds towards zero. ** Rust uses a remainder defined with truncating division . Given remainder = dividend % divisor, the remainder will have the same sign as the dividend. *** Arithmetic right shift on signed integer types, logical right shift on unsigned integer types.  For integer types, division by zero panics. Here are examples of these operators being used. assert_eq!(3 + 6, 9);\\nassert_eq!(5.5 - 1.25, 4.25);\\nassert_eq!(-5 * 14, -70);\\nassert_eq!(14 / 3, 4);\\nassert_eq!(100 % 7, 2);\\nassert_eq!(0b1010 & 0b1100, 0b1000);\\nassert_eq!(0b1010 | 0b1100, 0b1110);\\nassert_eq!(0b1010 ^ 0b1100, 0b110);\\nassert_eq!(13 << 3, 104);\\nassert_eq!(-10 >> 2, -3); [expr.cmp]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Arithmetic and logical binary operators","id":"272","title":"Arithmetic and logical binary operators"},"273":{"body":"[expr.cmp.syntax] Syntax ComparisonExpression  Expression == Expression | Expression != Expression | Expression > Expression | Expression < Expression | Expression >= Expression | Expression <= Expression Show Railroad ComparisonExpression Expression == Expression Expression != Expression Expression &gt; Expression Expression &lt; Expression Expression &gt;= Expression Expression &lt;= Expression [expr.cmp.intro] Comparison operators are also defined both for primitive types and many types in the standard library. [expr.cmp.paren-chaining] Parentheses are required when chaining comparison operators. For example, the expression a == b == c is invalid and may be written as (a == b) == c. [expr.cmp.trait] Unlike arithmetic and logical operators, the traits for overloading these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety). [expr.cmp.place] Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in place expression context : # let a = 1;\\n# let b = 1;\\na == b;\\n// is equivalent to\\n::std::cmp::PartialEq::eq(&a, &b); This means that the operands don\'t have to be moved out of. [expr.cmp.behavior] Symbol Meaning Overloading method == Equal std::cmp::PartialEq::eq != Not equal std::cmp::PartialEq::ne > Greater than std::cmp::PartialOrd::gt < Less than std::cmp::PartialOrd::lt >= Greater than or equal to std::cmp::PartialOrd::ge <= Less than or equal to std::cmp::PartialOrd::le Here are examples of the comparison operators being used. assert!(123 == 123);\\nassert!(23 != -12);\\nassert!(12.5 > 12.2);\\nassert!([1, 2, 3] < [1, 3, 4]);\\nassert!(\'A\' <= \'B\');\\nassert!(\\"World\\" >= \\"Hello\\"); [expr.bool-logic]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Comparison operators","id":"273","title":"Comparison operators"},"274":{"body":"[expr.bool-logic.syntax] Syntax LazyBooleanExpression  Expression || Expression | Expression && Expression Show Railroad LazyBooleanExpression Expression || Expression Expression &amp;&amp; Expression [expr.bool-logic.intro] The operators || and && may be applied to operands of boolean type. The || operator denotes logical \'or\', and the && operator denotes logical \'and\'. [expr.bool-logic.conditional-evaluation] They differ from | and & in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, || only evaluates its right-hand operand when the left-hand operand evaluates to false, and && only when it evaluates to true. let x = false || true; // true\\nlet y = false && panic!(); // false, doesn\'t evaluate `panic!()` [expr.as]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Lazy boolean operators","id":"274","title":"Lazy boolean operators"},"275":{"body":"[expr.as.syntax] Syntax TypeCastExpression  Expression as TypeNoBounds Show Railroad TypeCastExpression Expression as TypeNoBounds [expr.as.intro] A type cast expression is denoted with the binary operator as. [expr.as.result] Executing an as expression casts the value on the left-hand side to the type on the right-hand side. An example of an as expression: # fn sum(values: &[f64]) -> f64 { 0.0 }\\n# fn len(values: &[f64]) -> i32 { 0 }\\nfn average(values: &[f64]) -> f64 { let sum: f64 = sum(values); let size: f64 = len(values) as f64; sum / size\\n} [expr.as.coercions] as can be used to explicitly perform coercions , as well as the following additional casts. Any cast that does not fit either a coercion rule or an entry in the table is a compiler error. Here *T means either *const T or *mut T. m stands for optional mut in reference types and mut or const in pointer types. Type of e U Cast performed by e as U Integer or Float type Integer or Float type Numeric cast Enumeration Integer type Enum cast bool or char Integer type Primitive to integer cast u8 char u8 to char cast *T *V [1] Pointer to pointer cast *T where T: Sized Integer type Pointer to address cast Integer type *V where V: Sized Address to pointer cast &m [T; n] *m T [2] Array to pointer cast *m [T; n] *m T [2] Array to pointer cast Function item Function pointer Function item to function pointer cast Function item *V where V: Sized Function item to pointer cast Function item Integer Function item to address cast Function pointer *V where V: Sized Function pointer to pointer cast Function pointer Integer Function pointer to address cast Closure [3] Function pointer Closure to function pointer cast where T and V have compatible metadata: V: Sized, or Both slice metadata (*[u16] -> *[u8], *str -> *(u8, [u32])), or Both the same trait object metadata, modulo dropping auto traits (*dyn Debug -> *(u16, dyn Debug), *dyn Debug + Send -> *dyn Debug) Note : adding auto traits is only allowed if the principal trait has the auto trait as a super trait (given trait T: Send {}, *dyn T -> *dyn T + Send is valid, but *dyn Debug -> *dyn Debug + Send is not) Note : Generics (including lifetimes) must match (*dyn T<\'a, A> -> *dyn T<\'b, B> requires \'a = \'b and A = B) only when m is mut or m is const. Casting mut reference/pointer to const pointer is allowed. only for closures that do not capture (close over) any local variables can be casted to function pointers.","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Type cast expressions","id":"275","title":"Type cast expressions"},"276":{"body":"[expr.as.numeric] Numeric cast [expr.as.numeric.int-same-size] Casting between two integers of the same size (e.g. i32 -> u32) is a no-op (Rust uses 2\'s complement for negative values of fixed integers) assert_eq!(42i8 as u8, 42u8);\\nassert_eq!(-1i8 as u8, 255u8);\\nassert_eq!(255u8 as i8, -1i8);\\nassert_eq!(-1i16 as u16, 65535u16); [expr.as.numeric.int-truncation] Casting from a larger integer to a smaller integer (e.g. u32 -> u8) will truncate assert_eq!(42u16 as u8, 42u8);\\nassert_eq!(1234u16 as u8, 210u8);\\nassert_eq!(0xabcdu16 as u8, 0xcdu8); assert_eq!(-42i16 as i8, -42i8);\\nassert_eq!(1234u16 as i8, -46i8);\\nassert_eq!(0xabcdi32 as i8, -51i8); [expr.as.numeric.int-extension] Casting from a smaller integer to a larger integer (e.g. u8 -> u32) will zero-extend if the source is unsigned sign-extend if the source is signed assert_eq!(42i8 as i16, 42i16);\\nassert_eq!(-17i8 as i16, -17i16);\\nassert_eq!(0b1000_1010u8 as u16, 0b0000_0000_1000_1010u16, \\"Zero-extend\\");\\nassert_eq!(0b0000_1010i8 as i16, 0b0000_0000_0000_1010i16, \\"Sign-extend 0\\");\\nassert_eq!(0b1000_1010u8 as i8 as i16, 0b1111_1111_1000_1010u16 as i16, \\"Sign-extend 1\\"); [expr.as.numeric.float-as-int] Casting from a float to an integer will round the float towards zero NaN will return 0 Values larger than the maximum integer value, including INFINITY, will saturate to the maximum value of the integer type. Values smaller than the minimum integer value, including NEG_INFINITY, will saturate to the minimum value of the integer type. assert_eq!(42.9f32 as i32, 42);\\nassert_eq!(-42.9f32 as i32, -42);\\nassert_eq!(42_000_000f32 as i32, 42_000_000);\\nassert_eq!(std::f32::NAN as i32, 0);\\nassert_eq!(1_000_000_000_000_000f32 as i32, 0x7fffffffi32);\\nassert_eq!(std::f32::NEG_INFINITY as i32, -0x80000000i32); [expr.as.numeric.int-as-float] Casting from an integer to float will produce the closest possible float * if necessary, rounding is according to roundTiesToEven mode *** on overflow, infinity (of the same sign as the input) is produced note: with the current set of numeric types, overflow can only happen on u128 as f32 for values greater or equal to f32::MAX + (0.5 ULP) assert_eq!(1337i32 as f32, 1337f32);\\nassert_eq!(123_456_789i32 as f32, 123_456_790f32, \\"Rounded\\");\\nassert_eq!(0xffffffff_ffffffff_ffffffff_ffffffff_u128 as f32, std::f32::INFINITY); [expr.as.numeric.float-widening] Casting from an f32 to an f64 is perfect and lossless assert_eq!(1_234.5f32 as f64, 1_234.5f64);\\nassert_eq!(std::f32::INFINITY as f64, std::f64::INFINITY);\\nassert!((std::f32::NAN as f64).is_nan()); [expr.as.numeric.float-narrowing] Casting from an f64 to an f32 will produce the closest possible f32 ** if necessary, rounding is according to roundTiesToEven mode *** on overflow, infinity (of the same sign as the input) is produced assert_eq!(1_234.5f64 as f32, 1_234.5f32);\\nassert_eq!(1_234_567_891.123f64 as f32, 1_234_567_890f32, \\"Rounded\\");\\nassert_eq!(std::f64::INFINITY as f32, std::f32::INFINITY);\\nassert!((std::f64::NAN as f32).is_nan()); * if integer-to-float casts with this rounding mode and overflow behavior are not supported natively by the hardware, these casts will likely be slower than expected. ** if f64-to-f32 casts with this rounding mode and overflow behavior are not supported natively by the hardware, these casts will likely be slower than expected. *** as defined in IEEE 754-2008 4.3.1: pick the nearest floating point number, preferring the one with an even least significant digit if exactly halfway between two floating point numbers. [expr.as.enum] Enum cast [expr.as.enum.discriminant] Casts an enum to its discriminant, then uses a numeric cast if needed. Casting is limited to the following kinds of enumerations: Unit-only enums Field-less enums without explicit discriminants , or where only unit-variants have explicit discriminants enum Enum { A, B, C }\\nassert_eq!(Enum::A as i32, 0);\\nassert_eq!(Enum::B as i32, 1);\\nassert_eq!(Enum::C as i32, 2); [expr.as.enum.no-drop] Casting is not allowed if the enum implements Drop . [expr.as.bool-char-as-int] Primitive to integer cast false casts to 0, true casts to 1 char casts to the value of the code point, then uses a numeric cast if needed. assert_eq!(false as i32, 0);\\nassert_eq!(true as i32, 1);\\nassert_eq!(\'A\' as i32, 65);\\nassert_eq!(\'\' as i32, 214); [expr.as.u8-as-char] u8 to char cast Casts to the char with the corresponding code point. assert_eq!(65u8 as char, \'A\');\\nassert_eq!(214u8 as char, \'\'); [expr.as.pointer-as-int] Pointer to address cast Casting from a raw pointer to an integer produces the machine address of the referenced memory. If the integer type is smaller than the pointer type, the address may be truncated; using usize avoids this. [expr.as.int-as-pointer] Address to pointer cast Casting from an integer to a raw pointer interprets the integer as a memory address and produces a pointer referencing that memory. Warning This interacts with the Rust memory model, which is still under development. A pointer obtained from this cast may suffer additional restrictions even if it is bitwise equal to a valid pointer. Dereferencing such a pointer may be undefined behavior if aliasing rules are not followed. A trivial example of sound address arithmetic: let mut values: [i32; 2] = [1, 2];\\nlet p1: *mut i32 = values.as_mut_ptr();\\nlet first_address = p1 as usize;\\nlet second_address = first_address + 4; // 4 == size_of::<i32>()\\nlet p2 = second_address as *mut i32;\\nunsafe { *p2 += 1;\\n}\\nassert_eq!(values[1], 3); [expr.as.pointer] Pointer-to-pointer cast [expr.as.pointer.behavior] *const T / *mut T can be cast to *const U / *mut U with the following behavior: [expr.as.pointer.sized] If T and U are both sized, the pointer is returned unchanged. [expr.as.pointer.unsized] If T and U are both unsized, the pointer is also returned unchanged. In particular, the metadata is preserved exactly. For instance, a cast from *const [T] to *const [U] preserves the number of elements. Note that, as a consequence, such casts do not necessarily preserve the size of the pointer\'s referent (e.g., casting *const [u16] to *const [u8] will result in a raw pointer which refers to an object of half the size of the original). The same holds for str and any compound type whose unsized tail is a slice type, such as struct Foo(i32, [u8]) or (u64, Foo). [expr.as.pointer.discard-metadata] If T is unsized and U is sized, the cast discards all metadata that completes the wide pointer T and produces a thin pointer U consisting of the data part of the unsized pointer. [expr.assign]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Semantics","id":"276","title":"Semantics"},"277":{"body":"[expr.assign.syntax] Syntax AssignmentExpression  Expression = Expression Show Railroad AssignmentExpression Expression = Expression [expr.assign.intro] An assignment expression moves a value into a specified place. [expr.assign.assignee] An assignment expression consists of a mutable assignee expression , the assignee operand , followed by an equals sign (=) and a value expression , the assigned value operand . [expr.assign.behavior-basic] In its most basic form, an assignee expression is a place expression , and we discuss this case first. [expr.assign.behavior-destructuring] The more general case of destructuring assignment is discussed below, but this case always decomposes into sequential assignments to place expressions, which may be considered the more fundamental case. [expr.assign.basic]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Assignment expressions","id":"277","title":"Assignment expressions"},"278":{"body":"[expr.assign.evaluation-order] Evaluating assignment expressions begins by evaluating its operands. The assigned value operand is evaluated first, followed by the assignee expression. [expr.assign.destructuring-order] For destructuring assignment, subexpressions of the assignee expression are evaluated left-to-right. Note This is different than other expressions in that the right operand is evaluated before the left one. [expr.assign.drop-target] It then has the effect of first dropping the value at the assigned place, unless the place is an uninitialized local variable or an uninitialized field of a local variable. [expr.assign.behavior] Next it either copies or moves the assigned value to the assigned place. [expr.assign.result] An assignment expression always produces the unit value . Example: let mut x = 0;\\nlet y = 0;\\nx = y; [expr.assign.destructure]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Basic assignments","id":"278","title":"Basic assignments"},"279":{"body":"[expr.assign.destructure.intro] Destructuring assignment is a counterpart to destructuring pattern matches for variable declaration, permitting assignment to complex values, such as tuples or structs. For instance, we may swap two mutable variables: let (mut a, mut b) = (0, 1);\\n// Swap `a` and `b` using destructuring assignment.\\n(b, a) = (a, b); [expr.assign.destructure.assignee] In contrast to destructuring declarations using let, patterns may not appear on the left-hand side of an assignment due to syntactic ambiguities. Instead, a group of expressions that correspond to patterns are designated to be assignee expressions , and permitted on the left-hand side of an assignment. Assignee expressions are then desugared to pattern matches followed by sequential assignment. [expr.assign.destructure.irrefutable] The desugared patterns must be irrefutable: in particular, this means that only slice patterns whose length is known at compile-time, and the trivial slice [..], are permitted for destructuring assignment. The desugaring method is straightforward, and is illustrated best by example. # struct Struct { x: u32, y: u32 }\\n# let (mut a, mut b) = (0, 0);\\n(a, b) = (3, 4); [a, b] = [3, 4]; Struct { x: a, y: b } = Struct { x: 3, y: 4}; // desugars to: { let (_a, _b) = (3, 4); a = _a; b = _b;\\n} { let [_a, _b] = [3, 4]; a = _a; b = _b;\\n} { let Struct { x: _a, y: _b } = Struct { x: 3, y: 4}; a = _a; b = _b;\\n} [expr.assign.destructure.repeat-ident] Identifiers are not forbidden from being used multiple times in a single assignee expression. [expr.assign.destructure.discard-value] Underscore expressions and empty range expressions may be used to ignore certain values, without binding them. [expr.assign.destructure.default-binding] Note that default binding modes do not apply for the desugared expression. [expr.assign.destructure.tmp-scopes] Note The desugaring restricts the temporary scope of the assigned value operand (the RHS) of a destructuring assignment. In a basic assignment, the temporary is dropped at the end of the enclosing temporary scope. Below, that\'s the statement. Therefore, the assignment and use is allowed. # fn temp() {}\\nfn f<T>(x: T) -> T { x }\\nlet x;\\n(x = f(&temp()), x); // OK Conversely, in a destructuring assignment, the temporary is dropped at the end of the let statement in the desugaring. As that happens before we try to assign to x, below, it fails. # fn temp() {}\\n# fn f<T>(x: T) -> T { x }\\n# let x;\\n[x] = [f(&temp())]; // ERROR This desugars to: # fn temp() {}\\n# fn f<T>(x: T) -> T { x }\\n# let x;\\n{ let [_x] = [f(&temp())]; // ^ // The temporary is dropped here. x = _x; // ERROR\\n} [expr.assign.destructure.tmp-ext] Note Due to the desugaring, the assigned value operand (the RHS) of a destructuring assignment is an extending expression within a newly-introduced block. Below, because the temporary scope is extended to the end of this introduced block, the assignment is allowed. # fn temp() {}\\n# let x;\\n[x] = [&temp()]; // OK This desugars to: # fn temp() {}\\n# let x;\\n{ let [_x] = [&temp()]; x = _x; } // OK However, if we try to use x, even within the same statement, we\'ll get an error because the temporary is dropped at the end of this introduced block. # fn temp() {}\\n# let x;\\n([x] = [&temp()], x); // ERROR This desugars to: # fn temp() {}\\n# let x;\\n( { let [_x] = [&temp()]; x = _x; }, // <-- The temporary is dropped here. x, // ERROR\\n); [expr.compound-assign]","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Destructuring assignments","id":"279","title":"Destructuring assignments"},"28":{"body":"[lex.whitespace] [whitespace.syntax] Lexer WHITESPACE  U+0009 // Horizontal tab, \'\\\\t\' | U+000A // Line feed, \'\\\\n\' | U+000B // Vertical tab | U+000C // Form feed | U+000D // Carriage return, \'\\\\r\' | U+0020 // Space, \' \' | U+0085 // Next line | U+200E // Left-to-right mark | U+200F // Right-to-left mark | U+2028 // Line separator | U+2029 // Paragraph separator TAB  U+0009 // Horizontal tab, \'\\\\t\' LF  U+000A // Line feed, \'\\\\n\' CR  U+000D // Carriage return, \'\\\\r\' Show Railroad WHITESPACE U+0009 U+000A U+000B U+000C U+000D U+0020 U+0085 U+200E U+200F U+2028 U+2029 TAB U+0009 LF U+000A CR U+000D [lex.whitespace.intro] Whitespace is any non-empty string containing only characters that have the Pattern_White_Space Unicode property. [lex.whitespace.token-sep] Rust is a \\"free-form\\" language, meaning that all forms of whitespace serve only to separate tokens in the grammar, and have no semantic significance. [lex.whitespace.replacement] A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.","breadcrumbs":"Lexical structure  Whitespace  Whitespace","id":"28","title":"Whitespace"},"280":{"body":"[expr.compound-assign.syntax] Syntax CompoundAssignmentExpression  Expression += Expression | Expression -= Expression | Expression *= Expression | Expression /= Expression | Expression %= Expression | Expression &= Expression | Expression |= Expression | Expression ^= Expression | Expression <<= Expression | Expression >>= Expression Show Railroad CompoundAssignmentExpression Expression += Expression Expression -= Expression Expression *= Expression Expression /= Expression Expression %= Expression Expression &amp;= Expression Expression |= Expression Expression ^= Expression Expression &lt;&lt;= Expression Expression &gt;&gt;= Expression [expr.compound-assign.intro] Compound assignment expressions combine arithmetic and logical binary operators with assignment expressions. For example: let mut x = 5;\\nx += 1;\\nassert!(x == 6); The syntax of compound assignment is a mutable place expression , the assigned operand , then one of the operators followed by an = as a single token (no whitespace), and then a value expression , the modifying operand . [expr.compound-assign.place] Unlike other place operands, the assigned place operand must be a place expression. [expr.compound-assign.no-value] Attempting to use a value expression is a compiler error rather than promoting it to a temporary. [expr.compound-assign.operand-order] Evaluation of compound assignment expressions depends on the types of the operands. [expr.compound-assign.primitives] If the types of both operands are known, prior to monomorphization, to be primitive, the right hand side is evaluated first, the left hand side is evaluated next, and the place given by the evaluation of the left hand side is mutated by applying the operator to the values of both sides. # use core::{num::Wrapping, ops::AddAssign};\\n#\\ntrait Equate {}\\nimpl<T> Equate for (T, T) {} fn f1(x: (u8,)) { let mut order = vec![]; // The RHS is evaluated first as both operands are of primitive // type. { order.push(2); x }.0 += { order.push(1); x }.0; assert!(order.is_sorted());\\n} fn f2(x: (Wrapping<u8>,)) { let mut order = vec![]; // The LHS is evaluated first as `Wrapping<_>` is not a primitive // type. { order.push(1); x }.0 += { order.push(2); (0u8,) }.0; assert!(order.is_sorted());\\n} fn f3<T: AddAssign<u8> + Copy>(x: (T,)) where (T, u8): Equate { let mut order = vec![]; // The LHS is evaluated first as one of the operands is a generic // parameter, even though that generic parameter can be unified // with a primitive type due to the where clause bound. { order.push(1); x }.0 += { order.push(2); (0u8,) }.0; assert!(order.is_sorted());\\n} fn main() { f1((0u8,)); f2((Wrapping(0u8),)); // We supply a primitive type as the generic argument, but this // does not affect the evaluation order in `f3` when // monomorphized. f3::<u8>((0u8,));\\n} Note This is unusual. Elsewhere left to right evaluation is the norm. See the eval order test for more examples. [expr.compound-assign.trait] Otherwise, this expression is syntactic sugar for using the corresponding trait for the operator (see expr.arith-logic.behavior ) and calling its method with the left hand side as the receiver and the right hand side as the next argument. For example, the following two statements are equivalent: # use std::ops::AddAssign;\\nfn f<T: AddAssign + Copy>(mut x: T, y: T) { x += y; // Statement 1. x.add_assign(y); // Statement 2.\\n} Note Surprisingly, desugaring this further to a fully qualified method call is not equivalent, as there is special borrow checker behavior when the mutable reference to the first operand is taken via autoref . # use std::ops::AddAssign;\\nfn f<T: AddAssign + Copy>(mut x: T) { // Here we used `x` as both the LHS and the RHS. Because the // mutable borrow of the LHS needed to call the trait method // is taken implicitly by autoref, this is OK. x += x; //~ OK x.add_assign(x); //~ OK\\n} # use std::ops::AddAssign;\\nfn f<T: AddAssign + Copy>(mut x: T) { // We can\'t desugar the above to the below, as once we take the // mutable borrow of `x` to pass the first argument, we can\'t // pass `x` by value in the second argument because the mutable // reference is still live. <T as AddAssign>::add_assign(&mut x, x); //~^ ERROR cannot use `x` because it was mutably borrowed\\n} # use std::ops::AddAssign;\\nfn f<T: AddAssign + Copy>(mut x: T) { // As above. (&mut x).add_assign(x); //~^ ERROR cannot use `x` because it was mutably borrowed\\n} [expr.compound-assign.result] As with normal assignment expressions, compound assignment expressions always produce the unit value . Warning Avoid writing code that depends on the evaluation order of operands in compound assignments as it can be unusual and surprising.","breadcrumbs":"Statements and expressions  Expressions  Operator expressions  Compound assignment expressions","id":"280","title":"Compound assignment expressions"},"281":{"body":"[expr.paren] [expr.paren.syntax] Syntax GroupedExpression  ( Expression ) Show Railroad GroupedExpression ( Expression ) [expr.paren.intro] A parenthesized expression wraps a single expression, evaluating to that expression. The syntax for a parenthesized expression is a (, then an expression, called the enclosed operand , and then a ). [expr.paren.evaluation] Parenthesized expressions evaluate to the value of the enclosed operand. [expr.paren.place-or-value] Unlike other expressions, parenthesized expressions are both place expressions and value expressions . When the enclosed operand is a place expression, it is a place expression and when the enclosed operand is a value expression, it is a value expression. [expr.paren.override-precedence] Parentheses can be used to explicitly modify the precedence order of subexpressions within an expression. An example of a parenthesized expression: let x: i32 = 2 + 3 * 4; // not parenthesized\\nlet y: i32 = (2 + 3) * 4; // parenthesized\\nassert_eq!(x, 14);\\nassert_eq!(y, 20); An example of a necessary use of parentheses is when calling a function pointer that is a member of a struct: # struct A {\\n# f: fn() -> &\'static str\\n# }\\n# impl A {\\n# fn f(&self) -> &\'static str {\\n# \\"The method f\\"\\n# }\\n# }\\n# let a = A{f: || \\"The field f\\"};\\n#\\nassert_eq!( a.f (), \\"The method f\\");\\nassert_eq!((a.f)(), \\"The field f\\");","breadcrumbs":"Statements and expressions  Expressions  Grouped expressions  Grouped expressions","id":"281","title":"Grouped expressions"},"282":{"body":"[expr.array]","breadcrumbs":"Statements and expressions  Expressions  Array and index expressions  Array and array index expressions","id":"282","title":"Array and array index expressions"},"283":{"body":"[expr.array.syntax] Syntax ArrayExpression  [ ArrayElements ? ] ArrayElements  Expression ( , Expression )* ,? | Expression ; Expression Show Railroad ArrayExpression [ ArrayElements ] ArrayElements Expression , Expression , Expression ; Expression [expr.array.constructor] Array expressions construct arrays . Array expressions come in two forms. [expr.array.array] The first form lists out every value in the array. [expr.array.array-syntax] The syntax for this form is a comma-separated list of expressions of uniform type enclosed in square brackets. [expr.array.array-behavior] This produces an array containing each of these values in the order they are written. [expr.array.repeat] The syntax for the second form is two expressions separated by a semicolon (;) enclosed in square brackets. [expr.array.repeat-operand] The expression before the ; is called the repeat operand . [expr.array.length-operand] The expression after the ; is called the length operand . [expr.array.length-restriction] The length operand must either be an inferred const or be a constant expression of type usize (e.g. a literal or a constant item ). const C: usize = 1;\\nlet _: [u8; C] = [0; 1]; // Literal.\\nlet _: [u8; C] = [0; C]; // Constant item.\\nlet _: [u8; C] = [0; _]; // Inferred const.\\nlet _: [u8; C] = [0; (((_)))]; // Inferred const. Note In an array expression, an inferred const is parsed as an expression but then semantically treated as a separate kind of const generic argument . [expr.array.repeat-behavior] An array expression of this form creates an array with the length of the value of the length operand with each element being a copy of the repeat operand. That is, [a; b] creates an array containing b copies of the value of a. [expr.array.repeat-copy] If the length operand has a value greater than 1 then this requires the repeat operand to have a type that implements Copy , to be a const block expression , or to be a path to a constant item. [expr.array.repeat-const-item] When the repeat operand is a const block or a path to a constant item, it is evaluated the number of times specified in the length operand. [expr.array.repeat-evaluation-zero] If that value is 0, then the const block or constant item is not evaluated at all. [expr.array.repeat-non-const] For expressions that are neither a const block nor a path to a constant item, it is evaluated exactly once, and then the result is copied the length operand\'s value times. [1, 2, 3, 4];\\n[\\"a\\", \\"b\\", \\"c\\", \\"d\\"];\\n[0; 128]; // array with 128 zeros\\n[0u8, 0u8, 0u8, 0u8,];\\n[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 2D array\\nconst EMPTY: Vec<i32> = Vec::new();\\n[EMPTY; 2]; [expr.array.index]","breadcrumbs":"Statements and expressions  Expressions  Array and index expressions  Array expressions","id":"283","title":"Array expressions"},"284":{"body":"[expr.array.index.syntax] Syntax IndexExpression  Expression [ Expression ] Show Railroad IndexExpression Expression [ Expression ] [expr.array.index.array] Array and slice -typed values can be indexed by writing a square-bracket-enclosed expression of type usize (the index) after them. When the array is mutable, the resulting memory location can be assigned to. [expr.array.index.trait] For other types an index expression a[b] is equivalent to *std::ops::Index::index(&a, b), or *std::ops::IndexMut::index_mut(&mut a, b) in a mutable place expression context. Just as with methods, Rust will also insert dereference operations on a repeatedly to find an implementation. [expr.array.index.zero-index] Indices are zero-based for arrays and slices. [expr.array.index.const] Array access is a constant expression , so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a panicked state if it fails. // lint is deny by default.\\n#![warn(unconditional_panic)] ([1, 2, 3, 4])[2]; // Evaluates to 3 let b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\\nb[1][2]; // multidimensional array indexing let x = ([\\"a\\", \\"b\\"])[10]; // warning: index out of bounds let n = 10;\\nlet y = ([\\"a\\", \\"b\\"])[n]; // panics let arr = [\\"a\\", \\"b\\"];\\narr[10]; // warning: index out of bounds [expr.array.index.trait-impl] The array index expression can be implemented for types other than arrays and slices by implementing the Index and IndexMut traits.","breadcrumbs":"Statements and expressions  Expressions  Array and index expressions  Array and slice indexing expressions","id":"284","title":"Array and slice indexing expressions"},"285":{"body":"[expr.tuple]","breadcrumbs":"Statements and expressions  Expressions  Tuple and index expressions  Tuple and tuple indexing expressions","id":"285","title":"Tuple and tuple indexing expressions"},"286":{"body":"[expr.tuple.syntax] Syntax TupleExpression  ( TupleElements ? ) TupleElements  ( Expression , )+ Expression ? Show Railroad TupleExpression ( TupleElements ) TupleElements Expression , Expression [expr.tuple.result] A tuple expression constructs tuple values . [expr.tuple.intro] The syntax for tuple expressions is a parenthesized, comma separated list of expressions, called the tuple initializer operands . [expr.tuple.unary-tuple-restriction] 1-ary tuple expressions require a comma after their tuple initializer operand to be disambiguated with a parenthetical expression . [expr.tuple.value] Tuple expressions are a value expression that evaluate into a newly constructed value of a tuple type. [expr.tuple.type] The number of tuple initializer operands is the arity of the constructed tuple. [expr.tuple.unit] Tuple expressions without any tuple initializer operands produce the unit tuple. [expr.tuple.fields] For other tuple expressions, the first written tuple initializer operand initializes the field 0 and subsequent operands initializes the next highest field. For example, in the tuple expression (\'a\', \'b\', \'c\'), \'a\' initializes the value of the field 0, \'b\' field 1, and \'c\' field 2. Examples of tuple expressions and their types: Expression Type () () (unit) (0.0, 4.5) (f64, f64) (\\"x\\".to_string(), ) (String, ) (\\"a\\", 4usize, true) (&\'static str, usize, bool) [expr.tuple-index]","breadcrumbs":"Statements and expressions  Expressions  Tuple and index expressions  Tuple expressions","id":"286","title":"Tuple expressions"},"287":{"body":"[expr.tuple-index.syntax] Syntax TupleIndexingExpression  Expression . TUPLE_INDEX Show Railroad TupleIndexingExpression Expression . TUPLE_INDEX [expr.tuple-index.intro] A tuple indexing expression accesses fields of tuples and tuple structs . The syntax for a tuple index expression is an expression, called the tuple operand , then a ., then finally a tuple index. [expr.tuple-index.index-syntax] The syntax for the tuple index is a decimal literal with no leading zeros, underscores, or suffix. For example 0 and 2 are valid tuple indices but not 01, 0_, nor 0i32. [expr.tuple-index.required-type] The type of the tuple operand must be a tuple type or a tuple struct . [expr.tuple-index.index-name-operand] The tuple index must be a name of a field of the type of the tuple operand. [expr.tuple-index.result] Evaluation of tuple index expressions has no side effects beyond evaluation of its tuple operand. As a place expression , it evaluates to the location of the field of the tuple operand with the same name as the tuple index. Examples of tuple indexing expressions: // Indexing a tuple\\nlet pair = (\\"a string\\", 2);\\nassert_eq!(pair.1, 2); // Indexing a tuple struct\\n# struct Point(f32, f32);\\nlet point = Point(1.0, 0.0);\\nassert_eq!(point.0, 1.0);\\nassert_eq!(point.1, 0.0); Note Unlike field access expressions, tuple index expressions can be the function operand of a call expression as it cannot be confused with a method call since method names cannot be numbers. Note Although arrays and slices also have elements, you must use an array or slice indexing expression or a slice pattern to access their elements.","breadcrumbs":"Statements and expressions  Expressions  Tuple and index expressions  Tuple indexing expressions","id":"287","title":"Tuple indexing expressions"},"288":{"body":"[expr.struct] [expr.struct.syntax] Syntax StructExpression  PathInExpression { ( StructExprFields | StructBase )? } StructExprFields  StructExprField ( , StructExprField )* ( , StructBase | ,? ) StructExprField  OuterAttribute * ( IDENTIFIER | ( IDENTIFIER | TUPLE_INDEX ) : Expression ) StructBase  .. Expression Show Railroad StructExpression PathInExpression { StructExprFields StructBase } StructExprFields StructExprField , StructExprField , StructBase , StructExprField OuterAttribute IDENTIFIER IDENTIFIER TUPLE_INDEX : Expression StructBase .. Expression [expr.struct.intro] A struct expression creates a struct, enum, or union value. It consists of a path to a struct , enum variant , or union item followed by the values for the fields of the item. The following are examples of struct expressions: # struct Point { x: f64, y: f64 }\\n# struct NothingInMe { }\\n# mod game { pub struct User<\'a> { pub name: &\'a str, pub age: u32, pub score: usize } }\\n# enum Enum { Variant {} }\\nPoint {x: 10.0, y: 20.0};\\nNothingInMe {};\\nlet u = game::User {name: \\"Joe\\", age: 35, score: 100_000};\\nEnum::Variant {}; Note Tuple structs and tuple enum variants are typically instantiated using a call expression referring to the constructor in the value namespace . These are distinct from a struct expression using curly braces referring to the constructor in the type namespace. struct Position(i32, i32, i32);\\nPosition(0, 0, 0); // Typical way of creating a tuple struct.\\nlet c = Position; // `c` is a function that takes 3 arguments.\\nlet pos = c(8, 6, 7); // Creates a `Position` value. enum Version { Triple(i32, i32, i32) };\\nVersion::Triple(0, 0, 0);\\nlet f = Version::Triple;\\nlet ver = f(8, 6, 7); The last segment of the call path cannot refer to a type alias: trait Tr { type T; }\\nimpl<T> Tr for T { type T = T; } struct Tuple();\\nenum Enum { Tuple() } // <Unit as Tr>::T(); // causes an error -- `::T` is a type, not a value\\n<Enum as Tr>::T::Tuple(); // OK Unit structs and unit enum variants are typically instantiated using a path expression referring to the constant in the value namespace . struct Gamma;\\n// Gamma unit value, referring to the const in the value namespace.\\nlet a = Gamma;\\n// Exact same value as `a`, but constructed using a struct expression\\n// referring to the type namespace.\\nlet b = Gamma {}; enum ColorSpace { Oklch }\\nlet c = ColorSpace::Oklch;\\nlet d = ColorSpace::Oklch {}; [expr.struct.field]","breadcrumbs":"Statements and expressions  Expressions  Struct expressions  Struct expressions","id":"288","title":"Struct expressions"},"289":{"body":"[expr.struct.field.intro] A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon. [expr.struct.field.union-constraint] A value of a union type can only be created using this syntax, and it must specify exactly one field. [expr.struct.update]","breadcrumbs":"Statements and expressions  Expressions  Struct expressions  Field struct expression","id":"289","title":"Field struct expression"},"29":{"body":"[lex.token] [lex.token.syntax] Lexer Token  IDENTIFIER_OR_KEYWORD | RAW_IDENTIFIER | CHAR_LITERAL | STRING_LITERAL | RAW_STRING_LITERAL | BYTE_LITERAL | BYTE_STRING_LITERAL | RAW_BYTE_STRING_LITERAL | C_STRING_LITERAL | RAW_C_STRING_LITERAL | INTEGER_LITERAL | FLOAT_LITERAL | LIFETIME_TOKEN | PUNCTUATION | RESERVED_TOKEN Show Railroad Token IDENTIFIER_OR_KEYWORD RAW_IDENTIFIER CHAR_LITERAL STRING_LITERAL RAW_STRING_LITERAL BYTE_LITERAL BYTE_STRING_LITERAL RAW_BYTE_STRING_LITERAL C_STRING_LITERAL RAW_C_STRING_LITERAL INTEGER_LITERAL FLOAT_LITERAL LIFETIME_TOKEN PUNCTUATION RESERVED_TOKEN [lex.token.intro] Tokens are primitive productions in the grammar defined by regular (non-recursive) languages. Rust source input can be broken down into the following kinds of tokens: Keywords Identifiers Literals Lifetimes Punctuation Delimiters Within this documentation\'s grammar, \\"simple\\" tokens are given in string table production form, and appear in monospace font. [lex.token.literal]","breadcrumbs":"Lexical structure  Tokens  Tokens","id":"29","title":"Tokens"},"290":{"body":"[expr.struct.update.intro] A struct expression that constructs a value of a struct type can terminate with the syntax .. followed by an expression to denote a functional update. [expr.struct.update.base-same-type] The expression following .. (the base) must have the same struct type as the new struct type being formed. [expr.struct.update.fields] The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. [expr.struct.update.visibility-constraint] As with all struct expressions, all of the fields of the struct must be visible , even those not explicitly named. # struct Point3d { x: i32, y: i32, z: i32 }\\nlet mut base = Point3d {x: 1, y: 2, z: 3};\\nlet y_ref = &mut base.y;\\nPoint3d {y: 0, z: 10, .. base}; // OK, only base.x is accessed\\ndrop(y_ref); [expr.struct.brace-restricted-positions] Struct expressions can\'t be used directly in a loop or if expression\'s head, or in the scrutinee of an if let or match expression. However, struct expressions can be used in these situations if they are within another expression, for example inside parentheses . [expr.struct.tuple-field] The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified: struct Color(u8, u8, u8);\\nlet c1 = Color(0, 0, 0); // Typical way of creating a tuple struct.\\nlet c2 = Color{0: 255, 1: 127, 2: 0}; // Specifying fields by index.\\nlet c3 = Color{1: 0, ..c2}; // Fill out all other fields using a base struct. [expr.struct.field.named]","breadcrumbs":"Statements and expressions  Expressions  Struct expressions  Functional update syntax","id":"290","title":"Functional update syntax"},"291":{"body":"When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write fieldname as a shorthand for fieldname: fieldname. This allows a compact syntax with less duplication. For example: # struct Point3d { x: i32, y: i32, z: i32 }\\n# let x = 0;\\n# let y_value = 0;\\n# let z = 0;\\nPoint3d { x: x, y: y_value, z: z };\\nPoint3d { x, y: y_value, z };","breadcrumbs":"Statements and expressions  Expressions  Struct expressions  Struct field init shorthand","id":"291","title":"Struct field init shorthand"},"292":{"body":"[expr.call] [expr.call.syntax] Syntax CallExpression  Expression ( CallParams ? ) CallParams  Expression ( , Expression )* ,? Show Railroad CallExpression Expression ( CallParams ) CallParams Expression , Expression , [expr.call.intro] A call expression calls a function. The syntax of a call expression is an expression, called the function operand , followed by a parenthesized comma-separated list of expression, called the argument operands . [expr.call.convergence] If the function eventually returns, then the expression completes. [expr.call.trait] For non-function types , the expression f(...) uses the method on one of the following traits based on the function operand: Fn or AsyncFn --- shared reference. FnMut or AsyncFnMut --- mutable reference. FnOnce or AsyncFnOnce --- value. [expr.call.autoref-deref] An automatic borrow will be taken if needed. The function operand will also be automatically dereferenced as required. Some examples of call expressions: # fn add(x: i32, y: i32) -> i32 { 0 }\\nlet three: i32 = add(1i32, 2i32);\\nlet name: &\'static str = (|| \\"Rust\\")(); [expr.call.desugar]","breadcrumbs":"Statements and expressions  Expressions  Call expressions  Call expressions","id":"292","title":"Call expressions"},"293":{"body":"[expr.call.desugar.fully-qualified] All function calls are sugar for a more explicit fully-qualified syntax . [expr.call.desugar.ambiguity] Function calls may need to be fully qualified, depending on the ambiguity of a call in light of in-scope items. Note In the past, the terms \\"Unambiguous Function Call Syntax\\", \\"Universal Function Call Syntax\\", or \\"UFCS\\", have been used in documentation, issues, RFCs, and other community writings. However, these terms lack descriptive power and potentially confuse the issue at hand. We mention them here for searchability\'s sake. [expr.call.desugar.limits] Several situations often occur which result in ambiguities about the receiver or referent of method or associated function calls. These situations may include: Multiple in-scope traits define methods with the same name for the same types Auto-deref is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer\'s referent Methods which take no arguments, like default() , and return properties of a type, like size_of() [expr.call.desugar.explicit-path] To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits. For example, trait Pretty { fn print(&self);\\n} trait Ugly { fn print(&self);\\n} struct Foo;\\nimpl Pretty for Foo { fn print(&self) {}\\n} struct Bar;\\nimpl Pretty for Bar { fn print(&self) {}\\n}\\nimpl Ugly for Bar { fn print(&self) {}\\n} fn main() { let f = Foo; let b = Bar; // we can do this because we only have one item called `print` for `Foo`s f.print(); // more explicit, and, in the case of `Foo`, not necessary Foo::print(&f); // if you\'re not into the whole brevity thing <Foo as Pretty>::print(&f); // b.print(); // Error: multiple \'print\' found // Bar::print(&b); // Still an error: multiple `print` found // necessary because of in-scope items defining `print` <Bar as Pretty>::print(&b);\\n} Refer to RFC 132 for further details and motivations.","breadcrumbs":"Statements and expressions  Expressions  Call expressions  Disambiguating function calls","id":"293","title":"Disambiguating function calls"},"294":{"body":"[expr.method] [expr.method.syntax] Syntax MethodCallExpression  Expression . PathExprSegment ( CallParams ? ) Show Railroad MethodCallExpression Expression . PathExprSegment ( CallParams ) [expr.method.intro] A method call consists of an expression (the receiver ) followed by a single dot, an expression path segment, and a parenthesized expression-list. [expr.method.target] Method calls are resolved to associated methods on specific traits, either statically dispatching to a method if the exact self-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect trait object . let pi: Result<f32, _> = \\"3.14\\".parse();\\nlet log_pi = pi.unwrap_or(1.0).log(2.72);\\n# assert!(1.14 < log_pi && log_pi < 1.15) [expr.method.autoref-deref] When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used: [expr.method.candidate-receivers] The first step is to build a list of candidate receiver types. Obtain these by repeatedly dereferencing the receiver expression\'s type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, and adding the result type if that is successful. [expr.method.candidate-receivers-refs] Then, for each candidate T, add &T and &mut T to the list immediately after T. For instance, if the receiver has type Box<[i32;2]>, then the candidate types will be Box<[i32;2]>, &Box<[i32;2]>, &mut Box<[i32;2]>, [i32; 2] (by dereferencing), &[i32; 2], &mut [i32; 2], [i32] (by unsized coercion), &[i32], and finally &mut [i32]. [expr.method.candidate-search] Then, for each candidate type T, search for a visible method with a receiver of that type in the following places: T\'s inherent methods (methods implemented directly on T). Any of the methods provided by a visible trait implemented by T. If T is a type parameter, methods provided by trait bounds on T are looked up first. Then all remaining methods in scope are looked up. Note The lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print \\"In trait impl!\\", because &self methods are looked up first, the trait method is found before the struct\'s &mut self method is found. struct Foo {} trait Bar { fn bar(&self);\\n} impl Foo { fn bar(&mut self) { println!(\\"In struct impl!\\") }\\n} impl Bar for Foo { fn bar(&self) { println!(\\"In trait impl!\\") }\\n} fn main() { let mut f = Foo{}; f.bar();\\n} [expr.method.ambiguous-target] If this results in multiple possible candidates, then it is an error, and the receiver must be converted to an appropriate receiver type to make the method call. [expr.method.receiver-constraints] This process does not take into account the mutability or lifetime of the receiver, or whether a method is unsafe. Once a method is looked up, if it can\'t be called for one (or more) of those reasons, the result is a compiler error. [expr.method.ambiguous-search] If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a disambiguating function call syntax for method and function invocation. [expr.method.edition2021] 2021 Edition differences Before the 2021 edition, during the search for visible methods, if the candidate receiver type is an array type , methods provided by the standard library IntoIterator trait are ignored. The edition used for this purpose is determined by the token representing the method name. This special case may be removed in the future. Warning For trait objects , if there is an inherent method of the same name as a trait method, it will give a compiler error when trying to call the method in a method call expression. Instead, you can call the method using disambiguating function call syntax , in which case it calls the trait method, not the inherent method. There is no way to call the inherent method. Just don\'t define inherent methods on trait objects with the same name as a trait method and you\'ll be fine.","breadcrumbs":"Statements and expressions  Expressions  Method call expressions  Method-call expressions","id":"294","title":"Method-call expressions"},"295":{"body":"[expr.field] [expr.field.syntax] Syntax FieldExpression  Expression . IDENTIFIER Show Railroad FieldExpression Expression . IDENTIFIER [expr.field.intro] A field expression is a place expression that evaluates to the location of a field of a struct or union . [expr.field.mut] When the operand is mutable , the field expression is also mutable. [expr.field.form] The syntax for a field expression is an expression, called the container operand , then a ., and finally an identifier . [expr.field.not-method-call] Field expressions cannot be followed by a parenthetical comma-separated list of expressions, as that is instead parsed as a method call expression . That is, they cannot be the function operand of a call expression . Note Wrap the field expression in a parenthesized expression to use it in a call expression. # struct HoldsCallable<F: Fn()> { callable: F }\\nlet holds_callable = HoldsCallable { callable: || () }; // Invalid: Parsed as calling the method \\"callable\\"\\n// holds_callable.callable(); // Valid\\n(holds_callable.callable)(); Examples: mystruct.myfield;\\nfoo().x;\\n(Struct {a: 10, b: 20}).a;\\n(mystruct.function_field)() // Call expression containing a field expression [expr.field.autoref-deref]","breadcrumbs":"Statements and expressions  Expressions  Field access expressions  Field access expressions","id":"295","title":"Field access expressions"},"296":{"body":"If the type of the container operand implements Deref or DerefMut depending on whether the operand is mutable , it is automatically dereferenced as many times as necessary to make the field access possible. This process is also called autoderef for short. [expr.field.borrow]","breadcrumbs":"Statements and expressions  Expressions  Field access expressions  Automatic dereferencing","id":"296","title":"Automatic dereferencing"},"297":{"body":"The fields of a struct or a reference to a struct are treated as separate entities when borrowing. If the struct does not implement Drop and is stored in a local variable, this also applies to moving out of each of its fields. This also does not apply if automatic dereferencing is done through user-defined types other than Box . struct A { f1: String, f2: String, f3: String }\\nlet mut x: A;\\n# x = A {\\n# f1: \\"f1\\".to_string(),\\n# f2: \\"f2\\".to_string(),\\n# f3: \\"f3\\".to_string()\\n# };\\nlet a: &mut String = &mut x.f1; // x.f1 borrowed mutably\\nlet b: &String = &x.f2; // x.f2 borrowed immutably\\nlet c: &String = &x.f2; // Can borrow again\\nlet d: String = x.f3; // Move out of x.f3","breadcrumbs":"Statements and expressions  Expressions  Field access expressions  Borrowing","id":"297","title":"Borrowing"},"298":{"body":"[expr.closure] [expr.closure.syntax] Syntax ClosureExpression  async? [1] move? ( || | | ClosureParameters ? | ) ( Expression | -> TypeNoBounds BlockExpression ) ClosureParameters  ClosureParam ( , ClosureParam )* ,? ClosureParam  OuterAttribute * PatternNoTopAlt ( : Type )? Show Railroad ClosureExpression async move || | ClosureParameters | Expression -&gt; TypeNoBounds BlockExpression ClosureParameters ClosureParam , ClosureParam , ClosureParam OuterAttribute PatternNoTopAlt : Type The async qualifier is not allowed in the 2015 edition. [expr.closure.intro] A closure expression , also known as a lambda expression or a lambda, defines a closure type and evaluates to a value of that type. The syntax for a closure expression is an optional async keyword, an optional move keyword, then a pipe-symbol-delimited (|) comma-separated list of patterns , called the closure parameters each optionally followed by a : and a type, then an optional -> and type, called the return type , and then an expression, called the closure body operand . [expr.closure.param-type] The optional type after each pattern is a type annotation for the pattern. [expr.closure.explicit-type-body] If there is a return type, the closure body must be a block . [expr.closure.parameter-restriction] A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a let binding , the closure parameters are irrefutable patterns , whose type annotation is optional and will be inferred from context if not given. [expr.closure.unique-type] Each closure expression has a unique, anonymous type. [expr.closure.captures] Significantly, closure expressions capture their environment , which regular function definitions do not. [expr.closure.capture-inference] Without the move keyword, the closure expression infers how it captures each variable from its environment , preferring to capture by shared reference, effectively borrowing all outer variables mentioned inside the closure\'s body. [expr.closure.capture-mut-ref] If needed the compiler will infer that instead mutable references should be taken, or that the values should be moved or copied (depending on their type) from the environment. [expr.closure.capture-move] A closure can be forced to capture its environment by copying or moving values by prefixing it with the move keyword. This is often used to ensure that the closure\'s lifetime is \'static. [expr.closure.trait-impl]","breadcrumbs":"Statements and expressions  Expressions  Closure expressions  Closure expressions","id":"298","title":"Closure expressions"},"299":{"body":"Which traits the closure type implement depends on how variables are captured, the types of the captured variables, and the presence of async. See the call traits and coercions chapter for how and when a closure implements Fn, FnMut, and FnOnce. The closure type implements Send and Sync if the type of every captured variable also implements the trait. [expr.closure.async]","breadcrumbs":"Statements and expressions  Expressions  Closure expressions  Closure trait implementations","id":"299","title":"Closure trait implementations"},"3":{"body":"This book does not assume you are reading this book sequentially. Each chapter generally can be read standalone, but will cross-link to other chapters for facets of the language they refer to, but do not discuss. There are two main ways to read this document. The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press s or click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn\'t already know that the lifetime of temporaries is defined in the expressions chapter , you could search \\"temporary let\\" and the first search result will take you to that section. The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section. That said, there is no wrong way to read this book. Read it however you feel helps you best.","breadcrumbs":"Introduction  How to use this book","id":"3","title":"How to use this book"},"30":{"body":"Literals are tokens used in literal expressions .","breadcrumbs":"Lexical structure  Tokens  Literals","id":"30","title":"Literals"},"300":{"body":"[expr.closure.async.intro] Closures marked with the async keyword indicate that they are asynchronous in an analogous way to an async function . [expr.closure.async.future] Calling the async closure does not perform any work, but instead evaluates to a value that implements Future that corresponds to the computation of the body of the closure. async fn takes_async_callback(f: impl AsyncFn(u64)) { f(0).await; f(1).await;\\n} async fn example() { takes_async_callback(async |i| { core::future::ready(i).await; println!(\\"done with {i}.\\"); }).await;\\n} [expr.closure.async.edition2018] 2018 Edition differences Async closures are only available beginning with Rust 2018.","breadcrumbs":"Statements and expressions  Expressions  Closure expressions  Async closures","id":"300","title":"Async closures"},"301":{"body":"In this example, we define a function ten_times that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment. fn ten_times<F>(f: F) where F: Fn(i32) { for index in 0..10 { f(index); }\\n} ten_times(|j| println!(\\"hello, {}\\", j));\\n// With type annotations\\nten_times(|j: i32| -> () { println!(\\"hello, {}\\", j) }); let word = \\"konnichiwa\\".to_owned();\\nten_times(move |j| println!(\\"{}, {}\\", word, j));","breadcrumbs":"Statements and expressions  Expressions  Closure expressions  Example","id":"301","title":"Example"},"302":{"body":"[expr.closure.param-attributes] Attributes on closure parameters follow the same rules and restrictions as regular function parameters .","breadcrumbs":"Statements and expressions  Expressions  Closure expressions  Attributes on closure parameters","id":"302","title":"Attributes on closure parameters"},"303":{"body":"[expr.loop] [expr.loop.syntax] Syntax LoopExpression  LoopLabel ? ( InfiniteLoopExpression | PredicateLoopExpression | IteratorLoopExpression | LabelBlockExpression ) Show Railroad LoopExpression LoopLabel InfiniteLoopExpression PredicateLoopExpression IteratorLoopExpression LabelBlockExpression [expr.loop.intro] Rust supports four loop expressions: A loop expression denotes an infinite loop. A while expression loops until a predicate is false. A for expression extracts values from an iterator, looping until the iterator is empty. A labelled block expression runs a loop exactly once, but allows exiting the loop early with break. [expr.loop.break-label] All four types of loop support break expressions , and labels . [expr.loop.continue-label] All except labelled block expressions support continue expressions . [expr.loop.explicit-result] Only loop and labelled block expressions support evaluation to non-trivial values . [expr.loop.infinite]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  Loops and other breakable expressions","id":"303","title":"Loops and other breakable expressions"},"304":{"body":"[expr.loop.infinite.syntax] Syntax InfiniteLoopExpression  loop BlockExpression Show Railroad InfiniteLoopExpression loop BlockExpression [expr.loop.infinite.intro] A loop expression repeats execution of its body continuously: loop { println!(\\"I live.\\"); }. [expr.loop.infinite.diverging] A loop expression without an associated break expression is diverging and has type ! . [expr.loop.infinite.break] A loop expression containing associated break expression(s) may terminate, and must have type compatible with the value of the break expression(s). [expr.loop.while]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  Infinite loops","id":"304","title":"Infinite loops"},"305":{"body":"[expr.loop.while.grammar] Syntax PredicateLoopExpression  while Conditions BlockExpression Show Railroad PredicateLoopExpression while Conditions BlockExpression [expr.loop.while.intro] A while loop expression allows repeating the evaluation of a block while a set of conditions remain true. [expr.loop.while.syntax] The syntax of a while expression is a sequence of one or more condition operands separated by &&, followed by a BlockExpression . [expr.loop.while.condition] Condition operands must be either an Expression with a boolean type or a conditional let match. If all of the condition operands evaluate to true and all of the let patterns successfully match their scrutinee s, then the loop body block executes. [expr.loop.while.repeat] After the loop body successfully executes, the condition operands are re-evaluated to determine if the body should be executed again. [expr.loop.while.exit] If any condition operand evaluates to false or any let pattern does not match its scrutinee, the body is not executed and execution continues after the while expression. [expr.loop.while.eval] A while expression evaluates to (). An example: let mut i = 0; while i < 10 { println!(\\"hello\\"); i = i + 1;\\n} [expr.loop.while.let]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  Predicate loops","id":"305","title":"Predicate loops"},"306":{"body":"[expr.loop.while.let.intro] let patterns in a while condition allow binding new variables into scope when the pattern matches successfully. The following examples illustrate bindings using let patterns: let mut x = vec![1, 2, 3]; while let Some(y) = x.pop() { println!(\\"y = {}\\", y);\\n} while let _ = 5 { println!(\\"Irrefutable patterns are always true\\"); break;\\n} [expr.loop.while.let.desugar] A while let loop is equivalent to a loop expression containing a match expression as follows. \'label: while let PATS = EXPR { /* loop body */\\n} is equivalent to \'label: loop { match EXPR { PATS => { /* loop body */ }, _ => break, }\\n} [expr.loop.while.let.or-pattern] Multiple patterns may be specified with the | operator. This has the same semantics as with | in match expressions: let mut vals = vec![2, 3, 1, 2, 2];\\nwhile let Some(v @ 1) | Some(v @ 2) = vals.pop() { // Prints 2, 2, then 1 println!(\\"{}\\", v);\\n} [expr.loop.while.chains]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  while let patterns","id":"306","title":"while let patterns"},"307":{"body":"[expr.loop.while.chains.intro] Multiple condition operands can be separated with &&. These have the same semantics and restrictions as if condition chains . The following is an example of chaining multiple expressions, mixing let bindings and boolean expressions, and with expressions able to reference pattern bindings from previous expressions: fn main() { let outer_opt = Some(Some(1i32)); while let Some(inner_opt) = outer_opt && let Some(number) = inner_opt && number == 1 { println!(\\"Peek a boo\\"); break; }\\n} [expr.loop.for]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  while condition chains","id":"307","title":"while condition chains"},"308":{"body":"[expr.loop.for.syntax] Syntax IteratorLoopExpression  for Pattern in Expression except StructExpression BlockExpression Show Railroad IteratorLoopExpression for Pattern in except StructExpression Expression BlockExpression [expr.loop.for.intro] A for expression is a syntactic construct for looping over elements provided by an implementation of std::iter::IntoIterator. [expr.loop.for.condition] If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the for loop. If the iterator is empty, the for expression completes. An example of a for loop over the contents of an array: let v = &[\\"apples\\", \\"cake\\", \\"coffee\\"]; for text in v { println!(\\"I like {}.\\", text);\\n} An example of a for loop over a series of integers: let mut sum = 0;\\nfor n in 1..11 { sum += n;\\n}\\nassert_eq!(sum, 55); [expr.loop.for.desugar] A for loop is equivalent to a loop expression containing a match expression as follows: \'label: for PATTERN in iter_expr { /* loop body */\\n} is equivalent to { let result = match IntoIterator::into_iter(iter_expr) { mut iter => \'label: loop { let mut next; match Iterator::next(&mut iter) { Option::Some(val) => next = val, Option::None => break, }; let PATTERN = next; let () = { /* loop body */ }; }, }; result\\n} [expr.loop.for.lang-items] IntoIterator, Iterator, and Option are always the standard library items here, not whatever those names resolve to in the current scope. The variable names next, iter, and val are for exposition only, they do not actually have names the user can type. Note The outer match is used to ensure that any temporary values in iter_expr don\'t get dropped before the loop is finished. next is declared before being assigned because it results in types being inferred correctly more often. [expr.loop.label]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  Iterator loops","id":"308","title":"Iterator loops"},"309":{"body":"[expr.loop.label.syntax] Syntax LoopLabel  LIFETIME_OR_LABEL : Show Railroad LoopLabel LIFETIME_OR_LABEL : [expr.loop.label.intro] A loop expression may optionally have a label . The label is written as a lifetime preceding the loop expression, as in \'foo: loop { break \'foo; }, \'bar: while false {}, \'humbug: for _ in 0..0 {}. [expr.loop.label.control-flow] If a label is present, then labeled break and continue expressions nested within this loop may exit out of this loop or return control to its head. See break expressions and continue expressions . [expr.loop.label.ref] Labels follow the hygiene and shadowing rules of local variables. For example, this code will print \\"outer loop\\": \'a: loop { \'a: loop { break \'a; } print!(\\"outer loop\\"); break \'a;\\n} \'_ is not a valid loop label. [expr.loop.break]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  Loop labels","id":"309","title":"Loop labels"},"31":{"body":"Characters and strings Example #sets [1] Characters Escapes Character \'H\' 0 All Unicode Quote & ASCII & Unicode String \\"hello\\" 0 All Unicode Quote & ASCII & Unicode Raw string r#\\"hello\\"# <256 All Unicode N/A Byte b\'H\' 0 All ASCII Quote & Byte Byte string b\\"hello\\" 0 All ASCII Quote & Byte Raw byte string br#\\"hello\\"# <256 All ASCII N/A C string c\\"hello\\" 0 All Unicode Quote & Byte & Unicode Raw C string cr#\\"hello\\"# <256 All Unicode N/A The number of #s on each side of the same literal must be equivalent. ASCII escapes Name \\\\x41 7-bit character code (exactly 2 digits, up to 0x7F) \\\\n Newline \\\\r Carriage return \\\\t Tab \\\\\\\\ Backslash \\\\0 Null Byte escapes Name \\\\x7F 8-bit character code (exactly 2 digits) \\\\n Newline \\\\r Carriage return \\\\t Tab \\\\\\\\ Backslash \\\\0 Null Unicode escapes Name \\\\u{7FFF} 24-bit Unicode character code (up to 6 digits) Quote escapes Name \\\\\' Single quote \\\\\\" Double quote Numbers Number literals [2] Example Exponentiation Decimal integer 98_222 N/A Hex integer 0xff N/A Octal integer 0o77 N/A Binary integer 0b1111_0000 N/A Floating-point 123.0E+77 Optional All number literals allow _ as a visual separator: 1_234.0E+18f64 [lex.token.literal.suffix] Suffixes [lex.token.literal.literal.suffix.intro] A suffix is a sequence of characters following the primary part of a literal (without intervening whitespace), of the same form as a non-raw identifier or keyword. [lex.token.literal.suffix.syntax] Lexer SUFFIX  IDENTIFIER_OR_KEYWORD SUFFIX_NO_E  SUFFIX not beginning with e or E Show Railroad SUFFIX IDENTIFIER_OR_KEYWORD SUFFIX_NO_E not beginning with `e` or `E` SUFFIX [lex.token.literal.suffix.validity] Any kind of literal (string, integer, etc) with any suffix is valid as a token. A literal token with any suffix can be passed to a macro without producing an error. The macro itself will decide how to interpret such a token and whether to produce an error or not. In particular, the literal fragment specifier for by-example macros matches literal tokens with arbitrary suffixes. macro_rules! blackhole { ($tt:tt) => () }\\nmacro_rules! blackhole_lit { ($l:literal) => () } blackhole!(\\"string\\"suffix); // OK\\nblackhole_lit!(1suffix); // OK [lex.token.literal.suffix.parse] However, suffixes on literal tokens which are interpreted as literal expressions or patterns are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below. Integer Floating-point u8, i8, u16, i16, u32, i32, u64, i64, u128, i128, usize, isize f32, f64","breadcrumbs":"Lexical structure  Tokens  Examples","id":"31","title":"Examples"},"310":{"body":"[expr.loop.break.syntax] Syntax BreakExpression  break LIFETIME_OR_LABEL ? Expression ? Show Railroad BreakExpression break LIFETIME_OR_LABEL Expression [expr.loop.break.intro] When break is encountered, execution of the associated loop body is immediately terminated, for example: let mut last = 0;\\nfor x in 1..100 { if x > 12 { break; } last = x;\\n}\\nassert_eq!(last, 12); [expr.loop.break.label] A break expression is normally associated with the innermost loop, for or while loop enclosing the break expression, but a label can be used to specify which enclosing loop is affected. Example: \'outer: loop { while true { break \'outer; }\\n} [expr.loop.break.value] A break expression is only permitted in the body of a loop, and has one of the forms break, break \'label or ( see below ) break EXPR or break \'label EXPR. [expr.loop.block-labels]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  break expressions","id":"310","title":"break expressions"},"311":{"body":"[expr.loop.block-labels.syntax] Syntax LabelBlockExpression  BlockExpression Show Railroad LabelBlockExpression BlockExpression [expr.loop.block-labels.intro] Labelled block expressions are exactly like block expressions, except that they allow using break expressions within the block. [expr.loop.block-labels.break] Unlike loops, break expressions within a labelled block expression must have a label (i.e. the label is not optional). [expr.loop.block-labels.label-required] Similarly, labelled block expressions must begin with a label. # fn do_thing() {}\\n# fn condition_not_met() -> bool { true }\\n# fn do_next_thing() {}\\n# fn do_last_thing() {}\\nlet result = \'block: { do_thing(); if condition_not_met() { break \'block 1; } do_next_thing(); if condition_not_met() { break \'block 2; } do_last_thing(); 3\\n}; [expr.loop.continue]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  Labelled block expressions","id":"311","title":"Labelled block expressions"},"312":{"body":"[expr.loop.continue.syntax] Syntax ContinueExpression  continue LIFETIME_OR_LABEL ? Show Railroad ContinueExpression continue LIFETIME_OR_LABEL [expr.loop.continue.intro] When continue is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop head . [expr.loop.continue.while] In the case of a while loop, the head is the conditional operands controlling the loop. [expr.loop.continue.for] In the case of a for loop, the head is the call-expression controlling the loop. [expr.loop.continue.label] Like break, continue is normally associated with the innermost enclosing loop, but continue \'label may be used to specify the loop affected. [expr.loop.continue.in-loop-only] A continue expression is only permitted in the body of a loop. [expr.loop.break-value]","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  continue expressions","id":"312","title":"continue expressions"},"313":{"body":"[expr.loop.break-value.intro] When associated with a loop, a break expression may be used to return a value from that loop, via one of the forms break EXPR or break \'label EXPR, where EXPR is an expression whose result is returned from the loop. For example: let (mut a, mut b) = (1, 1);\\nlet result = loop { if b > 10 { break b; } let c = a + b; a = b; b = c;\\n};\\n// first number in Fibonacci sequence over 10:\\nassert_eq!(result, 13); [expr.loop.break-value.loop] In the case a loop has an associated break, it is not considered diverging, and the loop must have a type compatible with each break expression. break without an expression is considered identical to break with expression ().","breadcrumbs":"Statements and expressions  Expressions  Loop expressions  break and loop values","id":"313","title":"break and loop values"},"314":{"body":"[expr.range] [expr.range.syntax] Syntax RangeExpression  RangeExpr | RangeFromExpr | RangeToExpr | RangeFullExpr | RangeInclusiveExpr | RangeToInclusiveExpr RangeExpr  Expression .. Expression RangeFromExpr  Expression .. RangeToExpr  .. Expression RangeFullExpr  .. RangeInclusiveExpr  Expression ..= Expression RangeToInclusiveExpr  ..= Expression Show Railroad RangeExpression RangeExpr RangeFromExpr RangeToExpr RangeFullExpr RangeInclusiveExpr RangeToInclusiveExpr RangeExpr Expression .. Expression RangeFromExpr Expression .. RangeToExpr .. Expression RangeFullExpr .. RangeInclusiveExpr Expression ..= Expression RangeToInclusiveExpr ..= Expression [expr.range.behavior] The .. and ..= operators will construct an object of one of the std::ops::Range (or core::ops::Range) variants, according to the following table: Production Syntax Type Range RangeExpr start..end std::ops::Range start  x < end RangeFromExpr start.. std::ops::RangeFrom start  x RangeToExpr ..end std::ops::RangeTo x < end RangeFullExpr .. std::ops::RangeFull - RangeInclusiveExpr start..=end std::ops::RangeInclusive start  x  end RangeToInclusiveExpr ..=end std::ops::RangeToInclusive x  end Examples: 1..2; // std::ops::Range\\n3..; // std::ops::RangeFrom\\n..4; // std::ops::RangeTo\\n..; // std::ops::RangeFull\\n5..=6; // std::ops::RangeInclusive\\n..=7; // std::ops::RangeToInclusive [expr.range.equivalence] The following expressions are equivalent. let x = std::ops::Range {start: 0, end: 10};\\nlet y = 0..10; assert_eq!(x, y); [expr.range.for] Ranges can be used in for loops: for i in 1..11 { println!(\\"{}\\", i);\\n}","breadcrumbs":"Statements and expressions  Expressions  Range expressions  Range expressions","id":"314","title":"Range expressions"},"315":{"body":"[expr.if] [expr.if.syntax] Syntax IfExpression  if Conditions BlockExpression ( else ( BlockExpression | IfExpression ) )? Conditions  Expression except StructExpression | LetChain LetChain  LetChainCondition ( && LetChainCondition )* LetChainCondition  Expression except ExcludedConditions | OuterAttribute * let Pattern = Scrutinee except ExcludedConditions ExcludedConditions  StructExpression | LazyBooleanExpression | RangeExpr | RangeFromExpr | RangeInclusiveExpr | AssignmentExpression | CompoundAssignmentExpression Show Railroad IfExpression if Conditions BlockExpression else BlockExpression IfExpression Conditions except StructExpression Expression LetChain LetChain LetChainCondition &amp;&amp; LetChainCondition LetChainCondition except ExcludedConditions Expression OuterAttribute let Pattern = except ExcludedConditions Scrutinee ExcludedConditions StructExpression LazyBooleanExpression RangeExpr RangeFromExpr RangeInclusiveExpr AssignmentExpression CompoundAssignmentExpression [expr.if.intro] The syntax of an if expression is a sequence of one or more condition operands separated by &&, followed by a consequent block, any number of else if conditions and blocks, and an optional trailing else block. [expr.if.condition] Condition operands must be either an Expression with a boolean type or a conditional let match. [expr.if.condition-true] If all of the condition operands evaluate to true and all of the let patterns successfully match their scrutinee s, the consequent block is executed and any subsequent else if or else block is skipped. [expr.if.else-if] If any condition operand evaluates to false or any let pattern does not match its scrutinee, the consequent block is skipped and any subsequent else if condition is evaluated. [expr.if.else] If all if and else if conditions evaluate to false then any else block is executed. [expr.if.result] An if expression evaluates to the same value as the executed block, or () if no block is evaluated. [expr.if.type] An if expression must have the same type in all situations. # let x = 3;\\nif x == 4 { println!(\\"x is four\\");\\n} else if x == 3 { println!(\\"x is three\\");\\n} else { println!(\\"x is something else\\");\\n} // `if` can be used as an expression.\\nlet y = if 12 * 15 > 150 { \\"Bigger\\"\\n} else { \\"Smaller\\"\\n};\\nassert_eq!(y, \\"Bigger\\"); [expr.if.let]","breadcrumbs":"Statements and expressions  Expressions  If expressions  if expressions","id":"315","title":"if expressions"},"316":{"body":"[expr.if.let.intro] let patterns in an if condition allow binding new variables into scope when the pattern matches successfully. The following examples illustrate bindings using let patterns: let dish = (\\"Ham\\", \\"Eggs\\"); // This body will be skipped because the pattern is refuted.\\nif let (\\"Bacon\\", b) = dish { println!(\\"Bacon is served with {}\\", b);\\n} else { // This block is evaluated instead. println!(\\"No bacon will be served\\");\\n} // This body will execute.\\nif let (\\"Ham\\", b) = dish { println!(\\"Ham is served with {}\\", b);\\n} if let _ = 5 { println!(\\"Irrefutable patterns are always true\\");\\n} [expr.if.let.or-pattern] Multiple patterns may be specified with the | operator. This has the same semantics as with | in match expressions : enum E { X(u8), Y(u8), Z(u8),\\n}\\nlet v = E::Y(12);\\nif let E::X(n) | E::Y(n) = v { assert_eq!(n, 12);\\n} [expr.if.chains]","breadcrumbs":"Statements and expressions  Expressions  If expressions  if let patterns","id":"316","title":"if let patterns"},"317":{"body":"[expr.if.chains.intro] Multiple condition operands can be separated with &&. [expr.if.chains.order] Similar to a && LazyBooleanExpression , each operand is evaluated from left-to-right until an operand evaluates as false or a let match fails, in which case the subsequent operands are not evaluated. [expr.if.chains.bindings] The bindings of each pattern are put into scope to be available for the next condition operand and the consequent block. The following is an example of chaining multiple expressions, mixing let bindings and boolean expressions, and with expressions able to reference pattern bindings from previous expressions: fn single() { let outer_opt = Some(Some(1i32)); if let Some(inner_opt) = outer_opt && let Some(number) = inner_opt && number == 1 { println!(\\"Peek a boo\\"); }\\n} The above is equivalent to the following without using chains of conditions: fn nested() { let outer_opt = Some(Some(1i32)); if let Some(inner_opt) = outer_opt { if let Some(number) = inner_opt { if number == 1 { println!(\\"Peek a boo\\"); } } }\\n} [expr.if.chains.or] If any condition operand is a let pattern, then none of the condition operands can be a || lazy boolean operator expression due to ambiguity and precedence with the let scrutinee. If a || expression is needed, then parentheses can be used. For example: # let foo = Some(123);\\n# let condition1 = true;\\n# let condition2 = false;\\n// Parentheses are required here.\\nif let Some(x) = foo && (condition1 || condition2) { /*...*/ } [expr.if.edition2024] 2024 Edition differences Before the 2024 edition, let chains are not supported. That is, the LetChain grammar is not allowed in an if expression.","breadcrumbs":"Statements and expressions  Expressions  If expressions  Chains of conditions","id":"317","title":"Chains of conditions"},"318":{"body":"[expr.match] [expr.match.syntax] Syntax MatchExpression  match Scrutinee { InnerAttribute * MatchArms ? } Scrutinee  Expression except StructExpression MatchArms  ( MatchArm => ( ExpressionWithoutBlock , | ExpressionWithBlock ,? ) )* MatchArm => Expression ,? MatchArm  OuterAttribute * Pattern MatchArmGuard ? MatchArmGuard  if Expression Show Railroad MatchExpression match Scrutinee { InnerAttribute MatchArms } Scrutinee except StructExpression Expression MatchArms MatchArm =&gt; ExpressionWithoutBlock , ExpressionWithBlock , MatchArm =&gt; Expression , MatchArm OuterAttribute Pattern MatchArmGuard MatchArmGuard if Expression [expr.match.intro] A match expression branches on a pattern. The exact form of matching that occurs depends on the pattern . [expr.match.scrutinee] A match expression has a scrutinee expression , which is the value to compare to the patterns. [expr.match.scrutinee-constraint] The scrutinee expression and the patterns must have the same type. [expr.match.scrutinee-behavior] A match behaves differently depending on whether or not the scrutinee expression is a place expression or value expression . [expr.match.scrutinee-value] If the scrutinee expression is a value expression , it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the match, any variables bound by the pattern are assigned to local variables in the arm\'s block, and control enters the block. [expr.match.scrutinee-place] When the scrutinee expression is a place expression , the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match. An example of a match expression: let x = 1; match x { 1 => println!(\\"one\\"), 2 => println!(\\"two\\"), 3 => println!(\\"three\\"), 4 => println!(\\"four\\"), 5 => println!(\\"five\\"), _ => println!(\\"something else\\"),\\n} [expr.match.pattern-vars] Variables bound within the pattern are scoped to the match guard and the arm\'s expression. [expr.match.pattern-var-binding] The binding mode (move, copy, or reference) depends on the pattern. [expr.match.or-pattern] Multiple match patterns may be joined with the | operator. Each pattern will be tested in left-to-right sequence until a successful match is found. let x = 9;\\nlet message = match x { 0 | 1 => \\"not many\\", 2 ..= 9 => \\"a few\\", _ => \\"lots\\"\\n}; assert_eq!(message, \\"a few\\"); // Demonstration of pattern match order.\\nstruct S(i32, i32); match S(1, 2) { S(z @ 1, _) | S(_, z @ 2) => assert_eq!(z, 1), _ => panic!(),\\n} Note The 2..=9 is a Range Pattern , not a Range Expression . Thus, only those types of ranges supported by range patterns can be used in match arms. [expr.match.or-patterns-restriction] Every binding in each | separated pattern must appear in all of the patterns in the arm. [expr.match.binding-restriction] Every binding of the same name must have the same type, and have the same binding mode. [expr.match.guard]","breadcrumbs":"Statements and expressions  Expressions  Match expressions  match expressions","id":"318","title":"match expressions"},"319":{"body":"[expr.match.guard.intro] Match arms can accept match guards to further refine the criteria for matching a case. [expr.match.guard.type] Pattern guards appear after the pattern and consist of a bool-typed expression following the if keyword. [expr.match.guard.behavior] When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. [expr.match.guard.next] Otherwise, the next pattern, including other matches with the | operator in the same arm, is tested. # let maybe_digit = Some(0);\\n# fn process_digit(i: i32) { }\\n# fn process_other(i: i32) { }\\nlet message = match maybe_digit { Some(x) if x < 10 => process_digit(x), Some(x) => process_other(x), None => panic!(),\\n}; Note Multiple matches using the | operator can cause the pattern guard and the side effects it has to execute multiple times. For example: # use std::cell::Cell;\\nlet i : Cell<i32> = Cell::new(0);\\nmatch 1 { 1 | _ if { i.set(i.get() + 1); false } => {} _ => {}\\n}\\nassert_eq!(i.get(), 2); [expr.match.guard.bound-variables] A pattern guard may refer to the variables bound within the pattern they follow. [expr.match.guard.shared-ref] Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable. [expr.match.guard.value] Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match. [expr.match.guard.no-mutation] Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented. [expr.match.attributes]","breadcrumbs":"Statements and expressions  Expressions  Match expressions  Match guards","id":"319","title":"Match guards"},"32":{"body":"[lex.token.literal.char] Character literals [lex.token.literal.char.syntax] Lexer CHAR_LITERAL  \' ( ~[\' \\\\ LF CR TAB ] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE ) \' SUFFIX ? QUOTE_ESCAPE  \\\\\' | \\\\\\" ASCII_ESCAPE  \\\\x OCT_DIGIT HEX_DIGIT | \\\\n | \\\\r | \\\\t | \\\\\\\\ | \\\\0 UNICODE_ESCAPE  \\\\u{ ( HEX_DIGIT _* )1..6 } Show Railroad CHAR_LITERAL \'  with the exception of \' \\\\ LF CR TAB CHAR QUOTE_ESCAPE ASCII_ESCAPE UNICODE_ESCAPE \' SUFFIX QUOTE_ESCAPE \\\\\' \\\\\\" ASCII_ESCAPE \\\\x OCT_DIGIT HEX_DIGIT \\\\n \\\\r \\\\t \\\\\\\\ \\\\0 UNICODE_ESCAPE \\\\u{ at most 5 more times HEX_DIGIT _ } [lex.token.literal.char.intro] A character literal is a single Unicode character enclosed within two U+0027 (single-quote) characters, with the exception of U+0027 itself, which must be escaped by a preceding U+005C character (\\\\). [lex.token.literal.str] String literals [lex.token.literal.str.syntax] Lexer STRING_LITERAL  \\" ( ~[\\" \\\\ CR ] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE | STRING_CONTINUE )* \\" SUFFIX ? STRING_CONTINUE  \\\\ LF Show Railroad STRING_LITERAL \\"  with the exception of \\" \\\\ CR CHAR QUOTE_ESCAPE ASCII_ESCAPE UNICODE_ESCAPE STRING_CONTINUE \\" SUFFIX STRING_CONTINUE \\\\ LF [lex.token.literal.str.intro] A string literal is a sequence of any Unicode characters enclosed within two U+0022 (double-quote) characters, with the exception of U+0022 itself, which must be escaped by a preceding U+005C character (\\\\). [lex.token.literal.str.linefeed] Line-breaks, represented by the character U+000A (LF), are allowed in string literals. The character U+000D (CR) may not appear in a string literal. When an unescaped U+005C character (\\\\) occurs immediately before a line break, the line break does not appear in the string represented by the token. See String continuation escapes for details. [lex.token.literal.char-escape] Character escapes [lex.token.literal.char-escape.intro] Some additional escapes are available in either character or non-raw string literals. An escape starts with a U+005C (\\\\) and continues with one of the following forms: [lex.token.literal.char-escape.ascii] A 7-bit code point escape starts with U+0078 (x) and is followed by exactly two hex digits with value up to 0x7F. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values. [lex.token.literal.char-escape.unicode] A 24-bit code point escape starts with U+0075 (u) and is followed by up to six hex digits surrounded by braces U+007B ({) and U+007D (}). It denotes the Unicode code point equal to the provided hex value. [lex.token.literal.char-escape.whitespace] A whitespace escape is one of the characters U+006E (n), U+0072 (r), or U+0074 (t), denoting the Unicode values U+000A (LF), U+000D (CR) or U+0009 (HT) respectively. [lex.token.literal.char-escape.null] The null escape is the character U+0030 (0) and denotes the Unicode value U+0000 (NUL). [lex.token.literal.char-escape.slash] The backslash escape is the character U+005C (\\\\) which must be escaped in order to denote itself. [lex.token.literal.str-raw] Raw string literals [lex.token.literal.str-raw.syntax] Lexer RAW_STRING_LITERAL  r RAW_STRING_CONTENT SUFFIX ? RAW_STRING_CONTENT  \\" ( ~ CR )* (non-greedy) \\" | # RAW_STRING_CONTENT # Show Railroad RAW_STRING_LITERAL r RAW_STRING_CONTENT SUFFIX RAW_STRING_CONTENT \\" non-greedy  with the exception of CR CHAR \\" # RAW_STRING_CONTENT # [lex.token.literal.str-raw.intro] Raw string literals do not process any escapes. They start with the character U+0072 (r), followed by fewer than 256 of the character U+0023 (#) and a U+0022 (double-quote) character. [lex.token.literal.str-raw.body] The raw string body can contain any sequence of Unicode characters other than U+000D (CR). It is terminated only by another U+0022 (double-quote) character, followed by the same number of U+0023 (#) characters that preceded the opening U+0022 (double-quote) character. [lex.token.literal.str-raw.content] All Unicode characters contained in the raw string body represent themselves, the characters U+0022 (double-quote) (except when followed by at least as many U+0023 (#) characters as were used to start the raw string literal) or U+005C (\\\\) do not have any special meaning. Examples for string literals: \\"foo\\"; r\\"foo\\"; // foo\\n\\"\\\\\\"foo\\\\\\"\\"; r#\\"\\"foo\\"\\"#; // \\"foo\\" \\"foo #\\\\\\"# bar\\";\\nr##\\"foo #\\"# bar\\"##; // foo #\\"# bar \\"\\\\x52\\"; \\"R\\"; r\\"R\\"; // R\\n\\"\\\\\\\\x52\\"; r\\"\\\\x52\\"; // \\\\x52","breadcrumbs":"Lexical structure  Tokens  Character and string literals","id":"32","title":"Character and string literals"},"320":{"body":"[expr.match.attributes.outer] Outer attributes are allowed on match arms. The only attributes that have meaning on match arms are cfg and the lint check attributes . [expr.match.attributes.inner] Inner attributes are allowed directly after the opening brace of the match expression in the same expression contexts as attributes on block expressions .","breadcrumbs":"Statements and expressions  Expressions  Match expressions  Attributes on match arms","id":"320","title":"Attributes on match arms"},"321":{"body":"[expr.return] [expr.return.syntax] Syntax ReturnExpression  return Expression ? Show Railroad ReturnExpression return Expression [expr.return.intro] Return expressions are denoted with the keyword return. [expr.return.behavior] Evaluating a return expression moves its argument into the designated output location for the current function call, destroys the current function activation frame, and transfers control to the caller frame. An example of a return expression: fn max(a: i32, b: i32) -> i32 { if a > b { return a; } return b;\\n}","breadcrumbs":"Statements and expressions  Expressions  Return expressions  return expressions","id":"321","title":"return expressions"},"322":{"body":"[expr.await] [expr.await.syntax] Syntax AwaitExpression  Expression . await Show Railroad AwaitExpression Expression . await [expr.await.intro] An await expression is a syntactic construct for suspending a computation provided by an implementation of std::future::IntoFuture until the given future is ready to produce a value. [expr.await.construct] The syntax for an await expression is an expression with a type that implements the IntoFuture trait, called the future operand , then the token ., and then the await keyword. [expr.await.allowed-positions] Await expressions are legal only within an async context , like an async fn , async closure , or async block . [expr.await.effects] More specifically, an await expression has the following effect. Create a future by calling IntoFuture::into_future on the future operand. Evaluate the future to a future tmp; Pin tmp using Pin::new_unchecked ; This pinned future is then polled by calling the Future::poll method and passing it the current task context ; If the call to poll returns Poll::Pending , then the future returns Poll::Pending, suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3; Otherwise the call to poll must have returned Poll::Ready , in which case the value contained in the Poll::Ready variant is used as the result of the await expression itself. [expr.await.edition2018] 2018 Edition differences Await expressions are only available beginning with Rust 2018. [expr.await.task]","breadcrumbs":"Statements and expressions  Expressions  Await expressions  Await expressions","id":"322","title":"Await expressions"},"323":{"body":"The task context refers to the Context which was supplied to the current async context when the async context itself was polled. Because await expressions are only legal in an async context, there must be some task context available. [expr.await.desugar]","breadcrumbs":"Statements and expressions  Expressions  Await expressions  Task context","id":"323","title":"Task context"},"324":{"body":"Effectively, an await expression is roughly equivalent to the following non-normative desugaring: match operand.into_future() { mut pinned => loop { let mut pin = unsafe { Pin::new_unchecked(&mut pinned) }; match Pin::future::poll(Pin::borrow(&mut pin), &mut current_context) { Poll::Ready(r) => break r, Poll::Pending => yield Poll::Pending, } }\\n} where the yield pseudo-code returns Poll::Pending and, when re-invoked, resumes execution from that point. The variable current_context refers to the context taken from the async environment.","breadcrumbs":"Statements and expressions  Expressions  Await expressions  Approximate desugaring","id":"324","title":"Approximate desugaring"},"325":{"body":"[expr.placeholder] [expr.placeholder.syntax] Syntax UnderscoreExpression  _ Show Railroad UnderscoreExpression _ [expr.placeholder.intro] Underscore expressions, denoted with the symbol _, are used to signify a placeholder in a destructuring assignment. [expr.placeholder.lhs-assignment-only] They may only appear in the left-hand side of an assignment. [expr.placeholder.pattern] Note that this is distinct from the wildcard pattern . Examples of _ expressions: let p = (1, 2);\\nlet mut a = 0;\\n(_, a) = p; struct Position { x: u32, y: u32,\\n} Position { x: a, y: _ } = Position{ x: 2, y: 3 }; // unused result, assignment to `_` used to declare intent and remove a warning\\n_ = 2 + 2;\\n// triggers unused_must_use warning\\n// 2 + 2; // equivalent technique using a wildcard pattern in a let-binding\\nlet _ = 2 + 2;","breadcrumbs":"Statements and expressions  Expressions  Underscore expressions  _ expressions","id":"325","title":"_ expressions"},"326":{"body":"[patterns] [patterns.syntax] Syntax Pattern  |? PatternNoTopAlt ( | PatternNoTopAlt )* PatternNoTopAlt  PatternWithoutRange | RangePattern PatternWithoutRange  LiteralPattern | IdentifierPattern | WildcardPattern | RestPattern | ReferencePattern | StructPattern | TupleStructPattern | TuplePattern | GroupedPattern | SlicePattern | PathPattern | MacroInvocation Show Railroad Pattern | PatternNoTopAlt | PatternNoTopAlt PatternNoTopAlt PatternWithoutRange RangePattern PatternWithoutRange LiteralPattern IdentifierPattern WildcardPattern RestPattern ReferencePattern StructPattern TupleStructPattern TuplePattern GroupedPattern SlicePattern PathPattern MacroInvocation [patterns.intro] Patterns are used to match values against structures and to, optionally, bind variables to values inside these structures. They are also used in variable declarations and parameters for functions and closures. The pattern in the following example does four things: Tests if person has the car field filled with something. Tests if the person\'s age field is between 13 and 19, and binds its value to the person_age variable. Binds a reference to the name field to the variable person_name. Ignores the rest of the fields of person. The remaining fields can have any value and are not bound to any variables. # struct Car;\\n# struct Computer;\\n# struct Person {\\n# name: String,\\n# car: Option<Car>,\\n# computer: Option<Computer>,\\n# age: u8,\\n# }\\n# let person = Person {\\n# name: String::from(\\"John\\"),\\n# car: Some(Car),\\n# computer: None,\\n# age: 15,\\n# };\\nif let Person { car: Some(_), age: person_age @ 13..=19, name: ref person_name, .. } = person\\n{ println!(\\"{} has a car and is {} years old.\\", person_name, person_age);\\n} [patterns.usage] Patterns are used in: [patterns.let] let declarations [patterns.param] Function and closure parameters [patterns.match] match expressions [patterns.if-let] if let expressions [patterns.while-let] while let expressions [patterns.for] for expressions [patterns.destructure]","breadcrumbs":"Patterns  Patterns","id":"326","title":"Patterns"},"327":{"body":"[patterns.destructure.intro] Patterns can be used to destructure structs , enums , and tuples . Destructuring breaks up a value into its component pieces. The syntax used is almost the same as when creating such values. [patterns.destructure.wildcard] In a pattern whose scrutinee expression has a struct, enum or tuple type, a wildcard pattern (_) stands in for a single data field, whereas an et cetera or rest pattern (..) stands in for all the remaining fields of a particular variant. [patterns.destructure.named-field-shorthand] When destructuring a data structure with named (but not numbered) fields, it is allowed to write fieldname as a shorthand for fieldname: fieldname. # enum Message {\\n# Quit,\\n# WriteString(String),\\n# Move { x: i32, y: i32 },\\n# ChangeColor(u8, u8, u8),\\n# }\\n# let message = Message::Quit;\\nmatch message { Message::Quit => println!(\\"Quit\\"), Message::WriteString(write) => println!(\\"{}\\", &write), Message::Move{ x, y: 0 } => println!(\\"move {} horizontally\\", x), Message::Move{ .. } => println!(\\"other move\\"), Message::ChangeColor { 0: red, 1: green, 2: _ } => { println!(\\"color change, red: {}, green: {}\\", red, green); }\\n}; [patterns.refutable]","breadcrumbs":"Patterns  Destructuring","id":"327","title":"Destructuring"},"328":{"body":"A pattern is said to be refutable when it has the possibility of not being matched by the value it is being matched against. Irrefutable patterns, on the other hand, always match the value they are being matched against. Examples: let (x, y) = (1, 2); // \\"(x, y)\\" is an irrefutable pattern if let (a, 3) = (1, 2) { // \\"(a, 3)\\" is refutable, and will not match panic!(\\"Shouldn\'t reach here\\");\\n} else if let (a, 4) = (3, 4) { // \\"(a, 4)\\" is refutable, and will match println!(\\"Matched ({}, 4)\\", a);\\n} [patterns.literal]","breadcrumbs":"Patterns  Refutability","id":"328","title":"Refutability"},"329":{"body":"[patterns.literal.syntax] Syntax LiteralPattern  -? LiteralExpression Show Railroad LiteralPattern - LiteralExpression [patterns.literal.intro] Literal patterns match exactly the same value as what is created by the literal. Since negative numbers are not literals , literals in patterns may be prefixed by an optional minus sign, which acts like the negation operator. Warning C string and raw C string literals are accepted in literal patterns, but &CStr doesn\'t implement structural equality (#[derive(Eq, PartialEq)]) and therefore any such match on a &CStr will be rejected with a type error. [patterns.literal.refutable] Literal patterns are always refutable. Examples: for i in -2..5 { match i { -1 => println!(\\"It\'s minus one\\"), 1 => println!(\\"It\'s a one\\"), 2|4 => println!(\\"It\'s either a two or a four\\"), _ => println!(\\"Matched none of the arms\\"), }\\n} [patterns.ident]","breadcrumbs":"Patterns  Literal patterns","id":"329","title":"Literal patterns"},"33":{"body":"[lex.token.byte] Byte literals [lex.token.byte.syntax] Lexer BYTE_LITERAL  b\' ( ASCII_FOR_CHAR | BYTE_ESCAPE ) \' SUFFIX ? ASCII_FOR_CHAR  <any ASCII (i.e. 0x00 to 0x7F) except \', \\\\, LF, CR, or TAB> BYTE_ESCAPE  \\\\x HEX_DIGIT HEX_DIGIT | \\\\n | \\\\r | \\\\t | \\\\\\\\ | \\\\0 | \\\\\' | \\\\\\" Show Railroad BYTE_LITERAL b\' ASCII_FOR_CHAR BYTE_ESCAPE \' SUFFIX ASCII_FOR_CHAR any ASCII (i.e. 0x00 to 0x7F) except `\'`, `\\\\`, LF, CR, or TAB BYTE_ESCAPE \\\\x HEX_DIGIT HEX_DIGIT \\\\n \\\\r \\\\t \\\\\\\\ \\\\0 \\\\\' \\\\\\" [lex.token.byte.intro] A byte literal is a single ASCII character (in the U+0000 to U+007F range) or a single escape preceded by the characters U+0062 (b) and U+0027 (single-quote), and followed by the character U+0027. If the character U+0027 is present within the literal, it must be escaped by a preceding U+005C (\\\\) character. It is equivalent to a u8 unsigned 8-bit integer number literal . [lex.token.str-byte] Byte string literals [lex.token.str-byte.syntax] Lexer BYTE_STRING_LITERAL  b\\" ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )* \\" SUFFIX ? ASCII_FOR_STRING  <any ASCII (i.e 0x00 to 0x7F) except \\", \\\\, or CR> Show Railroad BYTE_STRING_LITERAL b\\" ASCII_FOR_STRING BYTE_ESCAPE STRING_CONTINUE \\" SUFFIX ASCII_FOR_STRING any ASCII (i.e 0x00 to 0x7F) except `\\"`, `\\\\`, or CR [lex.token.str-byte.intro] A non-raw byte string literal is a sequence of ASCII characters and escapes , preceded by the characters U+0062 (b) and U+0022 (double-quote), and followed by the character U+0022. If the character U+0022 is present within the literal, it must be escaped by a preceding U+005C (\\\\) character. Alternatively, a byte string literal can be a raw byte string literal , defined below. [lex.token.str-byte.linefeed] Line-breaks, represented by the character U+000A (LF), are allowed in byte string literals. The character U+000D (CR) may not appear in a byte string literal. When an unescaped U+005C character (\\\\) occurs immediately before a line break, the line break does not appear in the string represented by the token. See String continuation escapes for details. [lex.token.str-byte.escape] Some additional escapes are available in either byte or non-raw byte string literals. An escape starts with a U+005C (\\\\) and continues with one of the following forms: [lex.token.str-byte.escape-byte] A byte escape escape starts with U+0078 (x) and is followed by exactly two hex digits . It denotes the byte equal to the provided hex value. [lex.token.str-byte.escape-whitespace] A whitespace escape is one of the characters U+006E (n), U+0072 (r), or U+0074 (t), denoting the bytes values 0x0A (ASCII LF), 0x0D (ASCII CR) or 0x09 (ASCII HT) respectively. [lex.token.str-byte.escape-null] The null escape is the character U+0030 (0) and denotes the byte value 0x00 (ASCII NUL). [lex.token.str-byte.escape-slash] The backslash escape is the character U+005C (\\\\) which must be escaped in order to denote its ASCII encoding 0x5C. [lex.token.str-byte-raw] Raw byte string literals [lex.token.str-byte-raw.syntax] Lexer RAW_BYTE_STRING_LITERAL  br RAW_BYTE_STRING_CONTENT SUFFIX ? RAW_BYTE_STRING_CONTENT  \\" ASCII_FOR_RAW * (non-greedy) \\" | # RAW_BYTE_STRING_CONTENT # ASCII_FOR_RAW  <any ASCII (i.e. 0x00 to 0x7F) except CR> Show Railroad RAW_BYTE_STRING_LITERAL br RAW_BYTE_STRING_CONTENT SUFFIX RAW_BYTE_STRING_CONTENT \\" non-greedy ASCII_FOR_RAW \\" # RAW_BYTE_STRING_CONTENT # ASCII_FOR_RAW any ASCII (i.e. 0x00 to 0x7F) except CR [lex.token.str-byte-raw.intro] Raw byte string literals do not process any escapes. They start with the character U+0062 (b), followed by U+0072 (r), followed by fewer than 256 of the character U+0023 (#), and a U+0022 (double-quote) character. [lex.token.str-byte-raw.body] The raw string body can contain any sequence of ASCII characters other than U+000D (CR). It is terminated only by another U+0022 (double-quote) character, followed by the same number of U+0023 (#) characters that preceded the opening U+0022 (double-quote) character. A raw byte string literal can not contain any non-ASCII byte. [lex.token.literal.str-byte-raw.content] All characters contained in the raw string body represent their ASCII encoding, the characters U+0022 (double-quote) (except when followed by at least as many U+0023 (#) characters as were used to start the raw string literal) or U+005C (\\\\) do not have any special meaning. Examples for byte string literals: b\\"foo\\"; br\\"foo\\"; // foo\\nb\\"\\\\\\"foo\\\\\\"\\"; br#\\"\\"foo\\"\\"#; // \\"foo\\" b\\"foo #\\\\\\"# bar\\";\\nbr##\\"foo #\\"# bar\\"##; // foo #\\"# bar b\\"\\\\x52\\"; b\\"R\\"; br\\"R\\"; // R\\nb\\"\\\\\\\\x52\\"; br\\"\\\\x52\\"; // \\\\x52","breadcrumbs":"Lexical structure  Tokens  Byte and byte string literals","id":"33","title":"Byte and byte string literals"},"330":{"body":"[patterns.ident.syntax] Syntax IdentifierPattern  ref? mut? IDENTIFIER ( @ PatternNoTopAlt )? Show Railroad IdentifierPattern ref mut IDENTIFIER @ PatternNoTopAlt [patterns.ident.intro] Identifier patterns bind the value they match to a variable in the value namespace . [patterns.ident.unique] The identifier must be unique within the pattern. [patterns.ident.scope] The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a let binding or a match arm). [patterns.ident.bare] Patterns that consist of only an identifier, possibly with a mut, match any value and bind it to that identifier. This is the most commonly used pattern in variable declarations and parameters for functions and closures. let mut variable = 10;\\nfn sum(x: i32, y: i32) -> i32 {\\n# x + y\\n# } [patterns.ident.scrutinized] To bind the matched value of a pattern to a variable, use the syntax variable @ subpattern. For example, the following binds the value 2 to e (not the entire range: the range here is a range subpattern). let x = 2; match x { e @ 1 ..= 5 => println!(\\"got a range element {}\\", e), _ => println!(\\"anything\\"),\\n} [patterns.ident.move] By default, identifier patterns bind a variable to a copy of or move from the matched value depending on whether the matched value implements Copy . [patterns.ident.ref] This can be changed to bind to a reference by using the ref keyword, or to a mutable reference using ref mut. For example: # let a = Some(10);\\nmatch a { None => (), Some(value) => (),\\n} match a { None => (), Some(ref value) => (),\\n} In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the & operator can\'t be applied to the value\'s fields. For example, the following is not valid: # struct Person {\\n# name: String,\\n# age: u8,\\n# }\\n# let value = Person { name: String::from(\\"John\\"), age: 23 };\\nif let Person { name: &person_name, age: 18..=150 } = value { } To make it valid, write the following: # struct Person {\\n# name: String,\\n# age: u8,\\n# }\\n# let value = Person { name: String::from(\\"John\\"), age: 23 };\\nif let Person { name: ref person_name, age: 18..=150 } = value { } [patterns.ident.ref-ignored] Thus, ref is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched. [patterns.ident.precedent] Path patterns take precedence over identifier patterns. Note When a pattern is a single-segment identifier, the grammar is ambiguous whether it means an IdentifierPattern or a PathPattern . This ambiguity can only be resolved after name resolution . const EXPECTED_VALUE: u8 = 42;\\n// ^^^^^^^^^^^^^^ That this constant is in scope affects how the\\n// patterns below are treated. fn check_value(x: u8) -> Result<u8, u8> { match x { EXPECTED_VALUE => Ok(x), // ^^^^^^^^^^^^^^ Parsed as a `PathPattern` that resolves to // the constant `42`. other_value => Err(x), // ^^^^^^^^^^^ Parsed as an `IdentifierPattern`. }\\n} // If `EXPECTED_VALUE` were treated as an `IdentifierPattern` above,\\n// that pattern would always match, making the function always return\\n// `Ok(_) regardless of the input.\\nassert_eq!(check_value(42), Ok(42));\\nassert_eq!(check_value(43), Err(43)); [patterns.ident.constraint] It is an error if ref or ref mut is specified and the identifier shadows a constant. [patterns.ident.refutable] Identifier patterns are irrefutable if the @ subpattern is irrefutable or the subpattern is not specified. [patterns.ident.binding]","breadcrumbs":"Patterns  Identifier patterns","id":"330","title":"Identifier patterns"},"331":{"body":"[patterns.ident.binding.intro] To service better ergonomics, patterns operate in different binding modes in order to make it easier to bind references to values. When a reference value is matched by a non-reference pattern, it will be automatically treated as a ref or ref mut binding. Example: let x: &Option<i32> = &Some(3);\\nif let Some(y) = x { // y was converted to `ref y` and its type is &i32\\n} [patterns.ident.binding.non-reference] Non-reference patterns include all patterns except bindings, wildcard patterns (_), const patterns of reference types, and reference patterns . [patterns.ident.binding.default-mode] If a binding pattern does not explicitly have ref, ref mut, or mut, then it uses the default binding mode to determine how the variable is bound. [patterns.ident.binding.move] The default binding mode starts in \\"move\\" mode which uses move semantics. [patterns.ident.binding.top-down] When matching a pattern, the compiler starts from the outside of the pattern and works inwards. [patterns.ident.binding.auto-deref] Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. [patterns.ident.binding.ref] References will set the default binding mode to ref. [patterns.ident.binding.ref-mut] Mutable references will set the mode to ref mut unless the mode is already ref in which case it remains ref. [patterns.ident.binding.nested-references] If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats. [patterns.ident.binding.mode-limitations-binding] The binding pattern may only explicitly specify a ref or ref mut binding mode, or specify mutability with mut, when the default binding mode is \\"move\\". For example, these are not accepted: let [mut x] = &[()]; //~ ERROR\\nlet [ref x] = &[()]; //~ ERROR\\nlet [ref mut x] = &mut [()]; //~ ERROR [patterns.ident.binding.mode-limitations.edition2024] 2024 Edition differences Before the 2024 edition, bindings could explicitly specify a ref or ref mut binding mode even when the default binding mode was not \\"move\\", and they could specify mutability on such bindings with mut. In these editions, specifying mut on a binding set the binding mode to \\"move\\" regardless of the current default binding mode. [patterns.ident.binding.mode-limitations-reference] Similarly, a reference pattern may only appear when the default binding mode is \\"move\\". For example, this is not accepted: let [&x] = &[&()]; //~ ERROR [patterns.ident.binding.mode-limitations-reference.edition2024] 2024 Edition differences Before the 2024 edition, reference patterns could appear even when the default binding mode was not \\"move\\", and had both the effect of matching against the scrutinee and of causing the default binding mode to be reset to \\"move\\". [patterns.ident.binding.mixed] Move bindings and reference bindings can be mixed together in the same pattern. Doing so will result in partial move of the object bound to and the object cannot be used afterwards. This applies only if the type cannot be copied. In the example below, name is moved out of person. Trying to use person as a whole or person.name would result in an error because of partial move . Example: # struct Person {\\n# name: String,\\n# age: u8,\\n# }\\n# let person = Person{ name: String::from(\\"John\\"), age: 23 };\\n// `name` is moved from person and `age` referenced\\nlet Person { name, ref age } = person; [patterns.wildcard]","breadcrumbs":"Patterns  Binding modes","id":"331","title":"Binding modes"},"332":{"body":"[patterns.wildcard.syntax] Syntax WildcardPattern  _ Show Railroad WildcardPattern _ [patterns.wildcard.intro] The wildcard pattern (an underscore symbol) matches any value. It is used to ignore values when they don\'t matter. [patterns.wildcard.struct-matcher] Inside other patterns it matches a single data field (as opposed to the .. which matches the remaining fields). [patterns.wildcard.no-binding] Unlike identifier patterns, it does not copy, move or borrow the value it matches. Examples: # let x = 20;\\nlet (a, _) = (10, x); // the x is always matched by _\\n# assert_eq!(a, 10); // ignore a function/closure param\\nlet real_part = |a: f64, _: f64| { a }; // ignore a field from a struct\\n# struct RGBA {\\n# r: f32,\\n# g: f32,\\n# b: f32,\\n# a: f32,\\n# }\\n# let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};\\nlet RGBA{r: red, g: green, b: blue, a: _} = color;\\n# assert_eq!(color.r, red);\\n# assert_eq!(color.g, green);\\n# assert_eq!(color.b, blue); // accept any Some, with any value\\n# let x = Some(10);\\nif let Some(_) = x {} [patterns.wildcard.refutable] The wildcard pattern is always irrefutable. [patterns.rest]","breadcrumbs":"Patterns  Wildcard pattern","id":"332","title":"Wildcard pattern"},"333":{"body":"[patterns.rest.syntax] Syntax RestPattern  .. Show Railroad RestPattern .. [patterns.rest.intro] The rest pattern (the .. token) acts as a variable-length pattern which matches zero or more elements that haven\'t been matched already before and after. [patterns.rest.allowed-patterns] It may only be used in tuple , tuple struct , and slice patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an identifier pattern for slice patterns only. [patterns.rest.refutable] The rest pattern is always irrefutable. Examples: # let words = vec![\\"a\\", \\"b\\", \\"c\\"];\\n# let slice = &words[..];\\nmatch slice { [] => println!(\\"slice is empty\\"), [one] => println!(\\"single element {}\\", one), [head, tail @ ..] => println!(\\"head={} tail={:?}\\", head, tail),\\n} match slice { // Ignore everything but the last element, which must be \\"!\\". [.., \\"!\\"] => println!(\\"!!!\\"), // `start` is a slice of everything except the last element, which must be \\"z\\". [start @ .., \\"z\\"] => println!(\\"starts with: {:?}\\", start), // `end` is a slice of everything but the first element, which must be \\"a\\". [\\"a\\", end @ ..] => println!(\\"ends with: {:?}\\", end), // \'whole\' is the entire slice and `last` is the final element whole @ [.., last] => println!(\\"the last element of {:?} is {}\\", whole, last), rest => println!(\\"{:?}\\", rest),\\n} if let [.., penultimate, _] = slice { println!(\\"next to last is {}\\", penultimate);\\n} # let tuple = (1, 2, 3, 4, 5);\\n// Rest patterns may also be used in tuple and tuple struct patterns.\\nmatch tuple { (1, .., y, z) => println!(\\"y={} z={}\\", y, z), (.., 5) => println!(\\"tail must be 5\\"), (..) => println!(\\"matches everything else\\"),\\n} [patterns.range]","breadcrumbs":"Patterns  Rest patterns","id":"333","title":"Rest patterns"},"334":{"body":"[patterns.range.syntax] Syntax RangePattern  RangeExclusivePattern | RangeInclusivePattern | RangeFromPattern | RangeToExclusivePattern | RangeToInclusivePattern | ObsoleteRangePattern  [1] RangeExclusivePattern  RangePatternBound .. RangePatternBound RangeInclusivePattern  RangePatternBound ..= RangePatternBound RangeFromPattern  RangePatternBound .. RangeToExclusivePattern  .. RangePatternBound RangeToInclusivePattern  ..= RangePatternBound ObsoleteRangePattern  RangePatternBound ... RangePatternBound RangePatternBound  LiteralPattern | PathExpression Show Railroad RangePattern RangeExclusivePattern RangeInclusivePattern RangeFromPattern RangeToExclusivePattern RangeToInclusivePattern ObsoleteRangePattern RangeExclusivePattern RangePatternBound .. RangePatternBound RangeInclusivePattern RangePatternBound ..= RangePatternBound RangeFromPattern RangePatternBound .. RangeToExclusivePattern .. RangePatternBound RangeToInclusivePattern ..= RangePatternBound ObsoleteRangePattern RangePatternBound ... RangePatternBound RangePatternBound LiteralPattern PathExpression The ObsoleteRangePattern syntax has been removed in the 2021 edition. [patterns.range.intro] Range patterns match scalar values within the range defined by their bounds. They comprise a sigil (.. or ..=) and a bound on one or both sides. A bound on the left of the sigil is called a lower bound . A bound on the right is called an upper bound . [patterns.range.exclusive] The exclusive range pattern matches all values from the lower bound up to, but not including the upper bound. It is written as its lower bound, followed by .., followed by the upper bound. For example, a pattern \'m\'..\'p\' will match only \'m\', \'n\' and \'o\', specifically not including \'p\'. [patterns.range.inclusive] The inclusive range pattern matches all values from the lower bound up to and including the upper bound. It is written as its lower bound, followed by ..=, followed by the upper bound. For example, a pattern \'m\'..=\'p\' will match only the values \'m\', \'n\', \'o\', and \'p\'. [patterns.range.from] The from range pattern matches all values greater than or equal to the lower bound. It is written as its lower bound followed by ... For example, 1.. will match any integer greater than or equal to 1, such as 1, 9, or 9001, or 9007199254740991 (if it is of an appropriate size), but not 0, and not negative numbers for signed integers. [patterns.range.to-exclusive] The to exclusive range pattern matches all values less than the upper bound. It is written as .. followed by the upper bound. For example, ..10 will match any integer less than 10, such as 9, 1, 0, and for signed integer types, all negative values. [patterns.range.to-inclusive] The to inclusive range pattern matches all values less than or equal to the upper bound. It is written as ..= followed by the upper bound. For example, ..=10 will match any integer less than or equal to 10, such as 10, 1, 0, and for signed integer types, all negative values. [patterns.range.constraint-less-than] The lower bound cannot be greater than the upper bound. That is, in a..=b, a  b must be the case. For example, it is an error to have a range pattern 10..=0. [patterns.range.bound] A bound is written as one of: A character, byte, integer, or float literal. A - followed by an integer or float literal. A path . Note We syntactically accept more than this for a RangePatternBound . We later reject the other things semantically. [patterns.range.constraint-bound-path] If a bound is written as a path, after macro resolution, the path must resolve to a constant item of the type char, an integer type, or a float type. [patterns.range.type] The range pattern matches the type of its upper and lower bounds, which must be the same type. [patterns.range.path-value] If a bound is a path , the bound matches the type and has the value of the constant the path resolves to. [patterns.range.literal-value] If a bound is a literal, the bound matches the type and has the value of the corresponding literal expression . [patterns.range.negation] If a bound is a literal preceded by a -, the bound matches the same type as the corresponding literal expression and has the value of negating the value of the corresponding literal expression. [patterns.range.float-restriction] For float range patterns, the constant may not be a NaN. Examples: # let c = \'f\';\\nlet valid_variable = match c { \'a\'..=\'z\' => true, \'A\'..=\'Z\' => true, \'\'..=\'\' => true, _ => false,\\n}; # let ph = 10;\\nprintln!(\\"{}\\", match ph { 0..7 => \\"acid\\", 7 => \\"neutral\\", 8..=14 => \\"base\\", _ => unreachable!(),\\n}); # let uint: u32 = 5;\\nmatch uint { 0 => \\"zero!\\", 1.. => \\"positive number!\\",\\n}; // using paths to constants:\\n# const TROPOSPHERE_MIN : u8 = 6;\\n# const TROPOSPHERE_MAX : u8 = 20;\\n#\\n# const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;\\n# const STRATOSPHERE_MAX : u8 = 50;\\n#\\n# const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;\\n# const MESOSPHERE_MAX : u8 = 85;\\n#\\n# let altitude = 70;\\n#\\nprintln!(\\"{}\\", match altitude { TROPOSPHERE_MIN..=TROPOSPHERE_MAX => \\"troposphere\\", STRATOSPHERE_MIN..=STRATOSPHERE_MAX => \\"stratosphere\\", MESOSPHERE_MIN..=MESOSPHERE_MAX => \\"mesosphere\\", _ => \\"outer space, maybe\\",\\n}); # pub mod binary {\\n# pub const MEGA : u64 = 1024*1024;\\n# pub const GIGA : u64 = 1024*1024*1024;\\n# }\\n# let n_items = 20_832_425;\\n# let bytes_per_item = 12;\\nif let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item { println!(\\"It fits and occupies {} bytes\\", size);\\n} # trait MaxValue {\\n# const MAX: u64;\\n# }\\n# impl MaxValue for u8 {\\n# const MAX: u64 = (1 << 8) - 1;\\n# }\\n# impl MaxValue for u16 {\\n# const MAX: u64 = (1 << 16) - 1;\\n# }\\n# impl MaxValue for u32 {\\n# const MAX: u64 = (1 << 32) - 1;\\n# }\\n// using qualified paths:\\nprintln!(\\"{}\\", match 0xfacade { 0 ..= <u8 as MaxValue>::MAX => \\"fits in a u8\\", 0 ..= <u16 as MaxValue>::MAX => \\"fits in a u16\\", 0 ..= <u32 as MaxValue>::MAX => \\"fits in a u32\\", _ => \\"too big\\",\\n}); [patterns.range.refutable] Range patterns for fix-width integer and char types are irrefutable when they span the entire set of possible values of a type. For example, 0u8..=255u8 is irrefutable. [patterns.range.refutable-integer] The range of values for an integer type is the closed range from its minimum to maximum value. [patterns.range.refutable-char] The range of values for a char type are precisely those ranges containing all Unicode Scalar Values: \'\\\\u{0000}\'..=\'\\\\u{D7FF}\' and \'\\\\u{E000}\'..=\'\\\\u{10FFFF}\'. [patterns.range.constraint-slice] RangeFromPattern cannot be used as a top-level pattern for subpatterns in slice patterns . For example, the pattern [1.., _] is not a valid pattern. [patterns.range.edition2021] 2021 Edition differences Before the 2021 edition, range patterns with both a lower and upper bound may also be written using ... in place of ..=, with the same meaning. [patterns.ref]","breadcrumbs":"Patterns  Range patterns","id":"334","title":"Range patterns"},"335":{"body":"[patterns.ref.syntax] Syntax ReferencePattern  ( & | && ) mut? PatternWithoutRange Show Railroad ReferencePattern &amp; &amp;&amp; mut PatternWithoutRange [patterns.ref.intro] Reference patterns dereference the pointers that are being matched and, thus, borrow them. For example, these two matches on x: &i32 are equivalent: let int_reference = &3; let a = match *int_reference { 0 => \\"zero\\", _ => \\"some\\" };\\nlet b = match int_reference { &0 => \\"zero\\", _ => \\"some\\" }; assert_eq!(a, b); [patterns.ref.ref-ref] The grammar production for reference patterns has to match the token && to match a reference to a reference because it is a token by itself, not two & tokens. [patterns.ref.mut] Adding the mut keyword dereferences a mutable reference. The mutability must match the mutability of the reference. [patterns.ref.refutable] Reference patterns are always irrefutable. [patterns.struct]","breadcrumbs":"Patterns  Reference patterns","id":"335","title":"Reference patterns"},"336":{"body":"[patterns.struct.syntax] Syntax StructPattern  PathInExpression { StructPatternElements ? } StructPatternElements  StructPatternFields ( , | , StructPatternEtCetera )? | StructPatternEtCetera StructPatternFields  StructPatternField ( , StructPatternField )* StructPatternField  OuterAttribute * ( TUPLE_INDEX : Pattern | IDENTIFIER : Pattern | ref? mut? IDENTIFIER ) StructPatternEtCetera  .. Show Railroad StructPattern PathInExpression { StructPatternElements } StructPatternElements StructPatternFields , , StructPatternEtCetera StructPatternEtCetera StructPatternFields StructPatternField , StructPatternField StructPatternField OuterAttribute TUPLE_INDEX : Pattern IDENTIFIER : Pattern ref mut IDENTIFIER StructPatternEtCetera .. [patterns.struct.intro] Struct patterns match struct, enum, and union values that match all criteria defined by its subpatterns. They are also used to destructure a struct, enum, or union value. [patterns.struct.ignore-rest] On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of ..: # struct Point {\\n# x: u32,\\n# y: u32,\\n# }\\n# let s = Point {x: 1, y: 1};\\n#\\nmatch s { Point {x: 10, y: 20} => (), Point {y: 10, x: 20} => (), // order doesn\'t matter Point {x: 10, ..} => (), Point {..} => (),\\n} # struct PointTuple (\\n# u32,\\n# u32,\\n# );\\n# let t = PointTuple(1, 2);\\n#\\nmatch t { PointTuple {0: 10, 1: 20} => (), PointTuple {1: 10, 0: 20} => (), // order doesn\'t matter PointTuple {0: 10, ..} => (), PointTuple {..} => (),\\n} # enum Message {\\n# Quit,\\n# Move { x: i32, y: i32 },\\n# }\\n# let m = Message::Quit;\\n#\\nmatch m { Message::Quit => (), Message::Move {x: 10, y: 20} => (), Message::Move {..} => (),\\n} [patterns.struct.constraint-struct] If .. is not used, a struct pattern used to match a struct is required to specify all fields: # struct Struct {\\n# a: i32,\\n# b: char,\\n# c: bool,\\n# }\\n# let mut struct_value = Struct{a: 10, b: \'X\', c: false};\\n#\\nmatch struct_value { Struct{a: 10, b: \'X\', c: false} => (), Struct{a: 10, b: \'X\', ref c} => (), Struct{a: 10, b: \'X\', ref mut c} => (), Struct{a: 10, b: \'X\', c: _} => (), Struct{a: _, b: _, c: _} => (),\\n} [patterns.struct.constraint-union] A struct pattern used to match a union must specify exactly one field (see Pattern matching on unions ). [patterns.struct.binding-shorthand] The IDENTIFIER syntax matches any value and binds it to a variable with the same name as the given field. It is a shorthand for fieldname: fieldname. The ref and mut qualifiers can be included with the behavior as described in patterns.ident.ref . # struct Struct {\\n# a: i32,\\n# b: char,\\n# c: bool,\\n# }\\n# let struct_value = Struct{a: 10, b: \'X\', c: false};\\n#\\nlet Struct { a, b, c } = struct_value; [patterns.struct.refutable] A struct pattern is refutable if the PathInExpression resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable. [patterns.struct.namespace] A struct pattern matches against the struct, union, or enum variant whose constructor is resolved from PathInExpression in the type namespace . See patterns.tuple-struct.namespace for more details. [patterns.tuple-struct]","breadcrumbs":"Patterns  Struct patterns","id":"336","title":"Struct patterns"},"337":{"body":"[patterns.tuple-struct.syntax] Syntax TupleStructPattern  PathInExpression ( TupleStructItems ? ) TupleStructItems  Pattern ( , Pattern )* ,? Show Railroad TupleStructPattern PathInExpression ( TupleStructItems ) TupleStructItems Pattern , Pattern , [patterns.tuple-struct.intro] Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to destructure a tuple struct or enum value. [patterns.tuple-struct.refutable] A tuple struct pattern is refutable if the PathInExpression resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable. [patterns.tuple-struct.namespace] A tuple struct pattern matches against the tuple struct or tuple-like enum variant whose constructor is resolved from PathInExpression in the value namespace . Note Conversely, a struct pattern for a tuple struct or tuple-like enum variant , e.g. S { 0: _ }, matches against the tuple struct or variant whose constructor is resolved in the type namespace . enum E1 { V(u16) }\\nenum E2 { V(u32) } // Import `E1::V` from the type namespace only.\\nmod _0 { const V: () = (); // For namespace masking. pub(super) use super::E1::*;\\n}\\nuse _0::*; // Import `E2::V` from the value namespace only.\\nmod _1 { struct V {} // For namespace masking. pub(super) use super::E2::*;\\n}\\nuse _1::*; fn f() { // This struct pattern matches against the tuple-like // enum variant whose constructor was found in the type // namespace. let V { 0: ..=u16::MAX } = (loop {}) else { loop {} }; // This tuple struct pattern matches against the tuple-like // enum variant whose constructor was found in the value // namespace. let V(..=u32::MAX) = (loop {}) else { loop {} };\\n}\\n# // Required due to the odd behavior of `super` within functions.\\n# fn main() {} The Lang team has made certain decisions, such as in PR #138458 , that raise questions about the desirability of using the value namespace in this way for patterns, as described in PR #140593 . It might be prudent to not intentionally rely on this nuance in your code. [patterns.tuple]","breadcrumbs":"Patterns  Tuple struct patterns","id":"337","title":"Tuple struct patterns"},"338":{"body":"[patterns.tuple.syntax] Syntax TuplePattern  ( TuplePatternItems ? ) TuplePatternItems  Pattern , | RestPattern | Pattern ( , Pattern )+ ,? Show Railroad TuplePattern ( TuplePatternItems ) TuplePatternItems Pattern , RestPattern Pattern , Pattern , [patterns.tuple.intro] Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to destructure a tuple. [patterns.tuple.rest-syntax] The form (..) with a single RestPattern is a special form that does not require a comma, and matches a tuple of any size. [patterns.tuple.refutable] The tuple pattern is refutable when one of its subpatterns is refutable. An example of using tuple patterns: let pair = (10, \\"ten\\");\\nlet (a, b) = pair; assert_eq!(a, 10);\\nassert_eq!(b, \\"ten\\"); [patterns.paren]","breadcrumbs":"Patterns  Tuple patterns","id":"338","title":"Tuple patterns"},"339":{"body":"[patterns.paren.syntax] Syntax GroupedPattern  ( Pattern ) Show Railroad GroupedPattern ( Pattern ) [patterns.paren.intro] Enclosing a pattern in parentheses can be used to explicitly control the precedence of compound patterns. For example, a reference pattern next to a range pattern such as &0..=5 is ambiguous and is not allowed, but can be expressed with parentheses. let int_reference = &3;\\nmatch int_reference { &(0..=5) => (), _ => (),\\n} [patterns.slice]","breadcrumbs":"Patterns  Grouped patterns","id":"339","title":"Grouped patterns"},"34":{"body":"[lex.token.str-c] C string literals [lex.token.str-c.syntax] Lexer C_STRING_LITERAL  c\\" ( ~[\\" \\\\ CR NUL ] | BYTE_ESCAPE except \\\\0 or \\\\x00 | UNICODE_ESCAPE except \\\\u{0}, \\\\u{00}, , \\\\u{000000} | STRING_CONTINUE )* \\" SUFFIX ? Show Railroad C_STRING_LITERAL c\\"  with the exception of \\" \\\\ CR NUL CHAR except `\\\\0` or `\\\\x00` BYTE_ESCAPE except `\\\\u{0}`, `\\\\u{00}`, , `\\\\u{000000}` UNICODE_ESCAPE STRING_CONTINUE \\" SUFFIX [lex.token.str-c.intro] A C string literal is a sequence of Unicode characters and escapes , preceded by the characters U+0063 (c) and U+0022 (double-quote), and followed by the character U+0022. If the character U+0022 is present within the literal, it must be escaped by a preceding U+005C (\\\\) character. Alternatively, a C string literal can be a raw C string literal , defined below. [lex.token.str-c.null] C strings are implicitly terminated by byte 0x00, so the C string literal c\\"\\" is equivalent to manually constructing a &CStr from the byte string literal b\\"\\\\x00\\". Other than the implicit terminator, byte 0x00 is not permitted within a C string. [lex.token.str-c.linefeed] Line-breaks, represented by the character U+000A (LF), are allowed in C string literals. The character U+000D (CR) may not appear in a C string literal. When an unescaped U+005C character (\\\\) occurs immediately before a line break, the line break does not appear in the string represented by the token. See String continuation escapes for details. [lex.token.str-c.escape] Some additional escapes are available in non-raw C string literals. An escape starts with a U+005C (\\\\) and continues with one of the following forms: [lex.token.str-c.escape-byte] A byte escape escape starts with U+0078 (x) and is followed by exactly two hex digits . It denotes the byte equal to the provided hex value. [lex.token.str-c.escape-unicode] A 24-bit code point escape starts with U+0075 (u) and is followed by up to six hex digits surrounded by braces U+007B ({) and U+007D (}). It denotes the Unicode code point equal to the provided hex value, encoded as UTF-8. [lex.token.str-c.escape-whitespace] A whitespace escape is one of the characters U+006E (n), U+0072 (r), or U+0074 (t), denoting the bytes values 0x0A (ASCII LF), 0x0D (ASCII CR) or 0x09 (ASCII HT) respectively. [lex.token.str-c.escape-slash] The backslash escape is the character U+005C (\\\\) which must be escaped in order to denote its ASCII encoding 0x5C. [lex.token.str-c.char-unicode] A C string represents bytes with no defined encoding, but a C string literal may contain Unicode characters above U+007F. Such characters will be replaced with the bytes of that character\'s UTF-8 representation. The following C string literals are equivalent: c\\"\\"; // LATIN SMALL LETTER AE (U+00E6)\\nc\\"\\\\u{00E6}\\";\\nc\\"\\\\xC3\\\\xA6\\"; [lex.token.str-c.edition2021] 2021 Edition differences C string literals are accepted in the 2021 edition or later. In earlier editions the token c\\"\\" is lexed as c \\"\\". [lex.token.str-c-raw] Raw C string literals [lex.token.str-c-raw.syntax] Lexer RAW_C_STRING_LITERAL  cr RAW_C_STRING_CONTENT SUFFIX ? RAW_C_STRING_CONTENT  \\" ( ~[ CR NUL ] )* (non-greedy) \\" | # RAW_C_STRING_CONTENT # Show Railroad RAW_C_STRING_LITERAL cr RAW_C_STRING_CONTENT SUFFIX RAW_C_STRING_CONTENT \\" non-greedy  with the exception of CR NUL CHAR \\" # RAW_C_STRING_CONTENT # [lex.token.str-c-raw.intro] Raw C string literals do not process any escapes. They start with the character U+0063 (c), followed by U+0072 (r), followed by fewer than 256 of the character U+0023 (#), and a U+0022 (double-quote) character. [lex.token.str-c-raw.body] The raw C string body can contain any sequence of Unicode characters other than U+0000 (NUL) and U+000D (CR). It is terminated only by another U+0022 (double-quote) character, followed by the same number of U+0023 (#) characters that preceded the opening U+0022 (double-quote) character. [lex.token.str-c-raw.content] All characters contained in the raw C string body represent themselves in UTF-8 encoding. The characters U+0022 (double-quote) (except when followed by at least as many U+0023 (#) characters as were used to start the raw C string literal) or U+005C (\\\\) do not have any special meaning. [lex.token.str-c-raw.edition2021] 2021 Edition differences Raw C string literals are accepted in the 2021 edition or later. In earlier editions the token cr\\"\\" is lexed as cr \\"\\", and cr#\\"\\"# is lexed as cr #\\"\\"# (which is non-grammatical). Examples for C string and raw C string literals c\\"foo\\"; cr\\"foo\\"; // foo\\nc\\"\\\\\\"foo\\\\\\"\\"; cr#\\"\\"foo\\"\\"#; // \\"foo\\" c\\"foo #\\\\\\"# bar\\";\\ncr##\\"foo #\\"# bar\\"##; // foo #\\"# bar c\\"\\\\x52\\"; c\\"R\\"; cr\\"R\\"; // R\\nc\\"\\\\\\\\x52\\"; cr\\"\\\\x52\\"; // \\\\x52 [lex.token.literal.num]","breadcrumbs":"Lexical structure  Tokens  C string and raw C string literals","id":"34","title":"C string and raw C string literals"},"340":{"body":"[patterns.slice.syntax] Syntax SlicePattern  [ SlicePatternItems ? ] SlicePatternItems  Pattern ( , Pattern )* ,? Show Railroad SlicePattern [ SlicePatternItems ] SlicePatternItems Pattern , Pattern , [patterns.slice.intro] Slice patterns can match both arrays of fixed size and slices of dynamic size. // Fixed size\\nlet arr = [1, 2, 3];\\nmatch arr { [1, _, _] => \\"starts with one\\", [a, b, c] => \\"starts with something else\\",\\n}; // Dynamic size\\nlet v = vec![1, 2, 3];\\nmatch v[..] { [a, b] => { /* this arm will not apply because the length doesn\'t match */ } [a, b, c] => { /* this arm will apply */ } _ => { /* this wildcard is required, since the length is not known statically */ }\\n}; [patterns.slice.refutable-array] Slice patterns are irrefutable when matching an array as long as each element is irrefutable. [patterns.slice.refutable-slice] When matching a slice, it is irrefutable only in the form with a single .. rest pattern or identifier pattern with the .. rest pattern as a subpattern. [patterns.slice.restriction] Within a slice, a range pattern without both lower and upper bound must be enclosed in parentheses, as in (a..), to clarify it is intended to match against a single slice element. A range pattern with both lower and upper bound, like a..=b, is not required to be enclosed in parentheses. [patterns.path]","breadcrumbs":"Patterns  Slice patterns","id":"340","title":"Slice patterns"},"341":{"body":"[patterns.path.syntax] Syntax PathPattern  PathExpression Show Railroad PathPattern PathExpression [patterns.path.intro] Path patterns are patterns that refer either to constant values or to structs or enum variants that have no fields. [patterns.path.unqualified] Unqualified path patterns can refer to: enum variants structs constants associated constants [patterns.path.qualified] Qualified path patterns can only refer to associated constants. [patterns.path.refutable] Path patterns are irrefutable when they refer to structs or an enum variant when the enum has only one variant or a constant whose type is irrefutable. They are refutable when they refer to refutable constants or enum variants for enums with multiple variants. [patterns.const]","breadcrumbs":"Patterns  Path patterns","id":"341","title":"Path patterns"},"342":{"body":"[patterns.const.partial-eq] When a constant C of type T is used as a pattern, we first check that T: PartialEq. [patterns.const.structural-equality] Furthermore we require that the value of C has (recursive) structural equality , which is defined recursively as follows: [patterns.const.primitive] Integers as well as str, bool and char values always have structural equality. [patterns.const.builtin-aggregate] Tuples, arrays, and slices have structural equality if all their fields/elements have structural equality. (In particular, () and [] always have structural equality.) [patterns.const.ref] References have structural equality if the value they point to has structural equality. [patterns.const.aggregate] A value of struct or enum type has structural equality if its PartialEq instance is derived via #[derive(PartialEq)], and all fields (for enums: of the active variant) have structural equality. [patterns.const.pointer] A raw pointer has structural equality if it was defined as a constant integer (and then cast/transmuted). [patterns.const.float] A float value has structural equality if it is not a NaN. [patterns.const.exhaustive] Nothing else has structural equality. [patterns.const.generic] In particular, the value of C must be known at pattern-building time (which is pre-monomorphization). This means that associated consts that involve generic parameters cannot be used as patterns. [patterns.const.immutable] The value of C must not contain any references to mutable statics (static mut items or interior mutable static items) or extern statics. [patterns.const.translation] After ensuring all conditions are met, the constant value is translated into a pattern, and now behaves exactly as-if that pattern had been written directly. In particular, it fully participates in exhaustiveness checking. (For raw pointers, constants are the only way to write such patterns. Only _ is ever considered exhaustive for these types.) [patterns.or]","breadcrumbs":"Patterns  Constant patterns","id":"342","title":"Constant patterns"},"343":{"body":"Or-patterns are patterns that match on one of two or more sub-patterns (for example A | B | C). They can nest arbitrarily. Syntactically, or-patterns are allowed in any of the places where other patterns are allowed (represented by the Pattern production), with the exceptions of let-bindings and function and closure arguments (represented by the PatternNoTopAlt production). [patterns.constraints]","breadcrumbs":"Patterns  Or-patterns","id":"343","title":"Or-patterns"},"344":{"body":"[patterns.constraints.pattern] Given a pattern p | q at some depth for some arbitrary patterns p and q, the pattern is considered ill-formed if: the type inferred for p does not unify with the type inferred for q, or the same set of bindings are not introduced in p and q, or the type of any two bindings with the same name in p and q do not unify with respect to types or binding modes. Unification of types is in all instances aforementioned exact and implicit type coercions do not apply. [patterns.constraints.match-type-check] When type checking an expression match e_s { a_1 => e_1, ... a_n => e_n }, for each match arm a_i which contains a pattern of form p_i | q_i, the pattern p_i | q_i is considered ill formed if, at the depth d where it exists the fragment of e_s at depth d, the type of the expression fragment does not unify with p_i | q_i. [patterns.constraints.exhaustiveness-or-pattern] With respect to exhaustiveness checking, a pattern p | q is considered to cover p as well as q. For some constructor c(x, ..) the distributive law applies such that c(p | q, ..rest) covers the same set of value as c(p, ..rest) | c(q, ..rest) does. This can be applied recursively until there are no more nested patterns of form p | q other than those that exist at the top level. Note that by \\"constructor\\" we do not refer to tuple struct patterns, but rather we refer to a pattern for any product type. This includes enum variants, tuple structs, structs with named fields, arrays, tuples, and slices. [patterns.behavior]","breadcrumbs":"Patterns  Static semantics","id":"344","title":"Static semantics"},"345":{"body":"[patterns.behavior.nested-or-patterns] The dynamic semantics of pattern matching a scrutinee expression e_s against a pattern c(p | q, ..rest) at depth d where c is some constructor, p and q are arbitrary patterns, and rest is optionally any remaining potential factors in c, is defined as being the same as that of c(p, ..rest) | c(q, ..rest). [patterns.precedence]","breadcrumbs":"Patterns  Dynamic semantics","id":"345","title":"Dynamic semantics"},"346":{"body":"As shown elsewhere in this chapter, there are several types of patterns that are syntactically undelimited, including identifier patterns, reference patterns, and or-patterns. Or-patterns always have the lowest-precedence. This allows us to reserve syntactic space for a possible future type ascription feature and also to reduce ambiguity. For example, x @ A(..) | B(..) will result in an error that x is not bound in all patterns. &A(x) | B(x) will result in a type mismatch between x in the different subpatterns.","breadcrumbs":"Patterns  Precedence with other undelimited patterns","id":"346","title":"Precedence with other undelimited patterns"},"347":{"body":"","breadcrumbs":"Type system  Type system","id":"347","title":"Type system"},"348":{"body":"[type] [type.intro] Every variable, item, and value in a Rust program has a type. The type of a value defines the interpretation of the memory holding it and the operations that may be performed on the value. [type.builtin] Built-in types are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types. [type.user-defined] User-defined types have limited capabilities. [type.kinds] The list of types is: Primitive types: Boolean --- bool Numeric --- integer and float Textual --- char and str Never --- ! --- a type with no values Sequence types: Tuple Array Slice User-defined types: Struct Enum Union Function types: Functions Closures Pointer types: References Raw pointers Function pointers Trait types: Trait objects Impl trait [type.name]","breadcrumbs":"Type system  Types  Types","id":"348","title":"Types"},"349":{"body":"[type.name.syntax] Syntax Type  TypeNoBounds | ImplTraitType | TraitObjectType TypeNoBounds  ParenthesizedType | ImplTraitTypeOneBound | TraitObjectTypeOneBound | TypePath | TupleType | NeverType | RawPointerType | ReferenceType | ArrayType | SliceType | InferredType | QualifiedPathInType | BareFunctionType | MacroInvocation Show Railroad Type TypeNoBounds ImplTraitType TraitObjectType TypeNoBounds ParenthesizedType ImplTraitTypeOneBound TraitObjectTypeOneBound TypePath TupleType NeverType RawPointerType ReferenceType ArrayType SliceType InferredType QualifiedPathInType BareFunctionType MacroInvocation [type.name.intro] A type expression as defined in the Type grammar rule above is the syntax for referring to a type. It may refer to: [type.name.sequence] Sequence types ( tuple , array , slice ). [type.name.path] Type paths which can reference: Primitive types ( boolean , numeric , textual ). Paths to an item ( struct , enum , union , type alias , trait ). Self path where Self is the implementing type. Generic type parameters . [type.name.pointer] Pointer types ( reference , raw pointer , function pointer ). [type.name.inference] The inferred type which asks the compiler to determine the type. [type.name.grouped] Parentheses which are used for disambiguation. [type.name.trait] Trait types: Trait objects and impl trait . [type.name.never] The never type. [type.name.macro-expansion] Macros which expand to a type expression. [type.name.parenthesized]","breadcrumbs":"Type system  Types  Type expressions","id":"349","title":"Type expressions"},"35":{"body":"A number literal is either an integer literal or a floating-point literal . The grammar for recognizing the two kinds of literals is mixed. [lex.token.literal.int] Integer literals [lex.token.literal.int.syntax] Lexer INTEGER_LITERAL  ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) SUFFIX_NO_E ? DEC_LITERAL  DEC_DIGIT ( DEC_DIGIT | _ )* BIN_LITERAL  0b ( BIN_DIGIT | _ )* BIN_DIGIT ( BIN_DIGIT | _ )* OCT_LITERAL  0o ( OCT_DIGIT | _ )* OCT_DIGIT ( OCT_DIGIT | _ )* HEX_LITERAL  0x ( HEX_DIGIT | _ )* HEX_DIGIT ( HEX_DIGIT | _ )* BIN_DIGIT  [0-1] OCT_DIGIT  [0-7] DEC_DIGIT  [0-9] HEX_DIGIT  [0-9 a-f A-F] Show Railroad INTEGER_LITERAL DEC_LITERAL BIN_LITERAL OCT_LITERAL HEX_LITERAL SUFFIX_NO_E DEC_LITERAL DEC_DIGIT DEC_DIGIT _ BIN_LITERAL 0b BIN_DIGIT _ BIN_DIGIT BIN_DIGIT _ OCT_LITERAL 0o OCT_DIGIT _ OCT_DIGIT OCT_DIGIT _ HEX_LITERAL 0x HEX_DIGIT _ HEX_DIGIT HEX_DIGIT _ BIN_DIGIT 0-1 OCT_DIGIT 0-7 DEC_DIGIT 0-9 HEX_DIGIT 0-9 a-f A-F [lex.token.literal.int.kind] An integer literal has one of four forms: [lex.token.literal.int.kind-dec] A decimal literal starts with a decimal digit and continues with any mixture of decimal digits and underscores . [lex.token.literal.int.kind-hex] A hex literal starts with the character sequence U+0030 U+0078 (0x) and continues as any mixture (with at least one digit) of hex digits and underscores. [lex.token.literal.int.kind-oct] An octal literal starts with the character sequence U+0030 U+006F (0o) and continues as any mixture (with at least one digit) of octal digits and underscores. [lex.token.literal.int.kind-bin] A binary literal starts with the character sequence U+0030 U+0062 (0b) and continues as any mixture (with at least one digit) of binary digits and underscores. [lex.token.literal.int.restriction] Like any literal, an integer literal may be followed (immediately, without any spaces) by a suffix as described above. The suffix may not begin with e or E, as that would be interpreted as the exponent of a floating-point literal. See Integer literal expressions for the effect of these suffixes. Examples of integer literals which are accepted as literal expressions: # #![allow(overflowing_literals)]\\n123;\\n123i32;\\n123u32;\\n123_u32; 0xff;\\n0xff_u8;\\n0x01_f32; // integer 7986, not floating-point 1.0\\n0x01_e3; // integer 483, not floating-point 1000.0 0o70;\\n0o70_i16; 0b1111_1111_1001_0000;\\n0b1111_1111_1001_0000i64;\\n0b________1; 0usize; // These are too big for their type, but are accepted as literal expressions.\\n128_i8;\\n256_u8; // This is an integer literal, accepted as a floating-point literal expression.\\n5f32; Note that -1i8, for example, is analyzed as two tokens: - followed by 1i8. Examples of integer literals which are not accepted as literal expressions: # #[cfg(false)] {\\n0invalidSuffix;\\n123AFB43;\\n0b010a;\\n0xAB_CD_EF_GH;\\n0b1111_f32;\\n# } [lex.token.literal.int.tuple-field] Tuple index [lex.token.literal.int.tuple-field.syntax] Lexer TUPLE_INDEX  DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL Show Railroad TUPLE_INDEX DEC_LITERAL BIN_LITERAL OCT_LITERAL HEX_LITERAL [lex.token.literal.int.tuple-field.intro] A tuple index is used to refer to the fields of tuples , tuple structs , and tuple enum variants . [lex.token.literal.int.tuple-field.eq] Tuple indices are compared with the literal token directly. Tuple indices start with 0 and each successive index increments the value by 1 as a decimal value. Thus, only decimal values will match, and the value must not have any extra 0 prefix characters. Tuple indices may not include any suffixes (such as usize). let example = (\\"dog\\", \\"cat\\", \\"horse\\");\\nlet dog = example.0;\\nlet cat = example.1;\\n// The following examples are invalid.\\nlet cat = example.01; // ERROR no field named `01`\\nlet horse = example.0b10; // ERROR no field named `0b10`\\nlet unicorn = example.0usize; // ERROR suffixes on a tuple index are invalid\\nlet underscore = example.0_0; // ERROR no field `0_0` on type `(&str, &str, &str)` [lex.token.literal.float] Floating-point literals [lex.token.literal.float.syntax] Lexer FLOAT_LITERAL  DEC_LITERAL .not immediately followed by ., _ or an XID_Start character | DEC_LITERAL . DEC_LITERAL SUFFIX_NO_E ? | DEC_LITERAL ( . DEC_LITERAL )? FLOAT_EXPONENT SUFFIX ? FLOAT_EXPONENT  ( e | E ) ( + | - )? ( DEC_DIGIT | _ )* DEC_DIGIT ( DEC_DIGIT | _ )* Show Railroad FLOAT_LITERAL DEC_LITERAL not immediately followed by `.`, `_` or an XID_Start character . DEC_LITERAL . DEC_LITERAL SUFFIX_NO_E DEC_LITERAL . DEC_LITERAL FLOAT_EXPONENT SUFFIX FLOAT_EXPONENT e E + - DEC_DIGIT _ DEC_DIGIT DEC_DIGIT _ [lex.token.literal.float.form] A floating-point literal has one of two forms: A decimal literal followed by a period character U+002E (.). This is optionally followed by another decimal literal, with an optional exponent . A single decimal literal followed by an exponent . [lex.token.literal.float.suffix] Like integer literals, a floating-point literal may be followed by a suffix, so long as the pre-suffix part does not end with U+002E (.). The suffix may not begin with e or E if the literal does not include an exponent. See Floating-point literal expressions for the effect of these suffixes. Examples of floating-point literals which are accepted as literal expressions: 123.0f64;\\n0.1f64;\\n0.1f32;\\n12E+99_f64;\\nlet x: f64 = 2.; This last example is different because it is not possible to use the suffix syntax with a floating point literal end.token.ing in a period. 2.f64 would attempt to call a method named f64 on 2. Note that -1.0, for example, is analyzed as two tokens: - followed by 1.0. Examples of floating-point literals which are not accepted as literal expressions: # #[cfg(false)] {\\n2.0f80;\\n2e5f80;\\n2e5e6;\\n2.0e5e6;\\n1.3e10u64;\\n# } [lex.token.literal.reserved] Reserved forms similar to number literals [lex.token.literal.reserved.syntax] Lexer RESERVED_NUMBER  BIN_LITERAL [2-9] | OCT_LITERAL [8-9] | ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) .not immediately followed by ., _ or an XID_Start character | ( BIN_LITERAL | OCT_LITERAL ) ( e | E ) | 0b _* <end of input or not BIN_DIGIT> | 0o _* <end of input or not OCT_DIGIT> | 0x _* <end of input or not HEX_DIGIT> | DEC_LITERAL ( . DEC_LITERAL )? ( e | E ) ( + | - )? <end of input or not DEC_DIGIT> Show Railroad RESERVED_NUMBER BIN_LITERAL 2-9 OCT_LITERAL 8-9 BIN_LITERAL OCT_LITERAL HEX_LITERAL not immediately followed by `.`, `_` or an XID_Start character . BIN_LITERAL OCT_LITERAL e E 0b _ end of input or not BIN_DIGIT 0o _ end of input or not OCT_DIGIT 0x _ end of input or not HEX_DIGIT DEC_LITERAL . DEC_LITERAL e E + - end of input or not DEC_DIGIT [lex.token.literal.reserved.intro] The following lexical forms similar to number literals are reserved forms . Due to the possible ambiguity these raise, they are rejected by the tokenizer instead of being interpreted as separate tokens. [lex.token.literal.reserved.out-of-range] An unsuffixed binary or octal literal followed, without intervening whitespace, by a decimal digit out of the range for its radix. [lex.token.literal.reserved.period] An unsuffixed binary, octal, or hexadecimal literal followed, without intervening whitespace, by a period character (with the same restrictions on what follows the period as for floating-point literals). [lex.token.literal.reserved.exp] An unsuffixed binary or octal literal followed, without intervening whitespace, by the character e or E. [lex.token.literal.reserved.empty-with-radix] Input which begins with one of the radix prefixes but is not a valid binary, octal, or hexadecimal literal (because it contains no digits). [lex.token.literal.reserved.empty-exp] Input which has the form of a floating-point literal with no digits in the exponent. Examples of reserved forms: 0b0102; // this is not `0b010` followed by `2`\\n0o1279; // this is not `0o127` followed by `9`\\n0x80.0; // this is not `0x80` followed by `.` and `0`\\n0b101e; // this is not a suffixed literal, or `0b101` followed by `e`\\n0b; // this is not an integer literal, or `0` followed by `b`\\n0b_; // this is not an integer literal, or `0` followed by `b_`\\n2e; // this is not a floating-point literal, or `2` followed by `e`\\n2.0e; // this is not a floating-point literal, or `2.0` followed by `e`\\n2em; // this is not a suffixed literal, or `2` followed by `em`\\n2.0em; // this is not a suffixed literal, or `2.0` followed by `em` [lex.token.life]","breadcrumbs":"Lexical structure  Tokens  Number literals","id":"35","title":"Number literals"},"350":{"body":"[type.name.parenthesized.syntax] Syntax ParenthesizedType  ( Type ) Show Railroad ParenthesizedType ( Type ) [type.name.parenthesized.intro] In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the + operator for type boundaries within a reference type is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the TypeNoBounds rule instead of Type . # use std::any::Any;\\ntype T<\'a> = &\'a (dyn Any + Send); [type.recursive]","breadcrumbs":"Type system  Types  Parenthesized types","id":"350","title":"Parenthesized types"},"351":{"body":"[type.recursive.intro] Nominal types  structs , enumerations , and unions  may be recursive. That is, each enum variant or struct or union field may refer, directly or indirectly, to the enclosing enum or struct type itself. [type.recursive.constraint] Such recursion has restrictions: Recursive types must include a nominal type in the recursion (not mere type aliases , or other structural types such as arrays or tuples ). So type Rec = &\'static [Rec] is not allowed. The size of a recursive type must be finite; in other words the recursive fields of the type must be pointer types . An example of a recursive type and its use: enum List<T> { Nil, Cons(T, Box<List<T>>)\\n} let a: List<i32> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));","breadcrumbs":"Type system  Types  Recursive types","id":"351","title":"Recursive types"},"352":{"body":"[type.bool] let b: bool = true; [type.bool.intro] The boolean type or bool is a primitive data type that can take on one of two values, called true and false . [type.bool.literal] Values of this type may be created using a literal expression using the keywords true and false corresponding to the value of the same name. [type.bool.namespace] This type is a part of the language prelude with the name bool. [type.bool.layout] An object with the boolean type has a size and alignment of 1 each. [type.bool.repr] The value false has the bit pattern 0x00 and the value true has the bit pattern 0x01. It is undefined behavior for an object with the boolean type to have any other bit pattern. [type.bool.usage] The boolean type is the type of many operands in various expressions : [type.bool.usage-condition] The condition operand in if expressions and while expressions [type.bool.usage-lazy-operator] The operands in lazy boolean operator expressions Note The boolean type acts similarly to but is not an enumerated type . In practice, this mostly means that constructors are not associated to the type (e.g. bool::true). [type.bool.traits] Like all primitives, the boolean type implements the traits Clone , Copy , Sized , Send , and Sync . Note See the standard library docs for library operations. [type.bool.expr]","breadcrumbs":"Type system  Types  Boolean type  Boolean type","id":"352","title":"Boolean type"},"353":{"body":"When using certain operator expressions with a boolean type for its operands, they evaluate using the rules of boolean logic . [type.bool.expr.not]","breadcrumbs":"Type system  Types  Boolean type  Operations on boolean values","id":"353","title":"Operations on boolean values"},"354":{"body":"b !b true false false true [type.bool.expr.or]","breadcrumbs":"Type system  Types  Boolean type  Logical not","id":"354","title":"Logical not"},"355":{"body":"a b a | b true true true true false true false true true false false false [type.bool.expr.and]","breadcrumbs":"Type system  Types  Boolean type  Logical or","id":"355","title":"Logical or"},"356":{"body":"a b a & b true true true true false false false true false false false false [type.bool.expr.xor]","breadcrumbs":"Type system  Types  Boolean type  Logical and","id":"356","title":"Logical and"},"357":{"body":"a b a ^ b true true false true false true false true true false false false [type.bool.expr.cmp]","breadcrumbs":"Type system  Types  Boolean type  Logical xor","id":"357","title":"Logical xor"},"358":{"body":"[type.bool.expr.cmp.eq] a b a == b true true true true false false false true false false false true [type.bool.expr.cmp.greater] a b a > b true true false true false true false true false false false false [type.bool.expr.cmp.not-eq] a != b is the same as !(a == b) [type.bool.expr.cmp.greater-eq] a >= b is the same as a == b | a > b [type.bool.expr.cmp.less] a < b is the same as !(a >= b) [type.bool.expr.cmp.less-eq] a <= b is the same as a == b | a < b [type.bool.validity]","breadcrumbs":"Type system  Types  Boolean type  Comparisons","id":"358","title":"Comparisons"},"359":{"body":"The single byte of a bool is guaranteed to be initialized (in other words, transmute::<bool, u8>(...) is always sound -- but since some bit patterns are invalid bools, the inverse is not always sound).","breadcrumbs":"Type system  Types  Boolean type  Bit validity","id":"359","title":"Bit validity"},"36":{"body":"[lex.token.life.syntax] Lexer LIFETIME_TOKEN  \' IDENTIFIER_OR_KEYWORD not immediately followed by \' | \'_not immediately followed by \' | RAW_LIFETIME LIFETIME_OR_LABEL  \' NON_KEYWORD_IDENTIFIER not immediately followed by \' | RAW_LIFETIME RAW_LIFETIME  \'r# IDENTIFIER_OR_KEYWORD except crate, self, super, Self and not immediately followed by \' RESERVED_RAW_LIFETIME  \'r#_not immediately followed by \' Show Railroad LIFETIME_TOKEN \' not immediately followed by `\'` IDENTIFIER_OR_KEYWORD not immediately followed by `\'` \'_ RAW_LIFETIME LIFETIME_OR_LABEL \' not immediately followed by `\'` NON_KEYWORD_IDENTIFIER RAW_LIFETIME RAW_LIFETIME \'r# except `crate`, `self`, `super`, `Self` and not immediately followed by `\'` IDENTIFIER_OR_KEYWORD RESERVED_RAW_LIFETIME not immediately followed by `\'` \'r#_ [lex.token.life.intro] Lifetime parameters and loop labels use LIFETIME_OR_LABEL tokens. Any LIFETIME_TOKEN will be accepted by the lexer, and for example, can be used in macros. [lex.token.life.raw.intro] A raw lifetime is like a normal lifetime, but its identifier is prefixed by r#. (Note that the r# prefix is not included as part of the actual lifetime.) [lex.token.life.raw.allowed] Unlike a normal lifetime, a raw lifetime may be any strict or reserved keyword except the ones listed above for RAW_LIFETIME. [lex.token.life.raw.reserved] It is an error to use the RESERVED_RAW_LIFETIME token \'r#_ in order to avoid confusion with the placeholder lifetime . [lex.token.life.raw.edition2021] 2021 Edition differences Raw lifetimes are accepted in the 2021 edition or later. In earlier editions the token \'r#lt is lexed as \'r # lt. [lex.token.punct]","breadcrumbs":"Lexical structure  Tokens  Lifetimes and loop labels","id":"36","title":"Lifetimes and loop labels"},"360":{"body":"[type.numeric] [type.numeric.int]","breadcrumbs":"Type system  Types  Numeric types  Numeric types","id":"360","title":"Numeric types"},"361":{"body":"[type.numeric.int.unsigned] The unsigned integer types consist of: Type Minimum Maximum u8 0 28-1 u16 0 216-1 u32 0 232-1 u64 0 264-1 u128 0 2128-1 [type.numeric.int.signed] The signed two\'s complement integer types consist of: Type Minimum Maximum i8 -(27) 27-1 i16 -(215) 215-1 i32 -(231) 231-1 i64 -(263) 263-1 i128 -(2127) 2127-1 [type.numeric.float]","breadcrumbs":"Type system  Types  Numeric types  Integer types","id":"361","title":"Integer types"},"362":{"body":"The IEEE 754-2008 \\"binary32\\" and \\"binary64\\" floating-point types are f32 and f64, respectively. [type.numeric.int.size]","breadcrumbs":"Type system  Types  Numeric types  Floating-point types","id":"362","title":"Floating-point types"},"363":{"body":"[type.numeric.int.size.usize] The usize type is an unsigned integer type with the same number of bits as the platform\'s pointer type. It can represent every memory address in the process. Note While a usize can represent every address , converting a pointer to a usize is not necessarily a reversible operation. For more information, see the documentation for type cast expressions , std::ptr , and provenance in particular. [type.numeric.int.size.isize] The isize type is a signed integer type with the same number of bits as the platform\'s pointer type. The theoretical upper bound on object and array size is the maximum isize value. This ensures that isize can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end. [type.numeric.int.size.minimum] usize and isize are at least 16-bits wide. Note Many pieces of Rust code may assume that pointers, usize, and isize are either 32-bit or 64-bit. As a consequence, 16-bit pointer support is limited and may require explicit care and acknowledgment from a library to support. [type.numeric.validity]","breadcrumbs":"Type system  Types  Numeric types  Machine-dependent integer types","id":"363","title":"Machine-dependent integer types"},"364":{"body":"For every numeric type, T, the bit validity of T is equivalent to the bit validity of [u8; size_of::<T>()]. An uninitialized byte is not a valid u8.","breadcrumbs":"Type system  Types  Numeric types  Bit validity","id":"364","title":"Bit validity"},"365":{"body":"[type.text] [type.text.intro] The types char and str hold textual data. [type.text.char-value] A value of type char is a Unicode scalar value (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. [type.text.char-precondition] It is immediate undefined behavior to create a char that falls outside this range. A [char] is effectively a UCS-4 / UTF-32 string of length 1. [type.text.str-value] A value of type str is represented the same way as [u8], a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about str: methods working on str assume and ensure that the data in there is valid UTF-8. Calling a str method with a non-UTF-8 buffer can cause undefined behavior now or in the future. [type.text.str-unsized] Since str is a dynamically sized type , it can only be instantiated through a pointer type, such as &str. The layout of &str is the same as the layout of &[u8]. [type.text.layout]","breadcrumbs":"Type system  Types  Textual types  Textual types","id":"365","title":"Textual types"},"366":{"body":"[type.layout.char-layout] char is guaranteed to have the same size and alignment as u32 on all platforms. [type.layout.char-validity] Every byte of a char is guaranteed to be initialized (in other words, transmute::<char, [u8; size_of::<char>()]>(...) is always sound -- but since some bit patterns are invalid chars, the inverse is not always sound).","breadcrumbs":"Type system  Types  Textual types  Layout and bit validity","id":"366","title":"Layout and bit validity"},"367":{"body":"[type.never] [type.never.syntax] Syntax NeverType  ! Show Railroad NeverType ! [type.never.intro] The never type ! is a type with no values, representing the result of computations that never complete. [type.never.coercion] Expressions of type ! can be coerced into any other type. [type.never.constraint] The ! type can only appear in function return types presently, indicating it is a diverging function that never returns. fn foo() -> ! { panic!(\\"This call never returns.\\");\\n} unsafe extern \\"C\\" { pub safe fn no_return_extern_func() -> !;\\n}","breadcrumbs":"Type system  Types  Never type  Never type","id":"367","title":"Never type"},"368":{"body":"[type.tuple] [type.tuple.syntax] Syntax TupleType  ( ) | ( ( Type , )+ Type ? ) Show Railroad TupleType ( ) ( Type , Type ) [type.tuple.intro] Tuple types are a family of structural types [1] for heterogeneous lists of other types. The syntax for a tuple type is a parenthesized, comma-separated list of types. [type.tuple.restriction] 1-ary tuples require a comma after their element type to be disambiguated with a parenthesized type . [type.tuple.field-number] A tuple type has a number of fields equal to the length of the list of types. This number of fields determines the arity of the tuple. A tuple with n fields is called an n-ary tuple . For example, a tuple with 2 fields is a 2-ary tuple. [type.tuple.field-name] Fields of tuples are named using increasing numeric names matching their position in the list of types. The first field is 0. The second field is 1. And so on. The type of each field is the type of the same position in the tuple\'s list of types. [type.tuple.unit] For convenience and historical reasons, the tuple type with no fields (()) is often called unit or the unit type . Its one value is also called unit or the unit value . Some examples of tuple types: () (unit) (i32,) (1-ary tuple) (f64, f64) (String, i32) (i32, String) (different type from the previous example) (i32, f64, Vec<String>, Option<bool>) [type.tuple.constructor] Values of this type are constructed using a tuple expression . Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to. [type.tuple.access] Tuple fields can be accessed by either a tuple index expression or pattern matching . Structural types are always equivalent if their internal types are equivalent. For a nominal version of tuples, see tuple structs .","breadcrumbs":"Type system  Types  Tuple types  Tuple types","id":"368","title":"Tuple 